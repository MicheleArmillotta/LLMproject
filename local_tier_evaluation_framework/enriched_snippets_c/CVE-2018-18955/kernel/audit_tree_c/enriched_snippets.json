[
  {
    "function_name": "audit_tree_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "1021-1033",
    "snippet": "static int __init audit_tree_init(void)\n{\n\tint i;\n\n\taudit_tree_group = fsnotify_alloc_group(&audit_tree_ops);\n\tif (IS_ERR(audit_tree_group))\n\t\taudit_panic(\"cannot initialize fsnotify group for rectree watches\");\n\n\tfor (i = 0; i < HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&chunk_hash_heads[i]);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_tree_group;",
      "static struct list_head chunk_hash_heads[HASH_SIZE];",
      "static const struct fsnotify_ops audit_tree_ops = {\n\t.handle_event = audit_tree_handle_event,\n\t.freeing_mark = audit_tree_freeing_mark,\n\t.free_mark = audit_tree_destroy_watch,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&chunk_hash_heads[i]"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"cannot initialize fsnotify group for rectree watches\""
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "310-323",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "audit_tree_group"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_alloc_group",
          "args": [
            "&audit_tree_ops"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic struct list_head chunk_hash_heads[HASH_SIZE];\nstatic const struct fsnotify_ops audit_tree_ops = {\n\t.handle_event = audit_tree_handle_event,\n\t.freeing_mark = audit_tree_freeing_mark,\n\t.free_mark = audit_tree_destroy_watch,\n};\n\nstatic int __init audit_tree_init(void)\n{\n\tint i;\n\n\taudit_tree_group = fsnotify_alloc_group(&audit_tree_ops);\n\tif (IS_ERR(audit_tree_group))\n\t\taudit_panic(\"cannot initialize fsnotify group for rectree watches\");\n\n\tfor (i = 0; i < HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&chunk_hash_heads[i]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_tree_freeing_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "1002-1013",
    "snippet": "static void audit_tree_freeing_mark(struct fsnotify_mark *entry, struct fsnotify_group *group)\n{\n\tstruct audit_chunk *chunk = container_of(entry, struct audit_chunk, mark);\n\n\tevict_chunk(chunk);\n\n\t/*\n\t * We are guaranteed to have at least one reference to the mark from\n\t * either the inode or the caller of fsnotify_destroy_mark().\n\t */\n\tBUG_ON(refcount_read(&entry->refcnt) < 1);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "refcount_read(&entry->refcnt) < 1"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&entry->refcnt"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evict_chunk",
          "args": [
            "chunk"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "evict_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "955-991",
          "snippet": "static void evict_chunk(struct audit_chunk *chunk)\n{\n\tstruct audit_tree *owner;\n\tstruct list_head *postponed = audit_killed_trees();\n\tint need_prune = 0;\n\tint n;\n\n\tif (chunk->dead)\n\t\treturn;\n\n\tchunk->dead = 1;\n\tmutex_lock(&audit_filter_mutex);\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&chunk->trees)) {\n\t\towner = list_entry(chunk->trees.next,\n\t\t\t\t   struct audit_tree, same_root);\n\t\towner->goner = 1;\n\t\towner->root = NULL;\n\t\tlist_del_init(&owner->same_root);\n\t\tspin_unlock(&hash_lock);\n\t\tif (!postponed) {\n\t\t\tkill_rules(owner);\n\t\t\tlist_move(&owner->list, &prune_list);\n\t\t\tneed_prune = 1;\n\t\t} else {\n\t\t\tlist_move(&owner->list, postponed);\n\t\t}\n\t\tspin_lock(&hash_lock);\n\t}\n\tlist_del_rcu(&chunk->hash);\n\tfor (n = 0; n < chunk->count; n++)\n\t\tlist_del_init(&chunk->owners[n].list);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_filter_mutex);\n\tif (need_prune)\n\t\taudit_schedule_prune();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(prune_list);",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(prune_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\nstatic void audit_schedule_prune(void);\n\nstatic void evict_chunk(struct audit_chunk *chunk)\n{\n\tstruct audit_tree *owner;\n\tstruct list_head *postponed = audit_killed_trees();\n\tint need_prune = 0;\n\tint n;\n\n\tif (chunk->dead)\n\t\treturn;\n\n\tchunk->dead = 1;\n\tmutex_lock(&audit_filter_mutex);\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&chunk->trees)) {\n\t\towner = list_entry(chunk->trees.next,\n\t\t\t\t   struct audit_tree, same_root);\n\t\towner->goner = 1;\n\t\towner->root = NULL;\n\t\tlist_del_init(&owner->same_root);\n\t\tspin_unlock(&hash_lock);\n\t\tif (!postponed) {\n\t\t\tkill_rules(owner);\n\t\t\tlist_move(&owner->list, &prune_list);\n\t\t\tneed_prune = 1;\n\t\t} else {\n\t\t\tlist_move(&owner->list, postponed);\n\t\t}\n\t\tspin_lock(&hash_lock);\n\t}\n\tlist_del_rcu(&chunk->hash);\n\tfor (n = 0; n < chunk->count; n++)\n\t\tlist_del_init(&chunk->owners[n].list);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_filter_mutex);\n\tif (need_prune)\n\t\taudit_schedule_prune();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "entry",
            "structaudit_chunk",
            "mark"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void audit_tree_freeing_mark(struct fsnotify_mark *entry, struct fsnotify_group *group)\n{\n\tstruct audit_chunk *chunk = container_of(entry, struct audit_chunk, mark);\n\n\tevict_chunk(chunk);\n\n\t/*\n\t * We are guaranteed to have at least one reference to the mark from\n\t * either the inode or the caller of fsnotify_destroy_mark().\n\t */\n\tBUG_ON(refcount_read(&entry->refcnt) < 1);\n}"
  },
  {
    "function_name": "audit_tree_handle_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "993-1000",
    "snippet": "static int audit_tree_handle_event(struct fsnotify_group *group,\n\t\t\t\t   struct inode *to_tell,\n\t\t\t\t   u32 mask, const void *data, int data_type,\n\t\t\t\t   const unsigned char *file_name, u32 cookie,\n\t\t\t\t   struct fsnotify_iter_info *iter_info)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic int audit_tree_handle_event(struct fsnotify_group *group,\n\t\t\t\t   struct inode *to_tell,\n\t\t\t\t   u32 mask, const void *data, int data_type,\n\t\t\t\t   const unsigned char *file_name, u32 cookie,\n\t\t\t\t   struct fsnotify_iter_info *iter_info)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "evict_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "955-991",
    "snippet": "static void evict_chunk(struct audit_chunk *chunk)\n{\n\tstruct audit_tree *owner;\n\tstruct list_head *postponed = audit_killed_trees();\n\tint need_prune = 0;\n\tint n;\n\n\tif (chunk->dead)\n\t\treturn;\n\n\tchunk->dead = 1;\n\tmutex_lock(&audit_filter_mutex);\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&chunk->trees)) {\n\t\towner = list_entry(chunk->trees.next,\n\t\t\t\t   struct audit_tree, same_root);\n\t\towner->goner = 1;\n\t\towner->root = NULL;\n\t\tlist_del_init(&owner->same_root);\n\t\tspin_unlock(&hash_lock);\n\t\tif (!postponed) {\n\t\t\tkill_rules(owner);\n\t\t\tlist_move(&owner->list, &prune_list);\n\t\t\tneed_prune = 1;\n\t\t} else {\n\t\t\tlist_move(&owner->list, postponed);\n\t\t}\n\t\tspin_lock(&hash_lock);\n\t}\n\tlist_del_rcu(&chunk->hash);\n\tfor (n = 0; n < chunk->count; n++)\n\t\tlist_del_init(&chunk->owners[n].list);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_filter_mutex);\n\tif (need_prune)\n\t\taudit_schedule_prune();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(prune_list);",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);",
      "static void audit_schedule_prune(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_schedule_prune",
          "args": [],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&chunk->owners[n].list"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&chunk->hash"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&owner->list",
            "postponed"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&owner->list",
            "&prune_list"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_rules",
          "args": [
            "owner"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "kill_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "514-534",
          "snippet": "static void kill_rules(struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void kill_rules(struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&owner->same_root"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "chunk->trees.next",
            "structaudit_tree",
            "same_root"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&chunk->trees"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_killed_trees",
          "args": [],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "audit_killed_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "2523-2529",
          "snippet": "struct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = audit_context();\n\tif (likely(!ctx || !ctx->in_syscall))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstruct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = audit_context();\n\tif (likely(!ctx || !ctx->in_syscall))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(prune_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\nstatic void audit_schedule_prune(void);\n\nstatic void evict_chunk(struct audit_chunk *chunk)\n{\n\tstruct audit_tree *owner;\n\tstruct list_head *postponed = audit_killed_trees();\n\tint need_prune = 0;\n\tint n;\n\n\tif (chunk->dead)\n\t\treturn;\n\n\tchunk->dead = 1;\n\tmutex_lock(&audit_filter_mutex);\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&chunk->trees)) {\n\t\towner = list_entry(chunk->trees.next,\n\t\t\t\t   struct audit_tree, same_root);\n\t\towner->goner = 1;\n\t\towner->root = NULL;\n\t\tlist_del_init(&owner->same_root);\n\t\tspin_unlock(&hash_lock);\n\t\tif (!postponed) {\n\t\t\tkill_rules(owner);\n\t\t\tlist_move(&owner->list, &prune_list);\n\t\t\tneed_prune = 1;\n\t\t} else {\n\t\t\tlist_move(&owner->list, postponed);\n\t\t}\n\t\tspin_lock(&hash_lock);\n\t}\n\tlist_del_rcu(&chunk->hash);\n\tfor (n = 0; n < chunk->count; n++)\n\t\tlist_del_init(&chunk->owners[n].list);\n\tspin_unlock(&hash_lock);\n\tmutex_unlock(&audit_filter_mutex);\n\tif (need_prune)\n\t\taudit_schedule_prune();\n}"
  },
  {
    "function_name": "audit_kill_trees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "928-949",
    "snippet": "void audit_kill_trees(struct list_head *list)\n{\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_ctl_unlock",
          "args": [],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "251-255",
          "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_one",
          "args": [
            "victim"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "prune_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "539-551",
          "snippet": "static void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\n\t\tuntag_chunk(p);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\n\t\tuntag_chunk(p);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&victim->list"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_rules",
          "args": [
            "victim"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "kill_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "514-534",
          "snippet": "static void kill_rules(struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void kill_rules(struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list->next",
            "structaudit_tree",
            "list"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ctl_lock",
          "args": [],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "242-246",
          "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_kill_trees(struct list_head *list)\n{\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}"
  },
  {
    "function_name": "audit_schedule_prune",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "919-922",
    "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *prune_thread;",
      "static void audit_schedule_prune(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "prune_thread"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
  },
  {
    "function_name": "audit_tag_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "823-916",
    "snippet": "int audit_tag_tree(char *old, char *new)\n{\n\tstruct list_head cursor, barrier;\n\tint failed = 0;\n\tstruct path path1, path2;\n\tstruct vfsmount *tagged;\n\tint err;\n\n\terr = kern_path(new, 0, &path2);\n\tif (err)\n\t\treturn err;\n\ttagged = collect_mounts(&path2);\n\tpath_put(&path2);\n\tif (IS_ERR(tagged))\n\t\treturn PTR_ERR(tagged);\n\n\terr = kern_path(old, 0, &path1);\n\tif (err) {\n\t\tdrop_collected_mounts(tagged);\n\t\treturn err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&barrier, &tree_list);\n\tlist_add(&cursor, &barrier);\n\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tint good_one = 0;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&cursor);\n\t\tlist_add(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path2);\n\t\tif (!err) {\n\t\t\tgood_one = path_is_under(&path1, &path2);\n\t\t\tpath_put(&path2);\n\t\t}\n\n\t\tif (!good_one) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfailed = iterate_mounts(tag_mount, tree, tagged);\n\t\tif (failed) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tspin_lock(&hash_lock);\n\t\tif (!tree->goner) {\n\t\t\tlist_del(&tree->list);\n\t\t\tlist_add(&tree->list, &tree_list);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\tput_tree(tree);\n\t}\n\n\twhile (barrier.prev != &tree_list) {\n\t\tstruct audit_tree *tree;\n\n\t\ttree = container_of(barrier.prev, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&tree->list);\n\t\tlist_add(&tree->list, &barrier);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tif (!failed) {\n\t\t\tstruct node *node;\n\t\t\tspin_lock(&hash_lock);\n\t\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t\tspin_unlock(&hash_lock);\n\t\t} else {\n\t\t\ttrim_marked(tree);\n\t\t}\n\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&barrier);\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n\tpath_put(&path1);\n\tdrop_collected_mounts(tagged);\n\treturn failed;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tree_list);",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_collected_mounts",
          "args": [
            "tagged"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path1"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cursor"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "tree"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "693-696",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim_marked",
          "args": [
            "tree"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "trim_marked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "555-595",
          "snippet": "static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t/* have we run out of marked? */\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tuntag_chunk(node);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t/* have we run out of marked? */\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tuntag_chunk(node);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&tree->chunks",
            "list"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tree->list",
            "&barrier"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "tree"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "94-97",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "barrier.prev",
            "structaudit_tree",
            "list"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_mounts",
          "args": [
            "tag_mount",
            "tree",
            "tagged"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path2"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_is_under",
          "args": [
            "&path1",
            "&path2"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "tree->pathname",
            "0",
            "&path2"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cursor.next",
            "structaudit_tree",
            "list"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_collected_mounts",
          "args": [
            "tagged"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "old",
            "0",
            "&path1"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tagged"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tagged"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path2"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_mounts",
          "args": [
            "&path2"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "new",
            "0",
            "&path2"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nint audit_tag_tree(char *old, char *new)\n{\n\tstruct list_head cursor, barrier;\n\tint failed = 0;\n\tstruct path path1, path2;\n\tstruct vfsmount *tagged;\n\tint err;\n\n\terr = kern_path(new, 0, &path2);\n\tif (err)\n\t\treturn err;\n\ttagged = collect_mounts(&path2);\n\tpath_put(&path2);\n\tif (IS_ERR(tagged))\n\t\treturn PTR_ERR(tagged);\n\n\terr = kern_path(old, 0, &path1);\n\tif (err) {\n\t\tdrop_collected_mounts(tagged);\n\t\treturn err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&barrier, &tree_list);\n\tlist_add(&cursor, &barrier);\n\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tint good_one = 0;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&cursor);\n\t\tlist_add(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path2);\n\t\tif (!err) {\n\t\t\tgood_one = path_is_under(&path1, &path2);\n\t\t\tpath_put(&path2);\n\t\t}\n\n\t\tif (!good_one) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfailed = iterate_mounts(tag_mount, tree, tagged);\n\t\tif (failed) {\n\t\t\tput_tree(tree);\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tspin_lock(&hash_lock);\n\t\tif (!tree->goner) {\n\t\t\tlist_del(&tree->list);\n\t\t\tlist_add(&tree->list, &tree_list);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\tput_tree(tree);\n\t}\n\n\twhile (barrier.prev != &tree_list) {\n\t\tstruct audit_tree *tree;\n\n\t\ttree = container_of(barrier.prev, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&tree->list);\n\t\tlist_add(&tree->list, &barrier);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tif (!failed) {\n\t\t\tstruct node *node;\n\t\t\tspin_lock(&hash_lock);\n\t\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t\tspin_unlock(&hash_lock);\n\t\t} else {\n\t\t\ttrim_marked(tree);\n\t\t}\n\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&barrier);\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n\tpath_put(&path1);\n\tdrop_collected_mounts(tagged);\n\treturn failed;\n}"
  },
  {
    "function_name": "audit_add_tree_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "753-821",
    "snippet": "int audit_add_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *seed = rule->tree, *tree;\n\tstruct path path;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\trule->tree = NULL;\n\tlist_for_each_entry(tree, &tree_list, list) {\n\t\tif (!strcmp(seed->pathname, tree->pathname)) {\n\t\t\tput_tree(seed);\n\t\t\trule->tree = tree;\n\t\t\tlist_add(&rule->rlist, &tree->rules);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttree = seed;\n\tlist_add(&tree->list, &tree_list);\n\tlist_add(&rule->rlist, &tree->rules);\n\t/* do not set rule->tree yet */\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (unlikely(!prune_thread)) {\n\t\terr = audit_launch_prune();\n\t\tif (err)\n\t\t\tgoto Err;\n\t}\n\n\terr = kern_path(tree->pathname, 0, &path);\n\tif (err)\n\t\tgoto Err;\n\tmnt = collect_mounts(&path);\n\tpath_put(&path);\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto Err;\n\t}\n\n\tget_tree(tree);\n\terr = iterate_mounts(tag_mount, tree, mnt);\n\tdrop_collected_mounts(mnt);\n\n\tif (!err) {\n\t\tstruct node *node;\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\tnode->index &= ~(1U<<31);\n\t\tspin_unlock(&hash_lock);\n\t} else {\n\t\ttrim_marked(tree);\n\t\tgoto Err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tif (list_empty(&rule->rlist)) {\n\t\tput_tree(tree);\n\t\treturn -ENOENT;\n\t}\n\trule->tree = tree;\n\tput_tree(tree);\n\n\treturn 0;\nErr:\n\tmutex_lock(&audit_filter_mutex);\n\tlist_del_init(&tree->list);\n\tlist_del_init(&tree->rules);\n\tput_tree(tree);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tree_list);",
      "static struct task_struct *prune_thread;",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "tree"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "693-696",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tree->rules"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tree->list"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rule->rlist"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim_marked",
          "args": [
            "tree"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "trim_marked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "555-595",
          "snippet": "static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t/* have we run out of marked? */\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tuntag_chunk(node);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t/* have we run out of marked? */\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tuntag_chunk(node);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&tree->chunks",
            "list"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_collected_mounts",
          "args": [
            "mnt"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_mounts",
          "args": [
            "tag_mount",
            "tree",
            "mnt"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "tree"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "94-97",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mnt"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_mounts",
          "args": [
            "&path"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "tree->pathname",
            "0",
            "&path"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_launch_prune",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "audit_launch_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "738-750",
          "snippet": "static int audit_launch_prune(void)\n{\n\tif (prune_thread)\n\t\treturn 0;\n\tprune_thread = kthread_run(prune_tree_thread, NULL,\n\t\t\t\t\"audit_prune_tree\");\n\tif (IS_ERR(prune_thread)) {\n\t\tpr_err(\"cannot start thread audit_prune_tree\");\n\t\tprune_thread = NULL;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\n\nstatic int audit_launch_prune(void)\n{\n\tif (prune_thread)\n\t\treturn 0;\n\tprune_thread = kthread_run(prune_tree_thread, NULL,\n\t\t\t\t\"audit_prune_tree\");\n\tif (IS_ERR(prune_thread)) {\n\t\tpr_err(\"cannot start thread audit_prune_tree\");\n\t\tprune_thread = NULL;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!prune_thread"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&rule->rlist",
            "&tree->rules"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "seed->pathname",
            "tree->pathname"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tree",
            "&tree_list",
            "list"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic struct task_struct *prune_thread;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nint audit_add_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *seed = rule->tree, *tree;\n\tstruct path path;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\trule->tree = NULL;\n\tlist_for_each_entry(tree, &tree_list, list) {\n\t\tif (!strcmp(seed->pathname, tree->pathname)) {\n\t\t\tput_tree(seed);\n\t\t\trule->tree = tree;\n\t\t\tlist_add(&rule->rlist, &tree->rules);\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttree = seed;\n\tlist_add(&tree->list, &tree_list);\n\tlist_add(&rule->rlist, &tree->rules);\n\t/* do not set rule->tree yet */\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (unlikely(!prune_thread)) {\n\t\terr = audit_launch_prune();\n\t\tif (err)\n\t\t\tgoto Err;\n\t}\n\n\terr = kern_path(tree->pathname, 0, &path);\n\tif (err)\n\t\tgoto Err;\n\tmnt = collect_mounts(&path);\n\tpath_put(&path);\n\tif (IS_ERR(mnt)) {\n\t\terr = PTR_ERR(mnt);\n\t\tgoto Err;\n\t}\n\n\tget_tree(tree);\n\terr = iterate_mounts(tag_mount, tree, mnt);\n\tdrop_collected_mounts(mnt);\n\n\tif (!err) {\n\t\tstruct node *node;\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list)\n\t\t\tnode->index &= ~(1U<<31);\n\t\tspin_unlock(&hash_lock);\n\t} else {\n\t\ttrim_marked(tree);\n\t\tgoto Err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tif (list_empty(&rule->rlist)) {\n\t\tput_tree(tree);\n\t\treturn -ENOENT;\n\t}\n\trule->tree = tree;\n\tput_tree(tree);\n\n\treturn 0;\nErr:\n\tmutex_lock(&audit_filter_mutex);\n\tlist_del_init(&tree->list);\n\tlist_del_init(&tree->rules);\n\tput_tree(tree);\n\treturn err;\n}"
  },
  {
    "function_name": "audit_launch_prune",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "738-750",
    "snippet": "static int audit_launch_prune(void)\n{\n\tif (prune_thread)\n\t\treturn 0;\n\tprune_thread = kthread_run(prune_tree_thread, NULL,\n\t\t\t\t\"audit_prune_tree\");\n\tif (IS_ERR(prune_thread)) {\n\t\tpr_err(\"cannot start thread audit_prune_tree\");\n\t\tprune_thread = NULL;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *prune_thread;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cannot start thread audit_prune_tree\""
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prune_thread"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "prune_tree_thread",
            "NULL",
            "\"audit_prune_tree\""
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\n\nstatic int audit_launch_prune(void)\n{\n\tif (prune_thread)\n\t\treturn 0;\n\tprune_thread = kthread_run(prune_tree_thread, NULL,\n\t\t\t\t\"audit_prune_tree\");\n\tif (IS_ERR(prune_thread)) {\n\t\tpr_err(\"cannot start thread audit_prune_tree\");\n\t\tprune_thread = NULL;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "prune_tree_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "707-736",
    "snippet": "static int prune_tree_thread(void *unused)\n{\n\tfor (;;) {\n\t\tif (list_empty(&prune_list)) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule();\n\t\t}\n\n\t\taudit_ctl_lock();\n\t\tmutex_lock(&audit_filter_mutex);\n\n\t\twhile (!list_empty(&prune_list)) {\n\t\t\tstruct audit_tree *victim;\n\n\t\t\tvictim = list_entry(prune_list.next,\n\t\t\t\t\tstruct audit_tree, list);\n\t\t\tlist_del_init(&victim->list);\n\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\t\tprune_one(victim);\n\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t}\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\taudit_ctl_unlock();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(prune_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_ctl_unlock",
          "args": [],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "251-255",
          "snippet": "void audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_one",
          "args": [
            "victim"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "prune_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "539-551",
          "snippet": "static void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\n\t\tuntag_chunk(p);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\n\t\tuntag_chunk(p);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&victim->list"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "prune_list.next",
            "structaudit_tree",
            "list"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&prune_list"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ctl_lock",
          "args": [],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ctl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "242-246",
          "snippet": "void audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(prune_list);\n\nstatic int prune_tree_thread(void *unused)\n{\n\tfor (;;) {\n\t\tif (list_empty(&prune_list)) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule();\n\t\t}\n\n\t\taudit_ctl_lock();\n\t\tmutex_lock(&audit_filter_mutex);\n\n\t\twhile (!list_empty(&prune_list)) {\n\t\t\tstruct audit_tree *victim;\n\n\t\t\tvictim = list_entry(prune_list.next,\n\t\t\t\t\tstruct audit_tree, list);\n\t\t\tlist_del_init(&victim->list);\n\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\t\tprune_one(victim);\n\n\t\t\tmutex_lock(&audit_filter_mutex);\n\t\t}\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\taudit_ctl_unlock();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "tag_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "698-701",
    "snippet": "static int tag_mount(struct vfsmount *mnt, void *arg)\n{\n\treturn tag_chunk(d_backing_inode(mnt->mnt_root), arg);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tag_chunk",
          "args": [
            "d_backing_inode(mnt->mnt_root)",
            "arg"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "tag_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "389-495",
          "snippet": "static int tag_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *old_entry, *chunk_entry;\n\tstruct audit_tree *owner;\n\tstruct audit_chunk *chunk, *old;\n\tstruct node *p;\n\tint n;\n\n\told_entry = fsnotify_find_mark(&inode->i_fsnotify_marks,\n\t\t\t\t       audit_tree_group);\n\tif (!old_entry)\n\t\treturn create_chunk(inode, tree);\n\n\told = container_of(old_entry, struct audit_chunk, mark);\n\n\t/* are we already there? */\n\tspin_lock(&hash_lock);\n\tfor (n = 0; n < old->count; n++) {\n\t\tif (old->owners[n].owner == tree) {\n\t\t\tspin_unlock(&hash_lock);\n\t\t\tfsnotify_put_mark(old_entry);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tchunk = alloc_chunk(old->count + 1);\n\tif (!chunk) {\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tchunk_entry = &chunk->mark;\n\n\tmutex_lock(&old_entry->group->mark_mutex);\n\tspin_lock(&old_entry->lock);\n\t/*\n\t * mark_mutex protects mark from getting detached and thus also from\n\t * mark->connector->obj getting NULL.\n\t */\n\tif (!(old_entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\t/* old_entry is being shot, lets just lie */\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\t\tfsnotify_put_mark(old_entry);\n\t\tfsnotify_put_mark(&chunk->mark);\n\t\treturn -ENOENT;\n\t}\n\n\tif (fsnotify_add_mark_locked(chunk_entry, old_entry->connector->obj,\n\t\t\t\t     FSNOTIFY_OBJ_TYPE_INODE, 1)) {\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\t\tfsnotify_put_mark(chunk_entry);\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* even though we hold old_entry->lock, this is safe since chunk_entry->lock could NEVER have been grabbed before */\n\tspin_lock(&chunk_entry->lock);\n\tspin_lock(&hash_lock);\n\n\t/* we now hold old_entry->lock, chunk_entry->lock, and hash_lock */\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tchunk->dead = 1;\n\t\tspin_unlock(&chunk_entry->lock);\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\n\t\tfsnotify_destroy_mark(chunk_entry, audit_tree_group);\n\n\t\tfsnotify_put_mark(chunk_entry);\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn 0;\n\t}\n\tlist_replace_init(&old->trees, &chunk->trees);\n\tfor (n = 0, p = chunk->owners; n < old->count; n++, p++) {\n\t\tstruct audit_tree *s = old->owners[n].owner;\n\t\tp->owner = s;\n\t\tp->index = old->owners[n].index;\n\t\tif (!s) /* result of fallback in untag */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&old->owners[n].list, &p->list);\n\t}\n\tp->index = (chunk->count - 1) | (1U<<31);\n\tp->owner = tree;\n\tget_tree(tree);\n\tlist_add(&p->list, &tree->chunks);\n\tlist_replace_rcu(&old->hash, &chunk->hash);\n\tlist_for_each_entry(owner, &chunk->trees, same_root)\n\t\towner->root = chunk;\n\told->dead = 1;\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&chunk_entry->lock);\n\tspin_unlock(&old_entry->lock);\n\tmutex_unlock(&old_entry->group->mark_mutex);\n\tfsnotify_destroy_mark(old_entry, audit_tree_group);\n\tfsnotify_put_mark(chunk_entry);\t/* drop initial reference */\n\tfsnotify_put_mark(old_entry); /* pair to fsnotify_find mark_entry */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic int tag_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *old_entry, *chunk_entry;\n\tstruct audit_tree *owner;\n\tstruct audit_chunk *chunk, *old;\n\tstruct node *p;\n\tint n;\n\n\told_entry = fsnotify_find_mark(&inode->i_fsnotify_marks,\n\t\t\t\t       audit_tree_group);\n\tif (!old_entry)\n\t\treturn create_chunk(inode, tree);\n\n\told = container_of(old_entry, struct audit_chunk, mark);\n\n\t/* are we already there? */\n\tspin_lock(&hash_lock);\n\tfor (n = 0; n < old->count; n++) {\n\t\tif (old->owners[n].owner == tree) {\n\t\t\tspin_unlock(&hash_lock);\n\t\t\tfsnotify_put_mark(old_entry);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tchunk = alloc_chunk(old->count + 1);\n\tif (!chunk) {\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tchunk_entry = &chunk->mark;\n\n\tmutex_lock(&old_entry->group->mark_mutex);\n\tspin_lock(&old_entry->lock);\n\t/*\n\t * mark_mutex protects mark from getting detached and thus also from\n\t * mark->connector->obj getting NULL.\n\t */\n\tif (!(old_entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\t/* old_entry is being shot, lets just lie */\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\t\tfsnotify_put_mark(old_entry);\n\t\tfsnotify_put_mark(&chunk->mark);\n\t\treturn -ENOENT;\n\t}\n\n\tif (fsnotify_add_mark_locked(chunk_entry, old_entry->connector->obj,\n\t\t\t\t     FSNOTIFY_OBJ_TYPE_INODE, 1)) {\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\t\tfsnotify_put_mark(chunk_entry);\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* even though we hold old_entry->lock, this is safe since chunk_entry->lock could NEVER have been grabbed before */\n\tspin_lock(&chunk_entry->lock);\n\tspin_lock(&hash_lock);\n\n\t/* we now hold old_entry->lock, chunk_entry->lock, and hash_lock */\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tchunk->dead = 1;\n\t\tspin_unlock(&chunk_entry->lock);\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\n\t\tfsnotify_destroy_mark(chunk_entry, audit_tree_group);\n\n\t\tfsnotify_put_mark(chunk_entry);\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn 0;\n\t}\n\tlist_replace_init(&old->trees, &chunk->trees);\n\tfor (n = 0, p = chunk->owners; n < old->count; n++, p++) {\n\t\tstruct audit_tree *s = old->owners[n].owner;\n\t\tp->owner = s;\n\t\tp->index = old->owners[n].index;\n\t\tif (!s) /* result of fallback in untag */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&old->owners[n].list, &p->list);\n\t}\n\tp->index = (chunk->count - 1) | (1U<<31);\n\tp->owner = tree;\n\tget_tree(tree);\n\tlist_add(&p->list, &tree->chunks);\n\tlist_replace_rcu(&old->hash, &chunk->hash);\n\tlist_for_each_entry(owner, &chunk->trees, same_root)\n\t\towner->root = chunk;\n\told->dead = 1;\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&chunk_entry->lock);\n\tspin_unlock(&old_entry->lock);\n\tmutex_unlock(&old_entry->group->mark_mutex);\n\tfsnotify_destroy_mark(old_entry, audit_tree_group);\n\tfsnotify_put_mark(chunk_entry);\t/* drop initial reference */\n\tfsnotify_put_mark(old_entry); /* pair to fsnotify_find mark_entry */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "mnt->mnt_root"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic int tag_mount(struct vfsmount *mnt, void *arg)\n{\n\treturn tag_chunk(d_backing_inode(mnt->mnt_root), arg);\n}"
  },
  {
    "function_name": "audit_put_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "693-696",
    "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "tree"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "693-696",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
  },
  {
    "function_name": "audit_make_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "679-691",
    "snippet": "int audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)\n{\n\n\tif (pathname[0] != '/' ||\n\t    rule->listnr != AUDIT_FILTER_EXIT ||\n\t    op != Audit_equal ||\n\t    rule->inode_f || rule->watch || rule->tree)\n\t\treturn -EINVAL;\n\trule->tree = alloc_tree(pathname);\n\tif (!rule->tree)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_tree",
          "args": [
            "pathname"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "76-92",
          "snippet": "static struct audit_tree *alloc_tree(const char *s)\n{\n\tstruct audit_tree *tree;\n\n\ttree = kmalloc(sizeof(struct audit_tree) + strlen(s) + 1, GFP_KERNEL);\n\tif (tree) {\n\t\trefcount_set(&tree->count, 1);\n\t\ttree->goner = 0;\n\t\tINIT_LIST_HEAD(&tree->chunks);\n\t\tINIT_LIST_HEAD(&tree->rules);\n\t\tINIT_LIST_HEAD(&tree->list);\n\t\tINIT_LIST_HEAD(&tree->same_root);\n\t\ttree->root = NULL;\n\t\tstrcpy(tree->pathname, s);\n\t}\n\treturn tree;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_tree *alloc_tree(const char *s)\n{\n\tstruct audit_tree *tree;\n\n\ttree = kmalloc(sizeof(struct audit_tree) + strlen(s) + 1, GFP_KERNEL);\n\tif (tree) {\n\t\trefcount_set(&tree->count, 1);\n\t\ttree->goner = 0;\n\t\tINIT_LIST_HEAD(&tree->chunks);\n\t\tINIT_LIST_HEAD(&tree->rules);\n\t\tINIT_LIST_HEAD(&tree->list);\n\t\tINIT_LIST_HEAD(&tree->same_root);\n\t\ttree->root = NULL;\n\t\tstrcpy(tree->pathname, s);\n\t}\n\treturn tree;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nint audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)\n{\n\n\tif (pathname[0] != '/' ||\n\t    rule->listnr != AUDIT_FILTER_EXIT ||\n\t    op != Audit_equal ||\n\t    rule->inode_f || rule->watch || rule->tree)\n\t\treturn -EINVAL;\n\trule->tree = alloc_tree(pathname);\n\tif (!rule->tree)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_trim_trees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "630-677",
    "snippet": "void audit_trim_trees(void)\n{\n\tstruct list_head cursor;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&cursor, &tree_list);\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tstruct path path;\n\t\tstruct vfsmount *root_mnt;\n\t\tstruct node *node;\n\t\tint err;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&cursor);\n\t\tlist_add(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path);\n\t\tif (err)\n\t\t\tgoto skip_it;\n\n\t\troot_mnt = collect_mounts(&path);\n\t\tpath_put(&path);\n\t\tif (IS_ERR(root_mnt))\n\t\t\tgoto skip_it;\n\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list) {\n\t\t\tstruct audit_chunk *chunk = find_chunk(node);\n\t\t\t/* this could be NULL if the watch is dying else where... */\n\t\t\tnode->index |= 1U<<31;\n\t\t\tif (iterate_mounts(compare_root,\n\t\t\t\t\t   (void *)chunk_to_key(chunk),\n\t\t\t\t\t   root_mnt))\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\ttrim_marked(tree);\n\t\tdrop_collected_mounts(root_mnt);\nskip_it:\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tree_list);",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cursor"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "tree"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "693-696",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_collected_mounts",
          "args": [
            "root_mnt"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trim_marked",
          "args": [
            "tree"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "trim_marked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "555-595",
          "snippet": "static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t/* have we run out of marked? */\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tuntag_chunk(node);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t/* have we run out of marked? */\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tuntag_chunk(node);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_mounts",
          "args": [
            "compare_root",
            "(void *)chunk_to_key(chunk)",
            "root_mnt"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chunk_to_key",
          "args": [
            "chunk"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "179-188",
          "snippet": "static unsigned long chunk_to_key(struct audit_chunk *chunk)\n{\n\t/*\n\t * We have a reference to the mark so it should be attached to a\n\t * connector.\n\t */\n\tif (WARN_ON_ONCE(!chunk->mark.connector))\n\t\treturn 0;\n\treturn (unsigned long)chunk->mark.connector->obj;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long chunk_to_key(struct audit_chunk *chunk)\n{\n\t/*\n\t * We have a reference to the mark so it should be attached to a\n\t * connector.\n\t */\n\tif (WARN_ON_ONCE(!chunk->mark.connector))\n\t\treturn 0;\n\treturn (unsigned long)chunk->mark.connector->obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_chunk",
          "args": [
            "node"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "find_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "235-240",
          "snippet": "static struct audit_chunk *find_chunk(struct node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *find_chunk(struct node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&tree->chunks",
            "list"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root_mnt"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_mounts",
          "args": [
            "&path"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "tree->pathname",
            "0",
            "&path"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cursor",
            "&tree->list"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "tree"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "94-97",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cursor.next",
            "structaudit_tree",
            "list"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(tree_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nvoid audit_trim_trees(void)\n{\n\tstruct list_head cursor;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_add(&cursor, &tree_list);\n\twhile (cursor.next != &tree_list) {\n\t\tstruct audit_tree *tree;\n\t\tstruct path path;\n\t\tstruct vfsmount *root_mnt;\n\t\tstruct node *node;\n\t\tint err;\n\n\t\ttree = container_of(cursor.next, struct audit_tree, list);\n\t\tget_tree(tree);\n\t\tlist_del(&cursor);\n\t\tlist_add(&cursor, &tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\terr = kern_path(tree->pathname, 0, &path);\n\t\tif (err)\n\t\t\tgoto skip_it;\n\n\t\troot_mnt = collect_mounts(&path);\n\t\tpath_put(&path);\n\t\tif (IS_ERR(root_mnt))\n\t\t\tgoto skip_it;\n\n\t\tspin_lock(&hash_lock);\n\t\tlist_for_each_entry(node, &tree->chunks, list) {\n\t\t\tstruct audit_chunk *chunk = find_chunk(node);\n\t\t\t/* this could be NULL if the watch is dying else where... */\n\t\t\tnode->index |= 1U<<31;\n\t\t\tif (iterate_mounts(compare_root,\n\t\t\t\t\t   (void *)chunk_to_key(chunk),\n\t\t\t\t\t   root_mnt))\n\t\t\t\tnode->index &= ~(1U<<31);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\ttrim_marked(tree);\n\t\tdrop_collected_mounts(root_mnt);\nskip_it:\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n}"
  },
  {
    "function_name": "compare_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "624-628",
    "snippet": "static int compare_root(struct vfsmount *mnt, void *arg)\n{\n\treturn inode_to_key(d_backing_inode(mnt->mnt_root)) ==\n\t       (unsigned long)arg;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_to_key",
          "args": [
            "d_backing_inode(mnt->mnt_root)"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "169-173",
          "snippet": "static unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "mnt->mnt_root"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic int compare_root(struct vfsmount *mnt, void *arg)\n{\n\treturn inode_to_key(d_backing_inode(mnt->mnt_root)) ==\n\t       (unsigned long)arg;\n}"
  },
  {
    "function_name": "audit_remove_tree_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "600-622",
    "snippet": "int audit_remove_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *tree;\n\ttree = rule->tree;\n\tif (tree) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&rule->rlist);\n\t\tif (list_empty(&tree->rules) && !tree->goner) {\n\t\t\ttree->root = NULL;\n\t\t\tlist_del_init(&tree->same_root);\n\t\t\ttree->goner = 1;\n\t\t\tlist_move(&tree->list, &prune_list);\n\t\t\trule->tree = NULL;\n\t\t\tspin_unlock(&hash_lock);\n\t\t\taudit_schedule_prune();\n\t\t\treturn 1;\n\t\t}\n\t\trule->tree = NULL;\n\t\tspin_unlock(&hash_lock);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(prune_list);",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);",
      "static void audit_schedule_prune(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_schedule_prune",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&tree->list",
            "&prune_list"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tree->same_root"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tree->rules"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rule->rlist"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic LIST_HEAD(prune_list);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\nstatic void audit_schedule_prune(void);\n\nint audit_remove_tree_rule(struct audit_krule *rule)\n{\n\tstruct audit_tree *tree;\n\ttree = rule->tree;\n\tif (tree) {\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&rule->rlist);\n\t\tif (list_empty(&tree->rules) && !tree->goner) {\n\t\t\ttree->root = NULL;\n\t\t\tlist_del_init(&tree->same_root);\n\t\t\ttree->goner = 1;\n\t\t\tlist_move(&tree->list, &prune_list);\n\t\t\trule->tree = NULL;\n\t\t\tspin_unlock(&hash_lock);\n\t\t\taudit_schedule_prune();\n\t\t\treturn 1;\n\t\t}\n\t\trule->tree = NULL;\n\t\tspin_unlock(&hash_lock);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "trim_marked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "555-595",
    "snippet": "static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t/* have we run out of marked? */\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tuntag_chunk(node);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_one",
          "args": [
            "tree"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "prune_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "539-551",
          "snippet": "static void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\n\t\tuntag_chunk(p);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\n\t\tuntag_chunk(p);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tree->list"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_rules",
          "args": [
            "tree"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "kill_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "514-534",
          "snippet": "static void kill_rules(struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void kill_rules(struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "untag_chunk",
          "args": [
            "node"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "untag_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "242-348",
          "snippet": "static void untag_chunk(struct node *p)\n{\n\tstruct audit_chunk *chunk = find_chunk(p);\n\tstruct fsnotify_mark *entry = &chunk->mark;\n\tstruct audit_chunk *new = NULL;\n\tstruct audit_tree *owner;\n\tint size = chunk->count - 1;\n\tint i, j;\n\n\tfsnotify_get_mark(entry);\n\n\tspin_unlock(&hash_lock);\n\n\tif (size)\n\t\tnew = alloc_chunk(size);\n\n\tmutex_lock(&entry->group->mark_mutex);\n\tspin_lock(&entry->lock);\n\t/*\n\t * mark_mutex protects mark from getting detached and thus also from\n\t * mark->connector->obj getting NULL.\n\t */\n\tif (chunk->dead || !(entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tif (new)\n\t\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto out;\n\t}\n\n\towner = p->owner;\n\n\tif (!size) {\n\t\tchunk->dead = 1;\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tif (owner->root == chunk)\n\t\t\towner->root = NULL;\n\t\tlist_del_init(&p->list);\n\t\tlist_del_rcu(&chunk->hash);\n\t\tspin_unlock(&hash_lock);\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tfsnotify_destroy_mark(entry, audit_tree_group);\n\t\tgoto out;\n\t}\n\n\tif (!new)\n\t\tgoto Fallback;\n\n\tif (fsnotify_add_mark_locked(&new->mark, entry->connector->obj,\n\t\t\t\t     FSNOTIFY_OBJ_TYPE_INODE, 1)) {\n\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto Fallback;\n\t}\n\n\tchunk->dead = 1;\n\tspin_lock(&hash_lock);\n\tlist_replace_init(&chunk->trees, &new->trees);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\n\tfor (i = j = 0; j <= size; i++, j++) {\n\t\tstruct audit_tree *s;\n\t\tif (&chunk->owners[j] == p) {\n\t\t\tlist_del_init(&p->list);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\ts = chunk->owners[j].owner;\n\t\tnew->owners[i].owner = s;\n\t\tnew->owners[i].index = chunk->owners[j].index - j + i;\n\t\tif (!s) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&chunk->owners[j].list, &new->owners[i].list);\n\t}\n\n\tlist_replace_rcu(&chunk->hash, &new->hash);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\n\tfsnotify_destroy_mark(entry, audit_tree_group);\n\tfsnotify_put_mark(&new->mark);\t/* drop initial reference */\n\tgoto out;\n\nFallback:\n\t// do the best we can\n\tspin_lock(&hash_lock);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\nout:\n\tfsnotify_put_mark(entry);\n\tspin_lock(&hash_lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void untag_chunk(struct node *p)\n{\n\tstruct audit_chunk *chunk = find_chunk(p);\n\tstruct fsnotify_mark *entry = &chunk->mark;\n\tstruct audit_chunk *new = NULL;\n\tstruct audit_tree *owner;\n\tint size = chunk->count - 1;\n\tint i, j;\n\n\tfsnotify_get_mark(entry);\n\n\tspin_unlock(&hash_lock);\n\n\tif (size)\n\t\tnew = alloc_chunk(size);\n\n\tmutex_lock(&entry->group->mark_mutex);\n\tspin_lock(&entry->lock);\n\t/*\n\t * mark_mutex protects mark from getting detached and thus also from\n\t * mark->connector->obj getting NULL.\n\t */\n\tif (chunk->dead || !(entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tif (new)\n\t\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto out;\n\t}\n\n\towner = p->owner;\n\n\tif (!size) {\n\t\tchunk->dead = 1;\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tif (owner->root == chunk)\n\t\t\towner->root = NULL;\n\t\tlist_del_init(&p->list);\n\t\tlist_del_rcu(&chunk->hash);\n\t\tspin_unlock(&hash_lock);\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tfsnotify_destroy_mark(entry, audit_tree_group);\n\t\tgoto out;\n\t}\n\n\tif (!new)\n\t\tgoto Fallback;\n\n\tif (fsnotify_add_mark_locked(&new->mark, entry->connector->obj,\n\t\t\t\t     FSNOTIFY_OBJ_TYPE_INODE, 1)) {\n\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto Fallback;\n\t}\n\n\tchunk->dead = 1;\n\tspin_lock(&hash_lock);\n\tlist_replace_init(&chunk->trees, &new->trees);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\n\tfor (i = j = 0; j <= size; i++, j++) {\n\t\tstruct audit_tree *s;\n\t\tif (&chunk->owners[j] == p) {\n\t\t\tlist_del_init(&p->list);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\ts = chunk->owners[j].owner;\n\t\tnew->owners[i].owner = s;\n\t\tnew->owners[i].index = chunk->owners[j].index - j + i;\n\t\tif (!s) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&chunk->owners[j].list, &new->owners[i].list);\n\t}\n\n\tlist_replace_rcu(&chunk->hash, &new->hash);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\n\tfsnotify_destroy_mark(entry, audit_tree_group);\n\tfsnotify_put_mark(&new->mark);\t/* drop initial reference */\n\tgoto out;\n\nFallback:\n\t// do the best we can\n\tspin_lock(&hash_lock);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\nout:\n\tfsnotify_put_mark(entry);\n\tspin_lock(&hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tree->chunks.next",
            "structnode",
            "list"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tree->chunks"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "p",
            "&tree->chunks"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "p"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structnode",
            "list"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t/* reorder */\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t/* have we run out of marked? */\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tuntag_chunk(node);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}"
  },
  {
    "function_name": "prune_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "539-551",
    "snippet": "static void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\n\t\tuntag_chunk(p);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "victim"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "693-696",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untag_chunk",
          "args": [
            "p"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "untag_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "242-348",
          "snippet": "static void untag_chunk(struct node *p)\n{\n\tstruct audit_chunk *chunk = find_chunk(p);\n\tstruct fsnotify_mark *entry = &chunk->mark;\n\tstruct audit_chunk *new = NULL;\n\tstruct audit_tree *owner;\n\tint size = chunk->count - 1;\n\tint i, j;\n\n\tfsnotify_get_mark(entry);\n\n\tspin_unlock(&hash_lock);\n\n\tif (size)\n\t\tnew = alloc_chunk(size);\n\n\tmutex_lock(&entry->group->mark_mutex);\n\tspin_lock(&entry->lock);\n\t/*\n\t * mark_mutex protects mark from getting detached and thus also from\n\t * mark->connector->obj getting NULL.\n\t */\n\tif (chunk->dead || !(entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tif (new)\n\t\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto out;\n\t}\n\n\towner = p->owner;\n\n\tif (!size) {\n\t\tchunk->dead = 1;\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tif (owner->root == chunk)\n\t\t\towner->root = NULL;\n\t\tlist_del_init(&p->list);\n\t\tlist_del_rcu(&chunk->hash);\n\t\tspin_unlock(&hash_lock);\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tfsnotify_destroy_mark(entry, audit_tree_group);\n\t\tgoto out;\n\t}\n\n\tif (!new)\n\t\tgoto Fallback;\n\n\tif (fsnotify_add_mark_locked(&new->mark, entry->connector->obj,\n\t\t\t\t     FSNOTIFY_OBJ_TYPE_INODE, 1)) {\n\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto Fallback;\n\t}\n\n\tchunk->dead = 1;\n\tspin_lock(&hash_lock);\n\tlist_replace_init(&chunk->trees, &new->trees);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\n\tfor (i = j = 0; j <= size; i++, j++) {\n\t\tstruct audit_tree *s;\n\t\tif (&chunk->owners[j] == p) {\n\t\t\tlist_del_init(&p->list);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\ts = chunk->owners[j].owner;\n\t\tnew->owners[i].owner = s;\n\t\tnew->owners[i].index = chunk->owners[j].index - j + i;\n\t\tif (!s) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&chunk->owners[j].list, &new->owners[i].list);\n\t}\n\n\tlist_replace_rcu(&chunk->hash, &new->hash);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\n\tfsnotify_destroy_mark(entry, audit_tree_group);\n\tfsnotify_put_mark(&new->mark);\t/* drop initial reference */\n\tgoto out;\n\nFallback:\n\t// do the best we can\n\tspin_lock(&hash_lock);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\nout:\n\tfsnotify_put_mark(entry);\n\tspin_lock(&hash_lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void untag_chunk(struct node *p)\n{\n\tstruct audit_chunk *chunk = find_chunk(p);\n\tstruct fsnotify_mark *entry = &chunk->mark;\n\tstruct audit_chunk *new = NULL;\n\tstruct audit_tree *owner;\n\tint size = chunk->count - 1;\n\tint i, j;\n\n\tfsnotify_get_mark(entry);\n\n\tspin_unlock(&hash_lock);\n\n\tif (size)\n\t\tnew = alloc_chunk(size);\n\n\tmutex_lock(&entry->group->mark_mutex);\n\tspin_lock(&entry->lock);\n\t/*\n\t * mark_mutex protects mark from getting detached and thus also from\n\t * mark->connector->obj getting NULL.\n\t */\n\tif (chunk->dead || !(entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tif (new)\n\t\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto out;\n\t}\n\n\towner = p->owner;\n\n\tif (!size) {\n\t\tchunk->dead = 1;\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tif (owner->root == chunk)\n\t\t\towner->root = NULL;\n\t\tlist_del_init(&p->list);\n\t\tlist_del_rcu(&chunk->hash);\n\t\tspin_unlock(&hash_lock);\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tfsnotify_destroy_mark(entry, audit_tree_group);\n\t\tgoto out;\n\t}\n\n\tif (!new)\n\t\tgoto Fallback;\n\n\tif (fsnotify_add_mark_locked(&new->mark, entry->connector->obj,\n\t\t\t\t     FSNOTIFY_OBJ_TYPE_INODE, 1)) {\n\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto Fallback;\n\t}\n\n\tchunk->dead = 1;\n\tspin_lock(&hash_lock);\n\tlist_replace_init(&chunk->trees, &new->trees);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\n\tfor (i = j = 0; j <= size; i++, j++) {\n\t\tstruct audit_tree *s;\n\t\tif (&chunk->owners[j] == p) {\n\t\t\tlist_del_init(&p->list);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\ts = chunk->owners[j].owner;\n\t\tnew->owners[i].owner = s;\n\t\tnew->owners[i].index = chunk->owners[j].index - j + i;\n\t\tif (!s) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&chunk->owners[j].list, &new->owners[i].list);\n\t}\n\n\tlist_replace_rcu(&chunk->hash, &new->hash);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\n\tfsnotify_destroy_mark(entry, audit_tree_group);\n\tfsnotify_put_mark(&new->mark);\t/* drop initial reference */\n\tgoto out;\n\nFallback:\n\t// do the best we can\n\tspin_lock(&hash_lock);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\nout:\n\tfsnotify_put_mark(entry);\n\tspin_lock(&hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "victim->chunks.next",
            "structnode",
            "list"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&victim->chunks"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void prune_one(struct audit_tree *victim)\n{\n\tspin_lock(&hash_lock);\n\twhile (!list_empty(&victim->chunks)) {\n\t\tstruct node *p;\n\n\t\tp = list_entry(victim->chunks.next, struct node, list);\n\n\t\tuntag_chunk(p);\n\t}\n\tspin_unlock(&hash_lock);\n\tput_tree(victim);\n}"
  },
  {
    "function_name": "kill_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "514-534",
    "snippet": "static void kill_rules(struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&entry->rcu",
            "audit_free_rule_rcu"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->rule.list"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&entry->list"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "entry->rule.exe"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_fsnotify.c",
          "lines": "149-154",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_tree_log_remove_rule",
          "args": [
            "rule"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_log_remove_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "497-512",
          "snippet": "static void audit_tree_log_remove_rule(struct audit_krule *rule)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"op=remove_rule\");\n\taudit_log_format(ab, \" dir=\");\n\taudit_log_untrustedstring(ab, rule->tree->pathname);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void audit_tree_log_remove_rule(struct audit_krule *rule)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"op=remove_rule\");\n\taudit_log_format(ab, \" dir=\");\n\taudit_log_untrustedstring(ab, rule->tree->pathname);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rule->rlist"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rule",
            "structaudit_entry",
            "rule"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rule",
            "next",
            "&tree->rules",
            "rlist"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void kill_rules(struct audit_tree *tree)\n{\n\tstruct audit_krule *rule, *next;\n\tstruct audit_entry *entry;\n\n\tlist_for_each_entry_safe(rule, next, &tree->rules, rlist) {\n\t\tentry = container_of(rule, struct audit_entry, rule);\n\n\t\tlist_del_init(&rule->rlist);\n\t\tif (rule->tree) {\n\t\t\t/* not a half-baked one */\n\t\t\taudit_tree_log_remove_rule(rule);\n\t\t\tif (entry->rule.exe)\n\t\t\t\taudit_remove_mark(entry->rule.exe);\n\t\t\trule->tree = NULL;\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tlist_del(&entry->rule.list);\n\t\t\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "audit_tree_log_remove_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "497-512",
    "snippet": "static void audit_tree_log_remove_rule(struct audit_krule *rule)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"op=remove_rule\");\n\taudit_log_format(ab, \" dir=\");\n\taudit_log_untrustedstring(ab, rule->tree->pathname);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" list=%d res=1\"",
            "rule->listnr"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_key",
          "args": [
            "ab",
            "rule->filterkey"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2048-2055",
          "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "rule->tree->pathname"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2011-2014",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "NULL",
            "GFP_KERNEL",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void audit_tree_log_remove_rule(struct audit_krule *rule)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_format(ab, \"op=remove_rule\");\n\taudit_log_format(ab, \" dir=\");\n\taudit_log_untrustedstring(ab, rule->tree->pathname);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "tag_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "389-495",
    "snippet": "static int tag_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *old_entry, *chunk_entry;\n\tstruct audit_tree *owner;\n\tstruct audit_chunk *chunk, *old;\n\tstruct node *p;\n\tint n;\n\n\told_entry = fsnotify_find_mark(&inode->i_fsnotify_marks,\n\t\t\t\t       audit_tree_group);\n\tif (!old_entry)\n\t\treturn create_chunk(inode, tree);\n\n\told = container_of(old_entry, struct audit_chunk, mark);\n\n\t/* are we already there? */\n\tspin_lock(&hash_lock);\n\tfor (n = 0; n < old->count; n++) {\n\t\tif (old->owners[n].owner == tree) {\n\t\t\tspin_unlock(&hash_lock);\n\t\t\tfsnotify_put_mark(old_entry);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tchunk = alloc_chunk(old->count + 1);\n\tif (!chunk) {\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tchunk_entry = &chunk->mark;\n\n\tmutex_lock(&old_entry->group->mark_mutex);\n\tspin_lock(&old_entry->lock);\n\t/*\n\t * mark_mutex protects mark from getting detached and thus also from\n\t * mark->connector->obj getting NULL.\n\t */\n\tif (!(old_entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\t/* old_entry is being shot, lets just lie */\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\t\tfsnotify_put_mark(old_entry);\n\t\tfsnotify_put_mark(&chunk->mark);\n\t\treturn -ENOENT;\n\t}\n\n\tif (fsnotify_add_mark_locked(chunk_entry, old_entry->connector->obj,\n\t\t\t\t     FSNOTIFY_OBJ_TYPE_INODE, 1)) {\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\t\tfsnotify_put_mark(chunk_entry);\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* even though we hold old_entry->lock, this is safe since chunk_entry->lock could NEVER have been grabbed before */\n\tspin_lock(&chunk_entry->lock);\n\tspin_lock(&hash_lock);\n\n\t/* we now hold old_entry->lock, chunk_entry->lock, and hash_lock */\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tchunk->dead = 1;\n\t\tspin_unlock(&chunk_entry->lock);\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\n\t\tfsnotify_destroy_mark(chunk_entry, audit_tree_group);\n\n\t\tfsnotify_put_mark(chunk_entry);\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn 0;\n\t}\n\tlist_replace_init(&old->trees, &chunk->trees);\n\tfor (n = 0, p = chunk->owners; n < old->count; n++, p++) {\n\t\tstruct audit_tree *s = old->owners[n].owner;\n\t\tp->owner = s;\n\t\tp->index = old->owners[n].index;\n\t\tif (!s) /* result of fallback in untag */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&old->owners[n].list, &p->list);\n\t}\n\tp->index = (chunk->count - 1) | (1U<<31);\n\tp->owner = tree;\n\tget_tree(tree);\n\tlist_add(&p->list, &tree->chunks);\n\tlist_replace_rcu(&old->hash, &chunk->hash);\n\tlist_for_each_entry(owner, &chunk->trees, same_root)\n\t\towner->root = chunk;\n\told->dead = 1;\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&chunk_entry->lock);\n\tspin_unlock(&old_entry->lock);\n\tmutex_unlock(&old_entry->group->mark_mutex);\n\tfsnotify_destroy_mark(old_entry, audit_tree_group);\n\tfsnotify_put_mark(chunk_entry);\t/* drop initial reference */\n\tfsnotify_put_mark(old_entry); /* pair to fsnotify_find mark_entry */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_tree_group;",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "old_entry"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "chunk_entry"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "old_entry",
            "audit_tree_group"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&old_entry->group->mark_mutex"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&old_entry->lock"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tree->same_root",
            "&chunk->trees"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "owner",
            "&chunk->trees",
            "same_root"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_rcu",
          "args": [
            "&old->hash",
            "&chunk->hash"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "tree"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "94-97",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&old->owners[n].list",
            "&p->list"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&old->trees",
            "&chunk->trees"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "old_entry"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "chunk_entry"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "chunk_entry",
            "audit_tree_group"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "old_entry"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "chunk_entry"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_add_mark_locked",
          "args": [
            "chunk_entry",
            "old_entry->connector->obj",
            "FSNOTIFY_OBJ_TYPE_INODE",
            "1"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "&chunk->mark"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "old_entry"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&old_entry->group->mark_mutex"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "old_entry"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_chunk",
          "args": [
            "old->count + 1"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "140-162",
          "snippet": "static struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tsize_t size;\n\tint i;\n\n\tsize = offsetof(struct audit_chunk, owners) + count * sizeof(struct node);\n\tchunk = kzalloc(size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\tfsnotify_init_mark(&chunk->mark, audit_tree_group);\n\tchunk->mark.mask = FS_IN_IGNORED;\n\treturn chunk;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\n\nstatic struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tsize_t size;\n\tint i;\n\n\tsize = offsetof(struct audit_chunk, owners) + count * sizeof(struct node);\n\tchunk = kzalloc(size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\tfsnotify_init_mark(&chunk->mark, audit_tree_group);\n\tchunk->mark.mask = FS_IN_IGNORED;\n\treturn chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "old_entry"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "old_entry",
            "structaudit_chunk",
            "mark"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_chunk",
          "args": [
            "inode",
            "tree"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "create_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "350-386",
          "snippet": "static int create_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *entry;\n\tstruct audit_chunk *chunk = alloc_chunk(1);\n\tif (!chunk)\n\t\treturn -ENOMEM;\n\n\tentry = &chunk->mark;\n\tif (fsnotify_add_inode_mark(entry, inode, 0)) {\n\t\tfsnotify_put_mark(entry);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock(&entry->lock);\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tchunk->dead = 1;\n\t\tspin_unlock(&entry->lock);\n\t\tfsnotify_destroy_mark(entry, audit_tree_group);\n\t\tfsnotify_put_mark(entry);\n\t\treturn 0;\n\t}\n\tchunk->owners[0].index = (1U << 31);\n\tchunk->owners[0].owner = tree;\n\tget_tree(tree);\n\tlist_add(&chunk->owners[0].list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tinsert_hash(chunk);\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tfsnotify_put_mark(entry);\t/* drop initial reference */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic int create_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *entry;\n\tstruct audit_chunk *chunk = alloc_chunk(1);\n\tif (!chunk)\n\t\treturn -ENOMEM;\n\n\tentry = &chunk->mark;\n\tif (fsnotify_add_inode_mark(entry, inode, 0)) {\n\t\tfsnotify_put_mark(entry);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock(&entry->lock);\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tchunk->dead = 1;\n\t\tspin_unlock(&entry->lock);\n\t\tfsnotify_destroy_mark(entry, audit_tree_group);\n\t\tfsnotify_put_mark(entry);\n\t\treturn 0;\n\t}\n\tchunk->owners[0].index = (1U << 31);\n\tchunk->owners[0].owner = tree;\n\tget_tree(tree);\n\tlist_add(&chunk->owners[0].list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tinsert_hash(chunk);\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tfsnotify_put_mark(entry);\t/* drop initial reference */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_find_mark",
          "args": [
            "&inode->i_fsnotify_marks",
            "audit_tree_group"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic int tag_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *old_entry, *chunk_entry;\n\tstruct audit_tree *owner;\n\tstruct audit_chunk *chunk, *old;\n\tstruct node *p;\n\tint n;\n\n\told_entry = fsnotify_find_mark(&inode->i_fsnotify_marks,\n\t\t\t\t       audit_tree_group);\n\tif (!old_entry)\n\t\treturn create_chunk(inode, tree);\n\n\told = container_of(old_entry, struct audit_chunk, mark);\n\n\t/* are we already there? */\n\tspin_lock(&hash_lock);\n\tfor (n = 0; n < old->count; n++) {\n\t\tif (old->owners[n].owner == tree) {\n\t\t\tspin_unlock(&hash_lock);\n\t\t\tfsnotify_put_mark(old_entry);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&hash_lock);\n\n\tchunk = alloc_chunk(old->count + 1);\n\tif (!chunk) {\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tchunk_entry = &chunk->mark;\n\n\tmutex_lock(&old_entry->group->mark_mutex);\n\tspin_lock(&old_entry->lock);\n\t/*\n\t * mark_mutex protects mark from getting detached and thus also from\n\t * mark->connector->obj getting NULL.\n\t */\n\tif (!(old_entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\t/* old_entry is being shot, lets just lie */\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\t\tfsnotify_put_mark(old_entry);\n\t\tfsnotify_put_mark(&chunk->mark);\n\t\treturn -ENOENT;\n\t}\n\n\tif (fsnotify_add_mark_locked(chunk_entry, old_entry->connector->obj,\n\t\t\t\t     FSNOTIFY_OBJ_TYPE_INODE, 1)) {\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\t\tfsnotify_put_mark(chunk_entry);\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn -ENOSPC;\n\t}\n\n\t/* even though we hold old_entry->lock, this is safe since chunk_entry->lock could NEVER have been grabbed before */\n\tspin_lock(&chunk_entry->lock);\n\tspin_lock(&hash_lock);\n\n\t/* we now hold old_entry->lock, chunk_entry->lock, and hash_lock */\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tchunk->dead = 1;\n\t\tspin_unlock(&chunk_entry->lock);\n\t\tspin_unlock(&old_entry->lock);\n\t\tmutex_unlock(&old_entry->group->mark_mutex);\n\n\t\tfsnotify_destroy_mark(chunk_entry, audit_tree_group);\n\n\t\tfsnotify_put_mark(chunk_entry);\n\t\tfsnotify_put_mark(old_entry);\n\t\treturn 0;\n\t}\n\tlist_replace_init(&old->trees, &chunk->trees);\n\tfor (n = 0, p = chunk->owners; n < old->count; n++, p++) {\n\t\tstruct audit_tree *s = old->owners[n].owner;\n\t\tp->owner = s;\n\t\tp->index = old->owners[n].index;\n\t\tif (!s) /* result of fallback in untag */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&old->owners[n].list, &p->list);\n\t}\n\tp->index = (chunk->count - 1) | (1U<<31);\n\tp->owner = tree;\n\tget_tree(tree);\n\tlist_add(&p->list, &tree->chunks);\n\tlist_replace_rcu(&old->hash, &chunk->hash);\n\tlist_for_each_entry(owner, &chunk->trees, same_root)\n\t\towner->root = chunk;\n\told->dead = 1;\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&chunk_entry->lock);\n\tspin_unlock(&old_entry->lock);\n\tmutex_unlock(&old_entry->group->mark_mutex);\n\tfsnotify_destroy_mark(old_entry, audit_tree_group);\n\tfsnotify_put_mark(chunk_entry);\t/* drop initial reference */\n\tfsnotify_put_mark(old_entry); /* pair to fsnotify_find mark_entry */\n\treturn 0;\n}"
  },
  {
    "function_name": "create_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "350-386",
    "snippet": "static int create_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *entry;\n\tstruct audit_chunk *chunk = alloc_chunk(1);\n\tif (!chunk)\n\t\treturn -ENOMEM;\n\n\tentry = &chunk->mark;\n\tif (fsnotify_add_inode_mark(entry, inode, 0)) {\n\t\tfsnotify_put_mark(entry);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock(&entry->lock);\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tchunk->dead = 1;\n\t\tspin_unlock(&entry->lock);\n\t\tfsnotify_destroy_mark(entry, audit_tree_group);\n\t\tfsnotify_put_mark(entry);\n\t\treturn 0;\n\t}\n\tchunk->owners[0].index = (1U << 31);\n\tchunk->owners[0].owner = tree;\n\tget_tree(tree);\n\tlist_add(&chunk->owners[0].list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tinsert_hash(chunk);\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tfsnotify_put_mark(entry);\t/* drop initial reference */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_tree_group;",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "entry"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&entry->lock"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_hash",
          "args": [
            "chunk"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "insert_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "197-206",
          "snippet": "static void insert_hash(struct audit_chunk *chunk)\n{\n\tunsigned long key = chunk_to_key(chunk);\n\tstruct list_head *list;\n\n\tif (!(chunk->mark.flags & FSNOTIFY_MARK_FLAG_ATTACHED))\n\t\treturn;\n\tlist = chunk_hash(key);\n\tlist_add_rcu(&chunk->hash, list);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void insert_hash(struct audit_chunk *chunk)\n{\n\tunsigned long key = chunk_to_key(chunk);\n\tstruct list_head *list;\n\n\tif (!(chunk->mark.flags & FSNOTIFY_MARK_FLAG_ATTACHED))\n\t\treturn;\n\tlist = chunk_hash(key);\n\tlist_add_rcu(&chunk->hash, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tree->same_root",
            "&chunk->trees"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "tree"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "94-97",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "entry"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "entry",
            "audit_tree_group"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "entry"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_add_inode_mark",
          "args": [
            "entry",
            "inode",
            "0"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_chunk",
          "args": [
            "1"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "140-162",
          "snippet": "static struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tsize_t size;\n\tint i;\n\n\tsize = offsetof(struct audit_chunk, owners) + count * sizeof(struct node);\n\tchunk = kzalloc(size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\tfsnotify_init_mark(&chunk->mark, audit_tree_group);\n\tchunk->mark.mask = FS_IN_IGNORED;\n\treturn chunk;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\n\nstatic struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tsize_t size;\n\tint i;\n\n\tsize = offsetof(struct audit_chunk, owners) + count * sizeof(struct node);\n\tchunk = kzalloc(size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\tfsnotify_init_mark(&chunk->mark, audit_tree_group);\n\tchunk->mark.mask = FS_IN_IGNORED;\n\treturn chunk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic int create_chunk(struct inode *inode, struct audit_tree *tree)\n{\n\tstruct fsnotify_mark *entry;\n\tstruct audit_chunk *chunk = alloc_chunk(1);\n\tif (!chunk)\n\t\treturn -ENOMEM;\n\n\tentry = &chunk->mark;\n\tif (fsnotify_add_inode_mark(entry, inode, 0)) {\n\t\tfsnotify_put_mark(entry);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock(&entry->lock);\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\tchunk->dead = 1;\n\t\tspin_unlock(&entry->lock);\n\t\tfsnotify_destroy_mark(entry, audit_tree_group);\n\t\tfsnotify_put_mark(entry);\n\t\treturn 0;\n\t}\n\tchunk->owners[0].index = (1U << 31);\n\tchunk->owners[0].owner = tree;\n\tget_tree(tree);\n\tlist_add(&chunk->owners[0].list, &tree->chunks);\n\tif (!tree->root) {\n\t\ttree->root = chunk;\n\t\tlist_add(&tree->same_root, &chunk->trees);\n\t}\n\tinsert_hash(chunk);\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tfsnotify_put_mark(entry);\t/* drop initial reference */\n\treturn 0;\n}"
  },
  {
    "function_name": "untag_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "242-348",
    "snippet": "static void untag_chunk(struct node *p)\n{\n\tstruct audit_chunk *chunk = find_chunk(p);\n\tstruct fsnotify_mark *entry = &chunk->mark;\n\tstruct audit_chunk *new = NULL;\n\tstruct audit_tree *owner;\n\tint size = chunk->count - 1;\n\tint i, j;\n\n\tfsnotify_get_mark(entry);\n\n\tspin_unlock(&hash_lock);\n\n\tif (size)\n\t\tnew = alloc_chunk(size);\n\n\tmutex_lock(&entry->group->mark_mutex);\n\tspin_lock(&entry->lock);\n\t/*\n\t * mark_mutex protects mark from getting detached and thus also from\n\t * mark->connector->obj getting NULL.\n\t */\n\tif (chunk->dead || !(entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tif (new)\n\t\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto out;\n\t}\n\n\towner = p->owner;\n\n\tif (!size) {\n\t\tchunk->dead = 1;\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tif (owner->root == chunk)\n\t\t\towner->root = NULL;\n\t\tlist_del_init(&p->list);\n\t\tlist_del_rcu(&chunk->hash);\n\t\tspin_unlock(&hash_lock);\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tfsnotify_destroy_mark(entry, audit_tree_group);\n\t\tgoto out;\n\t}\n\n\tif (!new)\n\t\tgoto Fallback;\n\n\tif (fsnotify_add_mark_locked(&new->mark, entry->connector->obj,\n\t\t\t\t     FSNOTIFY_OBJ_TYPE_INODE, 1)) {\n\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto Fallback;\n\t}\n\n\tchunk->dead = 1;\n\tspin_lock(&hash_lock);\n\tlist_replace_init(&chunk->trees, &new->trees);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\n\tfor (i = j = 0; j <= size; i++, j++) {\n\t\tstruct audit_tree *s;\n\t\tif (&chunk->owners[j] == p) {\n\t\t\tlist_del_init(&p->list);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\ts = chunk->owners[j].owner;\n\t\tnew->owners[i].owner = s;\n\t\tnew->owners[i].index = chunk->owners[j].index - j + i;\n\t\tif (!s) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&chunk->owners[j].list, &new->owners[i].list);\n\t}\n\n\tlist_replace_rcu(&chunk->hash, &new->hash);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\n\tfsnotify_destroy_mark(entry, audit_tree_group);\n\tfsnotify_put_mark(&new->mark);\t/* drop initial reference */\n\tgoto out;\n\nFallback:\n\t// do the best we can\n\tspin_lock(&hash_lock);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\nout:\n\tfsnotify_put_mark(entry);\n\tspin_lock(&hash_lock);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_tree_group;",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "entry"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&entry->group->mark_mutex"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&entry->lock"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "owner"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "693-696",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->list"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&owner->same_root"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "&new->mark"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "entry",
            "audit_tree_group"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "owner",
            "&new->trees",
            "same_root"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_rcu",
          "args": [
            "&chunk->hash",
            "&new->hash"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&chunk->owners[j].list",
            "&new->owners[i].list"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tree",
          "args": [
            "s"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "94-97",
          "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->list"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&owner->same_root"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&chunk->trees",
            "&new->trees"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "&new->mark"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_add_mark_locked",
          "args": [
            "&new->mark",
            "entry->connector->obj",
            "FSNOTIFY_OBJ_TYPE_INODE",
            "1"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "entry",
            "audit_tree_group"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&chunk->hash"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->list"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&chunk->trees"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "&new->mark"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&entry->group->mark_mutex"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_chunk",
          "args": [
            "size"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "140-162",
          "snippet": "static struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tsize_t size;\n\tint i;\n\n\tsize = offsetof(struct audit_chunk, owners) + count * sizeof(struct node);\n\tchunk = kzalloc(size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\tfsnotify_init_mark(&chunk->mark, audit_tree_group);\n\tchunk->mark.mask = FS_IN_IGNORED;\n\treturn chunk;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_tree_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\n\nstatic struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tsize_t size;\n\tint i;\n\n\tsize = offsetof(struct audit_chunk, owners) + count * sizeof(struct node);\n\tchunk = kzalloc(size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\tfsnotify_init_mark(&chunk->mark, audit_tree_group);\n\tchunk->mark.mask = FS_IN_IGNORED;\n\treturn chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_get_mark",
          "args": [
            "entry"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_chunk",
          "args": [
            "p"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "find_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "235-240",
          "snippet": "static struct audit_chunk *find_chunk(struct node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *find_chunk(struct node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);\n\nstatic void untag_chunk(struct node *p)\n{\n\tstruct audit_chunk *chunk = find_chunk(p);\n\tstruct fsnotify_mark *entry = &chunk->mark;\n\tstruct audit_chunk *new = NULL;\n\tstruct audit_tree *owner;\n\tint size = chunk->count - 1;\n\tint i, j;\n\n\tfsnotify_get_mark(entry);\n\n\tspin_unlock(&hash_lock);\n\n\tif (size)\n\t\tnew = alloc_chunk(size);\n\n\tmutex_lock(&entry->group->mark_mutex);\n\tspin_lock(&entry->lock);\n\t/*\n\t * mark_mutex protects mark from getting detached and thus also from\n\t * mark->connector->obj getting NULL.\n\t */\n\tif (chunk->dead || !(entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tif (new)\n\t\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto out;\n\t}\n\n\towner = p->owner;\n\n\tif (!size) {\n\t\tchunk->dead = 1;\n\t\tspin_lock(&hash_lock);\n\t\tlist_del_init(&chunk->trees);\n\t\tif (owner->root == chunk)\n\t\t\towner->root = NULL;\n\t\tlist_del_init(&p->list);\n\t\tlist_del_rcu(&chunk->hash);\n\t\tspin_unlock(&hash_lock);\n\t\tspin_unlock(&entry->lock);\n\t\tmutex_unlock(&entry->group->mark_mutex);\n\t\tfsnotify_destroy_mark(entry, audit_tree_group);\n\t\tgoto out;\n\t}\n\n\tif (!new)\n\t\tgoto Fallback;\n\n\tif (fsnotify_add_mark_locked(&new->mark, entry->connector->obj,\n\t\t\t\t     FSNOTIFY_OBJ_TYPE_INODE, 1)) {\n\t\tfsnotify_put_mark(&new->mark);\n\t\tgoto Fallback;\n\t}\n\n\tchunk->dead = 1;\n\tspin_lock(&hash_lock);\n\tlist_replace_init(&chunk->trees, &new->trees);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\n\tfor (i = j = 0; j <= size; i++, j++) {\n\t\tstruct audit_tree *s;\n\t\tif (&chunk->owners[j] == p) {\n\t\t\tlist_del_init(&p->list);\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\ts = chunk->owners[j].owner;\n\t\tnew->owners[i].owner = s;\n\t\tnew->owners[i].index = chunk->owners[j].index - j + i;\n\t\tif (!s) /* result of earlier fallback */\n\t\t\tcontinue;\n\t\tget_tree(s);\n\t\tlist_replace_init(&chunk->owners[j].list, &new->owners[i].list);\n\t}\n\n\tlist_replace_rcu(&chunk->hash, &new->hash);\n\tlist_for_each_entry(owner, &new->trees, same_root)\n\t\towner->root = new;\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\n\tfsnotify_destroy_mark(entry, audit_tree_group);\n\tfsnotify_put_mark(&new->mark);\t/* drop initial reference */\n\tgoto out;\n\nFallback:\n\t// do the best we can\n\tspin_lock(&hash_lock);\n\tif (owner->root == chunk) {\n\t\tlist_del_init(&owner->same_root);\n\t\towner->root = NULL;\n\t}\n\tlist_del_init(&p->list);\n\tp->owner = NULL;\n\tput_tree(owner);\n\tspin_unlock(&hash_lock);\n\tspin_unlock(&entry->lock);\n\tmutex_unlock(&entry->group->mark_mutex);\nout:\n\tfsnotify_put_mark(entry);\n\tspin_lock(&hash_lock);\n}"
  },
  {
    "function_name": "find_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "235-240",
    "snippet": "static struct audit_chunk *find_chunk(struct node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structaudit_chunk",
            "owners[0]"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_chunk *find_chunk(struct node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}"
  },
  {
    "function_name": "audit_tree_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "224-231",
    "snippet": "bool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)\n{\n\tint n;\n\tfor (n = 0; n < chunk->count; n++)\n\t\tif (chunk->owners[n].owner == tree)\n\t\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nbool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)\n{\n\tint n;\n\tfor (n = 0; n < chunk->count; n++)\n\t\tif (chunk->owners[n].owner == tree)\n\t\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "audit_tree_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "209-222",
    "snippet": "struct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\tif (chunk_to_key(p) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&p->refs"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chunk_to_key",
          "args": [
            "p"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "179-188",
          "snippet": "static unsigned long chunk_to_key(struct audit_chunk *chunk)\n{\n\t/*\n\t * We have a reference to the mark so it should be attached to a\n\t * connector.\n\t */\n\tif (WARN_ON_ONCE(!chunk->mark.connector))\n\t\treturn 0;\n\treturn (unsigned long)chunk->mark.connector->obj;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long chunk_to_key(struct audit_chunk *chunk)\n{\n\t/*\n\t * We have a reference to the mark so it should be attached to a\n\t * connector.\n\t */\n\tif (WARN_ON_ONCE(!chunk->mark.connector))\n\t\treturn 0;\n\treturn (unsigned long)chunk->mark.connector->obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "p",
            "list",
            "hash"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chunk_hash",
          "args": [
            "key"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "190-194",
          "snippet": "static inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head chunk_hash_heads[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct list_head chunk_hash_heads[HASH_SIZE];\n\nstatic inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_key",
          "args": [
            "inode"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "169-173",
          "snippet": "static unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstruct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\tif (chunk_to_key(p) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "insert_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "197-206",
    "snippet": "static void insert_hash(struct audit_chunk *chunk)\n{\n\tunsigned long key = chunk_to_key(chunk);\n\tstruct list_head *list;\n\n\tif (!(chunk->mark.flags & FSNOTIFY_MARK_FLAG_ATTACHED))\n\t\treturn;\n\tlist = chunk_hash(key);\n\tlist_add_rcu(&chunk->hash, list);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&chunk->hash",
            "list"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chunk_hash",
          "args": [
            "key"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "190-194",
          "snippet": "static inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head chunk_hash_heads[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct list_head chunk_hash_heads[HASH_SIZE];\n\nstatic inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chunk_to_key",
          "args": [
            "chunk"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "chunk_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "179-188",
          "snippet": "static unsigned long chunk_to_key(struct audit_chunk *chunk)\n{\n\t/*\n\t * We have a reference to the mark so it should be attached to a\n\t * connector.\n\t */\n\tif (WARN_ON_ONCE(!chunk->mark.connector))\n\t\treturn 0;\n\treturn (unsigned long)chunk->mark.connector->obj;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long chunk_to_key(struct audit_chunk *chunk)\n{\n\t/*\n\t * We have a reference to the mark so it should be attached to a\n\t * connector.\n\t */\n\tif (WARN_ON_ONCE(!chunk->mark.connector))\n\t\treturn 0;\n\treturn (unsigned long)chunk->mark.connector->obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void insert_hash(struct audit_chunk *chunk)\n{\n\tunsigned long key = chunk_to_key(chunk);\n\tstruct list_head *list;\n\n\tif (!(chunk->mark.flags & FSNOTIFY_MARK_FLAG_ATTACHED))\n\t\treturn;\n\tlist = chunk_hash(key);\n\tlist_add_rcu(&chunk->hash, list);\n}"
  },
  {
    "function_name": "chunk_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "190-194",
    "snippet": "static inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head chunk_hash_heads[HASH_SIZE];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct list_head chunk_hash_heads[HASH_SIZE];\n\nstatic inline struct list_head *chunk_hash(unsigned long key)\n{\n\tunsigned long n = key / L1_CACHE_BYTES;\n\treturn chunk_hash_heads + n % HASH_SIZE;\n}"
  },
  {
    "function_name": "chunk_to_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "179-188",
    "snippet": "static unsigned long chunk_to_key(struct audit_chunk *chunk)\n{\n\t/*\n\t * We have a reference to the mark so it should be attached to a\n\t * connector.\n\t */\n\tif (WARN_ON_ONCE(!chunk->mark.connector))\n\t\treturn 0;\n\treturn (unsigned long)chunk->mark.connector->obj;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!chunk->mark.connector"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long chunk_to_key(struct audit_chunk *chunk)\n{\n\t/*\n\t * We have a reference to the mark so it should be attached to a\n\t * connector.\n\t */\n\tif (WARN_ON_ONCE(!chunk->mark.connector))\n\t\treturn 0;\n\treturn (unsigned long)chunk->mark.connector->obj;\n}"
  },
  {
    "function_name": "inode_to_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "169-173",
    "snippet": "static unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic unsigned long inode_to_key(const struct inode *inode)\n{\n\t/* Use address pointed to by connector->obj as the key */\n\treturn (unsigned long)&inode->i_fsnotify_marks;\n}"
  },
  {
    "function_name": "alloc_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "140-162",
    "snippet": "static struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tsize_t size;\n\tint i;\n\n\tsize = offsetof(struct audit_chunk, owners) + count * sizeof(struct node);\n\tchunk = kzalloc(size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\tfsnotify_init_mark(&chunk->mark, audit_tree_group);\n\tchunk->mark.mask = FS_IN_IGNORED;\n\treturn chunk;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_tree_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_init_mark",
          "args": [
            "&chunk->mark",
            "audit_tree_group"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&chunk->owners[i].list"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&chunk->refs",
            "1"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&chunk->trees"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&chunk->hash"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct fsnotify_group *audit_tree_group;\n\nstatic struct audit_chunk *alloc_chunk(int count)\n{\n\tstruct audit_chunk *chunk;\n\tsize_t size;\n\tint i;\n\n\tsize = offsetof(struct audit_chunk, owners) + count * sizeof(struct node);\n\tchunk = kzalloc(size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&chunk->hash);\n\tINIT_LIST_HEAD(&chunk->trees);\n\tchunk->count = count;\n\tatomic_long_set(&chunk->refs, 1);\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&chunk->owners[i].list);\n\t\tchunk->owners[i].index = i;\n\t}\n\tfsnotify_init_mark(&chunk->mark, audit_tree_group);\n\tchunk->mark.mask = FS_IN_IGNORED;\n\treturn chunk;\n}"
  },
  {
    "function_name": "audit_tree_destroy_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "134-138",
    "snippet": "static void audit_tree_destroy_watch(struct fsnotify_mark *entry)\n{\n\tstruct audit_chunk *chunk = container_of(entry, struct audit_chunk, mark);\n\tcall_rcu(&chunk->head, __put_chunk);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&chunk->head",
            "__put_chunk"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "entry",
            "structaudit_chunk",
            "mark"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void audit_tree_destroy_watch(struct fsnotify_mark *entry)\n{\n\tstruct audit_chunk *chunk = container_of(entry, struct audit_chunk, mark);\n\tcall_rcu(&chunk->head, __put_chunk);\n}"
  },
  {
    "function_name": "__put_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "128-132",
    "snippet": "static void __put_chunk(struct rcu_head *rcu)\n{\n\tstruct audit_chunk *chunk = container_of(rcu, struct audit_chunk, head);\n\taudit_put_chunk(chunk);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_chunk",
          "args": [
            "chunk"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "122-126",
          "snippet": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structaudit_chunk",
            "head"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void __put_chunk(struct rcu_head *rcu)\n{\n\tstruct audit_chunk *chunk = container_of(rcu, struct audit_chunk, head);\n\taudit_put_chunk(chunk);\n}"
  },
  {
    "function_name": "audit_put_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "122-126",
    "snippet": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_chunk",
          "args": [
            "chunk"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "free_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "111-120",
          "snippet": "static void free_chunk(struct audit_chunk *chunk)\n{\n\tint i;\n\n\tfor (i = 0; i < chunk->count; i++) {\n\t\tif (chunk->owners[i].owner)\n\t\t\tput_tree(chunk->owners[i].owner);\n\t}\n\tkfree(chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void free_chunk(struct audit_chunk *chunk)\n{\n\tint i;\n\n\tfor (i = 0; i < chunk->count; i++) {\n\t\tif (chunk->owners[i].owner)\n\t\t\tput_tree(chunk->owners[i].owner);\n\t}\n\tkfree(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_dec_and_test",
          "args": [
            "&chunk->refs"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}"
  },
  {
    "function_name": "free_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "111-120",
    "snippet": "static void free_chunk(struct audit_chunk *chunk)\n{\n\tint i;\n\n\tfor (i = 0; i < chunk->count; i++) {\n\t\tif (chunk->owners[i].owner)\n\t\t\tput_tree(chunk->owners[i].owner);\n\t}\n\tkfree(chunk);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "chunk"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_tree",
          "args": [
            "chunk->owners[i].owner"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "693-696",
          "snippet": "void audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_tree(struct audit_tree *tree)\n{\n\tput_tree(tree);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic void free_chunk(struct audit_chunk *chunk)\n{\n\tint i;\n\n\tfor (i = 0; i < chunk->count; i++) {\n\t\tif (chunk->owners[i].owner)\n\t\t\tput_tree(chunk->owners[i].owner);\n\t}\n\tkfree(chunk);\n}"
  },
  {
    "function_name": "audit_tree_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "106-109",
    "snippet": "const char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nconst char *audit_tree_path(struct audit_tree *tree)\n{\n\treturn tree->pathname;\n}"
  },
  {
    "function_name": "put_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "99-103",
    "snippet": "static inline void put_tree(struct audit_tree *tree)\n{\n\tif (refcount_dec_and_test(&tree->count))\n\t\tkfree_rcu(tree, head);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "tree",
            "head"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&tree->count"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void put_tree(struct audit_tree *tree)\n{\n\tif (refcount_dec_and_test(&tree->count))\n\t\tkfree_rcu(tree, head);\n}"
  },
  {
    "function_name": "get_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "94-97",
    "snippet": "static inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&tree->count"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "50-53",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic inline void get_tree(struct audit_tree *tree)\n{\n\trefcount_inc(&tree->count);\n}"
  },
  {
    "function_name": "alloc_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
    "lines": "76-92",
    "snippet": "static struct audit_tree *alloc_tree(const char *s)\n{\n\tstruct audit_tree *tree;\n\n\ttree = kmalloc(sizeof(struct audit_tree) + strlen(s) + 1, GFP_KERNEL);\n\tif (tree) {\n\t\trefcount_set(&tree->count, 1);\n\t\ttree->goner = 0;\n\t\tINIT_LIST_HEAD(&tree->chunks);\n\t\tINIT_LIST_HEAD(&tree->rules);\n\t\tINIT_LIST_HEAD(&tree->list);\n\t\tINIT_LIST_HEAD(&tree->same_root);\n\t\ttree->root = NULL;\n\t\tstrcpy(tree->pathname, s);\n\t}\n\treturn tree;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/refcount.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include \"audit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tree->pathname",
            "s"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tree->same_root"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tree->list"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tree->rules"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tree->chunks"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&tree->count",
            "1"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct audit_tree) + strlen(s) + 1",
            "GFP_KERNEL"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct audit_tree *alloc_tree(const char *s)\n{\n\tstruct audit_tree *tree;\n\n\ttree = kmalloc(sizeof(struct audit_tree) + strlen(s) + 1, GFP_KERNEL);\n\tif (tree) {\n\t\trefcount_set(&tree->count, 1);\n\t\ttree->goner = 0;\n\t\tINIT_LIST_HEAD(&tree->chunks);\n\t\tINIT_LIST_HEAD(&tree->rules);\n\t\tINIT_LIST_HEAD(&tree->list);\n\t\tINIT_LIST_HEAD(&tree->same_root);\n\t\ttree->root = NULL;\n\t\tstrcpy(tree->pathname, s);\n\t}\n\treturn tree;\n}"
  }
]