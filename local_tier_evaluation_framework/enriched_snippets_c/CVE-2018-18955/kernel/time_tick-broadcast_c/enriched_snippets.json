[
  {
    "function_name": "tick_broadcast_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "1006-1016",
    "snippet": "void __init tick_broadcast_init(void)\n{\n\tzalloc_cpumask_var(&tick_broadcast_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_on, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tmpmask, GFP_NOWAIT);\n#ifdef CONFIG_TICK_ONESHOT\n\tzalloc_cpumask_var(&tick_broadcast_oneshot_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_pending_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_force_mask, GFP_NOWAIT);\n#endif\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t tick_broadcast_mask",
      "static cpumask_var_t tick_broadcast_on"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tick_broadcast_force_mask",
            "GFP_NOWAIT"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tick_broadcast_pending_mask",
            "GFP_NOWAIT"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tick_broadcast_oneshot_mask",
            "GFP_NOWAIT"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tmpmask",
            "GFP_NOWAIT"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tick_broadcast_on",
            "GFP_NOWAIT"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&tick_broadcast_mask",
            "GFP_NOWAIT"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\n\nvoid __init tick_broadcast_init(void)\n{\n\tzalloc_cpumask_var(&tick_broadcast_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_on, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tmpmask, GFP_NOWAIT);\n#ifdef CONFIG_TICK_ONESHOT\n\tzalloc_cpumask_var(&tick_broadcast_oneshot_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_pending_mask, GFP_NOWAIT);\n\tzalloc_cpumask_var(&tick_broadcast_force_mask, GFP_NOWAIT);\n#endif\n}"
  },
  {
    "function_name": "__tick_broadcast_oneshot_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "995-1003",
    "snippet": "int __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (!bc || (bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (!bc || (bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tick_broadcast_oneshot_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "987-992",
    "snippet": "bool tick_broadcast_oneshot_available(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\treturn bc ? bc->features & CLOCK_EVT_FEAT_ONESHOT : false;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nbool tick_broadcast_oneshot_available(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\treturn bc ? bc->features & CLOCK_EVT_FEAT_ONESHOT : false;\n}"
  },
  {
    "function_name": "tick_broadcast_oneshot_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "979-982",
    "snippet": "int tick_broadcast_oneshot_active(void)\n{\n\treturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_broadcast_oneshot_active(void)\n{\n\treturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\n}"
  },
  {
    "function_name": "tick_shutdown_broadcast_oneshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "958-973",
    "snippet": "void tick_shutdown_broadcast_oneshot(unsigned int cpu)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Clear the broadcast masks for the dead cpu, but do not stop\n\t * the broadcast device!\n\t */\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_force_mask);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_force_mask"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_pending_mask"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_shutdown_broadcast_oneshot(unsigned int cpu)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Clear the broadcast masks for the dead cpu, but do not stop\n\t * the broadcast device!\n\t */\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_force_mask);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "hotplug_cpu__broadcast_tick_pull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "940-953",
    "snippet": "void hotplug_cpu__broadcast_tick_pull(int deadcpu)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc && broadcast_needs_cpu(bc, deadcpu)) {\n\t\t/* This moves the broadcast assignment to this CPU: */\n\t\tclockevents_program_event(bc, bc->next_event, 1);\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "bc",
            "bc->next_event",
            "1"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "311-347",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "broadcast_needs_cpu",
          "args": [
            "bc",
            "deadcpu"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "broadcast_needs_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "679-686",
          "snippet": "static int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid hotplug_cpu__broadcast_tick_pull(int deadcpu)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc && broadcast_needs_cpu(bc, deadcpu)) {\n\t\t/* This moves the broadcast assignment to this CPU: */\n\t\tclockevents_program_event(bc, bc->next_event, 1);\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_broadcast_switch_to_oneshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "924-937",
    "snippet": "void tick_broadcast_switch_to_oneshot(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\ttick_broadcast_device.mode = TICKDEV_MODE_ONESHOT;\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\ttick_broadcast_setup_oneshot(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_setup_oneshot",
          "args": [
            "bc"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_setup_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "878-919",
          "snippet": "static void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask,\n\t\t\t\t\t\t       tick_next_period);\n\t\t\ttick_broadcast_set_event(bc, cpu, tick_next_period);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstatic void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask,\n\t\t\t\t\t\t       tick_next_period);\n\t\t\ttick_broadcast_set_event(bc, cpu, tick_next_period);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_broadcast_switch_to_oneshot(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\ttick_broadcast_device.mode = TICKDEV_MODE_ONESHOT;\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\ttick_broadcast_setup_oneshot(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_broadcast_setup_oneshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "878-919",
    "snippet": "static void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask,\n\t\t\t\t\t\t       tick_next_period);\n\t\t\ttick_broadcast_set_event(bc, cpu, tick_next_period);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t tick_broadcast_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_broadcast_clear_oneshot",
          "args": [
            "cpu"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_clear_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "856-860",
          "snippet": "static void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_set_event",
          "args": [
            "bc",
            "cpu",
            "tick_next_period"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_set_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "560-568",
          "snippet": "static void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_init_next_event",
          "args": [
            "tmpmask",
            "tick_next_period"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_init_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "862-873",
          "snippet": "static void tick_broadcast_init_next_event(struct cpumask *mask,\n\t\t\t\t\t   ktime_t expires)\n{\n\tstruct tick_device *td;\n\tint cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev)\n\t\t\ttd->evtdev->next_event = expires;\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_init_next_event(struct cpumask *mask,\n\t\t\t\t\t   ktime_t expires)\n{\n\tstruct tick_device *td;\n\tint cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev)\n\t\t\ttd->evtdev->next_event = expires;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "bc",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "153-173",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tmpmask"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "tick_broadcast_oneshot_mask",
            "tick_broadcast_oneshot_mask",
            "tmpmask"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tmpmask"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "tmpmask",
            "tick_broadcast_mask"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_periodic",
          "args": [
            "bc"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstatic void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask,\n\t\t\t\t\t\t       tick_next_period);\n\t\t\ttick_broadcast_set_event(bc, cpu, tick_next_period);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}"
  },
  {
    "function_name": "tick_broadcast_init_next_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "862-873",
    "snippet": "static void tick_broadcast_init_next_event(struct cpumask *mask,\n\t\t\t\t\t   ktime_t expires)\n{\n\tstruct tick_device *td;\n\tint cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev)\n\t\t\ttd->evtdev->next_event = expires;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_init_next_event(struct cpumask *mask,\n\t\t\t\t\t   ktime_t expires)\n{\n\tstruct tick_device *td;\n\tint cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev)\n\t\t\ttd->evtdev->next_event = expires;\n\t}\n}"
  },
  {
    "function_name": "tick_broadcast_clear_oneshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "856-860",
    "snippet": "static void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_pending_mask"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}"
  },
  {
    "function_name": "__tick_broadcast_oneshot_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "705-849",
    "snippet": "int __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct clock_event_device *bc, *dev;\n\tint cpu, ret = 0;\n\tktime_t now;\n\n\t/*\n\t * If there is no broadcast device, tell the caller not to go\n\t * into deep idle.\n\t */\n\tif (!tick_broadcast_device.evtdev)\n\t\treturn -EBUSY;\n\n\tdev = this_cpu_ptr(&tick_cpu_device)->evtdev;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\tbc = tick_broadcast_device.evtdev;\n\tcpu = smp_processor_id();\n\n\tif (state == TICK_BROADCAST_ENTER) {\n\t\t/*\n\t\t * If the current CPU owns the hrtimer broadcast\n\t\t * mechanism, it cannot go deep idle and we do not add\n\t\t * the CPU to the broadcast mask. We don't have to go\n\t\t * through the EXIT path as the local timer is not\n\t\t * shutdown.\n\t\t */\n\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * If the broadcast device is in periodic mode, we\n\t\t * return.\n\t\t */\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\t\t/* If it is a hrtimer based broadcast, return busy */\n\t\t\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER)\n\t\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tWARN_ON_ONCE(cpumask_test_cpu(cpu, tick_broadcast_pending_mask));\n\n\t\t\t/* Conditionally shut down the local timer. */\n\t\t\tbroadcast_shutdown_local(bc, dev);\n\n\t\t\t/*\n\t\t\t * We only reprogram the broadcast timer if we\n\t\t\t * did not mark ourself in the force mask and\n\t\t\t * if the cpu local event is earlier than the\n\t\t\t * broadcast event. If the current CPU is in\n\t\t\t * the force mask, then we are going to be\n\t\t\t * woken by the IPI right away; we return\n\t\t\t * busy, so the CPU does not try to go deep\n\t\t\t * idle.\n\t\t\t */\n\t\t\tif (cpumask_test_cpu(cpu, tick_broadcast_force_mask)) {\n\t\t\t\tret = -EBUSY;\n\t\t\t} else if (dev->next_event < bc->next_event) {\n\t\t\t\ttick_broadcast_set_event(bc, cpu, dev->next_event);\n\t\t\t\t/*\n\t\t\t\t * In case of hrtimer broadcasts the\n\t\t\t\t * programming might have moved the\n\t\t\t\t * timer to this cpu. If yes, remove\n\t\t\t\t * us from the broadcast mask and\n\t\t\t\t * return busy.\n\t\t\t\t */\n\t\t\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcpumask_clear_cpu(cpu,\n\t\t\t\t\t\ttick_broadcast_oneshot_mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t\t\t/*\n\t\t\t * The cpu which was handling the broadcast\n\t\t\t * timer marked this cpu in the broadcast\n\t\t\t * pending mask and fired the broadcast\n\t\t\t * IPI. So we are going to handle the expired\n\t\t\t * event anyway via the broadcast IPI\n\t\t\t * handler. No need to reprogram the timer\n\t\t\t * with an already expired event.\n\t\t\t */\n\t\t\tif (cpumask_test_and_clear_cpu(cpu,\n\t\t\t\t       tick_broadcast_pending_mask))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Bail out if there is no next event.\n\t\t\t */\n\t\t\tif (dev->next_event == KTIME_MAX)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * If the pending bit is not set, then we are\n\t\t\t * either the CPU handling the broadcast\n\t\t\t * interrupt or we got woken by something else.\n\t\t\t *\n\t\t\t * We are not longer in the broadcast mask, so\n\t\t\t * if the cpu local expiry time is already\n\t\t\t * reached, we would reprogram the cpu local\n\t\t\t * timer with an already expired event.\n\t\t\t *\n\t\t\t * This can lead to a ping-pong when we return\n\t\t\t * to idle and therefor rearm the broadcast\n\t\t\t * timer before the cpu local timer was able\n\t\t\t * to fire. This happens because the forced\n\t\t\t * reprogramming makes sure that the event\n\t\t\t * will happen in the future and depending on\n\t\t\t * the min_delta setting this might be far\n\t\t\t * enough out that the ping-pong starts.\n\t\t\t *\n\t\t\t * If the cpu local next_event has expired\n\t\t\t * then we know that the broadcast timer\n\t\t\t * next_event has expired as well and\n\t\t\t * broadcast is about to be handled. So we\n\t\t\t * avoid reprogramming and enforce that the\n\t\t\t * broadcast handler, which did not run yet,\n\t\t\t * will invoke the cpu local handler.\n\t\t\t *\n\t\t\t * We cannot call the handler directly from\n\t\t\t * here, because we might be in a NOHZ phase\n\t\t\t * and we did not go through the irq_enter()\n\t\t\t * nohz fixups.\n\t\t\t */\n\t\t\tnow = ktime_get();\n\t\t\tif (dev->next_event <= now) {\n\t\t\t\tcpumask_set_cpu(cpu, tick_broadcast_force_mask);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We got woken by something else. Reprogram\n\t\t\t * the cpu local timer device.\n\t\t\t */\n\t\t\ttick_program_event(dev->next_event, 1);\n\t\t}\n\t}\nout:\n\traw_spin_unlock(&tick_broadcast_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_program_event",
          "args": [
            "dev->next_event",
            "1"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "tick_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "27-49",
          "snippet": "int tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_program_event(ktime_t expires, int force)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (unlikely(expires == KTIME_MAX)) {\n\t\t/*\n\t\t * We don't need the clock event device any more, stop it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT_STOPPED);\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(clockevent_state_oneshot_stopped(dev))) {\n\t\t/*\n\t\t * We need the clock event again, configure it in ONESHOT mode\n\t\t * before using it.\n\t\t */\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t}\n\n\treturn clockevents_program_event(dev, expires, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_force_mask"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_pending_mask"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "153-173",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "broadcast_needs_cpu",
          "args": [
            "bc",
            "cpu"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "broadcast_needs_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "679-686",
          "snippet": "static int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_set_event",
          "args": [
            "bc",
            "cpu",
            "dev->next_event"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_set_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "560-568",
          "snippet": "static void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tick_broadcast_force_mask"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "broadcast_shutdown_local",
          "args": [
            "bc",
            "dev"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "broadcast_shutdown_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "688-703",
          "snippet": "static void broadcast_shutdown_local(struct clock_event_device *bc,\n\t\t\t\t     struct clock_event_device *dev)\n{\n\t/*\n\t * For hrtimer based broadcasting we cannot shutdown the cpu\n\t * local device if our own event is the first one to expire or\n\t * if we own the broadcast timer.\n\t */\n\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER) {\n\t\tif (broadcast_needs_cpu(bc, smp_processor_id()))\n\t\t\treturn;\n\t\tif (dev->next_event < bc->next_event)\n\t\t\treturn;\n\t}\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void broadcast_shutdown_local(struct clock_event_device *bc,\n\t\t\t\t     struct clock_event_device *dev)\n{\n\t/*\n\t * For hrtimer based broadcasting we cannot shutdown the cpu\n\t * local device if our own event is the first one to expire or\n\t * if we own the broadcast timer.\n\t */\n\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER) {\n\t\tif (broadcast_needs_cpu(bc, smp_processor_id()))\n\t\t\treturn;\n\t\tif (dev->next_event < bc->next_event)\n\t\t\treturn;\n\t}\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpumask_test_cpu(cpu, tick_broadcast_pending_mask)"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tick_broadcast_pending_mask"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nint __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct clock_event_device *bc, *dev;\n\tint cpu, ret = 0;\n\tktime_t now;\n\n\t/*\n\t * If there is no broadcast device, tell the caller not to go\n\t * into deep idle.\n\t */\n\tif (!tick_broadcast_device.evtdev)\n\t\treturn -EBUSY;\n\n\tdev = this_cpu_ptr(&tick_cpu_device)->evtdev;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\tbc = tick_broadcast_device.evtdev;\n\tcpu = smp_processor_id();\n\n\tif (state == TICK_BROADCAST_ENTER) {\n\t\t/*\n\t\t * If the current CPU owns the hrtimer broadcast\n\t\t * mechanism, it cannot go deep idle and we do not add\n\t\t * the CPU to the broadcast mask. We don't have to go\n\t\t * through the EXIT path as the local timer is not\n\t\t * shutdown.\n\t\t */\n\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * If the broadcast device is in periodic mode, we\n\t\t * return.\n\t\t */\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\t\t/* If it is a hrtimer based broadcast, return busy */\n\t\t\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER)\n\t\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tWARN_ON_ONCE(cpumask_test_cpu(cpu, tick_broadcast_pending_mask));\n\n\t\t\t/* Conditionally shut down the local timer. */\n\t\t\tbroadcast_shutdown_local(bc, dev);\n\n\t\t\t/*\n\t\t\t * We only reprogram the broadcast timer if we\n\t\t\t * did not mark ourself in the force mask and\n\t\t\t * if the cpu local event is earlier than the\n\t\t\t * broadcast event. If the current CPU is in\n\t\t\t * the force mask, then we are going to be\n\t\t\t * woken by the IPI right away; we return\n\t\t\t * busy, so the CPU does not try to go deep\n\t\t\t * idle.\n\t\t\t */\n\t\t\tif (cpumask_test_cpu(cpu, tick_broadcast_force_mask)) {\n\t\t\t\tret = -EBUSY;\n\t\t\t} else if (dev->next_event < bc->next_event) {\n\t\t\t\ttick_broadcast_set_event(bc, cpu, dev->next_event);\n\t\t\t\t/*\n\t\t\t\t * In case of hrtimer broadcasts the\n\t\t\t\t * programming might have moved the\n\t\t\t\t * timer to this cpu. If yes, remove\n\t\t\t\t * us from the broadcast mask and\n\t\t\t\t * return busy.\n\t\t\t\t */\n\t\t\t\tret = broadcast_needs_cpu(bc, cpu);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcpumask_clear_cpu(cpu,\n\t\t\t\t\t\ttick_broadcast_oneshot_mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_oneshot_mask)) {\n\t\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\t\t\t/*\n\t\t\t * The cpu which was handling the broadcast\n\t\t\t * timer marked this cpu in the broadcast\n\t\t\t * pending mask and fired the broadcast\n\t\t\t * IPI. So we are going to handle the expired\n\t\t\t * event anyway via the broadcast IPI\n\t\t\t * handler. No need to reprogram the timer\n\t\t\t * with an already expired event.\n\t\t\t */\n\t\t\tif (cpumask_test_and_clear_cpu(cpu,\n\t\t\t\t       tick_broadcast_pending_mask))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Bail out if there is no next event.\n\t\t\t */\n\t\t\tif (dev->next_event == KTIME_MAX)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * If the pending bit is not set, then we are\n\t\t\t * either the CPU handling the broadcast\n\t\t\t * interrupt or we got woken by something else.\n\t\t\t *\n\t\t\t * We are not longer in the broadcast mask, so\n\t\t\t * if the cpu local expiry time is already\n\t\t\t * reached, we would reprogram the cpu local\n\t\t\t * timer with an already expired event.\n\t\t\t *\n\t\t\t * This can lead to a ping-pong when we return\n\t\t\t * to idle and therefor rearm the broadcast\n\t\t\t * timer before the cpu local timer was able\n\t\t\t * to fire. This happens because the forced\n\t\t\t * reprogramming makes sure that the event\n\t\t\t * will happen in the future and depending on\n\t\t\t * the min_delta setting this might be far\n\t\t\t * enough out that the ping-pong starts.\n\t\t\t *\n\t\t\t * If the cpu local next_event has expired\n\t\t\t * then we know that the broadcast timer\n\t\t\t * next_event has expired as well and\n\t\t\t * broadcast is about to be handled. So we\n\t\t\t * avoid reprogramming and enforce that the\n\t\t\t * broadcast handler, which did not run yet,\n\t\t\t * will invoke the cpu local handler.\n\t\t\t *\n\t\t\t * We cannot call the handler directly from\n\t\t\t * here, because we might be in a NOHZ phase\n\t\t\t * and we did not go through the irq_enter()\n\t\t\t * nohz fixups.\n\t\t\t */\n\t\t\tnow = ktime_get();\n\t\t\tif (dev->next_event <= now) {\n\t\t\t\tcpumask_set_cpu(cpu, tick_broadcast_force_mask);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We got woken by something else. Reprogram\n\t\t\t * the cpu local timer device.\n\t\t\t */\n\t\t\ttick_program_event(dev->next_event, 1);\n\t\t}\n\t}\nout:\n\traw_spin_unlock(&tick_broadcast_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "broadcast_shutdown_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "688-703",
    "snippet": "static void broadcast_shutdown_local(struct clock_event_device *bc,\n\t\t\t\t     struct clock_event_device *dev)\n{\n\t/*\n\t * For hrtimer based broadcasting we cannot shutdown the cpu\n\t * local device if our own event is the first one to expire or\n\t * if we own the broadcast timer.\n\t */\n\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER) {\n\t\tif (broadcast_needs_cpu(bc, smp_processor_id()))\n\t\t\treturn;\n\t\tif (dev->next_event < bc->next_event)\n\t\t\treturn;\n\t}\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_SHUTDOWN"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "153-173",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "broadcast_needs_cpu",
          "args": [
            "bc",
            "smp_processor_id()"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "broadcast_needs_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "679-686",
          "snippet": "static int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void broadcast_shutdown_local(struct clock_event_device *bc,\n\t\t\t\t     struct clock_event_device *dev)\n{\n\t/*\n\t * For hrtimer based broadcasting we cannot shutdown the cpu\n\t * local device if our own event is the first one to expire or\n\t * if we own the broadcast timer.\n\t */\n\tif (bc->features & CLOCK_EVT_FEAT_HRTIMER) {\n\t\tif (broadcast_needs_cpu(bc, smp_processor_id()))\n\t\t\treturn;\n\t\tif (dev->next_event < bc->next_event)\n\t\t\treturn;\n\t}\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n}"
  },
  {
    "function_name": "broadcast_needs_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "679-686",
    "snippet": "static int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic int broadcast_needs_cpu(struct clock_event_device *bc, int cpu)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn 0;\n\tif (bc->next_event == KTIME_MAX)\n\t\treturn 0;\n\treturn bc->bound_on == cpu ? -EBUSY : 0;\n}"
  },
  {
    "function_name": "tick_handle_oneshot_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "599-677",
    "snippet": "static void tick_handle_oneshot_broadcast(struct clock_event_device *dev)\n{\n\tstruct tick_device *td;\n\tktime_t now, next_event;\n\tint cpu, next_cpu = 0;\n\tbool bc_local;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\tdev->next_event = KTIME_MAX;\n\tnext_event = KTIME_MAX;\n\tcpumask_clear(tmpmask);\n\tnow = ktime_get();\n\t/* Find all expired events */\n\tfor_each_cpu(cpu, tick_broadcast_oneshot_mask) {\n\t\t/*\n\t\t * Required for !SMP because for_each_cpu() reports\n\t\t * unconditionally CPU0 as set on UP kernels.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_SMP) &&\n\t\t    cpumask_empty(tick_broadcast_oneshot_mask))\n\t\t\tbreak;\n\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev->next_event <= now) {\n\t\t\tcpumask_set_cpu(cpu, tmpmask);\n\t\t\t/*\n\t\t\t * Mark the remote cpu in the pending mask, so\n\t\t\t * it can avoid reprogramming the cpu local\n\t\t\t * timer in tick_broadcast_oneshot_control().\n\t\t\t */\n\t\t\tcpumask_set_cpu(cpu, tick_broadcast_pending_mask);\n\t\t} else if (td->evtdev->next_event < next_event) {\n\t\t\tnext_event = td->evtdev->next_event;\n\t\t\tnext_cpu = cpu;\n\t\t}\n\t}\n\n\t/*\n\t * Remove the current cpu from the pending mask. The event is\n\t * delivered immediately in tick_do_broadcast() !\n\t */\n\tcpumask_clear_cpu(smp_processor_id(), tick_broadcast_pending_mask);\n\n\t/* Take care of enforced broadcast requests */\n\tcpumask_or(tmpmask, tmpmask, tick_broadcast_force_mask);\n\tcpumask_clear(tick_broadcast_force_mask);\n\n\t/*\n\t * Sanity check. Catch the case where we try to broadcast to\n\t * offline cpus.\n\t */\n\tif (WARN_ON_ONCE(!cpumask_subset(tmpmask, cpu_online_mask)))\n\t\tcpumask_and(tmpmask, tmpmask, cpu_online_mask);\n\n\t/*\n\t * Wakeup the cpus which have an expired event.\n\t */\n\tbc_local = tick_do_broadcast(tmpmask);\n\n\t/*\n\t * Two reasons for reprogram:\n\t *\n\t * - The global event did not expire any CPU local\n\t * events. This happens in dyntick mode, as the maximum PIT\n\t * delta is quite small.\n\t *\n\t * - There are pending events on sleeping CPUs which were not\n\t * in the event mask\n\t */\n\tif (next_event != KTIME_MAX)\n\t\ttick_broadcast_set_event(dev, next_cpu, next_event);\n\n\traw_spin_unlock(&tick_broadcast_lock);\n\n\tif (bc_local) {\n\t\ttd = this_cpu_ptr(&tick_cpu_device);\n\t\ttd->evtdev->event_handler(td->evtdev);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "td->evtdev->event_handler",
          "args": [
            "td->evtdev"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_set_event",
          "args": [
            "dev",
            "next_cpu",
            "next_event"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_set_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "560-568",
          "snippet": "static void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_do_broadcast",
          "args": [
            "tmpmask"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_broadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "262-301",
          "snippet": "static bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstatic bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmpmask",
            "tmpmask",
            "cpu_online_mask"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cpumask_subset(tmpmask, cpu_online_mask)"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "tmpmask",
            "cpu_online_mask"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "tick_broadcast_force_mask"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "tmpmask",
            "tmpmask",
            "tick_broadcast_force_mask"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "smp_processor_id()",
            "tick_broadcast_pending_mask"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_pending_mask"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tmpmask"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_oneshot_mask"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SMP"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "tmpmask"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nstatic void tick_handle_oneshot_broadcast(struct clock_event_device *dev)\n{\n\tstruct tick_device *td;\n\tktime_t now, next_event;\n\tint cpu, next_cpu = 0;\n\tbool bc_local;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\tdev->next_event = KTIME_MAX;\n\tnext_event = KTIME_MAX;\n\tcpumask_clear(tmpmask);\n\tnow = ktime_get();\n\t/* Find all expired events */\n\tfor_each_cpu(cpu, tick_broadcast_oneshot_mask) {\n\t\t/*\n\t\t * Required for !SMP because for_each_cpu() reports\n\t\t * unconditionally CPU0 as set on UP kernels.\n\t\t */\n\t\tif (!IS_ENABLED(CONFIG_SMP) &&\n\t\t    cpumask_empty(tick_broadcast_oneshot_mask))\n\t\t\tbreak;\n\n\t\ttd = &per_cpu(tick_cpu_device, cpu);\n\t\tif (td->evtdev->next_event <= now) {\n\t\t\tcpumask_set_cpu(cpu, tmpmask);\n\t\t\t/*\n\t\t\t * Mark the remote cpu in the pending mask, so\n\t\t\t * it can avoid reprogramming the cpu local\n\t\t\t * timer in tick_broadcast_oneshot_control().\n\t\t\t */\n\t\t\tcpumask_set_cpu(cpu, tick_broadcast_pending_mask);\n\t\t} else if (td->evtdev->next_event < next_event) {\n\t\t\tnext_event = td->evtdev->next_event;\n\t\t\tnext_cpu = cpu;\n\t\t}\n\t}\n\n\t/*\n\t * Remove the current cpu from the pending mask. The event is\n\t * delivered immediately in tick_do_broadcast() !\n\t */\n\tcpumask_clear_cpu(smp_processor_id(), tick_broadcast_pending_mask);\n\n\t/* Take care of enforced broadcast requests */\n\tcpumask_or(tmpmask, tmpmask, tick_broadcast_force_mask);\n\tcpumask_clear(tick_broadcast_force_mask);\n\n\t/*\n\t * Sanity check. Catch the case where we try to broadcast to\n\t * offline cpus.\n\t */\n\tif (WARN_ON_ONCE(!cpumask_subset(tmpmask, cpu_online_mask)))\n\t\tcpumask_and(tmpmask, tmpmask, cpu_online_mask);\n\n\t/*\n\t * Wakeup the cpus which have an expired event.\n\t */\n\tbc_local = tick_do_broadcast(tmpmask);\n\n\t/*\n\t * Two reasons for reprogram:\n\t *\n\t * - The global event did not expire any CPU local\n\t * events. This happens in dyntick mode, as the maximum PIT\n\t * delta is quite small.\n\t *\n\t * - There are pending events on sleeping CPUs which were not\n\t * in the event mask\n\t */\n\tif (next_event != KTIME_MAX)\n\t\ttick_broadcast_set_event(dev, next_cpu, next_event);\n\n\traw_spin_unlock(&tick_broadcast_lock);\n\n\tif (bc_local) {\n\t\ttd = this_cpu_ptr(&tick_cpu_device);\n\t\ttd->evtdev->event_handler(td->evtdev);\n\t}\n}"
  },
  {
    "function_name": "tick_check_oneshot_broadcast_this_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "579-594",
    "snippet": "void tick_check_oneshot_broadcast_this_cpu(void)\n{\n\tif (cpumask_test_cpu(smp_processor_id(), tick_broadcast_oneshot_mask)) {\n\t\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\t\t/*\n\t\t * We might be in the middle of switching over from\n\t\t * periodic to oneshot. If the CPU has not yet\n\t\t * switched over, leave the device alone.\n\t\t */\n\t\tif (td->mode == TICKDEV_MODE_ONESHOT) {\n\t\t\tclockevents_switch_state(td->evtdev,\n\t\t\t\t\t      CLOCK_EVT_STATE_ONESHOT);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "td->evtdev",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "153-173",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "smp_processor_id()",
            "tick_broadcast_oneshot_mask"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_check_oneshot_broadcast_this_cpu(void)\n{\n\tif (cpumask_test_cpu(smp_processor_id(), tick_broadcast_oneshot_mask)) {\n\t\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\t\t/*\n\t\t * We might be in the middle of switching over from\n\t\t * periodic to oneshot. If the CPU has not yet\n\t\t * switched over, leave the device alone.\n\t\t */\n\t\tif (td->mode == TICKDEV_MODE_ONESHOT) {\n\t\t\tclockevents_switch_state(td->evtdev,\n\t\t\t\t\t      CLOCK_EVT_STATE_ONESHOT);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "tick_resume_broadcast_oneshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "570-573",
    "snippet": "static void tick_resume_broadcast_oneshot(struct clock_event_device *bc)\n{\n\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "bc",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "153-173",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_resume_broadcast_oneshot(struct clock_event_device *bc)\n{\n\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n}"
  },
  {
    "function_name": "tick_broadcast_set_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "560-568",
    "snippet": "static void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_broadcast_set_affinity",
          "args": [
            "bc",
            "cpumask_of(cpu)"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_set_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "547-558",
          "snippet": "static void tick_broadcast_set_affinity(struct clock_event_device *bc,\n\t\t\t\t\tconst struct cpumask *cpumask)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_DYNIRQ))\n\t\treturn;\n\n\tif (cpumask_equal(bc->cpumask, cpumask))\n\t\treturn;\n\n\tbc->cpumask = cpumask;\n\tirq_set_affinity(bc->irq, bc->cpumask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_set_affinity(struct clock_event_device *bc,\n\t\t\t\t\tconst struct cpumask *cpumask)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_DYNIRQ))\n\t\treturn;\n\n\tif (cpumask_equal(bc->cpumask, cpumask))\n\t\treturn;\n\n\tbc->cpumask = cpumask;\n\tirq_set_affinity(bc->irq, bc->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "bc",
            "expires",
            "1"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "311-347",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "bc",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "153-173",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "bc"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_set_event(struct clock_event_device *bc, int cpu,\n\t\t\t\t     ktime_t expires)\n{\n\tif (!clockevent_state_oneshot(bc))\n\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\n\tclockevents_program_event(bc, expires, 1);\n\ttick_broadcast_set_affinity(bc, cpumask_of(cpu));\n}"
  },
  {
    "function_name": "tick_broadcast_set_affinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "547-558",
    "snippet": "static void tick_broadcast_set_affinity(struct clock_event_device *bc,\n\t\t\t\t\tconst struct cpumask *cpumask)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_DYNIRQ))\n\t\treturn;\n\n\tif (cpumask_equal(bc->cpumask, cpumask))\n\t\treturn;\n\n\tbc->cpumask = cpumask;\n\tirq_set_affinity(bc->irq, bc->cpumask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_set_affinity",
          "args": [
            "bc->irq",
            "bc->cpumask"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_affinity_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "334-363",
          "snippet": "int\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify)\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify)\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "bc->cpumask",
            "cpumask"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_set_affinity(struct clock_event_device *bc,\n\t\t\t\t\tconst struct cpumask *cpumask)\n{\n\tif (!(bc->features & CLOCK_EVT_FEAT_DYNIRQ))\n\t\treturn;\n\n\tif (cpumask_equal(bc->cpumask, cpumask))\n\t\treturn;\n\n\tbc->cpumask = cpumask;\n\tirq_set_affinity(bc->irq, bc->cpumask);\n}"
  },
  {
    "function_name": "tick_check_broadcast_expired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "539-542",
    "snippet": "int tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "smp_processor_id()",
            "tick_broadcast_force_mask"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}"
  },
  {
    "function_name": "tick_get_broadcast_oneshot_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "527-530",
    "snippet": "struct cpumask *tick_get_broadcast_oneshot_mask(void)\n{\n\treturn tick_broadcast_oneshot_mask;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct cpumask *tick_get_broadcast_oneshot_mask(void)\n{\n\treturn tick_broadcast_oneshot_mask;\n}"
  },
  {
    "function_name": "tick_resume_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "492-516",
    "snippet": "void tick_resume_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc) {\n\t\tclockevents_tick_resume(bc);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\tbreak;\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_resume_broadcast_oneshot(bc);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_resume_broadcast_oneshot",
          "args": [
            "bc"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_broadcast_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "570-573",
          "snippet": "static void tick_resume_broadcast_oneshot(struct clock_event_device *bc)\n{\n\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_resume_broadcast_oneshot(struct clock_event_device *bc)\n{\n\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_broadcast_start_periodic",
          "args": [
            "bc"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_start_periodic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "65-69",
          "snippet": "static void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_tick_resume",
          "args": [
            "bc"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_tick_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "189-197",
          "snippet": "int clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_resume_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc) {\n\t\tclockevents_tick_resume(bc);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\tbreak;\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_resume_broadcast_oneshot(bc);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_resume_check_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "484-490",
    "snippet": "bool tick_resume_check_broadcast(void)\n{\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT)\n\t\treturn false;\n\telse\n\t\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_mask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "smp_processor_id()",
            "tick_broadcast_mask"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\n\nbool tick_resume_check_broadcast(void)\n{\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT)\n\t\treturn false;\n\telse\n\t\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_mask);\n}"
  },
  {
    "function_name": "tick_suspend_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "462-474",
    "snippet": "void tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "bc"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "179-183",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_shutdown_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "442-459",
    "snippet": "void tick_shutdown_broadcast(unsigned int cpu)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_on);\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\tif (bc && cpumask_empty(tick_broadcast_mask))\n\t\t\tclockevents_shutdown(bc);\n\t}\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask",
      "static cpumask_var_t tick_broadcast_on",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "bc"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "179-183",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_on"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_shutdown_broadcast(unsigned int cpu)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_on);\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\n\t\tif (bc && cpumask_empty(tick_broadcast_mask))\n\t\t\tclockevents_shutdown(bc);\n\t}\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_set_periodic_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "430-436",
    "snippet": "void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)\n{\n\tif (!broadcast)\n\t\tdev->event_handler = tick_handle_periodic;\n\telse\n\t\tdev->event_handler = tick_handle_periodic_broadcast;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)\n{\n\tif (!broadcast)\n\t\tdev->event_handler = tick_handle_periodic;\n\telse\n\t\tdev->event_handler = tick_handle_periodic_broadcast;\n}"
  },
  {
    "function_name": "tick_broadcast_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "354-424",
    "snippet": "void tick_broadcast_control(enum tick_broadcast_mode mode)\n{\n\tstruct clock_event_device *bc, *dev;\n\tstruct tick_device *td;\n\tint cpu, bc_stopped;\n\tunsigned long flags;\n\n\t/* Protects also the local clockevent device. */\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\ttd = this_cpu_ptr(&tick_cpu_device);\n\tdev = td->evtdev;\n\n\t/*\n\t * Is the device not affected by the powerstate ?\n\t */\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\tgoto out;\n\n\tif (!tick_device_is_functional(dev))\n\t\tgoto out;\n\n\tcpu = smp_processor_id();\n\tbc = tick_broadcast_device.evtdev;\n\tbc_stopped = cpumask_empty(tick_broadcast_mask);\n\n\tswitch (mode) {\n\tcase TICK_BROADCAST_FORCE:\n\t\ttick_broadcast_forced = 1;\n\tcase TICK_BROADCAST_ON:\n\t\tcpumask_set_cpu(cpu, tick_broadcast_on);\n\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_mask)) {\n\t\t\t/*\n\t\t\t * Only shutdown the cpu local device, if:\n\t\t\t *\n\t\t\t * - the broadcast device exists\n\t\t\t * - the broadcast device is not a hrtimer based one\n\t\t\t * - the broadcast device is in periodic mode to\n\t\t\t *   avoid a hickup during switch to oneshot mode\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER) &&\n\t\t\t    tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\t\tclockevents_shutdown(dev);\n\t\t}\n\t\tbreak;\n\n\tcase TICK_BROADCAST_OFF:\n\t\tif (tick_broadcast_forced)\n\t\t\tbreak;\n\t\tcpumask_clear_cpu(cpu, tick_broadcast_on);\n\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_mask)) {\n\t\t\tif (tick_broadcast_device.mode ==\n\t\t\t    TICKDEV_MODE_PERIODIC)\n\t\t\t\ttick_setup_periodic(dev, 0);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (bc) {\n\t\tif (cpumask_empty(tick_broadcast_mask)) {\n\t\t\tif (!bc_stopped)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t} else if (bc_stopped) {\n\t\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\telse\n\t\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\t}\n\t}\nout:\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask",
      "static cpumask_var_t tick_broadcast_on",
      "static int tick_broadcast_forced;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_setup_oneshot",
          "args": [
            "bc"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_setup_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "878-919",
          "snippet": "static void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask,\n\t\t\t\t\t\t       tick_next_period);\n\t\t\ttick_broadcast_set_event(bc, cpu, tick_next_period);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstatic void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask,\n\t\t\t\t\t\t       tick_next_period);\n\t\t\ttick_broadcast_set_event(bc, cpu, tick_next_period);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_start_periodic",
          "args": [
            "bc"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_start_periodic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "65-69",
          "snippet": "static void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "bc"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "179-183",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_setup_periodic",
          "args": [
            "dev",
            "0"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_periodic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "144-172",
          "snippet": "void tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;",
            "ktime_t tick_period;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nktime_t tick_period;\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_on"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_and_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_on"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_device_is_functional",
          "args": [
            "dev"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "tick_device_is_functional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-internal.h",
          "lines": "35-38",
          "snippet": "static inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\nstatic int tick_broadcast_forced;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_broadcast_control(enum tick_broadcast_mode mode)\n{\n\tstruct clock_event_device *bc, *dev;\n\tstruct tick_device *td;\n\tint cpu, bc_stopped;\n\tunsigned long flags;\n\n\t/* Protects also the local clockevent device. */\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\ttd = this_cpu_ptr(&tick_cpu_device);\n\tdev = td->evtdev;\n\n\t/*\n\t * Is the device not affected by the powerstate ?\n\t */\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\tgoto out;\n\n\tif (!tick_device_is_functional(dev))\n\t\tgoto out;\n\n\tcpu = smp_processor_id();\n\tbc = tick_broadcast_device.evtdev;\n\tbc_stopped = cpumask_empty(tick_broadcast_mask);\n\n\tswitch (mode) {\n\tcase TICK_BROADCAST_FORCE:\n\t\ttick_broadcast_forced = 1;\n\tcase TICK_BROADCAST_ON:\n\t\tcpumask_set_cpu(cpu, tick_broadcast_on);\n\t\tif (!cpumask_test_and_set_cpu(cpu, tick_broadcast_mask)) {\n\t\t\t/*\n\t\t\t * Only shutdown the cpu local device, if:\n\t\t\t *\n\t\t\t * - the broadcast device exists\n\t\t\t * - the broadcast device is not a hrtimer based one\n\t\t\t * - the broadcast device is in periodic mode to\n\t\t\t *   avoid a hickup during switch to oneshot mode\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER) &&\n\t\t\t    tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\t\tclockevents_shutdown(dev);\n\t\t}\n\t\tbreak;\n\n\tcase TICK_BROADCAST_OFF:\n\t\tif (tick_broadcast_forced)\n\t\t\tbreak;\n\t\tcpumask_clear_cpu(cpu, tick_broadcast_on);\n\t\tif (cpumask_test_and_clear_cpu(cpu, tick_broadcast_mask)) {\n\t\t\tif (tick_broadcast_device.mode ==\n\t\t\t    TICKDEV_MODE_PERIODIC)\n\t\t\t\ttick_setup_periodic(dev, 0);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (bc) {\n\t\tif (cpumask_empty(tick_broadcast_mask)) {\n\t\t\tif (!bc_stopped)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t} else if (bc_stopped) {\n\t\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\telse\n\t\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\t}\n\t}\nout:\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
  },
  {
    "function_name": "tick_handle_periodic_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "316-345",
    "snippet": "static void tick_handle_periodic_broadcast(struct clock_event_device *dev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool bc_local;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\n\t/* Handle spurious interrupts gracefully */\n\tif (clockevent_state_shutdown(tick_broadcast_device.evtdev)) {\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t\treturn;\n\t}\n\n\tbc_local = tick_do_periodic_broadcast();\n\n\tif (clockevent_state_oneshot(dev)) {\n\t\tktime_t next = ktime_add(dev->next_event, tick_period);\n\n\t\tclockevents_program_event(dev, next, true);\n\t}\n\traw_spin_unlock(&tick_broadcast_lock);\n\n\t/*\n\t * We run the handler of the local cpu after dropping\n\t * tick_broadcast_lock because the handler might deadlock when\n\t * trying to switch to oneshot mode.\n\t */\n\tif (bc_local)\n\t\ttd->evtdev->event_handler(td->evtdev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "td->evtdev->event_handler",
          "args": [
            "td->evtdev"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "dev",
            "next",
            "true"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "311-347",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "dev->next_event",
            "tick_period"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_do_periodic_broadcast",
          "args": [],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_periodic_broadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "307-311",
          "snippet": "static bool tick_do_periodic_broadcast(void)\n{\n\tcpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);\n\treturn tick_do_broadcast(tmpmask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstatic bool tick_do_periodic_broadcast(void)\n{\n\tcpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);\n\treturn tick_do_broadcast(tmpmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_shutdown",
          "args": [
            "tick_broadcast_device.evtdev"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nstatic void tick_handle_periodic_broadcast(struct clock_event_device *dev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool bc_local;\n\n\traw_spin_lock(&tick_broadcast_lock);\n\n\t/* Handle spurious interrupts gracefully */\n\tif (clockevent_state_shutdown(tick_broadcast_device.evtdev)) {\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t\treturn;\n\t}\n\n\tbc_local = tick_do_periodic_broadcast();\n\n\tif (clockevent_state_oneshot(dev)) {\n\t\tktime_t next = ktime_add(dev->next_event, tick_period);\n\n\t\tclockevents_program_event(dev, next, true);\n\t}\n\traw_spin_unlock(&tick_broadcast_lock);\n\n\t/*\n\t * We run the handler of the local cpu after dropping\n\t * tick_broadcast_lock because the handler might deadlock when\n\t * trying to switch to oneshot mode.\n\t */\n\tif (bc_local)\n\t\ttd->evtdev->event_handler(td->evtdev);\n}"
  },
  {
    "function_name": "tick_do_periodic_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "307-311",
    "snippet": "static bool tick_do_periodic_broadcast(void)\n{\n\tcpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);\n\treturn tick_do_broadcast(tmpmask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t tick_broadcast_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_do_broadcast",
          "args": [
            "tmpmask"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "tick_do_broadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "262-301",
          "snippet": "static bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstatic bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmpmask",
            "cpu_online_mask",
            "tick_broadcast_mask"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstatic bool tick_do_periodic_broadcast(void)\n{\n\tcpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);\n\treturn tick_do_broadcast(tmpmask);\n}"
  },
  {
    "function_name": "tick_do_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "262-301",
    "snippet": "static bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "td->evtdev->broadcast",
          "args": [
            "mask"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpumask_first(mask)"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "mask"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "mask"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstatic bool tick_do_broadcast(struct cpumask *mask)\n{\n\tint cpu = smp_processor_id();\n\tstruct tick_device *td;\n\tbool local = false;\n\n\t/*\n\t * Check, if the current cpu is in the mask\n\t */\n\tif (cpumask_test_cpu(cpu, mask)) {\n\t\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\t\t/*\n\t\t * We only run the local handler, if the broadcast\n\t\t * device is not hrtimer based. Otherwise we run into\n\t\t * a hrtimer recursion.\n\t\t *\n\t\t * local timer_interrupt()\n\t\t *   local_handler()\n\t\t *     expire_hrtimers()\n\t\t *       bc_handler()\n\t\t *         local_handler()\n\t\t *\t     expire_hrtimers()\n\t\t */\n\t\tlocal = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);\n\t}\n\n\tif (!cpumask_empty(mask)) {\n\t\t/*\n\t\t * It might be necessary to actually check whether the devices\n\t\t * have different broadcast functions. For now, just use the\n\t\t * one of the first device. This works as long as we have this\n\t\t * misfeature only on x86 (lapic)\n\t\t */\n\t\ttd = &per_cpu(tick_cpu_device, cpumask_first(mask));\n\t\ttd->evtdev->broadcast(mask);\n\t}\n\treturn local;\n}"
  },
  {
    "function_name": "tick_receive_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "243-256",
    "snippet": "int tick_receive_broadcast(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tstruct clock_event_device *evt = td->evtdev;\n\n\tif (!evt)\n\t\treturn -ENODEV;\n\n\tif (!evt->event_handler)\n\t\treturn -EINVAL;\n\n\tevt->event_handler(evt);\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evt->event_handler",
          "args": [
            "evt"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_receive_broadcast(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tstruct clock_event_device *evt = td->evtdev;\n\n\tif (!evt)\n\t\treturn -ENODEV;\n\n\tif (!evt->event_handler)\n\t\treturn -EINVAL;\n\n\tevt->event_handler(evt);\n\treturn 0;\n}"
  },
  {
    "function_name": "tick_device_uses_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "161-240",
    "snippet": "int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Devices might be registered with both periodic and oneshot\n\t * mode disabled. This signals, that the device needs to be\n\t * operated from the broadcast device and is a placeholder for\n\t * the cpu local device.\n\t */\n\tif (!tick_device_is_functional(dev)) {\n\t\tdev->event_handler = tick_handle_periodic;\n\t\ttick_device_setup_broadcast_func(dev);\n\t\tcpumask_set_cpu(cpu, tick_broadcast_mask);\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_broadcast_start_periodic(bc);\n\t\telse\n\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\tret = 1;\n\t} else {\n\t\t/*\n\t\t * Clear the broadcast bit for this cpu if the\n\t\t * device is not power state affected.\n\t\t */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\t\telse\n\t\t\ttick_device_setup_broadcast_func(dev);\n\n\t\t/*\n\t\t * Clear the broadcast bit if the CPU is not in\n\t\t * periodic broadcast on state.\n\t\t */\n\t\tif (!cpumask_test_cpu(cpu, tick_broadcast_on))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\t/*\n\t\t\t * If the system is in oneshot mode we can\n\t\t\t * unconditionally clear the oneshot mask bit,\n\t\t\t * because the CPU is running and therefore\n\t\t\t * not in an idle state which causes the power\n\t\t\t * state affected device to stop. Let the\n\t\t\t * caller initialize the device.\n\t\t\t */\n\t\t\ttick_broadcast_clear_oneshot(cpu);\n\t\t\tret = 0;\n\t\t\tbreak;\n\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\t/*\n\t\t\t * If the system is in periodic mode, check\n\t\t\t * whether the broadcast device can be\n\t\t\t * switched off now.\n\t\t\t */\n\t\t\tif (cpumask_empty(tick_broadcast_mask) && bc)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t\t/*\n\t\t\t * If we kept the cpu in the broadcast mask,\n\t\t\t * tell the caller to leave the per cpu device\n\t\t\t * in shutdown state. The periodic interrupt\n\t\t\t * is delivered by the broadcast device, if\n\t\t\t * the broadcast device exists and is not\n\t\t\t * hrtimer based.\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\t\t\tret = cpumask_test_cpu(cpu, tick_broadcast_mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask",
      "static cpumask_var_t tick_broadcast_on",
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "bc"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "179-183",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_broadcast_clear_oneshot",
          "args": [
            "cpu"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_clear_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "856-860",
          "snippet": "static void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_clear_oneshot(int cpu)\n{\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "tick_broadcast_on"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_device_setup_broadcast_func",
          "args": [
            "dev"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "tick_device_setup_broadcast_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "146-155",
          "snippet": "static void tick_device_setup_broadcast_func(struct clock_event_device *dev)\n{\n\tif (!dev->broadcast)\n\t\tdev->broadcast = tick_broadcast;\n\tif (!dev->broadcast) {\n\t\tpr_warn_once(\"%s depends on broadcast, but no broadcast function available\\n\",\n\t\t\t     dev->name);\n\t\tdev->broadcast = err_broadcast;\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_device_setup_broadcast_func(struct clock_event_device *dev)\n{\n\tif (!dev->broadcast)\n\t\tdev->broadcast = tick_broadcast;\n\tif (!dev->broadcast) {\n\t\tpr_warn_once(\"%s depends on broadcast, but no broadcast function available\\n\",\n\t\t\t     dev->name);\n\t\tdev->broadcast = err_broadcast;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_broadcast_setup_oneshot",
          "args": [
            "bc"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_setup_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "878-919",
          "snippet": "static void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask,\n\t\t\t\t\t\t       tick_next_period);\n\t\t\ttick_broadcast_set_event(bc, cpu, tick_next_period);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstatic void tick_broadcast_setup_oneshot(struct clock_event_device *bc)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!bc)\n\t\treturn;\n\n\t/* Set it up only once ! */\n\tif (bc->event_handler != tick_handle_oneshot_broadcast) {\n\t\tint was_periodic = clockevent_state_periodic(bc);\n\n\t\tbc->event_handler = tick_handle_oneshot_broadcast;\n\n\t\t/*\n\t\t * We must be careful here. There might be other CPUs\n\t\t * waiting for periodic broadcast. We need to set the\n\t\t * oneshot_mask bits for those and program the\n\t\t * broadcast device to fire.\n\t\t */\n\t\tcpumask_copy(tmpmask, tick_broadcast_mask);\n\t\tcpumask_clear_cpu(cpu, tmpmask);\n\t\tcpumask_or(tick_broadcast_oneshot_mask,\n\t\t\t   tick_broadcast_oneshot_mask, tmpmask);\n\n\t\tif (was_periodic && !cpumask_empty(tmpmask)) {\n\t\t\tclockevents_switch_state(bc, CLOCK_EVT_STATE_ONESHOT);\n\t\t\ttick_broadcast_init_next_event(tmpmask,\n\t\t\t\t\t\t       tick_next_period);\n\t\t\ttick_broadcast_set_event(bc, cpu, tick_next_period);\n\t\t} else\n\t\t\tbc->next_event = KTIME_MAX;\n\t} else {\n\t\t/*\n\t\t * The first cpu which switches to oneshot mode sets\n\t\t * the bit for all other cpus which are in the general\n\t\t * (periodic) broadcast mask. So the bit is set and\n\t\t * would prevent the first broadcast enter after this\n\t\t * to program the bc device.\n\t\t */\n\t\ttick_broadcast_clear_oneshot(cpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_start_periodic",
          "args": [
            "bc"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_start_periodic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "65-69",
          "snippet": "static void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tick_broadcast_mask"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_device_is_functional",
          "args": [
            "dev"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "tick_device_is_functional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-internal.h",
          "lines": "35-38",
          "snippet": "static inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&tick_broadcast_lock",
            "flags"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nint tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Devices might be registered with both periodic and oneshot\n\t * mode disabled. This signals, that the device needs to be\n\t * operated from the broadcast device and is a placeholder for\n\t * the cpu local device.\n\t */\n\tif (!tick_device_is_functional(dev)) {\n\t\tdev->event_handler = tick_handle_periodic;\n\t\ttick_device_setup_broadcast_func(dev);\n\t\tcpumask_set_cpu(cpu, tick_broadcast_mask);\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_broadcast_start_periodic(bc);\n\t\telse\n\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\tret = 1;\n\t} else {\n\t\t/*\n\t\t * Clear the broadcast bit for this cpu if the\n\t\t * device is not power state affected.\n\t\t */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\t\telse\n\t\t\ttick_device_setup_broadcast_func(dev);\n\n\t\t/*\n\t\t * Clear the broadcast bit if the CPU is not in\n\t\t * periodic broadcast on state.\n\t\t */\n\t\tif (!cpumask_test_cpu(cpu, tick_broadcast_on))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\t/*\n\t\t\t * If the system is in oneshot mode we can\n\t\t\t * unconditionally clear the oneshot mask bit,\n\t\t\t * because the CPU is running and therefore\n\t\t\t * not in an idle state which causes the power\n\t\t\t * state affected device to stop. Let the\n\t\t\t * caller initialize the device.\n\t\t\t */\n\t\t\ttick_broadcast_clear_oneshot(cpu);\n\t\t\tret = 0;\n\t\t\tbreak;\n\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\t/*\n\t\t\t * If the system is in periodic mode, check\n\t\t\t * whether the broadcast device can be\n\t\t\t * switched off now.\n\t\t\t */\n\t\t\tif (cpumask_empty(tick_broadcast_mask) && bc)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t\t/*\n\t\t\t * If we kept the cpu in the broadcast mask,\n\t\t\t * tell the caller to leave the per cpu device\n\t\t\t * in shutdown state. The periodic interrupt\n\t\t\t * is delivered by the broadcast device, if\n\t\t\t * the broadcast device exists and is not\n\t\t\t * hrtimer based.\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\t\t\tret = cpumask_test_cpu(cpu, tick_broadcast_mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "tick_device_setup_broadcast_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "146-155",
    "snippet": "static void tick_device_setup_broadcast_func(struct clock_event_device *dev)\n{\n\tif (!dev->broadcast)\n\t\tdev->broadcast = tick_broadcast;\n\tif (!dev->broadcast) {\n\t\tpr_warn_once(\"%s depends on broadcast, but no broadcast function available\\n\",\n\t\t\t     dev->name);\n\t\tdev->broadcast = err_broadcast;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"%s depends on broadcast, but no broadcast function available\\n\"",
            "dev->name"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_device_setup_broadcast_func(struct clock_event_device *dev)\n{\n\tif (!dev->broadcast)\n\t\tdev->broadcast = tick_broadcast;\n\tif (!dev->broadcast) {\n\t\tpr_warn_once(\"%s depends on broadcast, but no broadcast function available\\n\",\n\t\t\t     dev->name);\n\t\tdev->broadcast = err_broadcast;\n\t}\n}"
  },
  {
    "function_name": "err_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "141-144",
    "snippet": "static void err_broadcast(const struct cpumask *mask)\n{\n\tpr_crit_once(\"Failed to broadcast timer tick. Some CPUs may be unresponsive.\\n\");\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_crit_once",
          "args": [
            "\"Failed to broadcast timer tick. Some CPUs may be unresponsive.\\n\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void err_broadcast(const struct cpumask *mask)\n{\n\tpr_crit_once(\"Failed to broadcast timer tick. Some CPUs may be unresponsive.\\n\");\n}"
  },
  {
    "function_name": "tick_broadcast_update_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "128-138",
    "snippet": "int tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tint ret = -ENODEV;\n\n\tif (tick_is_broadcast_device(dev)) {\n\t\traw_spin_lock(&tick_broadcast_lock);\n\t\tret = __clockevents_update_freq(dev, freq);\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clockevents_update_freq",
          "args": [
            "dev",
            "freq"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_update_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "526-537",
          "snippet": "int __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_broadcast_lock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_is_broadcast_device",
          "args": [
            "dev"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "tick_is_broadcast_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "123-126",
          "snippet": "int tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nint tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tint ret = -ENODEV;\n\n\tif (tick_is_broadcast_device(dev)) {\n\t\traw_spin_lock(&tick_broadcast_lock);\n\t\tret = __clockevents_update_freq(dev, freq);\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "tick_is_broadcast_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "123-126",
    "snippet": "int tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}"
  },
  {
    "function_name": "tick_install_broadcast_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "92-118",
    "snippet": "void tick_install_broadcast_device(struct clock_event_device *dev)\n{\n\tstruct clock_event_device *cur = tick_broadcast_device.evtdev;\n\n\tif (!tick_check_broadcast_device(cur, dev))\n\t\treturn;\n\n\tif (!try_module_get(dev->owner))\n\t\treturn;\n\n\tclockevents_exchange_device(cur, dev);\n\tif (cur)\n\t\tcur->event_handler = clockevents_handle_noop;\n\ttick_broadcast_device.evtdev = dev;\n\tif (!cpumask_empty(tick_broadcast_mask))\n\t\ttick_broadcast_start_periodic(dev);\n\t/*\n\t * Inform all cpus about this. We might be in a situation\n\t * where we did not switch to oneshot mode because the per cpu\n\t * devices are affected by CLOCK_EVT_FEAT_C3STOP and the lack\n\t * of a oneshot capable broadcast device. Without that\n\t * notification the systems stays stuck in periodic mode\n\t * forever.\n\t */\n\tif (dev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_clock_notify();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;",
      "static cpumask_var_t tick_broadcast_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_clock_notify",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "tick_clock_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1345-1351",
          "snippet": "void tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_start_periodic",
          "args": [
            "dev"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_start_periodic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "65-69",
          "snippet": "static void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tick_broadcast_mask"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_exchange_device",
          "args": [
            "cur",
            "dev"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_exchange_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "579-597",
          "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_del(&old->list);\n\t\tlist_add(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_del(&old->list);\n\t\tlist_add(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "dev->owner"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1113-1129",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_broadcast_device",
          "args": [
            "cur",
            "dev"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_broadcast_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "74-87",
          "snippet": "static bool tick_check_broadcast_device(struct clock_event_device *curdev,\n\t\t\t\t\tstruct clock_event_device *newdev)\n{\n\tif ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_PERCPU) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn false;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT &&\n\t    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn false;\n\n\treturn !curdev || newdev->rating > curdev->rating;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstatic bool tick_check_broadcast_device(struct clock_event_device *curdev,\n\t\t\t\t\tstruct clock_event_device *newdev)\n{\n\tif ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_PERCPU) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn false;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT &&\n\t    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn false;\n\n\treturn !curdev || newdev->rating > curdev->rating;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\n\nvoid tick_install_broadcast_device(struct clock_event_device *dev)\n{\n\tstruct clock_event_device *cur = tick_broadcast_device.evtdev;\n\n\tif (!tick_check_broadcast_device(cur, dev))\n\t\treturn;\n\n\tif (!try_module_get(dev->owner))\n\t\treturn;\n\n\tclockevents_exchange_device(cur, dev);\n\tif (cur)\n\t\tcur->event_handler = clockevents_handle_noop;\n\ttick_broadcast_device.evtdev = dev;\n\tif (!cpumask_empty(tick_broadcast_mask))\n\t\ttick_broadcast_start_periodic(dev);\n\t/*\n\t * Inform all cpus about this. We might be in a situation\n\t * where we did not switch to oneshot mode because the per cpu\n\t * devices are affected by CLOCK_EVT_FEAT_C3STOP and the lack\n\t * of a oneshot capable broadcast device. Without that\n\t * notification the systems stays stuck in periodic mode\n\t * forever.\n\t */\n\tif (dev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_clock_notify();\n}"
  },
  {
    "function_name": "tick_check_broadcast_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "74-87",
    "snippet": "static bool tick_check_broadcast_device(struct clock_event_device *curdev,\n\t\t\t\t\tstruct clock_event_device *newdev)\n{\n\tif ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_PERCPU) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn false;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT &&\n\t    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn false;\n\n\treturn !curdev || newdev->rating > curdev->rating;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstatic bool tick_check_broadcast_device(struct clock_event_device *curdev,\n\t\t\t\t\tstruct clock_event_device *newdev)\n{\n\tif ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_PERCPU) ||\n\t    (newdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn false;\n\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT &&\n\t    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn false;\n\n\treturn !curdev || newdev->rating > curdev->rating;\n}"
  },
  {
    "function_name": "tick_broadcast_start_periodic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "65-69",
    "snippet": "static void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_setup_periodic",
          "args": [
            "bc",
            "1"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_periodic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "144-172",
          "snippet": "void tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;",
            "ktime_t tick_period;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nktime_t tick_period;\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\n{\n\tif (bc)\n\t\ttick_setup_periodic(bc, 1);\n}"
  },
  {
    "function_name": "tick_get_broadcast_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "57-60",
    "snippet": "struct cpumask *tick_get_broadcast_mask(void)\n{\n\treturn tick_broadcast_mask;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t tick_broadcast_mask"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstruct cpumask *tick_get_broadcast_mask(void)\n{\n\treturn tick_broadcast_mask;\n}"
  },
  {
    "function_name": "tick_get_broadcast_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "52-55",
    "snippet": "struct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tick_device tick_broadcast_device;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstruct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}"
  },
  {
    "function_name": "tick_resume_broadcast_oneshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "46-46",
    "snippet": "static inline void tick_resume_broadcast_oneshot(struct clock_event_device *bc) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_resume_broadcast_oneshot(struct clock_event_device *bc) { }"
  },
  {
    "function_name": "tick_broadcast_clear_oneshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "45-45",
    "snippet": "static inline void tick_broadcast_clear_oneshot(int cpu) { }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_broadcast_clear_oneshot(int cpu) { }"
  },
  {
    "function_name": "tick_broadcast_setup_oneshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
    "lines": "44-44",
    "snippet": "static inline void tick_broadcast_setup_oneshot(struct clock_event_device *bc) { BUG(); }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic inline void tick_broadcast_setup_oneshot(struct clock_event_device *bc) { BUG(); }"
  }
]