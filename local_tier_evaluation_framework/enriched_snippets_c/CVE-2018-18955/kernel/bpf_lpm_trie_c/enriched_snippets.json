[
  {
    "function_name": "trie_check_btf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
    "lines": "691-698",
    "snippet": "static int trie_check_btf(const struct bpf_map *map,\n\t\t\t  const struct btf_type *key_type,\n\t\t\t  const struct btf_type *value_type)\n{\n\t/* Keys must have struct bpf_lpm_trie_key embedded. */\n\treturn BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ?\n\t       -EINVAL : 0;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "key_type->info"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int trie_check_btf(const struct bpf_map *map,\n\t\t\t  const struct btf_type *key_type,\n\t\t\t  const struct btf_type *value_type)\n{\n\t/* Keys must have struct bpf_lpm_trie_key embedded. */\n\treturn BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ?\n\t       -EINVAL : 0;\n}"
  },
  {
    "function_name": "trie_get_next_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
    "lines": "598-689",
    "snippet": "static int trie_get_next_key(struct bpf_map *map, void *_key, void *_next_key)\n{\n\tstruct lpm_trie_node *node, *next_node = NULL, *parent, *search_root;\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct bpf_lpm_trie_key *key = _key, *next_key = _next_key;\n\tstruct lpm_trie_node **node_stack = NULL;\n\tint err = 0, stack_ptr = -1;\n\tunsigned int next_bit;\n\tsize_t matchlen;\n\n\t/* The get_next_key follows postorder. For the 4 node example in\n\t * the top of this file, the trie_get_next_key() returns the following\n\t * one after another:\n\t *   192.168.0.0/24\n\t *   192.168.1.0/24\n\t *   192.168.128.0/24\n\t *   192.168.0.0/16\n\t *\n\t * The idea is to return more specific keys before less specific ones.\n\t */\n\n\t/* Empty trie */\n\tsearch_root = rcu_dereference(trie->root);\n\tif (!search_root)\n\t\treturn -ENOENT;\n\n\t/* For invalid key, find the leftmost node in the trie */\n\tif (!key || key->prefixlen > trie->max_prefixlen)\n\t\tgoto find_leftmost;\n\n\tnode_stack = kmalloc_array(trie->max_prefixlen,\n\t\t\t\t   sizeof(struct lpm_trie_node *),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN);\n\tif (!node_stack)\n\t\treturn -ENOMEM;\n\n\t/* Try to find the exact node for the given key */\n\tfor (node = search_root; node;) {\n\t\tnode_stack[++stack_ptr] = node;\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen)\n\t\t\tbreak;\n\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tnode = rcu_dereference(node->child[next_bit]);\n\t}\n\tif (!node || node->prefixlen != key->prefixlen ||\n\t    (node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\tgoto find_leftmost;\n\n\t/* The node with the exactly-matching key has been found,\n\t * find the first node in postorder after the matched node.\n\t */\n\tnode = node_stack[stack_ptr];\n\twhile (stack_ptr > 0) {\n\t\tparent = node_stack[stack_ptr - 1];\n\t\tif (rcu_dereference(parent->child[0]) == node) {\n\t\t\tsearch_root = rcu_dereference(parent->child[1]);\n\t\t\tif (search_root)\n\t\t\t\tgoto find_leftmost;\n\t\t}\n\t\tif (!(parent->flags & LPM_TREE_NODE_FLAG_IM)) {\n\t\t\tnext_node = parent;\n\t\t\tgoto do_copy;\n\t\t}\n\n\t\tnode = parent;\n\t\tstack_ptr--;\n\t}\n\n\t/* did not find anything */\n\terr = -ENOENT;\n\tgoto free_stack;\n\nfind_leftmost:\n\t/* Find the leftmost non-intermediate node, all intermediate nodes\n\t * have exact two children, so this function will never return NULL.\n\t */\n\tfor (node = search_root; node;) {\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\tnext_node = node;\n\t\tnode = rcu_dereference(node->child[0]);\n\t}\ndo_copy:\n\tnext_key->prefixlen = next_node->prefixlen;\n\tmemcpy((void *)next_key + offsetof(struct bpf_lpm_trie_key, data),\n\t       next_node->data, trie->data_size);\nfree_stack:\n\tkfree(node_stack);\n\treturn err;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define LPM_TREE_NODE_FLAG_IM BIT(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node_stack"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)next_key + offsetof(struct bpf_lpm_trie_key, data)",
            "next_node->data",
            "trie->data_size"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "node->child[0]"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_bit",
          "args": [
            "key->data",
            "node->prefixlen"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "extract_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
          "lines": "154-157",
          "snippet": "static inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "longest_prefix_match",
          "args": [
            "trie",
            "node",
            "key"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "longest_prefix_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
          "lines": "167-188",
          "snippet": "static size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tsize_t prefixlen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < trie->data_size; i++) {\n\t\tsize_t b;\n\n\t\tb = 8 - fls(node->data[i] ^ key->data[i]);\n\t\tprefixlen += b;\n\n\t\tif (prefixlen >= node->prefixlen || prefixlen >= key->prefixlen)\n\t\t\treturn min(node->prefixlen, key->prefixlen);\n\n\t\tif (b < 8)\n\t\t\tbreak;\n\t}\n\n\treturn prefixlen;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tsize_t prefixlen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < trie->data_size; i++) {\n\t\tsize_t b;\n\n\t\tb = 8 - fls(node->data[i] ^ key->data[i]);\n\t\tprefixlen += b;\n\n\t\tif (prefixlen >= node->prefixlen || prefixlen >= key->prefixlen)\n\t\t\treturn min(node->prefixlen, key->prefixlen);\n\n\t\tif (b < 8)\n\t\t\tbreak;\n\t}\n\n\treturn prefixlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "trie->max_prefixlen",
            "sizeof(struct lpm_trie_node *)",
            "GFP_ATOMIC | __GFP_NOWARN"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structlpm_trie",
            "map"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define LPM_TREE_NODE_FLAG_IM BIT(0)\n\nstatic int trie_get_next_key(struct bpf_map *map, void *_key, void *_next_key)\n{\n\tstruct lpm_trie_node *node, *next_node = NULL, *parent, *search_root;\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct bpf_lpm_trie_key *key = _key, *next_key = _next_key;\n\tstruct lpm_trie_node **node_stack = NULL;\n\tint err = 0, stack_ptr = -1;\n\tunsigned int next_bit;\n\tsize_t matchlen;\n\n\t/* The get_next_key follows postorder. For the 4 node example in\n\t * the top of this file, the trie_get_next_key() returns the following\n\t * one after another:\n\t *   192.168.0.0/24\n\t *   192.168.1.0/24\n\t *   192.168.128.0/24\n\t *   192.168.0.0/16\n\t *\n\t * The idea is to return more specific keys before less specific ones.\n\t */\n\n\t/* Empty trie */\n\tsearch_root = rcu_dereference(trie->root);\n\tif (!search_root)\n\t\treturn -ENOENT;\n\n\t/* For invalid key, find the leftmost node in the trie */\n\tif (!key || key->prefixlen > trie->max_prefixlen)\n\t\tgoto find_leftmost;\n\n\tnode_stack = kmalloc_array(trie->max_prefixlen,\n\t\t\t\t   sizeof(struct lpm_trie_node *),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN);\n\tif (!node_stack)\n\t\treturn -ENOMEM;\n\n\t/* Try to find the exact node for the given key */\n\tfor (node = search_root; node;) {\n\t\tnode_stack[++stack_ptr] = node;\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen)\n\t\t\tbreak;\n\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tnode = rcu_dereference(node->child[next_bit]);\n\t}\n\tif (!node || node->prefixlen != key->prefixlen ||\n\t    (node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\tgoto find_leftmost;\n\n\t/* The node with the exactly-matching key has been found,\n\t * find the first node in postorder after the matched node.\n\t */\n\tnode = node_stack[stack_ptr];\n\twhile (stack_ptr > 0) {\n\t\tparent = node_stack[stack_ptr - 1];\n\t\tif (rcu_dereference(parent->child[0]) == node) {\n\t\t\tsearch_root = rcu_dereference(parent->child[1]);\n\t\t\tif (search_root)\n\t\t\t\tgoto find_leftmost;\n\t\t}\n\t\tif (!(parent->flags & LPM_TREE_NODE_FLAG_IM)) {\n\t\t\tnext_node = parent;\n\t\t\tgoto do_copy;\n\t\t}\n\n\t\tnode = parent;\n\t\tstack_ptr--;\n\t}\n\n\t/* did not find anything */\n\terr = -ENOENT;\n\tgoto free_stack;\n\nfind_leftmost:\n\t/* Find the leftmost non-intermediate node, all intermediate nodes\n\t * have exact two children, so this function will never return NULL.\n\t */\n\tfor (node = search_root; node;) {\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\tnext_node = node;\n\t\tnode = rcu_dereference(node->child[0]);\n\t}\ndo_copy:\n\tnext_key->prefixlen = next_node->prefixlen;\n\tmemcpy((void *)next_key + offsetof(struct bpf_lpm_trie_key, data),\n\t       next_node->data, trie->data_size);\nfree_stack:\n\tkfree(node_stack);\n\treturn err;\n}"
  },
  {
    "function_name": "trie_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
    "lines": "554-596",
    "snippet": "static void trie_free(struct bpf_map *map)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node __rcu **slot;\n\tstruct lpm_trie_node *node;\n\n\t/* Wait for outstanding programs to complete\n\t * update/lookup/delete/get_next_key and free the trie.\n\t */\n\tsynchronize_rcu();\n\n\t/* Always start at the root and walk down to a node that has no\n\t * children. Then free that node, nullify its reference in the parent\n\t * and start over.\n\t */\n\n\tfor (;;) {\n\t\tslot = &trie->root;\n\n\t\tfor (;;) {\n\t\t\tnode = rcu_dereference_protected(*slot, 1);\n\t\t\tif (!node)\n\t\t\t\tgoto out;\n\n\t\t\tif (rcu_access_pointer(node->child[0])) {\n\t\t\t\tslot = &node->child[0];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rcu_access_pointer(node->child[1])) {\n\t\t\t\tslot = &node->child[1];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkfree(node);\n\t\t\tRCU_INIT_POINTER(*slot, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(trie);\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "trie"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "*slot",
            "NULL"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[1]"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[0]"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "*slot",
            "1"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structlpm_trie",
            "map"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void trie_free(struct bpf_map *map)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node __rcu **slot;\n\tstruct lpm_trie_node *node;\n\n\t/* Wait for outstanding programs to complete\n\t * update/lookup/delete/get_next_key and free the trie.\n\t */\n\tsynchronize_rcu();\n\n\t/* Always start at the root and walk down to a node that has no\n\t * children. Then free that node, nullify its reference in the parent\n\t * and start over.\n\t */\n\n\tfor (;;) {\n\t\tslot = &trie->root;\n\n\t\tfor (;;) {\n\t\t\tnode = rcu_dereference_protected(*slot, 1);\n\t\t\tif (!node)\n\t\t\t\tgoto out;\n\n\t\t\tif (rcu_access_pointer(node->child[0])) {\n\t\t\t\tslot = &node->child[0];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rcu_access_pointer(node->child[1])) {\n\t\t\t\tslot = &node->child[1];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkfree(node);\n\t\t\tRCU_INIT_POINTER(*slot, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(trie);\n}"
  },
  {
    "function_name": "trie_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
    "lines": "503-552",
    "snippet": "static struct bpf_map *trie_alloc(union bpf_attr *attr)\n{\n\tstruct lpm_trie *trie;\n\tu64 cost = sizeof(*trie), cost_per_node;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 ||\n\t    !(attr->map_flags & BPF_F_NO_PREALLOC) ||\n\t    attr->map_flags & ~LPM_CREATE_FLAG_MASK ||\n\t    attr->key_size < LPM_KEY_SIZE_MIN ||\n\t    attr->key_size > LPM_KEY_SIZE_MAX ||\n\t    attr->value_size < LPM_VAL_SIZE_MIN ||\n\t    attr->value_size > LPM_VAL_SIZE_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttrie = kzalloc(sizeof(*trie), GFP_USER | __GFP_NOWARN);\n\tif (!trie)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&trie->map, attr);\n\ttrie->data_size = attr->key_size -\n\t\t\t  offsetof(struct bpf_lpm_trie_key, data);\n\ttrie->max_prefixlen = trie->data_size * 8;\n\n\tcost_per_node = sizeof(struct lpm_trie_node) +\n\t\t\tattr->value_size + trie->data_size;\n\tcost += (u64) attr->max_entries * cost_per_node;\n\tif (cost >= U32_MAX - PAGE_SIZE) {\n\t\tret = -E2BIG;\n\t\tgoto out_err;\n\t}\n\n\ttrie->map.pages = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;\n\n\tret = bpf_map_precharge_memlock(trie->map.pages);\n\tif (ret)\n\t\tgoto out_err;\n\n\traw_spin_lock_init(&trie->lock);\n\n\treturn &trie->map;\nout_err:\n\tkfree(trie);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define LPM_CREATE_FLAG_MASK\t(BPF_F_NO_PREALLOC | BPF_F_NUMA_NODE |\t\\\n\t\t\t\t BPF_F_RDONLY | BPF_F_WRONLY)",
      "#define LPM_KEY_SIZE_MIN\tLPM_KEY_SIZE(LPM_DATA_SIZE_MIN)",
      "#define LPM_KEY_SIZE_MAX\tLPM_KEY_SIZE(LPM_DATA_SIZE_MAX)",
      "#define LPM_VAL_SIZE_MIN\t1",
      "#define LPM_VAL_SIZE_MAX\t(KMALLOC_MAX_SIZE - LPM_DATA_SIZE_MAX - \\\n\t\t\t\t sizeof(struct lpm_trie_node))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "trie"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&trie->lock"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_precharge_memlock",
          "args": [
            "trie->map.pages"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_precharge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "171-182",
          "snippet": "int bpf_map_precharge_memlock(u32 pages)\n{\n\tstruct user_struct *user = get_current_user();\n\tunsigned long memlock_limit, cur;\n\n\tmemlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tcur = atomic_long_read(&user->locked_vm);\n\tfree_uid(user);\n\tif (cur + pages > memlock_limit)\n\t\treturn -EPERM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_map_precharge_memlock(u32 pages)\n{\n\tstruct user_struct *user = get_current_user();\n\tunsigned long memlock_limit, cur;\n\n\tmemlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tcur = atomic_long_read(&user->locked_vm);\n\tfree_uid(user);\n\tif (cur + pages > memlock_limit)\n\t\treturn -EPERM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "cost",
            "PAGE_SIZE"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&trie->map",
            "attr"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "161-169",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*trie)",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define LPM_CREATE_FLAG_MASK\t(BPF_F_NO_PREALLOC | BPF_F_NUMA_NODE |\t\\\n\t\t\t\t BPF_F_RDONLY | BPF_F_WRONLY)\n#define LPM_KEY_SIZE_MIN\tLPM_KEY_SIZE(LPM_DATA_SIZE_MIN)\n#define LPM_KEY_SIZE_MAX\tLPM_KEY_SIZE(LPM_DATA_SIZE_MAX)\n#define LPM_VAL_SIZE_MIN\t1\n#define LPM_VAL_SIZE_MAX\t(KMALLOC_MAX_SIZE - LPM_DATA_SIZE_MAX - \\\n\t\t\t\t sizeof(struct lpm_trie_node))\n\nstatic struct bpf_map *trie_alloc(union bpf_attr *attr)\n{\n\tstruct lpm_trie *trie;\n\tu64 cost = sizeof(*trie), cost_per_node;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 ||\n\t    !(attr->map_flags & BPF_F_NO_PREALLOC) ||\n\t    attr->map_flags & ~LPM_CREATE_FLAG_MASK ||\n\t    attr->key_size < LPM_KEY_SIZE_MIN ||\n\t    attr->key_size > LPM_KEY_SIZE_MAX ||\n\t    attr->value_size < LPM_VAL_SIZE_MIN ||\n\t    attr->value_size > LPM_VAL_SIZE_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttrie = kzalloc(sizeof(*trie), GFP_USER | __GFP_NOWARN);\n\tif (!trie)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&trie->map, attr);\n\ttrie->data_size = attr->key_size -\n\t\t\t  offsetof(struct bpf_lpm_trie_key, data);\n\ttrie->max_prefixlen = trie->data_size * 8;\n\n\tcost_per_node = sizeof(struct lpm_trie_node) +\n\t\t\tattr->value_size + trie->data_size;\n\tcost += (u64) attr->max_entries * cost_per_node;\n\tif (cost >= U32_MAX - PAGE_SIZE) {\n\t\tret = -E2BIG;\n\t\tgoto out_err;\n\t}\n\n\ttrie->map.pages = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;\n\n\tret = bpf_map_precharge_memlock(trie->map.pages);\n\tif (ret)\n\t\tgoto out_err;\n\n\traw_spin_lock_init(&trie->lock);\n\n\treturn &trie->map;\nout_err:\n\tkfree(trie);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "trie_delete_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
    "lines": "395-487",
    "snippet": "static int trie_delete_elem(struct bpf_map *map, void *_key)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct bpf_lpm_trie_key *key = _key;\n\tstruct lpm_trie_node __rcu **trim, **trim2;\n\tstruct lpm_trie_node *node, *parent;\n\tunsigned long irq_flags;\n\tunsigned int next_bit;\n\tsize_t matchlen = 0;\n\tint ret = 0;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&trie->lock, irq_flags);\n\n\t/* Walk the tree looking for an exact key/length match and keeping\n\t * track of the path we traverse.  We will need to know the node\n\t * we wish to delete, and the slot that points to the node we want\n\t * to delete.  We may also need to know the nodes parent and the\n\t * slot that contains it.\n\t */\n\ttrim = &trie->root;\n\ttrim2 = trim;\n\tparent = NULL;\n\twhile ((node = rcu_dereference_protected(\n\t\t       *trim, lockdep_is_held(&trie->lock)))) {\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen)\n\t\t\tbreak;\n\n\t\tparent = node;\n\t\ttrim2 = trim;\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\ttrim = &node->child[next_bit];\n\t}\n\n\tif (!node || node->prefixlen != key->prefixlen ||\n\t    (node->flags & LPM_TREE_NODE_FLAG_IM)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrie->n_entries--;\n\n\t/* If the node we are removing has two children, simply mark it\n\t * as intermediate and we are done.\n\t */\n\tif (rcu_access_pointer(node->child[0]) &&\n\t    rcu_access_pointer(node->child[1])) {\n\t\tnode->flags |= LPM_TREE_NODE_FLAG_IM;\n\t\tgoto out;\n\t}\n\n\t/* If the parent of the node we are about to delete is an intermediate\n\t * node, and the deleted node doesn't have any children, we can delete\n\t * the intermediate parent as well and promote its other child\n\t * up the tree.  Doing this maintains the invariant that all\n\t * intermediate nodes have exactly 2 children and that there are no\n\t * unnecessary intermediate nodes in the tree.\n\t */\n\tif (parent && (parent->flags & LPM_TREE_NODE_FLAG_IM) &&\n\t    !node->child[0] && !node->child[1]) {\n\t\tif (node == rcu_access_pointer(parent->child[0]))\n\t\t\trcu_assign_pointer(\n\t\t\t\t*trim2, rcu_access_pointer(parent->child[1]));\n\t\telse\n\t\t\trcu_assign_pointer(\n\t\t\t\t*trim2, rcu_access_pointer(parent->child[0]));\n\t\tkfree_rcu(parent, rcu);\n\t\tkfree_rcu(node, rcu);\n\t\tgoto out;\n\t}\n\n\t/* The node we are removing has either zero or one child. If there\n\t * is a child, move it into the removed node's slot then delete\n\t * the node.  Otherwise just clear the slot and delete the node.\n\t */\n\tif (node->child[0])\n\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[0]));\n\telse if (node->child[1])\n\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[1]));\n\telse\n\t\tRCU_INIT_POINTER(*trim, NULL);\n\tkfree_rcu(node, rcu);\n\nout:\n\traw_spin_unlock_irqrestore(&trie->lock, irq_flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define LPM_TREE_NODE_FLAG_IM BIT(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&trie->lock",
            "irq_flags"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "node",
            "rcu"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "*trim",
            "NULL"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*trim",
            "rcu_access_pointer(node->child[1])"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[1]"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*trim",
            "rcu_access_pointer(node->child[0])"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[0]"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "node",
            "rcu"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "parent",
            "rcu"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*trim2",
            "rcu_access_pointer(parent->child[0])"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "parent->child[0]"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*trim2",
            "rcu_access_pointer(parent->child[1])"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "parent->child[1]"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "parent->child[0]"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[1]"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[0]"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_bit",
          "args": [
            "key->data",
            "node->prefixlen"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "extract_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
          "lines": "154-157",
          "snippet": "static inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "longest_prefix_match",
          "args": [
            "trie",
            "node",
            "key"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "longest_prefix_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
          "lines": "167-188",
          "snippet": "static size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tsize_t prefixlen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < trie->data_size; i++) {\n\t\tsize_t b;\n\n\t\tb = 8 - fls(node->data[i] ^ key->data[i]);\n\t\tprefixlen += b;\n\n\t\tif (prefixlen >= node->prefixlen || prefixlen >= key->prefixlen)\n\t\t\treturn min(node->prefixlen, key->prefixlen);\n\n\t\tif (b < 8)\n\t\t\tbreak;\n\t}\n\n\treturn prefixlen;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tsize_t prefixlen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < trie->data_size; i++) {\n\t\tsize_t b;\n\n\t\tb = 8 - fls(node->data[i] ^ key->data[i]);\n\t\tprefixlen += b;\n\n\t\tif (prefixlen >= node->prefixlen || prefixlen >= key->prefixlen)\n\t\t\treturn min(node->prefixlen, key->prefixlen);\n\n\t\tif (b < 8)\n\t\t\tbreak;\n\t}\n\n\treturn prefixlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "*trim",
            "lockdep_is_held(&trie->lock)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&trie->lock"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&trie->lock",
            "irq_flags"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structlpm_trie",
            "map"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define LPM_TREE_NODE_FLAG_IM BIT(0)\n\nstatic int trie_delete_elem(struct bpf_map *map, void *_key)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct bpf_lpm_trie_key *key = _key;\n\tstruct lpm_trie_node __rcu **trim, **trim2;\n\tstruct lpm_trie_node *node, *parent;\n\tunsigned long irq_flags;\n\tunsigned int next_bit;\n\tsize_t matchlen = 0;\n\tint ret = 0;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&trie->lock, irq_flags);\n\n\t/* Walk the tree looking for an exact key/length match and keeping\n\t * track of the path we traverse.  We will need to know the node\n\t * we wish to delete, and the slot that points to the node we want\n\t * to delete.  We may also need to know the nodes parent and the\n\t * slot that contains it.\n\t */\n\ttrim = &trie->root;\n\ttrim2 = trim;\n\tparent = NULL;\n\twhile ((node = rcu_dereference_protected(\n\t\t       *trim, lockdep_is_held(&trie->lock)))) {\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen)\n\t\t\tbreak;\n\n\t\tparent = node;\n\t\ttrim2 = trim;\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\ttrim = &node->child[next_bit];\n\t}\n\n\tif (!node || node->prefixlen != key->prefixlen ||\n\t    (node->flags & LPM_TREE_NODE_FLAG_IM)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrie->n_entries--;\n\n\t/* If the node we are removing has two children, simply mark it\n\t * as intermediate and we are done.\n\t */\n\tif (rcu_access_pointer(node->child[0]) &&\n\t    rcu_access_pointer(node->child[1])) {\n\t\tnode->flags |= LPM_TREE_NODE_FLAG_IM;\n\t\tgoto out;\n\t}\n\n\t/* If the parent of the node we are about to delete is an intermediate\n\t * node, and the deleted node doesn't have any children, we can delete\n\t * the intermediate parent as well and promote its other child\n\t * up the tree.  Doing this maintains the invariant that all\n\t * intermediate nodes have exactly 2 children and that there are no\n\t * unnecessary intermediate nodes in the tree.\n\t */\n\tif (parent && (parent->flags & LPM_TREE_NODE_FLAG_IM) &&\n\t    !node->child[0] && !node->child[1]) {\n\t\tif (node == rcu_access_pointer(parent->child[0]))\n\t\t\trcu_assign_pointer(\n\t\t\t\t*trim2, rcu_access_pointer(parent->child[1]));\n\t\telse\n\t\t\trcu_assign_pointer(\n\t\t\t\t*trim2, rcu_access_pointer(parent->child[0]));\n\t\tkfree_rcu(parent, rcu);\n\t\tkfree_rcu(node, rcu);\n\t\tgoto out;\n\t}\n\n\t/* The node we are removing has either zero or one child. If there\n\t * is a child, move it into the removed node's slot then delete\n\t * the node.  Otherwise just clear the slot and delete the node.\n\t */\n\tif (node->child[0])\n\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[0]));\n\telse if (node->child[1])\n\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[1]));\n\telse\n\t\tRCU_INIT_POINTER(*trim, NULL);\n\tkfree_rcu(node, rcu);\n\nout:\n\traw_spin_unlock_irqrestore(&trie->lock, irq_flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trie_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
    "lines": "264-392",
    "snippet": "static int trie_update_elem(struct bpf_map *map,\n\t\t\t    void *_key, void *value, u64 flags)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node *node, *im_node = NULL, *new_node = NULL;\n\tstruct lpm_trie_node __rcu **slot;\n\tstruct bpf_lpm_trie_key *key = _key;\n\tunsigned long irq_flags;\n\tunsigned int next_bit;\n\tsize_t matchlen = 0;\n\tint ret = 0;\n\n\tif (unlikely(flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&trie->lock, irq_flags);\n\n\t/* Allocate and fill a new node */\n\n\tif (trie->n_entries == trie->map.max_entries) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tnew_node = lpm_trie_node_alloc(trie, value);\n\tif (!new_node) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttrie->n_entries++;\n\n\tnew_node->prefixlen = key->prefixlen;\n\tRCU_INIT_POINTER(new_node->child[0], NULL);\n\tRCU_INIT_POINTER(new_node->child[1], NULL);\n\tmemcpy(new_node->data, key->data, trie->data_size);\n\n\t/* Now find a slot to attach the new node. To do that, walk the tree\n\t * from the root and match as many bits as possible for each node until\n\t * we either find an empty slot or a slot that needs to be replaced by\n\t * an intermediate node.\n\t */\n\tslot = &trie->root;\n\n\twhile ((node = rcu_dereference_protected(*slot,\n\t\t\t\t\tlockdep_is_held(&trie->lock)))) {\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen ||\n\t\t    node->prefixlen == trie->max_prefixlen)\n\t\t\tbreak;\n\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tslot = &node->child[next_bit];\n\t}\n\n\t/* If the slot is empty (a free child pointer or an empty root),\n\t * simply assign the @new_node to that slot and be done.\n\t */\n\tif (!node) {\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tgoto out;\n\t}\n\n\t/* If the slot we picked already exists, replace it with @new_node\n\t * which already has the correct data array set.\n\t */\n\tif (node->prefixlen == matchlen) {\n\t\tnew_node->child[0] = node->child[0];\n\t\tnew_node->child[1] = node->child[1];\n\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\ttrie->n_entries--;\n\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tkfree_rcu(node, rcu);\n\n\t\tgoto out;\n\t}\n\n\t/* If the new node matches the prefix completely, it must be inserted\n\t * as an ancestor. Simply insert it between @node and *@slot.\n\t */\n\tif (matchlen == key->prefixlen) {\n\t\tnext_bit = extract_bit(node->data, matchlen);\n\t\trcu_assign_pointer(new_node->child[next_bit], node);\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tgoto out;\n\t}\n\n\tim_node = lpm_trie_node_alloc(trie, NULL);\n\tif (!im_node) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tim_node->prefixlen = matchlen;\n\tim_node->flags |= LPM_TREE_NODE_FLAG_IM;\n\tmemcpy(im_node->data, node->data, trie->data_size);\n\n\t/* Now determine which child to install in which slot */\n\tif (extract_bit(key->data, matchlen)) {\n\t\trcu_assign_pointer(im_node->child[0], node);\n\t\trcu_assign_pointer(im_node->child[1], new_node);\n\t} else {\n\t\trcu_assign_pointer(im_node->child[0], new_node);\n\t\trcu_assign_pointer(im_node->child[1], node);\n\t}\n\n\t/* Finally, assign the intermediate node to the determined spot */\n\trcu_assign_pointer(*slot, im_node);\n\nout:\n\tif (ret) {\n\t\tif (new_node)\n\t\t\ttrie->n_entries--;\n\n\t\tkfree(new_node);\n\t\tkfree(im_node);\n\t}\n\n\traw_spin_unlock_irqrestore(&trie->lock, irq_flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define LPM_TREE_NODE_FLAG_IM BIT(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&trie->lock",
            "irq_flags"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "im_node"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*slot",
            "im_node"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "im_node->child[1]",
            "node"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "im_node->child[0]",
            "new_node"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "im_node->child[1]",
            "new_node"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "im_node->child[0]",
            "node"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_bit",
          "args": [
            "key->data",
            "matchlen"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "extract_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
          "lines": "154-157",
          "snippet": "static inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "im_node->data",
            "node->data",
            "trie->data_size"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lpm_trie_node_alloc",
          "args": [
            "trie",
            "NULL"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "lpm_trie_node_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
          "lines": "240-261",
          "snippet": "static struct lpm_trie_node *lpm_trie_node_alloc(const struct lpm_trie *trie,\n\t\t\t\t\t\t const void *value)\n{\n\tstruct lpm_trie_node *node;\n\tsize_t size = sizeof(struct lpm_trie_node) + trie->data_size;\n\n\tif (value)\n\t\tsize += trie->map.value_size;\n\n\tnode = kmalloc_node(size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t    trie->map.numa_node);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->flags = 0;\n\n\tif (value)\n\t\tmemcpy(node->data + trie->data_size, value,\n\t\t       trie->map.value_size);\n\n\treturn node;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct lpm_trie_node *lpm_trie_node_alloc(const struct lpm_trie *trie,\n\t\t\t\t\t\t const void *value)\n{\n\tstruct lpm_trie_node *node;\n\tsize_t size = sizeof(struct lpm_trie_node) + trie->data_size;\n\n\tif (value)\n\t\tsize += trie->map.value_size;\n\n\tnode = kmalloc_node(size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t    trie->map.numa_node);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->flags = 0;\n\n\tif (value)\n\t\tmemcpy(node->data + trie->data_size, value,\n\t\t       trie->map.value_size);\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*slot",
            "new_node"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "new_node->child[next_bit]",
            "node"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "node",
            "rcu"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*slot",
            "new_node"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*slot",
            "new_node"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "longest_prefix_match",
          "args": [
            "trie",
            "node",
            "key"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "longest_prefix_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
          "lines": "167-188",
          "snippet": "static size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tsize_t prefixlen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < trie->data_size; i++) {\n\t\tsize_t b;\n\n\t\tb = 8 - fls(node->data[i] ^ key->data[i]);\n\t\tprefixlen += b;\n\n\t\tif (prefixlen >= node->prefixlen || prefixlen >= key->prefixlen)\n\t\t\treturn min(node->prefixlen, key->prefixlen);\n\n\t\tif (b < 8)\n\t\t\tbreak;\n\t}\n\n\treturn prefixlen;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tsize_t prefixlen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < trie->data_size; i++) {\n\t\tsize_t b;\n\n\t\tb = 8 - fls(node->data[i] ^ key->data[i]);\n\t\tprefixlen += b;\n\n\t\tif (prefixlen >= node->prefixlen || prefixlen >= key->prefixlen)\n\t\t\treturn min(node->prefixlen, key->prefixlen);\n\n\t\tif (b < 8)\n\t\t\tbreak;\n\t}\n\n\treturn prefixlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "*slot",
            "lockdep_is_held(&trie->lock)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&trie->lock"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "new_node->child[1]",
            "NULL"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "new_node->child[0]",
            "NULL"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&trie->lock",
            "irq_flags"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags > BPF_EXIST"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structlpm_trie",
            "map"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define LPM_TREE_NODE_FLAG_IM BIT(0)\n\nstatic int trie_update_elem(struct bpf_map *map,\n\t\t\t    void *_key, void *value, u64 flags)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node *node, *im_node = NULL, *new_node = NULL;\n\tstruct lpm_trie_node __rcu **slot;\n\tstruct bpf_lpm_trie_key *key = _key;\n\tunsigned long irq_flags;\n\tunsigned int next_bit;\n\tsize_t matchlen = 0;\n\tint ret = 0;\n\n\tif (unlikely(flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&trie->lock, irq_flags);\n\n\t/* Allocate and fill a new node */\n\n\tif (trie->n_entries == trie->map.max_entries) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tnew_node = lpm_trie_node_alloc(trie, value);\n\tif (!new_node) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttrie->n_entries++;\n\n\tnew_node->prefixlen = key->prefixlen;\n\tRCU_INIT_POINTER(new_node->child[0], NULL);\n\tRCU_INIT_POINTER(new_node->child[1], NULL);\n\tmemcpy(new_node->data, key->data, trie->data_size);\n\n\t/* Now find a slot to attach the new node. To do that, walk the tree\n\t * from the root and match as many bits as possible for each node until\n\t * we either find an empty slot or a slot that needs to be replaced by\n\t * an intermediate node.\n\t */\n\tslot = &trie->root;\n\n\twhile ((node = rcu_dereference_protected(*slot,\n\t\t\t\t\tlockdep_is_held(&trie->lock)))) {\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen ||\n\t\t    node->prefixlen == trie->max_prefixlen)\n\t\t\tbreak;\n\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tslot = &node->child[next_bit];\n\t}\n\n\t/* If the slot is empty (a free child pointer or an empty root),\n\t * simply assign the @new_node to that slot and be done.\n\t */\n\tif (!node) {\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tgoto out;\n\t}\n\n\t/* If the slot we picked already exists, replace it with @new_node\n\t * which already has the correct data array set.\n\t */\n\tif (node->prefixlen == matchlen) {\n\t\tnew_node->child[0] = node->child[0];\n\t\tnew_node->child[1] = node->child[1];\n\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\ttrie->n_entries--;\n\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tkfree_rcu(node, rcu);\n\n\t\tgoto out;\n\t}\n\n\t/* If the new node matches the prefix completely, it must be inserted\n\t * as an ancestor. Simply insert it between @node and *@slot.\n\t */\n\tif (matchlen == key->prefixlen) {\n\t\tnext_bit = extract_bit(node->data, matchlen);\n\t\trcu_assign_pointer(new_node->child[next_bit], node);\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tgoto out;\n\t}\n\n\tim_node = lpm_trie_node_alloc(trie, NULL);\n\tif (!im_node) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tim_node->prefixlen = matchlen;\n\tim_node->flags |= LPM_TREE_NODE_FLAG_IM;\n\tmemcpy(im_node->data, node->data, trie->data_size);\n\n\t/* Now determine which child to install in which slot */\n\tif (extract_bit(key->data, matchlen)) {\n\t\trcu_assign_pointer(im_node->child[0], node);\n\t\trcu_assign_pointer(im_node->child[1], new_node);\n\t} else {\n\t\trcu_assign_pointer(im_node->child[0], new_node);\n\t\trcu_assign_pointer(im_node->child[1], node);\n\t}\n\n\t/* Finally, assign the intermediate node to the determined spot */\n\trcu_assign_pointer(*slot, im_node);\n\nout:\n\tif (ret) {\n\t\tif (new_node)\n\t\t\ttrie->n_entries--;\n\n\t\tkfree(new_node);\n\t\tkfree(im_node);\n\t}\n\n\traw_spin_unlock_irqrestore(&trie->lock, irq_flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lpm_trie_node_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
    "lines": "240-261",
    "snippet": "static struct lpm_trie_node *lpm_trie_node_alloc(const struct lpm_trie *trie,\n\t\t\t\t\t\t const void *value)\n{\n\tstruct lpm_trie_node *node;\n\tsize_t size = sizeof(struct lpm_trie_node) + trie->data_size;\n\n\tif (value)\n\t\tsize += trie->map.value_size;\n\n\tnode = kmalloc_node(size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t    trie->map.numa_node);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->flags = 0;\n\n\tif (value)\n\t\tmemcpy(node->data + trie->data_size, value,\n\t\t       trie->map.value_size);\n\n\treturn node;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "node->data + trie->data_size",
            "value",
            "trie->map.value_size"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "size",
            "GFP_ATOMIC | __GFP_NOWARN",
            "trie->map.numa_node"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct lpm_trie_node *lpm_trie_node_alloc(const struct lpm_trie *trie,\n\t\t\t\t\t\t const void *value)\n{\n\tstruct lpm_trie_node *node;\n\tsize_t size = sizeof(struct lpm_trie_node) + trie->data_size;\n\n\tif (value)\n\t\tsize += trie->map.value_size;\n\n\tnode = kmalloc_node(size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t    trie->map.numa_node);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->flags = 0;\n\n\tif (value)\n\t\tmemcpy(node->data + trie->data_size, value,\n\t\t       trie->map.value_size);\n\n\treturn node;\n}"
  },
  {
    "function_name": "trie_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
    "lines": "191-238",
    "snippet": "static void *trie_lookup_elem(struct bpf_map *map, void *_key)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node *node, *found = NULL;\n\tstruct bpf_lpm_trie_key *key = _key;\n\n\t/* Start walking the trie from the root node ... */\n\n\tfor (node = rcu_dereference(trie->root); node;) {\n\t\tunsigned int next_bit;\n\t\tsize_t matchlen;\n\n\t\t/* Determine the longest prefix of @node that matches @key.\n\t\t * If it's the maximum possible prefix for this trie, we have\n\t\t * an exact match and can return it directly.\n\t\t */\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\t\tif (matchlen == trie->max_prefixlen) {\n\t\t\tfound = node;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If the number of bits that match is smaller than the prefix\n\t\t * length of @node, bail out and return the node we have seen\n\t\t * last in the traversal (ie, the parent).\n\t\t */\n\t\tif (matchlen < node->prefixlen)\n\t\t\tbreak;\n\n\t\t/* Consider this node as return candidate unless it is an\n\t\t * artificially added intermediate one.\n\t\t */\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\tfound = node;\n\n\t\t/* If the node match is fully satisfied, let's see if we can\n\t\t * become more specific. Determine the next bit in the key and\n\t\t * traverse down.\n\t\t */\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tnode = rcu_dereference(node->child[next_bit]);\n\t}\n\n\tif (!found)\n\t\treturn NULL;\n\n\treturn found->data + trie->data_size;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define LPM_TREE_NODE_FLAG_IM BIT(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "node->child[next_bit]"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_bit",
          "args": [
            "key->data",
            "node->prefixlen"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "extract_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
          "lines": "154-157",
          "snippet": "static inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "longest_prefix_match",
          "args": [
            "trie",
            "node",
            "key"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "longest_prefix_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
          "lines": "167-188",
          "snippet": "static size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tsize_t prefixlen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < trie->data_size; i++) {\n\t\tsize_t b;\n\n\t\tb = 8 - fls(node->data[i] ^ key->data[i]);\n\t\tprefixlen += b;\n\n\t\tif (prefixlen >= node->prefixlen || prefixlen >= key->prefixlen)\n\t\t\treturn min(node->prefixlen, key->prefixlen);\n\n\t\tif (b < 8)\n\t\t\tbreak;\n\t}\n\n\treturn prefixlen;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tsize_t prefixlen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < trie->data_size; i++) {\n\t\tsize_t b;\n\n\t\tb = 8 - fls(node->data[i] ^ key->data[i]);\n\t\tprefixlen += b;\n\n\t\tif (prefixlen >= node->prefixlen || prefixlen >= key->prefixlen)\n\t\t\treturn min(node->prefixlen, key->prefixlen);\n\n\t\tif (b < 8)\n\t\t\tbreak;\n\t}\n\n\treturn prefixlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structlpm_trie",
            "map"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define LPM_TREE_NODE_FLAG_IM BIT(0)\n\nstatic void *trie_lookup_elem(struct bpf_map *map, void *_key)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node *node, *found = NULL;\n\tstruct bpf_lpm_trie_key *key = _key;\n\n\t/* Start walking the trie from the root node ... */\n\n\tfor (node = rcu_dereference(trie->root); node;) {\n\t\tunsigned int next_bit;\n\t\tsize_t matchlen;\n\n\t\t/* Determine the longest prefix of @node that matches @key.\n\t\t * If it's the maximum possible prefix for this trie, we have\n\t\t * an exact match and can return it directly.\n\t\t */\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\t\tif (matchlen == trie->max_prefixlen) {\n\t\t\tfound = node;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If the number of bits that match is smaller than the prefix\n\t\t * length of @node, bail out and return the node we have seen\n\t\t * last in the traversal (ie, the parent).\n\t\t */\n\t\tif (matchlen < node->prefixlen)\n\t\t\tbreak;\n\n\t\t/* Consider this node as return candidate unless it is an\n\t\t * artificially added intermediate one.\n\t\t */\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\tfound = node;\n\n\t\t/* If the node match is fully satisfied, let's see if we can\n\t\t * become more specific. Determine the next bit in the key and\n\t\t * traverse down.\n\t\t */\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tnode = rcu_dereference(node->child[next_bit]);\n\t}\n\n\tif (!found)\n\t\treturn NULL;\n\n\treturn found->data + trie->data_size;\n}"
  },
  {
    "function_name": "longest_prefix_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
    "lines": "167-188",
    "snippet": "static size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tsize_t prefixlen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < trie->data_size; i++) {\n\t\tsize_t b;\n\n\t\tb = 8 - fls(node->data[i] ^ key->data[i]);\n\t\tprefixlen += b;\n\n\t\tif (prefixlen >= node->prefixlen || prefixlen >= key->prefixlen)\n\t\t\treturn min(node->prefixlen, key->prefixlen);\n\n\t\tif (b < 8)\n\t\t\tbreak;\n\t}\n\n\treturn prefixlen;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "node->prefixlen",
            "key->prefixlen"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__reg_combine_min_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/verifier.c",
          "lines": "3907-3935",
          "snippet": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "node->data[i] ^ key->data[i]"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tsize_t prefixlen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < trie->data_size; i++) {\n\t\tsize_t b;\n\n\t\tb = 8 - fls(node->data[i] ^ key->data[i]);\n\t\tprefixlen += b;\n\n\t\tif (prefixlen >= node->prefixlen || prefixlen >= key->prefixlen)\n\t\t\treturn min(node->prefixlen, key->prefixlen);\n\n\t\tif (b < 8)\n\t\t\tbreak;\n\t}\n\n\treturn prefixlen;\n}"
  },
  {
    "function_name": "extract_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/lpm_trie.c",
    "lines": "154-157",
    "snippet": "static inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}"
  }
]