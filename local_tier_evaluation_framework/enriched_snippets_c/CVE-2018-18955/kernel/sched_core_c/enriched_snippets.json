[
  {
    "function_name": "dump_cpu_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "7007-7011",
    "snippet": "void dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "cpu_curr(cpu)"
          ],
          "line": 7010
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5268-5295",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_curr",
          "args": [
            "cpu"
          ],
          "line": 7010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Task dump for CPU %d:\\n\"",
            "cpu"
          ],
          "line": 7009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}"
  },
  {
    "function_name": "cpu_max_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6949-6961",
    "snippet": "static ssize_t cpu_max_write(struct kernfs_open_file *of,\n\t\t\t     char *buf, size_t nbytes, loff_t off)\n{\n\tstruct task_group *tg = css_tg(of_css(of));\n\tu64 period = tg_get_cfs_period(tg);\n\tu64 quota;\n\tint ret;\n\n\tret = cpu_period_quota_parse(buf, &period, &quota);\n\tif (!ret)\n\t\tret = tg_set_cfs_bandwidth(tg, period, quota);\n\treturn ret ?: nbytes;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tg_set_cfs_bandwidth",
          "args": [
            "tg",
            "period",
            "quota"
          ],
          "line": 6959
        },
        "resolved": true,
        "details": {
          "function_name": "tg_set_cfs_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6505-6579",
          "snippet": "static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)\n{\n\tint i, ret = 0, runtime_enabled, runtime_was_enabled;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tif (tg == &root_task_group)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ensure we have at some amount of bandwidth every period.  This is\n\t * to prevent reaching a state of large arrears when throttled via\n\t * entity_tick() resulting in prolonged exit starvation.\n\t */\n\tif (quota < min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Likewise, bound things on the otherside by preventing insane quota\n\t * periods.  This also allows us to normalize in computing quota\n\t * feasibility.\n\t */\n\tif (period > max_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Prevent race between setting of cfs_rq->runtime_enabled and\n\t * unthrottle_offline_cfs_rqs().\n\t */\n\tget_online_cpus();\n\tmutex_lock(&cfs_constraints_mutex);\n\tret = __cfs_schedulable(tg, period, quota);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\truntime_enabled = quota != RUNTIME_INF;\n\truntime_was_enabled = cfs_b->quota != RUNTIME_INF;\n\t/*\n\t * If we need to toggle cfs_bandwidth_used, off->on must occur\n\t * before making related changes, and on->off must occur afterwards\n\t */\n\tif (runtime_enabled && !runtime_was_enabled)\n\t\tcfs_bandwidth_usage_inc();\n\traw_spin_lock_irq(&cfs_b->lock);\n\tcfs_b->period = ns_to_ktime(period);\n\tcfs_b->quota = quota;\n\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\n\t/* Restart the period timer (if active) to handle new period expiry: */\n\tif (runtime_enabled)\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\traw_spin_unlock_irq(&cfs_b->lock);\n\n\tfor_each_online_cpu(i) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[i];\n\t\tstruct rq *rq = cfs_rq->rq;\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irq(rq, &rf);\n\t\tcfs_rq->runtime_enabled = runtime_enabled;\n\t\tcfs_rq->runtime_remaining = 0;\n\n\t\tif (cfs_rq->throttled)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\tif (runtime_was_enabled && !runtime_enabled)\n\t\tcfs_bandwidth_usage_dec();\nout_unlock:\n\tmutex_unlock(&cfs_constraints_mutex);\n\tput_online_cpus();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)\n{\n\tint i, ret = 0, runtime_enabled, runtime_was_enabled;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tif (tg == &root_task_group)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ensure we have at some amount of bandwidth every period.  This is\n\t * to prevent reaching a state of large arrears when throttled via\n\t * entity_tick() resulting in prolonged exit starvation.\n\t */\n\tif (quota < min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Likewise, bound things on the otherside by preventing insane quota\n\t * periods.  This also allows us to normalize in computing quota\n\t * feasibility.\n\t */\n\tif (period > max_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Prevent race between setting of cfs_rq->runtime_enabled and\n\t * unthrottle_offline_cfs_rqs().\n\t */\n\tget_online_cpus();\n\tmutex_lock(&cfs_constraints_mutex);\n\tret = __cfs_schedulable(tg, period, quota);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\truntime_enabled = quota != RUNTIME_INF;\n\truntime_was_enabled = cfs_b->quota != RUNTIME_INF;\n\t/*\n\t * If we need to toggle cfs_bandwidth_used, off->on must occur\n\t * before making related changes, and on->off must occur afterwards\n\t */\n\tif (runtime_enabled && !runtime_was_enabled)\n\t\tcfs_bandwidth_usage_inc();\n\traw_spin_lock_irq(&cfs_b->lock);\n\tcfs_b->period = ns_to_ktime(period);\n\tcfs_b->quota = quota;\n\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\n\t/* Restart the period timer (if active) to handle new period expiry: */\n\tif (runtime_enabled)\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\traw_spin_unlock_irq(&cfs_b->lock);\n\n\tfor_each_online_cpu(i) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[i];\n\t\tstruct rq *rq = cfs_rq->rq;\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irq(rq, &rf);\n\t\tcfs_rq->runtime_enabled = runtime_enabled;\n\t\tcfs_rq->runtime_remaining = 0;\n\n\t\tif (cfs_rq->throttled)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\tif (runtime_was_enabled && !runtime_enabled)\n\t\tcfs_bandwidth_usage_dec();\nout_unlock:\n\tmutex_unlock(&cfs_constraints_mutex);\n\tput_online_cpus();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_period_quota_parse",
          "args": [
            "buf",
            "&period",
            "&quota"
          ],
          "line": 6957
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_period_quota_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6920-6938",
          "snippet": "static int __maybe_unused cpu_period_quota_parse(char *buf,\n\t\t\t\t\t\t u64 *periodp, u64 *quotap)\n{\n\tchar tok[21];\t/* U64_MAX */\n\n\tif (!sscanf(buf, \"%s %llu\", tok, periodp))\n\t\treturn -EINVAL;\n\n\t*periodp *= NSEC_PER_USEC;\n\n\tif (sscanf(tok, \"%llu\", quotap))\n\t\t*quotap *= NSEC_PER_USEC;\n\telse if (!strcmp(tok, \"max\"))\n\t\t*quotap = RUNTIME_INF;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic int __maybe_unused cpu_period_quota_parse(char *buf,\n\t\t\t\t\t\t u64 *periodp, u64 *quotap)\n{\n\tchar tok[21];\t/* U64_MAX */\n\n\tif (!sscanf(buf, \"%s %llu\", tok, periodp))\n\t\treturn -EINVAL;\n\n\t*periodp *= NSEC_PER_USEC;\n\n\tif (sscanf(tok, \"%llu\", quotap))\n\t\t*quotap *= NSEC_PER_USEC;\n\telse if (!strcmp(tok, \"max\"))\n\t\t*quotap = RUNTIME_INF;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tg_get_cfs_period",
          "args": [
            "tg"
          ],
          "line": 6953
        },
        "resolved": true,
        "details": {
          "function_name": "tg_get_cfs_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6617-6625",
          "snippet": "long tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "of_css(of)"
          ],
          "line": 6952
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 6952
        },
        "resolved": true,
        "details": {
          "function_name": "of_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "565-582",
          "snippet": "struct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic ssize_t cpu_max_write(struct kernfs_open_file *of,\n\t\t\t     char *buf, size_t nbytes, loff_t off)\n{\n\tstruct task_group *tg = css_tg(of_css(of));\n\tu64 period = tg_get_cfs_period(tg);\n\tu64 quota;\n\tint ret;\n\n\tret = cpu_period_quota_parse(buf, &period, &quota);\n\tif (!ret)\n\t\tret = tg_set_cfs_bandwidth(tg, period, quota);\n\treturn ret ?: nbytes;\n}"
  },
  {
    "function_name": "cpu_max_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6941-6947",
    "snippet": "static int cpu_max_show(struct seq_file *sf, void *v)\n{\n\tstruct task_group *tg = css_tg(seq_css(sf));\n\n\tcpu_period_quota_print(sf, tg_get_cfs_period(tg), tg_get_cfs_quota(tg));\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_period_quota_print",
          "args": [
            "sf",
            "tg_get_cfs_period(tg)",
            "tg_get_cfs_quota(tg)"
          ],
          "line": 6945
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_period_quota_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6908-6917",
          "snippet": "static void __maybe_unused cpu_period_quota_print(struct seq_file *sf,\n\t\t\t\t\t\t  long period, long quota)\n{\n\tif (quota < 0)\n\t\tseq_puts(sf, \"max\");\n\telse\n\t\tseq_printf(sf, \"%ld\", quota);\n\n\tseq_printf(sf, \" %ld\\n\", period);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __maybe_unused cpu_period_quota_print(struct seq_file *sf,\n\t\t\t\t\t\t  long period, long quota)\n{\n\tif (quota < 0)\n\t\tseq_puts(sf, \"max\");\n\telse\n\t\tseq_printf(sf, \"%ld\", quota);\n\n\tseq_printf(sf, \" %ld\\n\", period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tg_get_cfs_quota",
          "args": [
            "tg"
          ],
          "line": 6945
        },
        "resolved": true,
        "details": {
          "function_name": "tg_get_cfs_quota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6594-6605",
          "snippet": "long tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->cfs_bandwidth.quota == RUNTIME_INF)\n\t\treturn -1;\n\n\tquota_us = tg->cfs_bandwidth.quota;\n\tdo_div(quota_us, NSEC_PER_USEC);\n\n\treturn quota_us;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->cfs_bandwidth.quota == RUNTIME_INF)\n\t\treturn -1;\n\n\tquota_us = tg->cfs_bandwidth.quota;\n\tdo_div(quota_us, NSEC_PER_USEC);\n\n\treturn quota_us;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tg_get_cfs_period",
          "args": [
            "tg"
          ],
          "line": 6945
        },
        "resolved": true,
        "details": {
          "function_name": "tg_get_cfs_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6617-6625",
          "snippet": "long tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "seq_css(sf)"
          ],
          "line": 6943
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 6943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_max_show(struct seq_file *sf, void *v)\n{\n\tstruct task_group *tg = css_tg(seq_css(sf));\n\n\tcpu_period_quota_print(sf, tg_get_cfs_period(tg), tg_get_cfs_quota(tg));\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_period_quota_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6920-6938",
    "snippet": "static int __maybe_unused cpu_period_quota_parse(char *buf,\n\t\t\t\t\t\t u64 *periodp, u64 *quotap)\n{\n\tchar tok[21];\t/* U64_MAX */\n\n\tif (!sscanf(buf, \"%s %llu\", tok, periodp))\n\t\treturn -EINVAL;\n\n\t*periodp *= NSEC_PER_USEC;\n\n\tif (sscanf(tok, \"%llu\", quotap))\n\t\t*quotap *= NSEC_PER_USEC;\n\telse if (!strcmp(tok, \"max\"))\n\t\t*quotap = RUNTIME_INF;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tok",
            "\"max\""
          ],
          "line": 6932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tok",
            "\"%llu\"",
            "quotap"
          ],
          "line": 6930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%s %llu\"",
            "tok",
            "periodp"
          ],
          "line": 6925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic int __maybe_unused cpu_period_quota_parse(char *buf,\n\t\t\t\t\t\t u64 *periodp, u64 *quotap)\n{\n\tchar tok[21];\t/* U64_MAX */\n\n\tif (!sscanf(buf, \"%s %llu\", tok, periodp))\n\t\treturn -EINVAL;\n\n\t*periodp *= NSEC_PER_USEC;\n\n\tif (sscanf(tok, \"%llu\", quotap))\n\t\t*quotap *= NSEC_PER_USEC;\n\telse if (!strcmp(tok, \"max\"))\n\t\t*quotap = RUNTIME_INF;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_period_quota_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6908-6917",
    "snippet": "static void __maybe_unused cpu_period_quota_print(struct seq_file *sf,\n\t\t\t\t\t\t  long period, long quota)\n{\n\tif (quota < 0)\n\t\tseq_puts(sf, \"max\");\n\telse\n\t\tseq_printf(sf, \"%ld\", quota);\n\n\tseq_printf(sf, \" %ld\\n\", period);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\" %ld\\n\"",
            "period"
          ],
          "line": 6916
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "sf",
            "\"max\""
          ],
          "line": 6912
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __maybe_unused cpu_period_quota_print(struct seq_file *sf,\n\t\t\t\t\t\t  long period, long quota)\n{\n\tif (quota < 0)\n\t\tseq_puts(sf, \"max\");\n\telse\n\t\tseq_printf(sf, \"%ld\", quota);\n\n\tseq_printf(sf, \" %ld\\n\", period);\n}"
  },
  {
    "function_name": "cpu_weight_nice_write_s64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6891-6905",
    "snippet": "static int cpu_weight_nice_write_s64(struct cgroup_subsys_state *css,\n\t\t\t\t     struct cftype *cft, s64 nice)\n{\n\tunsigned long weight;\n\tint idx;\n\n\tif (nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn -ERANGE;\n\n\tidx = NICE_TO_PRIO(nice) - MAX_RT_PRIO;\n\tidx = array_index_nospec(idx, 40);\n\tweight = sched_prio_to_weight[idx];\n\n\treturn sched_group_set_shares(css_tg(css), scale_load(weight));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "const int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_group_set_shares",
          "args": [
            "css_tg(css)",
            "scale_load(weight)"
          ],
          "line": 6904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_load",
          "args": [
            "weight"
          ],
          "line": 6904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6904
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "idx",
            "40"
          ],
          "line": 6901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NICE_TO_PRIO",
          "args": [
            "nice"
          ],
          "line": 6900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nconst int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};\n\nstatic int cpu_weight_nice_write_s64(struct cgroup_subsys_state *css,\n\t\t\t\t     struct cftype *cft, s64 nice)\n{\n\tunsigned long weight;\n\tint idx;\n\n\tif (nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn -ERANGE;\n\n\tidx = NICE_TO_PRIO(nice) - MAX_RT_PRIO;\n\tidx = array_index_nospec(idx, 40);\n\tweight = sched_prio_to_weight[idx];\n\n\treturn sched_group_set_shares(css_tg(css), scale_load(weight));\n}"
  },
  {
    "function_name": "cpu_weight_nice_read_s64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6873-6889",
    "snippet": "static s64 cpu_weight_nice_read_s64(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cft)\n{\n\tunsigned long weight = scale_load_down(css_tg(css)->shares);\n\tint last_delta = INT_MAX;\n\tint prio, delta;\n\n\t/* find the closest nice value to the current weight */\n\tfor (prio = 0; prio < ARRAY_SIZE(sched_prio_to_weight); prio++) {\n\t\tdelta = abs(sched_prio_to_weight[prio] - weight);\n\t\tif (delta >= last_delta)\n\t\t\tbreak;\n\t\tlast_delta = delta;\n\t}\n\n\treturn PRIO_TO_NICE(prio - 1 + MAX_RT_PRIO);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "const int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRIO_TO_NICE",
          "args": [
            "prio - 1 + MAX_RT_PRIO"
          ],
          "line": 6888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "sched_prio_to_weight[prio] - weight"
          ],
          "line": 6882
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "462-469",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sched_prio_to_weight"
          ],
          "line": 6881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_load_down",
          "args": [
            "css_tg(css)->shares"
          ],
          "line": 6876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6876
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nconst int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};\n\nstatic s64 cpu_weight_nice_read_s64(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cft)\n{\n\tunsigned long weight = scale_load_down(css_tg(css)->shares);\n\tint last_delta = INT_MAX;\n\tint prio, delta;\n\n\t/* find the closest nice value to the current weight */\n\tfor (prio = 0; prio < ARRAY_SIZE(sched_prio_to_weight); prio++) {\n\t\tdelta = abs(sched_prio_to_weight[prio] - weight);\n\t\tif (delta >= last_delta)\n\t\t\tbreak;\n\t\tlast_delta = delta;\n\t}\n\n\treturn PRIO_TO_NICE(prio - 1 + MAX_RT_PRIO);\n}"
  },
  {
    "function_name": "cpu_weight_write_u64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6855-6871",
    "snippet": "static int cpu_weight_write_u64(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cft, u64 weight)\n{\n\t/*\n\t * cgroup weight knobs should use the common MIN, DFL and MAX\n\t * values which are 1, 100 and 10000 respectively.  While it loses\n\t * a bit of range on both ends, it maps pretty well onto the shares\n\t * value used by scheduler and the round-trip conversions preserve\n\t * the original value over the entire range.\n\t */\n\tif (weight < CGROUP_WEIGHT_MIN || weight > CGROUP_WEIGHT_MAX)\n\t\treturn -ERANGE;\n\n\tweight = DIV_ROUND_CLOSEST_ULL(weight * 1024, CGROUP_WEIGHT_DFL);\n\n\treturn sched_group_set_shares(css_tg(css), scale_load(weight));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_group_set_shares",
          "args": [
            "css_tg(css)",
            "scale_load(weight)"
          ],
          "line": 6870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_load",
          "args": [
            "weight"
          ],
          "line": 6870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6870
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_CLOSEST_ULL",
          "args": [
            "weight * 1024",
            "CGROUP_WEIGHT_DFL"
          ],
          "line": 6868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_weight_write_u64(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cft, u64 weight)\n{\n\t/*\n\t * cgroup weight knobs should use the common MIN, DFL and MAX\n\t * values which are 1, 100 and 10000 respectively.  While it loses\n\t * a bit of range on both ends, it maps pretty well onto the shares\n\t * value used by scheduler and the round-trip conversions preserve\n\t * the original value over the entire range.\n\t */\n\tif (weight < CGROUP_WEIGHT_MIN || weight > CGROUP_WEIGHT_MAX)\n\t\treturn -ERANGE;\n\n\tweight = DIV_ROUND_CLOSEST_ULL(weight * 1024, CGROUP_WEIGHT_DFL);\n\n\treturn sched_group_set_shares(css_tg(css), scale_load(weight));\n}"
  },
  {
    "function_name": "cpu_weight_read_u64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6846-6853",
    "snippet": "static u64 cpu_weight_read_u64(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\tstruct task_group *tg = css_tg(css);\n\tu64 weight = scale_load_down(tg->shares);\n\n\treturn DIV_ROUND_CLOSEST_ULL(weight * CGROUP_WEIGHT_DFL, 1024);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_CLOSEST_ULL",
          "args": [
            "weight * CGROUP_WEIGHT_DFL",
            "1024"
          ],
          "line": 6852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_load_down",
          "args": [
            "tg->shares"
          ],
          "line": 6850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6849
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic u64 cpu_weight_read_u64(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\tstruct task_group *tg = css_tg(css);\n\tu64 weight = scale_load_down(tg->shares);\n\n\treturn DIV_ROUND_CLOSEST_ULL(weight * CGROUP_WEIGHT_DFL, 1024);\n}"
  },
  {
    "function_name": "cpu_extra_stat_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6823-6843",
    "snippet": "static int cpu_extra_stat_show(struct seq_file *sf,\n\t\t\t       struct cgroup_subsys_state *css)\n{\n#ifdef CONFIG_CFS_BANDWIDTH\n\t{\n\t\tstruct task_group *tg = css_tg(css);\n\t\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\t\tu64 throttled_usec;\n\n\t\tthrottled_usec = cfs_b->throttled_time;\n\t\tdo_div(throttled_usec, NSEC_PER_USEC);\n\n\t\tseq_printf(sf, \"nr_periods %d\\n\"\n\t\t\t   \"nr_throttled %d\\n\"\n\t\t\t   \"throttled_usec %llu\\n\",\n\t\t\t   cfs_b->nr_periods, cfs_b->nr_throttled,\n\t\t\t   throttled_usec);\n\t}\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"nr_periods %d\\n\"\n\t\t\t   \"nr_throttled %d\\n\"\n\t\t\t   \"throttled_usec %llu\\n\"",
            "cfs_b->nr_periods",
            "cfs_b->nr_throttled",
            "throttled_usec"
          ],
          "line": 6835
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "throttled_usec",
            "NSEC_PER_USEC"
          ],
          "line": 6833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6828
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_extra_stat_show(struct seq_file *sf,\n\t\t\t       struct cgroup_subsys_state *css)\n{\n#ifdef CONFIG_CFS_BANDWIDTH\n\t{\n\t\tstruct task_group *tg = css_tg(css);\n\t\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\t\tu64 throttled_usec;\n\n\t\tthrottled_usec = cfs_b->throttled_time;\n\t\tdo_div(throttled_usec, NSEC_PER_USEC);\n\n\t\tseq_printf(sf, \"nr_periods %d\\n\"\n\t\t\t   \"nr_throttled %d\\n\"\n\t\t\t   \"throttled_usec %llu\\n\",\n\t\t\t   cfs_b->nr_periods, cfs_b->nr_throttled,\n\t\t\t   throttled_usec);\n\t}\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_rt_period_read_uint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6777-6781",
    "snippet": "static u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cft)\n{\n\treturn sched_group_rt_period(css_tg(css));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_group_rt_period",
          "args": [
            "css_tg(css)"
          ],
          "line": 6780
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_rt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2588-2595",
          "snippet": "long sched_group_rt_period(struct task_group *tg)\n{\n\tu64 rt_period_us;\n\n\trt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period);\n\tdo_div(rt_period_us, NSEC_PER_USEC);\n\treturn rt_period_us;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nlong sched_group_rt_period(struct task_group *tg)\n{\n\tu64 rt_period_us;\n\n\trt_period_us = ktime_to_ns(tg->rt_bandwidth.rt_period);\n\tdo_div(rt_period_us, NSEC_PER_USEC);\n\treturn rt_period_us;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6780
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cft)\n{\n\treturn sched_group_rt_period(css_tg(css));\n}"
  },
  {
    "function_name": "cpu_rt_period_write_uint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6771-6775",
    "snippet": "static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cftype, u64 rt_period_us)\n{\n\treturn sched_group_set_rt_period(css_tg(css), rt_period_us);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_group_set_rt_period",
          "args": [
            "css_tg(css)",
            "rt_period_us"
          ],
          "line": 6774
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_set_rt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2578-2586",
          "snippet": "int sched_group_set_rt_period(struct task_group *tg, u64 rt_period_us)\n{\n\tu64 rt_runtime, rt_period;\n\n\trt_period = rt_period_us * NSEC_PER_USEC;\n\trt_runtime = tg->rt_bandwidth.rt_runtime;\n\n\treturn tg_set_rt_bandwidth(tg, rt_period, rt_runtime);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nint sched_group_set_rt_period(struct task_group *tg, u64 rt_period_us)\n{\n\tu64 rt_runtime, rt_period;\n\n\trt_period = rt_period_us * NSEC_PER_USEC;\n\trt_runtime = tg->rt_bandwidth.rt_runtime;\n\n\treturn tg_set_rt_bandwidth(tg, rt_period, rt_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6774
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_rt_period_write_uint(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cftype, u64 rt_period_us)\n{\n\treturn sched_group_set_rt_period(css_tg(css), rt_period_us);\n}"
  },
  {
    "function_name": "cpu_rt_runtime_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6765-6769",
    "snippet": "static s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\treturn sched_group_rt_runtime(css_tg(css));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_group_rt_runtime",
          "args": [
            "css_tg(css)"
          ],
          "line": 6768
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_rt_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2566-2576",
          "snippet": "long sched_group_rt_runtime(struct task_group *tg)\n{\n\tu64 rt_runtime_us;\n\n\tif (tg->rt_bandwidth.rt_runtime == RUNTIME_INF)\n\t\treturn -1;\n\n\trt_runtime_us = tg->rt_bandwidth.rt_runtime;\n\tdo_div(rt_runtime_us, NSEC_PER_USEC);\n\treturn rt_runtime_us;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nlong sched_group_rt_runtime(struct task_group *tg)\n{\n\tu64 rt_runtime_us;\n\n\tif (tg->rt_bandwidth.rt_runtime == RUNTIME_INF)\n\t\treturn -1;\n\n\trt_runtime_us = tg->rt_bandwidth.rt_runtime;\n\tdo_div(rt_runtime_us, NSEC_PER_USEC);\n\treturn rt_runtime_us;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6768
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\treturn sched_group_rt_runtime(css_tg(css));\n}"
  },
  {
    "function_name": "cpu_rt_runtime_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6759-6763",
    "snippet": "static int cpu_rt_runtime_write(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cft, s64 val)\n{\n\treturn sched_group_set_rt_runtime(css_tg(css), val);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_group_set_rt_runtime",
          "args": [
            "css_tg(css)",
            "val"
          ],
          "line": 6762
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_set_rt_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2554-2564",
          "snippet": "int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us)\n{\n\tu64 rt_runtime, rt_period;\n\n\trt_period = ktime_to_ns(tg->rt_bandwidth.rt_period);\n\trt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC;\n\tif (rt_runtime_us < 0)\n\t\trt_runtime = RUNTIME_INF;\n\n\treturn tg_set_rt_bandwidth(tg, rt_period, rt_runtime);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nint sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us)\n{\n\tu64 rt_runtime, rt_period;\n\n\trt_period = ktime_to_ns(tg->rt_bandwidth.rt_period);\n\trt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC;\n\tif (rt_runtime_us < 0)\n\t\trt_runtime = RUNTIME_INF;\n\n\treturn tg_set_rt_bandwidth(tg, rt_period, rt_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6762
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_rt_runtime_write(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cft, s64 val)\n{\n\treturn sched_group_set_rt_runtime(css_tg(css), val);\n}"
  },
  {
    "function_name": "cpu_cfs_stat_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6734-6754",
    "snippet": "static int cpu_cfs_stat_show(struct seq_file *sf, void *v)\n{\n\tstruct task_group *tg = css_tg(seq_css(sf));\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tseq_printf(sf, \"nr_periods %d\\n\", cfs_b->nr_periods);\n\tseq_printf(sf, \"nr_throttled %d\\n\", cfs_b->nr_throttled);\n\tseq_printf(sf, \"throttled_time %llu\\n\", cfs_b->throttled_time);\n\n\tif (schedstat_enabled() && tg != &root_task_group) {\n\t\tu64 ws = 0;\n\t\tint i;\n\n\t\tfor_each_possible_cpu(i)\n\t\t\tws += schedstat_val(tg->se[i]->statistics.wait_sum);\n\n\t\tseq_printf(sf, \"wait_sum %llu\\n\", ws);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"wait_sum %llu\\n\"",
            "ws"
          ],
          "line": 6750
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 6743
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2231-2237",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "seq_css(sf)"
          ],
          "line": 6736
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 6736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_cfs_stat_show(struct seq_file *sf, void *v)\n{\n\tstruct task_group *tg = css_tg(seq_css(sf));\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tseq_printf(sf, \"nr_periods %d\\n\", cfs_b->nr_periods);\n\tseq_printf(sf, \"nr_throttled %d\\n\", cfs_b->nr_throttled);\n\tseq_printf(sf, \"throttled_time %llu\\n\", cfs_b->throttled_time);\n\n\tif (schedstat_enabled() && tg != &root_task_group) {\n\t\tu64 ws = 0;\n\t\tint i;\n\n\t\tfor_each_possible_cpu(i)\n\t\t\tws += schedstat_val(tg->se[i]->statistics.wait_sum);\n\n\t\tseq_printf(sf, \"wait_sum %llu\\n\", ws);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__cfs_schedulable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6713-6732",
    "snippet": "static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)\n{\n\tint ret;\n\tstruct cfs_schedulable_data data = {\n\t\t.tg = tg,\n\t\t.period = period,\n\t\t.quota = quota,\n\t};\n\n\tif (quota != RUNTIME_INF) {\n\t\tdo_div(data.period, NSEC_PER_USEC);\n\t\tdo_div(data.quota, NSEC_PER_USEC);\n\t}\n\n\trcu_read_lock();\n\tret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 6729
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_tg_tree",
          "args": [
            "tg_cfs_schedulable_down",
            "tg_nop",
            "&data"
          ],
          "line": 6728
        },
        "resolved": true,
        "details": {
          "function_name": "walk_tg_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "423-426",
          "snippet": "static inline int walk_tg_tree(tg_visitor down, tg_visitor up, void *data)\n{\n\treturn walk_tg_tree_from(&root_task_group, down, up, data);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int walk_tg_tree(tg_visitor down, tg_visitor up, void *data)\n{\n\treturn walk_tg_tree_from(&root_task_group, down, up, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 6727
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "data.quota",
            "NSEC_PER_USEC"
          ],
          "line": 6724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "data.period",
            "NSEC_PER_USEC"
          ],
          "line": 6723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)\n{\n\tint ret;\n\tstruct cfs_schedulable_data data = {\n\t\t.tg = tg,\n\t\t.period = period,\n\t\t.quota = quota,\n\t};\n\n\tif (quota != RUNTIME_INF) {\n\t\tdo_div(data.period, NSEC_PER_USEC);\n\t\tdo_div(data.quota, NSEC_PER_USEC);\n\t}\n\n\trcu_read_lock();\n\tret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tg_cfs_schedulable_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6680-6711",
    "snippet": "static int tg_cfs_schedulable_down(struct task_group *tg, void *data)\n{\n\tstruct cfs_schedulable_data *d = data;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\ts64 quota = 0, parent_quota = -1;\n\n\tif (!tg->parent) {\n\t\tquota = RUNTIME_INF;\n\t} else {\n\t\tstruct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth;\n\n\t\tquota = normalize_cfs_quota(tg, d);\n\t\tparent_quota = parent_b->hierarchical_quota;\n\n\t\t/*\n\t\t * Ensure max(child_quota) <= parent_quota.  On cgroup2,\n\t\t * always take the min.  On cgroup1, only inherit when no\n\t\t * limit is set:\n\t\t */\n\t\tif (cgroup_subsys_on_dfl(cpu_cgrp_subsys)) {\n\t\t\tquota = min(quota, parent_quota);\n\t\t} else {\n\t\t\tif (quota == RUNTIME_INF)\n\t\t\t\tquota = parent_quota;\n\t\t\telse if (parent_quota != RUNTIME_INF && quota > parent_quota)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcfs_b->hierarchical_quota = quota;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "quota",
            "parent_quota"
          ],
          "line": 6700
        },
        "resolved": true,
        "details": {
          "function_name": "sched_get_priority_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5177-5193",
          "snippet": "SYSCALL_DEFINE1(sched_get_priority_min, int, policy)\n{\n\tint ret = -EINVAL;\n\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = 1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nSYSCALL_DEFINE1(sched_get_priority_min, int, policy)\n{\n\tint ret = -EINVAL;\n\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = 1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "cpu_cgrp_subsys"
          ],
          "line": 6699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "normalize_cfs_quota",
          "args": [
            "tg",
            "d"
          ],
          "line": 6691
        },
        "resolved": true,
        "details": {
          "function_name": "normalize_cfs_quota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6660-6678",
          "snippet": "static u64 normalize_cfs_quota(struct task_group *tg,\n\t\t\t       struct cfs_schedulable_data *d)\n{\n\tu64 quota, period;\n\n\tif (tg == d->tg) {\n\t\tperiod = d->period;\n\t\tquota = d->quota;\n\t} else {\n\t\tperiod = tg_get_cfs_period(tg);\n\t\tquota = tg_get_cfs_quota(tg);\n\t}\n\n\t/* note: these should typically be equivalent */\n\tif (quota == RUNTIME_INF || quota == -1)\n\t\treturn RUNTIME_INF;\n\n\treturn to_ratio(period, quota);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic u64 normalize_cfs_quota(struct task_group *tg,\n\t\t\t       struct cfs_schedulable_data *d)\n{\n\tu64 quota, period;\n\n\tif (tg == d->tg) {\n\t\tperiod = d->period;\n\t\tquota = d->quota;\n\t} else {\n\t\tperiod = tg_get_cfs_period(tg);\n\t\tquota = tg_get_cfs_quota(tg);\n\t}\n\n\t/* note: these should typically be equivalent */\n\tif (quota == RUNTIME_INF || quota == -1)\n\t\treturn RUNTIME_INF;\n\n\treturn to_ratio(period, quota);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int tg_cfs_schedulable_down(struct task_group *tg, void *data)\n{\n\tstruct cfs_schedulable_data *d = data;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\ts64 quota = 0, parent_quota = -1;\n\n\tif (!tg->parent) {\n\t\tquota = RUNTIME_INF;\n\t} else {\n\t\tstruct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth;\n\n\t\tquota = normalize_cfs_quota(tg, d);\n\t\tparent_quota = parent_b->hierarchical_quota;\n\n\t\t/*\n\t\t * Ensure max(child_quota) <= parent_quota.  On cgroup2,\n\t\t * always take the min.  On cgroup1, only inherit when no\n\t\t * limit is set:\n\t\t */\n\t\tif (cgroup_subsys_on_dfl(cpu_cgrp_subsys)) {\n\t\t\tquota = min(quota, parent_quota);\n\t\t} else {\n\t\t\tif (quota == RUNTIME_INF)\n\t\t\t\tquota = parent_quota;\n\t\t\telse if (parent_quota != RUNTIME_INF && quota > parent_quota)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcfs_b->hierarchical_quota = quota;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "normalize_cfs_quota",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6660-6678",
    "snippet": "static u64 normalize_cfs_quota(struct task_group *tg,\n\t\t\t       struct cfs_schedulable_data *d)\n{\n\tu64 quota, period;\n\n\tif (tg == d->tg) {\n\t\tperiod = d->period;\n\t\tquota = d->quota;\n\t} else {\n\t\tperiod = tg_get_cfs_period(tg);\n\t\tquota = tg_get_cfs_quota(tg);\n\t}\n\n\t/* note: these should typically be equivalent */\n\tif (quota == RUNTIME_INF || quota == -1)\n\t\treturn RUNTIME_INF;\n\n\treturn to_ratio(period, quota);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "period",
            "quota"
          ],
          "line": 6677
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2377-2391",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tg_get_cfs_quota",
          "args": [
            "tg"
          ],
          "line": 6670
        },
        "resolved": true,
        "details": {
          "function_name": "tg_get_cfs_quota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6594-6605",
          "snippet": "long tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->cfs_bandwidth.quota == RUNTIME_INF)\n\t\treturn -1;\n\n\tquota_us = tg->cfs_bandwidth.quota;\n\tdo_div(quota_us, NSEC_PER_USEC);\n\n\treturn quota_us;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->cfs_bandwidth.quota == RUNTIME_INF)\n\t\treturn -1;\n\n\tquota_us = tg->cfs_bandwidth.quota;\n\tdo_div(quota_us, NSEC_PER_USEC);\n\n\treturn quota_us;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tg_get_cfs_period",
          "args": [
            "tg"
          ],
          "line": 6669
        },
        "resolved": true,
        "details": {
          "function_name": "tg_get_cfs_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6617-6625",
          "snippet": "long tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic u64 normalize_cfs_quota(struct task_group *tg,\n\t\t\t       struct cfs_schedulable_data *d)\n{\n\tu64 quota, period;\n\n\tif (tg == d->tg) {\n\t\tperiod = d->period;\n\t\tquota = d->quota;\n\t} else {\n\t\tperiod = tg_get_cfs_period(tg);\n\t\tquota = tg_get_cfs_quota(tg);\n\t}\n\n\t/* note: these should typically be equivalent */\n\tif (quota == RUNTIME_INF || quota == -1)\n\t\treturn RUNTIME_INF;\n\n\treturn to_ratio(period, quota);\n}"
  },
  {
    "function_name": "cpu_cfs_period_write_u64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6645-6649",
    "snippet": "static int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cftype, u64 cfs_period_us)\n{\n\treturn tg_set_cfs_period(css_tg(css), cfs_period_us);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tg_set_cfs_period",
          "args": [
            "css_tg(css)",
            "cfs_period_us"
          ],
          "line": 6648
        },
        "resolved": true,
        "details": {
          "function_name": "tg_set_cfs_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6607-6615",
          "snippet": "int tg_set_cfs_period(struct task_group *tg, long cfs_period_us)\n{\n\tu64 quota, period;\n\n\tperiod = (u64)cfs_period_us * NSEC_PER_USEC;\n\tquota = tg->cfs_bandwidth.quota;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint tg_set_cfs_period(struct task_group *tg, long cfs_period_us)\n{\n\tu64 quota, period;\n\n\tperiod = (u64)cfs_period_us * NSEC_PER_USEC;\n\tquota = tg->cfs_bandwidth.quota;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6648
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cftype, u64 cfs_period_us)\n{\n\treturn tg_set_cfs_period(css_tg(css), cfs_period_us);\n}"
  },
  {
    "function_name": "cpu_cfs_period_read_u64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6639-6643",
    "snippet": "static u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cft)\n{\n\treturn tg_get_cfs_period(css_tg(css));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tg_get_cfs_period",
          "args": [
            "css_tg(css)"
          ],
          "line": 6642
        },
        "resolved": true,
        "details": {
          "function_name": "tg_get_cfs_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6617-6625",
          "snippet": "long tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6642
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cft)\n{\n\treturn tg_get_cfs_period(css_tg(css));\n}"
  },
  {
    "function_name": "cpu_cfs_quota_write_s64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6633-6637",
    "snippet": "static int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cftype, s64 cfs_quota_us)\n{\n\treturn tg_set_cfs_quota(css_tg(css), cfs_quota_us);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tg_set_cfs_quota",
          "args": [
            "css_tg(css)",
            "cfs_quota_us"
          ],
          "line": 6636
        },
        "resolved": true,
        "details": {
          "function_name": "tg_set_cfs_quota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6581-6592",
          "snippet": "int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us)\n{\n\tu64 quota, period;\n\n\tperiod = ktime_to_ns(tg->cfs_bandwidth.period);\n\tif (cfs_quota_us < 0)\n\t\tquota = RUNTIME_INF;\n\telse\n\t\tquota = (u64)cfs_quota_us * NSEC_PER_USEC;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us)\n{\n\tu64 quota, period;\n\n\tperiod = ktime_to_ns(tg->cfs_bandwidth.period);\n\tif (cfs_quota_us < 0)\n\t\tquota = RUNTIME_INF;\n\telse\n\t\tquota = (u64)cfs_quota_us * NSEC_PER_USEC;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6636
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cftype, s64 cfs_quota_us)\n{\n\treturn tg_set_cfs_quota(css_tg(css), cfs_quota_us);\n}"
  },
  {
    "function_name": "cpu_cfs_quota_read_s64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6627-6631",
    "snippet": "static s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css,\n\t\t\t\t  struct cftype *cft)\n{\n\treturn tg_get_cfs_quota(css_tg(css));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tg_get_cfs_quota",
          "args": [
            "css_tg(css)"
          ],
          "line": 6630
        },
        "resolved": true,
        "details": {
          "function_name": "tg_get_cfs_quota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6594-6605",
          "snippet": "long tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->cfs_bandwidth.quota == RUNTIME_INF)\n\t\treturn -1;\n\n\tquota_us = tg->cfs_bandwidth.quota;\n\tdo_div(quota_us, NSEC_PER_USEC);\n\n\treturn quota_us;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->cfs_bandwidth.quota == RUNTIME_INF)\n\t\treturn -1;\n\n\tquota_us = tg->cfs_bandwidth.quota;\n\tdo_div(quota_us, NSEC_PER_USEC);\n\n\treturn quota_us;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6630
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css,\n\t\t\t\t  struct cftype *cft)\n{\n\treturn tg_get_cfs_quota(css_tg(css));\n}"
  },
  {
    "function_name": "tg_get_cfs_period",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6617-6625",
    "snippet": "long tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "cfs_period_us",
            "NSEC_PER_USEC"
          ],
          "line": 6622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tg->cfs_bandwidth.period"
          ],
          "line": 6621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}"
  },
  {
    "function_name": "tg_set_cfs_period",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6607-6615",
    "snippet": "int tg_set_cfs_period(struct task_group *tg, long cfs_period_us)\n{\n\tu64 quota, period;\n\n\tperiod = (u64)cfs_period_us * NSEC_PER_USEC;\n\tquota = tg->cfs_bandwidth.quota;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tg_set_cfs_bandwidth",
          "args": [
            "tg",
            "period",
            "quota"
          ],
          "line": 6614
        },
        "resolved": true,
        "details": {
          "function_name": "tg_set_cfs_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6505-6579",
          "snippet": "static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)\n{\n\tint i, ret = 0, runtime_enabled, runtime_was_enabled;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tif (tg == &root_task_group)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ensure we have at some amount of bandwidth every period.  This is\n\t * to prevent reaching a state of large arrears when throttled via\n\t * entity_tick() resulting in prolonged exit starvation.\n\t */\n\tif (quota < min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Likewise, bound things on the otherside by preventing insane quota\n\t * periods.  This also allows us to normalize in computing quota\n\t * feasibility.\n\t */\n\tif (period > max_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Prevent race between setting of cfs_rq->runtime_enabled and\n\t * unthrottle_offline_cfs_rqs().\n\t */\n\tget_online_cpus();\n\tmutex_lock(&cfs_constraints_mutex);\n\tret = __cfs_schedulable(tg, period, quota);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\truntime_enabled = quota != RUNTIME_INF;\n\truntime_was_enabled = cfs_b->quota != RUNTIME_INF;\n\t/*\n\t * If we need to toggle cfs_bandwidth_used, off->on must occur\n\t * before making related changes, and on->off must occur afterwards\n\t */\n\tif (runtime_enabled && !runtime_was_enabled)\n\t\tcfs_bandwidth_usage_inc();\n\traw_spin_lock_irq(&cfs_b->lock);\n\tcfs_b->period = ns_to_ktime(period);\n\tcfs_b->quota = quota;\n\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\n\t/* Restart the period timer (if active) to handle new period expiry: */\n\tif (runtime_enabled)\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\traw_spin_unlock_irq(&cfs_b->lock);\n\n\tfor_each_online_cpu(i) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[i];\n\t\tstruct rq *rq = cfs_rq->rq;\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irq(rq, &rf);\n\t\tcfs_rq->runtime_enabled = runtime_enabled;\n\t\tcfs_rq->runtime_remaining = 0;\n\n\t\tif (cfs_rq->throttled)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\tif (runtime_was_enabled && !runtime_enabled)\n\t\tcfs_bandwidth_usage_dec();\nout_unlock:\n\tmutex_unlock(&cfs_constraints_mutex);\n\tput_online_cpus();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)\n{\n\tint i, ret = 0, runtime_enabled, runtime_was_enabled;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tif (tg == &root_task_group)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ensure we have at some amount of bandwidth every period.  This is\n\t * to prevent reaching a state of large arrears when throttled via\n\t * entity_tick() resulting in prolonged exit starvation.\n\t */\n\tif (quota < min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Likewise, bound things on the otherside by preventing insane quota\n\t * periods.  This also allows us to normalize in computing quota\n\t * feasibility.\n\t */\n\tif (period > max_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Prevent race between setting of cfs_rq->runtime_enabled and\n\t * unthrottle_offline_cfs_rqs().\n\t */\n\tget_online_cpus();\n\tmutex_lock(&cfs_constraints_mutex);\n\tret = __cfs_schedulable(tg, period, quota);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\truntime_enabled = quota != RUNTIME_INF;\n\truntime_was_enabled = cfs_b->quota != RUNTIME_INF;\n\t/*\n\t * If we need to toggle cfs_bandwidth_used, off->on must occur\n\t * before making related changes, and on->off must occur afterwards\n\t */\n\tif (runtime_enabled && !runtime_was_enabled)\n\t\tcfs_bandwidth_usage_inc();\n\traw_spin_lock_irq(&cfs_b->lock);\n\tcfs_b->period = ns_to_ktime(period);\n\tcfs_b->quota = quota;\n\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\n\t/* Restart the period timer (if active) to handle new period expiry: */\n\tif (runtime_enabled)\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\traw_spin_unlock_irq(&cfs_b->lock);\n\n\tfor_each_online_cpu(i) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[i];\n\t\tstruct rq *rq = cfs_rq->rq;\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irq(rq, &rf);\n\t\tcfs_rq->runtime_enabled = runtime_enabled;\n\t\tcfs_rq->runtime_remaining = 0;\n\n\t\tif (cfs_rq->throttled)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\tif (runtime_was_enabled && !runtime_enabled)\n\t\tcfs_bandwidth_usage_dec();\nout_unlock:\n\tmutex_unlock(&cfs_constraints_mutex);\n\tput_online_cpus();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint tg_set_cfs_period(struct task_group *tg, long cfs_period_us)\n{\n\tu64 quota, period;\n\n\tperiod = (u64)cfs_period_us * NSEC_PER_USEC;\n\tquota = tg->cfs_bandwidth.quota;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}"
  },
  {
    "function_name": "tg_get_cfs_quota",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6594-6605",
    "snippet": "long tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->cfs_bandwidth.quota == RUNTIME_INF)\n\t\treturn -1;\n\n\tquota_us = tg->cfs_bandwidth.quota;\n\tdo_div(quota_us, NSEC_PER_USEC);\n\n\treturn quota_us;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "quota_us",
            "NSEC_PER_USEC"
          ],
          "line": 6602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->cfs_bandwidth.quota == RUNTIME_INF)\n\t\treturn -1;\n\n\tquota_us = tg->cfs_bandwidth.quota;\n\tdo_div(quota_us, NSEC_PER_USEC);\n\n\treturn quota_us;\n}"
  },
  {
    "function_name": "tg_set_cfs_quota",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6581-6592",
    "snippet": "int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us)\n{\n\tu64 quota, period;\n\n\tperiod = ktime_to_ns(tg->cfs_bandwidth.period);\n\tif (cfs_quota_us < 0)\n\t\tquota = RUNTIME_INF;\n\telse\n\t\tquota = (u64)cfs_quota_us * NSEC_PER_USEC;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tg_set_cfs_bandwidth",
          "args": [
            "tg",
            "period",
            "quota"
          ],
          "line": 6591
        },
        "resolved": true,
        "details": {
          "function_name": "tg_set_cfs_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6505-6579",
          "snippet": "static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)\n{\n\tint i, ret = 0, runtime_enabled, runtime_was_enabled;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tif (tg == &root_task_group)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ensure we have at some amount of bandwidth every period.  This is\n\t * to prevent reaching a state of large arrears when throttled via\n\t * entity_tick() resulting in prolonged exit starvation.\n\t */\n\tif (quota < min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Likewise, bound things on the otherside by preventing insane quota\n\t * periods.  This also allows us to normalize in computing quota\n\t * feasibility.\n\t */\n\tif (period > max_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Prevent race between setting of cfs_rq->runtime_enabled and\n\t * unthrottle_offline_cfs_rqs().\n\t */\n\tget_online_cpus();\n\tmutex_lock(&cfs_constraints_mutex);\n\tret = __cfs_schedulable(tg, period, quota);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\truntime_enabled = quota != RUNTIME_INF;\n\truntime_was_enabled = cfs_b->quota != RUNTIME_INF;\n\t/*\n\t * If we need to toggle cfs_bandwidth_used, off->on must occur\n\t * before making related changes, and on->off must occur afterwards\n\t */\n\tif (runtime_enabled && !runtime_was_enabled)\n\t\tcfs_bandwidth_usage_inc();\n\traw_spin_lock_irq(&cfs_b->lock);\n\tcfs_b->period = ns_to_ktime(period);\n\tcfs_b->quota = quota;\n\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\n\t/* Restart the period timer (if active) to handle new period expiry: */\n\tif (runtime_enabled)\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\traw_spin_unlock_irq(&cfs_b->lock);\n\n\tfor_each_online_cpu(i) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[i];\n\t\tstruct rq *rq = cfs_rq->rq;\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irq(rq, &rf);\n\t\tcfs_rq->runtime_enabled = runtime_enabled;\n\t\tcfs_rq->runtime_remaining = 0;\n\n\t\tif (cfs_rq->throttled)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\tif (runtime_was_enabled && !runtime_enabled)\n\t\tcfs_bandwidth_usage_dec();\nout_unlock:\n\tmutex_unlock(&cfs_constraints_mutex);\n\tput_online_cpus();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)\n{\n\tint i, ret = 0, runtime_enabled, runtime_was_enabled;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tif (tg == &root_task_group)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ensure we have at some amount of bandwidth every period.  This is\n\t * to prevent reaching a state of large arrears when throttled via\n\t * entity_tick() resulting in prolonged exit starvation.\n\t */\n\tif (quota < min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Likewise, bound things on the otherside by preventing insane quota\n\t * periods.  This also allows us to normalize in computing quota\n\t * feasibility.\n\t */\n\tif (period > max_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Prevent race between setting of cfs_rq->runtime_enabled and\n\t * unthrottle_offline_cfs_rqs().\n\t */\n\tget_online_cpus();\n\tmutex_lock(&cfs_constraints_mutex);\n\tret = __cfs_schedulable(tg, period, quota);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\truntime_enabled = quota != RUNTIME_INF;\n\truntime_was_enabled = cfs_b->quota != RUNTIME_INF;\n\t/*\n\t * If we need to toggle cfs_bandwidth_used, off->on must occur\n\t * before making related changes, and on->off must occur afterwards\n\t */\n\tif (runtime_enabled && !runtime_was_enabled)\n\t\tcfs_bandwidth_usage_inc();\n\traw_spin_lock_irq(&cfs_b->lock);\n\tcfs_b->period = ns_to_ktime(period);\n\tcfs_b->quota = quota;\n\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\n\t/* Restart the period timer (if active) to handle new period expiry: */\n\tif (runtime_enabled)\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\traw_spin_unlock_irq(&cfs_b->lock);\n\n\tfor_each_online_cpu(i) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[i];\n\t\tstruct rq *rq = cfs_rq->rq;\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irq(rq, &rf);\n\t\tcfs_rq->runtime_enabled = runtime_enabled;\n\t\tcfs_rq->runtime_remaining = 0;\n\n\t\tif (cfs_rq->throttled)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\tif (runtime_was_enabled && !runtime_enabled)\n\t\tcfs_bandwidth_usage_dec();\nout_unlock:\n\tmutex_unlock(&cfs_constraints_mutex);\n\tput_online_cpus();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tg->cfs_bandwidth.period"
          ],
          "line": 6585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us)\n{\n\tu64 quota, period;\n\n\tperiod = ktime_to_ns(tg->cfs_bandwidth.period);\n\tif (cfs_quota_us < 0)\n\t\tquota = RUNTIME_INF;\n\telse\n\t\tquota = (u64)cfs_quota_us * NSEC_PER_USEC;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}"
  },
  {
    "function_name": "tg_set_cfs_bandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6505-6579",
    "snippet": "static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)\n{\n\tint i, ret = 0, runtime_enabled, runtime_was_enabled;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tif (tg == &root_task_group)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ensure we have at some amount of bandwidth every period.  This is\n\t * to prevent reaching a state of large arrears when throttled via\n\t * entity_tick() resulting in prolonged exit starvation.\n\t */\n\tif (quota < min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Likewise, bound things on the otherside by preventing insane quota\n\t * periods.  This also allows us to normalize in computing quota\n\t * feasibility.\n\t */\n\tif (period > max_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Prevent race between setting of cfs_rq->runtime_enabled and\n\t * unthrottle_offline_cfs_rqs().\n\t */\n\tget_online_cpus();\n\tmutex_lock(&cfs_constraints_mutex);\n\tret = __cfs_schedulable(tg, period, quota);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\truntime_enabled = quota != RUNTIME_INF;\n\truntime_was_enabled = cfs_b->quota != RUNTIME_INF;\n\t/*\n\t * If we need to toggle cfs_bandwidth_used, off->on must occur\n\t * before making related changes, and on->off must occur afterwards\n\t */\n\tif (runtime_enabled && !runtime_was_enabled)\n\t\tcfs_bandwidth_usage_inc();\n\traw_spin_lock_irq(&cfs_b->lock);\n\tcfs_b->period = ns_to_ktime(period);\n\tcfs_b->quota = quota;\n\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\n\t/* Restart the period timer (if active) to handle new period expiry: */\n\tif (runtime_enabled)\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\traw_spin_unlock_irq(&cfs_b->lock);\n\n\tfor_each_online_cpu(i) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[i];\n\t\tstruct rq *rq = cfs_rq->rq;\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irq(rq, &rf);\n\t\tcfs_rq->runtime_enabled = runtime_enabled;\n\t\tcfs_rq->runtime_remaining = 0;\n\n\t\tif (cfs_rq->throttled)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\tif (runtime_was_enabled && !runtime_enabled)\n\t\tcfs_bandwidth_usage_dec();\nout_unlock:\n\tmutex_unlock(&cfs_constraints_mutex);\n\tput_online_cpus();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 6576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cfs_constraints_mutex"
          ],
          "line": 6575
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cfs_bandwidth_usage_dec",
          "args": [],
          "line": 6573
        },
        "resolved": true,
        "details": {
          "function_name": "cfs_bandwidth_usage_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "4235-4235",
          "snippet": "void cfs_bandwidth_usage_dec(void) {}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nvoid cfs_bandwidth_usage_dec(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unlock_irq",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 6570
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1146-1152",
          "snippet": "static inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unthrottle_cfs_rq",
          "args": [
            "cfs_rq"
          ],
          "line": 6569
        },
        "resolved": true,
        "details": {
          "function_name": "unthrottle_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "4499-4544",
          "snippet": "void unthrottle_cfs_rq(struct cfs_rq *cfs_rq)\n{\n\tstruct rq *rq = rq_of(cfs_rq);\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tstruct sched_entity *se;\n\tint enqueue = 1;\n\tlong task_delta;\n\n\tse = cfs_rq->tg->se[cpu_of(rq)];\n\n\tcfs_rq->throttled = 0;\n\n\tupdate_rq_clock(rq);\n\n\traw_spin_lock(&cfs_b->lock);\n\tcfs_b->throttled_time += rq_clock(rq) - cfs_rq->throttled_clock;\n\tlist_del_rcu(&cfs_rq->throttled_list);\n\traw_spin_unlock(&cfs_b->lock);\n\n\t/* update hierarchical throttle state */\n\twalk_tg_tree_from(cfs_rq->tg, tg_nop, tg_unthrottle_up, (void *)rq);\n\n\tif (!cfs_rq->load.weight)\n\t\treturn;\n\n\ttask_delta = cfs_rq->h_nr_running;\n\tfor_each_sched_entity(se) {\n\t\tif (se->on_rq)\n\t\t\tenqueue = 0;\n\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tif (enqueue)\n\t\t\tenqueue_entity(cfs_rq, se, ENQUEUE_WAKEUP);\n\t\tcfs_rq->h_nr_running += task_delta;\n\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tbreak;\n\t}\n\n\tif (!se)\n\t\tadd_nr_running(rq, task_delta);\n\n\t/* Determine whether we need to wake up potentially idle CPU: */\n\tif (rq->curr == rq->idle && rq->cfs.nr_running)\n\t\tresched_curr(rq);\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static int\nwakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static void set_next_buddy(struct sched_entity *se);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic int\nwakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic void set_next_buddy(struct sched_entity *se);\n\nvoid unthrottle_cfs_rq(struct cfs_rq *cfs_rq)\n{\n\tstruct rq *rq = rq_of(cfs_rq);\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tstruct sched_entity *se;\n\tint enqueue = 1;\n\tlong task_delta;\n\n\tse = cfs_rq->tg->se[cpu_of(rq)];\n\n\tcfs_rq->throttled = 0;\n\n\tupdate_rq_clock(rq);\n\n\traw_spin_lock(&cfs_b->lock);\n\tcfs_b->throttled_time += rq_clock(rq) - cfs_rq->throttled_clock;\n\tlist_del_rcu(&cfs_rq->throttled_list);\n\traw_spin_unlock(&cfs_b->lock);\n\n\t/* update hierarchical throttle state */\n\twalk_tg_tree_from(cfs_rq->tg, tg_nop, tg_unthrottle_up, (void *)rq);\n\n\tif (!cfs_rq->load.weight)\n\t\treturn;\n\n\ttask_delta = cfs_rq->h_nr_running;\n\tfor_each_sched_entity(se) {\n\t\tif (se->on_rq)\n\t\t\tenqueue = 0;\n\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tif (enqueue)\n\t\t\tenqueue_entity(cfs_rq, se, ENQUEUE_WAKEUP);\n\t\tcfs_rq->h_nr_running += task_delta;\n\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tbreak;\n\t}\n\n\tif (!se)\n\t\tadd_nr_running(rq, task_delta);\n\n\t/* Determine whether we need to wake up potentially idle CPU: */\n\tif (rq->curr == rq->idle && rq->cfs.nr_running)\n\t\tresched_curr(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_lock_irq",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 6564
        },
        "resolved": true,
        "details": {
          "function_name": "rq_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1114-1120",
          "snippet": "static inline void\nrq_lock_irq(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irq(&rq->lock);\n\trq_pin_lock(rq, rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_lock_irq(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irq(&rq->lock);\n\trq_pin_lock(rq, rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&cfs_b->lock"
          ],
          "line": 6557
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_cfs_bandwidth",
          "args": [
            "cfs_b"
          ],
          "line": 6555
        },
        "resolved": true,
        "details": {
          "function_name": "start_cfs_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "4896-4910",
          "snippet": "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\n\tlockdep_assert_held(&cfs_b->lock);\n\n\tif (cfs_b->period_active)\n\t\treturn;\n\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nvoid start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\n\tlockdep_assert_held(&cfs_b->lock);\n\n\tif (cfs_b->period_active)\n\t\treturn;\n\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__refill_cfs_bandwidth_runtime",
          "args": [
            "cfs_b"
          ],
          "line": 6551
        },
        "resolved": true,
        "details": {
          "function_name": "__refill_cfs_bandwidth_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "4259-4270",
          "snippet": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nvoid __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "period"
          ],
          "line": 6548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&cfs_b->lock"
          ],
          "line": 6547
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cfs_bandwidth_usage_inc",
          "args": [],
          "line": 6546
        },
        "resolved": true,
        "details": {
          "function_name": "cfs_bandwidth_usage_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "4234-4234",
          "snippet": "void cfs_bandwidth_usage_inc(void) {}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nvoid cfs_bandwidth_usage_inc(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "__cfs_schedulable",
          "args": [
            "tg",
            "period",
            "quota"
          ],
          "line": 6535
        },
        "resolved": true,
        "details": {
          "function_name": "__cfs_schedulable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6713-6732",
          "snippet": "static int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)\n{\n\tint ret;\n\tstruct cfs_schedulable_data data = {\n\t\t.tg = tg,\n\t\t.period = period,\n\t\t.quota = quota,\n\t};\n\n\tif (quota != RUNTIME_INF) {\n\t\tdo_div(data.period, NSEC_PER_USEC);\n\t\tdo_div(data.quota, NSEC_PER_USEC);\n\t}\n\n\trcu_read_lock();\n\tret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)\n{\n\tint ret;\n\tstruct cfs_schedulable_data data = {\n\t\t.tg = tg,\n\t\t.period = period,\n\t\t.quota = quota,\n\t};\n\n\tif (quota != RUNTIME_INF) {\n\t\tdo_div(data.period, NSEC_PER_USEC);\n\t\tdo_div(data.quota, NSEC_PER_USEC);\n\t}\n\n\trcu_read_lock();\n\tret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cfs_constraints_mutex"
          ],
          "line": 6534
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 6533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)\n{\n\tint i, ret = 0, runtime_enabled, runtime_was_enabled;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tif (tg == &root_task_group)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ensure we have at some amount of bandwidth every period.  This is\n\t * to prevent reaching a state of large arrears when throttled via\n\t * entity_tick() resulting in prolonged exit starvation.\n\t */\n\tif (quota < min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Likewise, bound things on the otherside by preventing insane quota\n\t * periods.  This also allows us to normalize in computing quota\n\t * feasibility.\n\t */\n\tif (period > max_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Prevent race between setting of cfs_rq->runtime_enabled and\n\t * unthrottle_offline_cfs_rqs().\n\t */\n\tget_online_cpus();\n\tmutex_lock(&cfs_constraints_mutex);\n\tret = __cfs_schedulable(tg, period, quota);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\truntime_enabled = quota != RUNTIME_INF;\n\truntime_was_enabled = cfs_b->quota != RUNTIME_INF;\n\t/*\n\t * If we need to toggle cfs_bandwidth_used, off->on must occur\n\t * before making related changes, and on->off must occur afterwards\n\t */\n\tif (runtime_enabled && !runtime_was_enabled)\n\t\tcfs_bandwidth_usage_inc();\n\traw_spin_lock_irq(&cfs_b->lock);\n\tcfs_b->period = ns_to_ktime(period);\n\tcfs_b->quota = quota;\n\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\n\t/* Restart the period timer (if active) to handle new period expiry: */\n\tif (runtime_enabled)\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\traw_spin_unlock_irq(&cfs_b->lock);\n\n\tfor_each_online_cpu(i) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[i];\n\t\tstruct rq *rq = cfs_rq->rq;\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irq(rq, &rf);\n\t\tcfs_rq->runtime_enabled = runtime_enabled;\n\t\tcfs_rq->runtime_remaining = 0;\n\n\t\tif (cfs_rq->throttled)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\tif (runtime_was_enabled && !runtime_enabled)\n\t\tcfs_bandwidth_usage_dec();\nout_unlock:\n\tmutex_unlock(&cfs_constraints_mutex);\n\tput_online_cpus();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cpu_shares_read_u64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6489-6495",
    "snippet": "static u64 cpu_shares_read_u64(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\tstruct task_group *tg = css_tg(css);\n\n\treturn (u64) scale_load_down(tg->shares);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scale_load_down",
          "args": [
            "tg->shares"
          ],
          "line": 6494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6492
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic u64 cpu_shares_read_u64(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\tstruct task_group *tg = css_tg(css);\n\n\treturn (u64) scale_load_down(tg->shares);\n}"
  },
  {
    "function_name": "cpu_shares_write_u64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6483-6487",
    "snippet": "static int cpu_shares_write_u64(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cftype, u64 shareval)\n{\n\treturn sched_group_set_shares(css_tg(css), scale_load(shareval));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_group_set_shares",
          "args": [
            "css_tg(css)",
            "scale_load(shareval)"
          ],
          "line": 6486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_load",
          "args": [
            "shareval"
          ],
          "line": 6486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6486
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_shares_write_u64(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cftype, u64 shareval)\n{\n\treturn sched_group_set_shares(css_tg(css), scale_load(shareval));\n}"
  },
  {
    "function_name": "cpu_cgroup_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6473-6480",
    "snippet": "static void cpu_cgroup_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_for_each(task, css, tset)\n\t\tsched_move_task(task);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_move_task",
          "args": [
            "task"
          ],
          "line": 6479
        },
        "resolved": true,
        "details": {
          "function_name": "sched_move_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6342-6368",
          "snippet": "void sched_move_task(struct task_struct *tsk)\n{\n\tint queued, running, queue_flags =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(tsk, &rf);\n\tupdate_rq_clock(rq);\n\n\trunning = task_current(rq, tsk);\n\tqueued = task_on_rq_queued(tsk);\n\n\tif (queued)\n\t\tdequeue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, tsk);\n\n\tsched_change_group(tsk, TASK_MOVE_GROUP);\n\n\tif (queued)\n\t\tenqueue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tset_curr_task(rq, tsk);\n\n\ttask_rq_unlock(rq, tsk, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_move_task(struct task_struct *tsk)\n{\n\tint queued, running, queue_flags =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(tsk, &rf);\n\tupdate_rq_clock(rq);\n\n\trunning = task_current(rq, tsk);\n\tqueued = task_on_rq_queued(tsk);\n\n\tif (queued)\n\t\tdequeue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, tsk);\n\n\tsched_change_group(tsk, TASK_MOVE_GROUP);\n\n\tif (queued)\n\t\tenqueue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tset_curr_task(rq, tsk);\n\n\ttask_rq_unlock(rq, tsk, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each",
          "args": [
            "task",
            "css",
            "tset"
          ],
          "line": 6478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void cpu_cgroup_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_for_each(task, css, tset)\n\t\tsched_move_task(task);\n}"
  },
  {
    "function_name": "cpu_cgroup_can_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6438-6471",
    "snippet": "static int cpu_cgroup_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tcgroup_taskset_for_each(task, css, tset) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\tif (!sched_rt_can_attach(css_tg(css), task))\n\t\t\treturn -EINVAL;\n#else\n\t\t/* We don't support RT-tasks being in separate groups */\n\t\tif (task->sched_class != &fair_sched_class)\n\t\t\treturn -EINVAL;\n#endif\n\t\t/*\n\t\t * Serialize against wake_up_new_task() such that if its\n\t\t * running, we're sure to observe its full state.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\t/*\n\t\t * Avoid calling sched_move_task() before wake_up_new_task()\n\t\t * has happened. This would lead to problems with PELT, due to\n\t\t * move wanting to detach+attach while we're not attached yet.\n\t\t */\n\t\tif (task->state == TASK_NEW)\n\t\t\tret = -EINVAL;\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&task->pi_lock"
          ],
          "line": 6465
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&task->pi_lock"
          ],
          "line": 6457
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_rt_can_attach",
          "args": [
            "css_tg(css)",
            "task"
          ],
          "line": 6446
        },
        "resolved": true,
        "details": {
          "function_name": "sched_rt_can_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2610-2617",
          "snippet": "int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk)\n{\n\t/* Don't accept realtime tasks when there is no way for them to run */\n\tif (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nint sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk)\n{\n\t/* Don't accept realtime tasks when there is no way for them to run */\n\tif (rt_task(tsk) && tg->rt_bandwidth.rt_runtime == 0)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6446
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each",
          "args": [
            "task",
            "css",
            "tset"
          ],
          "line": 6444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_cgroup_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tcgroup_taskset_for_each(task, css, tset) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\tif (!sched_rt_can_attach(css_tg(css), task))\n\t\t\treturn -EINVAL;\n#else\n\t\t/* We don't support RT-tasks being in separate groups */\n\t\tif (task->sched_class != &fair_sched_class)\n\t\t\treturn -EINVAL;\n#endif\n\t\t/*\n\t\t * Serialize against wake_up_new_task() such that if its\n\t\t * running, we're sure to observe its full state.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\t/*\n\t\t * Avoid calling sched_move_task() before wake_up_new_task()\n\t\t * has happened. This would lead to problems with PELT, due to\n\t\t * move wanting to detach+attach while we're not attached yet.\n\t\t */\n\t\tif (task->state == TASK_NEW)\n\t\t\tret = -EINVAL;\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "cpu_cgroup_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6425-6436",
    "snippet": "static void cpu_cgroup_fork(struct task_struct *task)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(task, &rf);\n\n\tupdate_rq_clock(rq);\n\tsched_change_group(task, TASK_SET_GROUP);\n\n\ttask_rq_unlock(rq, task, &rf);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "task",
            "&rf"
          ],
          "line": 6435
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_change_group",
          "args": [
            "task",
            "TASK_SET_GROUP"
          ],
          "line": 6433
        },
        "resolved": true,
        "details": {
          "function_name": "sched_change_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6313-6333",
          "snippet": "static void sched_change_group(struct task_struct *tsk, int type)\n{\n\tstruct task_group *tg;\n\n\t/*\n\t * All callers are synchronized by task_rq_lock(); we do not use RCU\n\t * which is pointless here. Thus, we pass \"true\" to task_css_check()\n\t * to prevent lockdep warnings.\n\t */\n\ttg = container_of(task_css_check(tsk, cpu_cgrp_id, true),\n\t\t\t  struct task_group, css);\n\ttg = autogroup_task_group(tsk, tg);\n\ttsk->sched_task_group = tg;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tif (tsk->sched_class->task_change_group)\n\t\ttsk->sched_class->task_change_group(tsk, type);\n\telse\n#endif\n\t\tset_task_rq(tsk, task_cpu(tsk));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void sched_change_group(struct task_struct *tsk, int type)\n{\n\tstruct task_group *tg;\n\n\t/*\n\t * All callers are synchronized by task_rq_lock(); we do not use RCU\n\t * which is pointless here. Thus, we pass \"true\" to task_css_check()\n\t * to prevent lockdep warnings.\n\t */\n\ttg = container_of(task_css_check(tsk, cpu_cgrp_id, true),\n\t\t\t  struct task_group, css);\n\ttg = autogroup_task_group(tsk, tg);\n\ttsk->sched_task_group = tg;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tif (tsk->sched_class->task_change_group)\n\t\ttsk->sched_class->task_change_group(tsk, type);\n\telse\n#endif\n\t\tset_task_rq(tsk, task_cpu(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 6432
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "task",
            "&rf"
          ],
          "line": 6430
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void cpu_cgroup_fork(struct task_struct *task)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(task, &rf);\n\n\tupdate_rq_clock(rq);\n\tsched_change_group(task, TASK_SET_GROUP);\n\n\ttask_rq_unlock(rq, task, &rf);\n}"
  },
  {
    "function_name": "cpu_cgroup_css_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6411-6419",
    "snippet": "static void cpu_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct task_group *tg = css_tg(css);\n\n\t/*\n\t * Relies on the RCU grace period between css_released() and this.\n\t */\n\tsched_free_group(tg);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_free_group",
          "args": [
            "tg"
          ],
          "line": 6418
        },
        "resolved": true,
        "details": {
          "function_name": "sched_free_group_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6288-6292",
          "snippet": "static void sched_free_group_rcu(struct rcu_head *rhp)\n{\n\t/* Now it should be safe to free those cfs_rqs: */\n\tsched_free_group(container_of(rhp, struct task_group, rcu));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void sched_free_group_rcu(struct rcu_head *rhp)\n{\n\t/* Now it should be safe to free those cfs_rqs: */\n\tsched_free_group(container_of(rhp, struct task_group, rcu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6413
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void cpu_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct task_group *tg = css_tg(css);\n\n\t/*\n\t * Relies on the RCU grace period between css_released() and this.\n\t */\n\tsched_free_group(tg);\n}"
  },
  {
    "function_name": "cpu_cgroup_css_released",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6404-6409",
    "snippet": "static void cpu_cgroup_css_released(struct cgroup_subsys_state *css)\n{\n\tstruct task_group *tg = css_tg(css);\n\n\tsched_offline_group(tg);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_offline_group",
          "args": [
            "tg"
          ],
          "line": 6408
        },
        "resolved": true,
        "details": {
          "function_name": "sched_offline_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6300-6311",
          "snippet": "void sched_offline_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\n\t/* End participation in shares distribution: */\n\tunregister_fair_sched_group(tg);\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_del_rcu(&tg->list);\n\tlist_del_rcu(&tg->siblings);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static DEFINE_SPINLOCK(task_group_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(task_group_lock);\n\nvoid sched_offline_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\n\t/* End participation in shares distribution: */\n\tunregister_fair_sched_group(tg);\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_del_rcu(&tg->list);\n\tlist_del_rcu(&tg->siblings);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css"
          ],
          "line": 6406
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void cpu_cgroup_css_released(struct cgroup_subsys_state *css)\n{\n\tstruct task_group *tg = css_tg(css);\n\n\tsched_offline_group(tg);\n}"
  },
  {
    "function_name": "cpu_cgroup_css_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6394-6402",
    "snippet": "static int cpu_cgroup_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct task_group *tg = css_tg(css);\n\tstruct task_group *parent = css_tg(css->parent);\n\n\tif (parent)\n\t\tsched_online_group(tg, parent);\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_online_group",
          "args": [
            "tg",
            "parent"
          ],
          "line": 6400
        },
        "resolved": true,
        "details": {
          "function_name": "sched_online_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6269-6285",
          "snippet": "void sched_online_group(struct task_group *tg, struct task_group *parent)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_add_rcu(&tg->list, &task_groups);\n\n\t/* Root should already exist: */\n\tWARN_ON(!parent);\n\n\ttg->parent = parent;\n\tINIT_LIST_HEAD(&tg->children);\n\tlist_add_rcu(&tg->siblings, &parent->children);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n\n\tonline_fair_sched_group(tg);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static DEFINE_SPINLOCK(task_group_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(task_group_lock);\n\nvoid sched_online_group(struct task_group *tg, struct task_group *parent)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_add_rcu(&tg->list, &task_groups);\n\n\t/* Root should already exist: */\n\tWARN_ON(!parent);\n\n\ttg->parent = parent;\n\tINIT_LIST_HEAD(&tg->children);\n\tlist_add_rcu(&tg->siblings, &parent->children);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n\n\tonline_fair_sched_group(tg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "css->parent"
          ],
          "line": 6397
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int cpu_cgroup_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct task_group *tg = css_tg(css);\n\tstruct task_group *parent = css_tg(css->parent);\n\n\tif (parent)\n\t\tsched_online_group(tg, parent);\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_cgroup_css_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6375-6391",
    "snippet": "static struct cgroup_subsys_state *\ncpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct task_group *parent = css_tg(parent_css);\n\tstruct task_group *tg;\n\n\tif (!parent) {\n\t\t/* This is early initialization for the top cgroup */\n\t\treturn &root_task_group.css;\n\t}\n\n\ttg = sched_create_group(parent);\n\tif (IS_ERR(tg))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn &tg->css;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 6388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tg"
          ],
          "line": 6387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_create_group",
          "args": [
            "parent"
          ],
          "line": 6386
        },
        "resolved": true,
        "details": {
          "function_name": "sched_create_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6248-6267",
          "snippet": "struct task_group *sched_create_group(struct task_group *parent)\n{\n\tstruct task_group *tg;\n\n\ttg = kmem_cache_alloc(task_group_cache, GFP_KERNEL | __GFP_ZERO);\n\tif (!tg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!alloc_fair_sched_group(tg, parent))\n\t\tgoto err;\n\n\tif (!alloc_rt_sched_group(tg, parent))\n\t\tgoto err;\n\n\treturn tg;\n\nerr:\n\tsched_free_group(tg);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct task_group *sched_create_group(struct task_group *parent)\n{\n\tstruct task_group *tg;\n\n\ttg = kmem_cache_alloc(task_group_cache, GFP_KERNEL | __GFP_ZERO);\n\tif (!tg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!alloc_fair_sched_group(tg, parent))\n\t\tgoto err;\n\n\tif (!alloc_rt_sched_group(tg, parent))\n\t\tgoto err;\n\n\treturn tg;\n\nerr:\n\tsched_free_group(tg);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tg",
          "args": [
            "parent_css"
          ],
          "line": 6378
        },
        "resolved": true,
        "details": {
          "function_name": "css_tg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6370-6373",
          "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct cgroup_subsys_state *\ncpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct task_group *parent = css_tg(parent_css);\n\tstruct task_group *tg;\n\n\tif (!parent) {\n\t\t/* This is early initialization for the top cgroup */\n\t\treturn &root_task_group.css;\n\t}\n\n\ttg = sched_create_group(parent);\n\tif (IS_ERR(tg))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn &tg->css;\n}"
  },
  {
    "function_name": "css_tg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6370-6373",
    "snippet": "static inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structtask_group",
            "css"
          ],
          "line": 6372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}"
  },
  {
    "function_name": "sched_move_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6342-6368",
    "snippet": "void sched_move_task(struct task_struct *tsk)\n{\n\tint queued, running, queue_flags =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(tsk, &rf);\n\tupdate_rq_clock(rq);\n\n\trunning = task_current(rq, tsk);\n\tqueued = task_on_rq_queued(tsk);\n\n\tif (queued)\n\t\tdequeue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, tsk);\n\n\tsched_change_group(tsk, TASK_MOVE_GROUP);\n\n\tif (queued)\n\t\tenqueue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tset_curr_task(rq, tsk);\n\n\ttask_rq_unlock(rq, tsk, &rf);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "tsk",
            "&rf"
          ],
          "line": 6367
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_curr_task",
          "args": [
            "rq",
            "tsk"
          ],
          "line": 6365
        },
        "resolved": true,
        "details": {
          "function_name": "ia64_set_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6228-6231",
          "snippet": "void ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task",
          "args": [
            "rq",
            "tsk",
            "queue_flags"
          ],
          "line": 6363
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "720-731",
          "snippet": "static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_change_group",
          "args": [
            "tsk",
            "TASK_MOVE_GROUP"
          ],
          "line": 6360
        },
        "resolved": true,
        "details": {
          "function_name": "sched_change_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6313-6333",
          "snippet": "static void sched_change_group(struct task_struct *tsk, int type)\n{\n\tstruct task_group *tg;\n\n\t/*\n\t * All callers are synchronized by task_rq_lock(); we do not use RCU\n\t * which is pointless here. Thus, we pass \"true\" to task_css_check()\n\t * to prevent lockdep warnings.\n\t */\n\ttg = container_of(task_css_check(tsk, cpu_cgrp_id, true),\n\t\t\t  struct task_group, css);\n\ttg = autogroup_task_group(tsk, tg);\n\ttsk->sched_task_group = tg;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tif (tsk->sched_class->task_change_group)\n\t\ttsk->sched_class->task_change_group(tsk, type);\n\telse\n#endif\n\t\tset_task_rq(tsk, task_cpu(tsk));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void sched_change_group(struct task_struct *tsk, int type)\n{\n\tstruct task_group *tg;\n\n\t/*\n\t * All callers are synchronized by task_rq_lock(); we do not use RCU\n\t * which is pointless here. Thus, we pass \"true\" to task_css_check()\n\t * to prevent lockdep warnings.\n\t */\n\ttg = container_of(task_css_check(tsk, cpu_cgrp_id, true),\n\t\t\t  struct task_group, css);\n\ttg = autogroup_task_group(tsk, tg);\n\ttsk->sched_task_group = tg;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tif (tsk->sched_class->task_change_group)\n\t\ttsk->sched_class->task_change_group(tsk, type);\n\telse\n#endif\n\t\tset_task_rq(tsk, task_cpu(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_prev_task",
          "args": [
            "rq",
            "tsk"
          ],
          "line": 6358
        },
        "resolved": true,
        "details": {
          "function_name": "put_prev_task_fake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5553-5555",
          "snippet": "static void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_task",
          "args": [
            "rq",
            "tsk",
            "queue_flags"
          ],
          "line": 6356
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "733-744",
          "snippet": "static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "tsk"
          ],
          "line": 6353
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "tsk"
          ],
          "line": 6352
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1521-1524",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 6350
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "tsk",
            "&rf"
          ],
          "line": 6349
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_move_task(struct task_struct *tsk)\n{\n\tint queued, running, queue_flags =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(tsk, &rf);\n\tupdate_rq_clock(rq);\n\n\trunning = task_current(rq, tsk);\n\tqueued = task_on_rq_queued(tsk);\n\n\tif (queued)\n\t\tdequeue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, tsk);\n\n\tsched_change_group(tsk, TASK_MOVE_GROUP);\n\n\tif (queued)\n\t\tenqueue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tset_curr_task(rq, tsk);\n\n\ttask_rq_unlock(rq, tsk, &rf);\n}"
  },
  {
    "function_name": "sched_change_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6313-6333",
    "snippet": "static void sched_change_group(struct task_struct *tsk, int type)\n{\n\tstruct task_group *tg;\n\n\t/*\n\t * All callers are synchronized by task_rq_lock(); we do not use RCU\n\t * which is pointless here. Thus, we pass \"true\" to task_css_check()\n\t * to prevent lockdep warnings.\n\t */\n\ttg = container_of(task_css_check(tsk, cpu_cgrp_id, true),\n\t\t\t  struct task_group, css);\n\ttg = autogroup_task_group(tsk, tg);\n\ttsk->sched_task_group = tg;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tif (tsk->sched_class->task_change_group)\n\t\ttsk->sched_class->task_change_group(tsk, type);\n\telse\n#endif\n\t\tset_task_rq(tsk, task_cpu(tsk));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_task_rq",
          "args": [
            "tsk",
            "task_cpu(tsk)"
          ],
          "line": 6332
        },
        "resolved": true,
        "details": {
          "function_name": "set_task_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1420-1420",
          "snippet": "static inline void set_task_rq(struct task_struct *p, unsigned int cpu) { }",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline void set_task_rq(struct task_struct *p, unsigned int cpu) { }"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "tsk"
          ],
          "line": 6332
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsk->sched_class->task_change_group",
          "args": [
            "tsk",
            "type"
          ],
          "line": 6329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autogroup_task_group",
          "args": [
            "tsk",
            "tg"
          ],
          "line": 6324
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_task_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/autogroup.h",
          "lines": "49-53",
          "snippet": "static inline struct task_group *\nautogroup_task_group(struct task_struct *p, struct task_group *tg)\n{\n\treturn tg;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct task_group *\nautogroup_task_group(struct task_struct *p, struct task_group *tg)\n{\n\treturn tg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "task_css_check(tsk, cpu_cgrp_id, true)",
            "structtask_group",
            "css"
          ],
          "line": 6322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_check",
          "args": [
            "tsk",
            "cpu_cgrp_id",
            "true"
          ],
          "line": 6322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void sched_change_group(struct task_struct *tsk, int type)\n{\n\tstruct task_group *tg;\n\n\t/*\n\t * All callers are synchronized by task_rq_lock(); we do not use RCU\n\t * which is pointless here. Thus, we pass \"true\" to task_css_check()\n\t * to prevent lockdep warnings.\n\t */\n\ttg = container_of(task_css_check(tsk, cpu_cgrp_id, true),\n\t\t\t  struct task_group, css);\n\ttg = autogroup_task_group(tsk, tg);\n\ttsk->sched_task_group = tg;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tif (tsk->sched_class->task_change_group)\n\t\ttsk->sched_class->task_change_group(tsk, type);\n\telse\n#endif\n\t\tset_task_rq(tsk, task_cpu(tsk));\n}"
  },
  {
    "function_name": "sched_offline_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6300-6311",
    "snippet": "void sched_offline_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\n\t/* End participation in shares distribution: */\n\tunregister_fair_sched_group(tg);\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_del_rcu(&tg->list);\n\tlist_del_rcu(&tg->siblings);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static DEFINE_SPINLOCK(task_group_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&task_group_lock",
            "flags"
          ],
          "line": 6310
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&tg->siblings"
          ],
          "line": 6309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&tg->list"
          ],
          "line": 6308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&task_group_lock",
            "flags"
          ],
          "line": 6307
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_fair_sched_group",
          "args": [
            "tg"
          ],
          "line": 6305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(task_group_lock);\n\nvoid sched_offline_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\n\t/* End participation in shares distribution: */\n\tunregister_fair_sched_group(tg);\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_del_rcu(&tg->list);\n\tlist_del_rcu(&tg->siblings);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n}"
  },
  {
    "function_name": "sched_destroy_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6294-6298",
    "snippet": "void sched_destroy_group(struct task_group *tg)\n{\n\t/* Wait for possible concurrent references to cfs_rqs complete: */\n\tcall_rcu(&tg->rcu, sched_free_group_rcu);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&tg->rcu",
            "sched_free_group_rcu"
          ],
          "line": 6297
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_destroy_group(struct task_group *tg)\n{\n\t/* Wait for possible concurrent references to cfs_rqs complete: */\n\tcall_rcu(&tg->rcu, sched_free_group_rcu);\n}"
  },
  {
    "function_name": "sched_free_group_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6288-6292",
    "snippet": "static void sched_free_group_rcu(struct rcu_head *rhp)\n{\n\t/* Now it should be safe to free those cfs_rqs: */\n\tsched_free_group(container_of(rhp, struct task_group, rcu));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void sched_free_group_rcu(struct rcu_head *rhp)\n{\n\t/* Now it should be safe to free those cfs_rqs: */\n\tsched_free_group(container_of(rhp, struct task_group, rcu));\n}"
  },
  {
    "function_name": "sched_online_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6269-6285",
    "snippet": "void sched_online_group(struct task_group *tg, struct task_group *parent)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_add_rcu(&tg->list, &task_groups);\n\n\t/* Root should already exist: */\n\tWARN_ON(!parent);\n\n\ttg->parent = parent;\n\tINIT_LIST_HEAD(&tg->children);\n\tlist_add_rcu(&tg->siblings, &parent->children);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n\n\tonline_fair_sched_group(tg);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static DEFINE_SPINLOCK(task_group_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "online_fair_sched_group",
          "args": [
            "tg"
          ],
          "line": 6284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&task_group_lock",
            "flags"
          ],
          "line": 6282
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&tg->siblings",
            "&parent->children"
          ],
          "line": 6281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tg->children"
          ],
          "line": 6280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!parent"
          ],
          "line": 6277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&tg->list",
            "&task_groups"
          ],
          "line": 6274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&task_group_lock",
            "flags"
          ],
          "line": 6273
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(task_group_lock);\n\nvoid sched_online_group(struct task_group *tg, struct task_group *parent)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_add_rcu(&tg->list, &task_groups);\n\n\t/* Root should already exist: */\n\tWARN_ON(!parent);\n\n\ttg->parent = parent;\n\tINIT_LIST_HEAD(&tg->children);\n\tlist_add_rcu(&tg->siblings, &parent->children);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n\n\tonline_fair_sched_group(tg);\n}"
  },
  {
    "function_name": "sched_create_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6248-6267",
    "snippet": "struct task_group *sched_create_group(struct task_group *parent)\n{\n\tstruct task_group *tg;\n\n\ttg = kmem_cache_alloc(task_group_cache, GFP_KERNEL | __GFP_ZERO);\n\tif (!tg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!alloc_fair_sched_group(tg, parent))\n\t\tgoto err;\n\n\tif (!alloc_rt_sched_group(tg, parent))\n\t\tgoto err;\n\n\treturn tg;\n\nerr:\n\tsched_free_group(tg);\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 6266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_free_group",
          "args": [
            "tg"
          ],
          "line": 6265
        },
        "resolved": true,
        "details": {
          "function_name": "sched_free_group_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6288-6292",
          "snippet": "static void sched_free_group_rcu(struct rcu_head *rhp)\n{\n\t/* Now it should be safe to free those cfs_rqs: */\n\tsched_free_group(container_of(rhp, struct task_group, rcu));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void sched_free_group_rcu(struct rcu_head *rhp)\n{\n\t/* Now it should be safe to free those cfs_rqs: */\n\tsched_free_group(container_of(rhp, struct task_group, rcu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_rt_sched_group",
          "args": [
            "tg",
            "parent"
          ],
          "line": 6259
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rt_sched_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "252-255",
          "snippet": "int alloc_rt_sched_group(struct task_group *tg, struct task_group *parent)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nint alloc_rt_sched_group(struct task_group *tg, struct task_group *parent)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_fair_sched_group",
          "args": [
            "tg",
            "parent"
          ],
          "line": 6256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 6254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "task_group_cache",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 6252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct task_group *sched_create_group(struct task_group *parent)\n{\n\tstruct task_group *tg;\n\n\ttg = kmem_cache_alloc(task_group_cache, GFP_KERNEL | __GFP_ZERO);\n\tif (!tg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!alloc_fair_sched_group(tg, parent))\n\t\tgoto err;\n\n\tif (!alloc_rt_sched_group(tg, parent))\n\t\tgoto err;\n\n\treturn tg;\n\nerr:\n\tsched_free_group(tg);\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "sched_free_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6239-6245",
    "snippet": "static void sched_free_group(struct task_group *tg)\n{\n\tfree_fair_sched_group(tg);\n\tfree_rt_sched_group(tg);\n\tautogroup_free(tg);\n\tkmem_cache_free(task_group_cache, tg);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "task_group_cache",
            "tg"
          ],
          "line": 6244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autogroup_free",
          "args": [
            "tg"
          ],
          "line": 6243
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/autogroup.h",
          "lines": "43-43",
          "snippet": "static inline void autogroup_free(struct task_group *tg) { }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void autogroup_free(struct task_group *tg) { }"
        }
      },
      {
        "call_info": {
          "callee": "free_rt_sched_group",
          "args": [
            "tg"
          ],
          "line": 6242
        },
        "resolved": true,
        "details": {
          "function_name": "free_rt_sched_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "250-250",
          "snippet": "void free_rt_sched_group(struct task_group *tg) { }",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid free_rt_sched_group(struct task_group *tg) { }"
        }
      },
      {
        "call_info": {
          "callee": "free_fair_sched_group",
          "args": [
            "tg"
          ],
          "line": 6241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void sched_free_group(struct task_group *tg)\n{\n\tfree_fair_sched_group(tg);\n\tfree_rt_sched_group(tg);\n\tautogroup_free(tg);\n\tkmem_cache_free(task_group_cache, tg);\n}"
  },
  {
    "function_name": "ia64_set_curr_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6228-6231",
    "snippet": "void ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_curr",
          "args": [
            "cpu"
          ],
          "line": 6230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}"
  },
  {
    "function_name": "curr_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6205-6208",
    "snippet": "struct task_struct *curr_task(int cpu)\n{\n\treturn cpu_curr(cpu);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_curr",
          "args": [
            "cpu"
          ],
          "line": 6207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct task_struct *curr_task(int cpu)\n{\n\treturn cpu_curr(cpu);\n}"
  },
  {
    "function_name": "normalize_rt_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6149-6182",
    "snippet": "void normalize_rt_tasks(void)\n{\n\tstruct task_struct *g, *p;\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t};\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\t/*\n\t\t * Only normalize user tasks:\n\t\t */\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\tp->se.exec_start = 0;\n\t\tschedstat_set(p->se.statistics.wait_start,  0);\n\t\tschedstat_set(p->se.statistics.sleep_start, 0);\n\t\tschedstat_set(p->se.statistics.block_start, 0);\n\n\t\tif (!dl_task(p) && !rt_task(p)) {\n\t\t\t/*\n\t\t\t * Renice negative nice level userspace\n\t\t\t * tasks back to 0:\n\t\t\t */\n\t\t\tif (task_nice(p) < 0)\n\t\t\t\tset_user_nice(p, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__sched_setscheduler(p, &attr, false, false);\n\t}\n\tread_unlock(&tasklist_lock);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 6181
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sched_setscheduler",
          "args": [
            "p",
            "&attr",
            "false",
            "false"
          ],
          "line": 6179
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_setscheduler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4114-4355",
          "snippet": "static int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (idle_policy(p->policy) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn 0;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\treturn -EPERM;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, &p->cpus_allowed) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EBUSY;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\t__setscheduler(rq, p, attr, pi);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi)\n\t\trt_mutex_adjust_pi(p);\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (idle_policy(p->policy) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn 0;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\treturn -EPERM;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, &p->cpus_allowed) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EBUSY;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\t__setscheduler(rq, p, attr, pi);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi)\n\t\trt_mutex_adjust_pi(p);\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "p",
            "0"
          ],
          "line": 6175
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 6174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "p"
          ],
          "line": 6169
        },
        "resolved": true,
        "details": {
          "function_name": "tg_has_rt_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2416-2432",
          "snippet": "static inline int tg_has_rt_tasks(struct task_group *tg)\n{\n\tstruct task_struct *g, *p;\n\n\t/*\n\t * Autogroups do not have RT tasks; see autogroup_create().\n\t */\n\tif (task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\tfor_each_process_thread(g, p) {\n\t\tif (rt_task(p) && task_group(p) == tg)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int tg_has_rt_tasks(struct task_group *tg)\n{\n\tstruct task_struct *g, *p;\n\n\t/*\n\t * Autogroups do not have RT tasks; see autogroup_create().\n\t */\n\tif (task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\tfor_each_process_thread(g, p) {\n\t\tif (rt_task(p) && task_group(p) == tg)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 6169
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedstat_set",
          "args": [
            "p->se.statistics.block_start",
            "0"
          ],
          "line": 6167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_set",
          "args": [
            "p->se.statistics.sleep_start",
            "0"
          ],
          "line": 6166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_set",
          "args": [
            "p->se.statistics.wait_start",
            "0"
          ],
          "line": 6165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 6157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 6156
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid normalize_rt_tasks(void)\n{\n\tstruct task_struct *g, *p;\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t};\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\t/*\n\t\t * Only normalize user tasks:\n\t\t */\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\tp->se.exec_start = 0;\n\t\tschedstat_set(p->se.statistics.wait_start,  0);\n\t\tschedstat_set(p->se.statistics.sleep_start, 0);\n\t\tschedstat_set(p->se.statistics.block_start, 0);\n\n\t\tif (!dl_task(p) && !rt_task(p)) {\n\t\t\t/*\n\t\t\t * Renice negative nice level userspace\n\t\t\t * tasks back to 0:\n\t\t\t */\n\t\t\tif (task_nice(p) < 0)\n\t\t\t\tset_user_nice(p, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__sched_setscheduler(p, &attr, false, false);\n\t}\n\tread_unlock(&tasklist_lock);\n}"
  },
  {
    "function_name": "___might_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6099-6144",
    "snippet": "void ___might_sleep(const char *file, int line, int preempt_offset)\n{\n\t/* Ratelimiting timestamp: */\n\tstatic unsigned long prev_jiffy;\n\n\tunsigned long preempt_disable_ip;\n\n\t/* WARN_ON_ONCE() by default, no rate limit required: */\n\trcu_sleep_check();\n\n\tif ((preempt_count_equals(preempt_offset) && !irqs_disabled() &&\n\t     !is_idle_task(current)) ||\n\t    system_state == SYSTEM_BOOTING || system_state > SYSTEM_RUNNING ||\n\t    oops_in_progress)\n\t\treturn;\n\n\tif (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)\n\t\treturn;\n\tprev_jiffy = jiffies;\n\n\t/* Save this before calling printk(), since that will clobber it: */\n\tpreempt_disable_ip = get_preempt_disable_ip(current);\n\n\tprintk(KERN_ERR\n\t\t\"BUG: sleeping function called from invalid context at %s:%d\\n\",\n\t\t\tfile, line);\n\tprintk(KERN_ERR\n\t\t\"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\",\n\t\t\tin_atomic(), irqs_disabled(),\n\t\t\tcurrent->pid, current->comm);\n\n\tif (task_stack_end_corrupted(current))\n\t\tprintk(KERN_EMERG \"Thread overran stack, or stack corrupted\\n\");\n\n\tdebug_show_held_locks(current);\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(current);\n\tif (IS_ENABLED(CONFIG_DEBUG_PREEMPT)\n\t    && !preempt_count_equals(preempt_offset)) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_WARN",
            "LOCKDEP_STILL_OK"
          ],
          "line": 6143
        },
        "resolved": true,
        "details": {
          "function_name": "add_taint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "386-392",
          "snippet": "void add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\n\nvoid add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 6142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 6140
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "preempt_disable_ip"
          ],
          "line": 6139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Preemption disabled at:\""
          ],
          "line": 6138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count_equals",
          "args": [
            "preempt_offset"
          ],
          "line": 6137
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_count_equals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6074-6079",
          "snippet": "static inline int preempt_count_equals(int preempt_offset)\n{\n\tint nested = preempt_count() + rcu_preempt_depth();\n\n\treturn (nested == preempt_offset);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic inline int preempt_count_equals(int preempt_offset)\n{\n\tint nested = preempt_count() + rcu_preempt_depth();\n\n\treturn (nested == preempt_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DEBUG_PREEMPT"
          ],
          "line": 6136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "current"
          ],
          "line": 6135
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2606-2621",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 6134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_show_held_locks",
          "args": [
            "current"
          ],
          "line": 6133
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4403-4410",
          "snippet": "void debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Thread overran stack, or stack corrupted\\n\""
          ],
          "line": 6131
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_stack_end_corrupted",
          "args": [
            "current"
          ],
          "line": 6130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\"",
            "in_atomic()",
            "irqs_disabled()",
            "current->pid",
            "current->comm"
          ],
          "line": 6125
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 6127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 6127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_preempt_disable_ip",
          "args": [
            "current"
          ],
          "line": 6120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "prev_jiffy + HZ"
          ],
          "line": 6115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 6110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 6109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_sleep_check",
          "args": [],
          "line": 6107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid ___might_sleep(const char *file, int line, int preempt_offset)\n{\n\t/* Ratelimiting timestamp: */\n\tstatic unsigned long prev_jiffy;\n\n\tunsigned long preempt_disable_ip;\n\n\t/* WARN_ON_ONCE() by default, no rate limit required: */\n\trcu_sleep_check();\n\n\tif ((preempt_count_equals(preempt_offset) && !irqs_disabled() &&\n\t     !is_idle_task(current)) ||\n\t    system_state == SYSTEM_BOOTING || system_state > SYSTEM_RUNNING ||\n\t    oops_in_progress)\n\t\treturn;\n\n\tif (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)\n\t\treturn;\n\tprev_jiffy = jiffies;\n\n\t/* Save this before calling printk(), since that will clobber it: */\n\tpreempt_disable_ip = get_preempt_disable_ip(current);\n\n\tprintk(KERN_ERR\n\t\t\"BUG: sleeping function called from invalid context at %s:%d\\n\",\n\t\t\tfile, line);\n\tprintk(KERN_ERR\n\t\t\"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\",\n\t\t\tin_atomic(), irqs_disabled(),\n\t\t\tcurrent->pid, current->comm);\n\n\tif (task_stack_end_corrupted(current))\n\t\tprintk(KERN_EMERG \"Thread overran stack, or stack corrupted\\n\");\n\n\tdebug_show_held_locks(current);\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(current);\n\tif (IS_ENABLED(CONFIG_DEBUG_PREEMPT)\n\t    && !preempt_count_equals(preempt_offset)) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}"
  },
  {
    "function_name": "__might_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6081-6096",
    "snippet": "void __might_sleep(const char *file, int line, int preempt_offset)\n{\n\t/*\n\t * Blocking primitives will set (and therefore destroy) current->state,\n\t * since we will exit with TASK_RUNNING make sure we enter with it,\n\t * otherwise we will destroy state.\n\t */\n\tWARN_ONCE(current->state != TASK_RUNNING && current->task_state_change,\n\t\t\t\"do not call blocking ops when !TASK_RUNNING; \"\n\t\t\t\"state=%lx set at [<%p>] %pS\\n\",\n\t\t\tcurrent->state,\n\t\t\t(void *)current->task_state_change,\n\t\t\t(void *)current->task_state_change);\n\n\t___might_sleep(file, line, preempt_offset);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "___might_sleep",
          "args": [
            "file",
            "line",
            "preempt_offset"
          ],
          "line": 6095
        },
        "resolved": true,
        "details": {
          "function_name": "___might_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6099-6144",
          "snippet": "void ___might_sleep(const char *file, int line, int preempt_offset)\n{\n\t/* Ratelimiting timestamp: */\n\tstatic unsigned long prev_jiffy;\n\n\tunsigned long preempt_disable_ip;\n\n\t/* WARN_ON_ONCE() by default, no rate limit required: */\n\trcu_sleep_check();\n\n\tif ((preempt_count_equals(preempt_offset) && !irqs_disabled() &&\n\t     !is_idle_task(current)) ||\n\t    system_state == SYSTEM_BOOTING || system_state > SYSTEM_RUNNING ||\n\t    oops_in_progress)\n\t\treturn;\n\n\tif (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)\n\t\treturn;\n\tprev_jiffy = jiffies;\n\n\t/* Save this before calling printk(), since that will clobber it: */\n\tpreempt_disable_ip = get_preempt_disable_ip(current);\n\n\tprintk(KERN_ERR\n\t\t\"BUG: sleeping function called from invalid context at %s:%d\\n\",\n\t\t\tfile, line);\n\tprintk(KERN_ERR\n\t\t\"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\",\n\t\t\tin_atomic(), irqs_disabled(),\n\t\t\tcurrent->pid, current->comm);\n\n\tif (task_stack_end_corrupted(current))\n\t\tprintk(KERN_EMERG \"Thread overran stack, or stack corrupted\\n\");\n\n\tdebug_show_held_locks(current);\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(current);\n\tif (IS_ENABLED(CONFIG_DEBUG_PREEMPT)\n\t    && !preempt_count_equals(preempt_offset)) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid ___might_sleep(const char *file, int line, int preempt_offset)\n{\n\t/* Ratelimiting timestamp: */\n\tstatic unsigned long prev_jiffy;\n\n\tunsigned long preempt_disable_ip;\n\n\t/* WARN_ON_ONCE() by default, no rate limit required: */\n\trcu_sleep_check();\n\n\tif ((preempt_count_equals(preempt_offset) && !irqs_disabled() &&\n\t     !is_idle_task(current)) ||\n\t    system_state == SYSTEM_BOOTING || system_state > SYSTEM_RUNNING ||\n\t    oops_in_progress)\n\t\treturn;\n\n\tif (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)\n\t\treturn;\n\tprev_jiffy = jiffies;\n\n\t/* Save this before calling printk(), since that will clobber it: */\n\tpreempt_disable_ip = get_preempt_disable_ip(current);\n\n\tprintk(KERN_ERR\n\t\t\"BUG: sleeping function called from invalid context at %s:%d\\n\",\n\t\t\tfile, line);\n\tprintk(KERN_ERR\n\t\t\"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\",\n\t\t\tin_atomic(), irqs_disabled(),\n\t\t\tcurrent->pid, current->comm);\n\n\tif (task_stack_end_corrupted(current))\n\t\tprintk(KERN_EMERG \"Thread overran stack, or stack corrupted\\n\");\n\n\tdebug_show_held_locks(current);\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(current);\n\tif (IS_ENABLED(CONFIG_DEBUG_PREEMPT)\n\t    && !preempt_count_equals(preempt_offset)) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "current->state != TASK_RUNNING && current->task_state_change",
            "\"do not call blocking ops when !TASK_RUNNING; \"\n\t\t\t\"state=%lx set at [<%p>] %pS\\n\"",
            "current->state",
            "(void *)current->task_state_change",
            "(void *)current->task_state_change"
          ],
          "line": 6088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid __might_sleep(const char *file, int line, int preempt_offset)\n{\n\t/*\n\t * Blocking primitives will set (and therefore destroy) current->state,\n\t * since we will exit with TASK_RUNNING make sure we enter with it,\n\t * otherwise we will destroy state.\n\t */\n\tWARN_ONCE(current->state != TASK_RUNNING && current->task_state_change,\n\t\t\t\"do not call blocking ops when !TASK_RUNNING; \"\n\t\t\t\"state=%lx set at [<%p>] %pS\\n\",\n\t\t\tcurrent->state,\n\t\t\t(void *)current->task_state_change,\n\t\t\t(void *)current->task_state_change);\n\n\t___might_sleep(file, line, preempt_offset);\n}"
  },
  {
    "function_name": "preempt_count_equals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "6074-6079",
    "snippet": "static inline int preempt_count_equals(int preempt_offset)\n{\n\tint nested = preempt_count() + rcu_preempt_depth();\n\n\treturn (nested == preempt_offset);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_preempt_depth",
          "args": [],
          "line": 6076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 6076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic inline int preempt_count_equals(int preempt_offset)\n{\n\tint nested = preempt_count() + rcu_preempt_depth();\n\n\treturn (nested == preempt_offset);\n}"
  },
  {
    "function_name": "sched_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5907-6071",
    "snippet": "void __init sched_init(void)\n{\n\tint i, j;\n\tunsigned long alloc_size = 0, ptr;\n\n\twait_bit_init();\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\talloc_size += 2 * nr_cpu_ids * sizeof(void **);\n#endif\n#ifdef CONFIG_RT_GROUP_SCHED\n\talloc_size += 2 * nr_cpu_ids * sizeof(void **);\n#endif\n\tif (alloc_size) {\n\t\tptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t\troot_task_group.se = (struct sched_entity **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.cfs_rq = (struct cfs_rq **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\troot_task_group.rt_se = (struct sched_rt_entity **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.rt_rq = (struct rt_rq **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n#endif /* CONFIG_RT_GROUP_SCHED */\n\t}\n#ifdef CONFIG_CPUMASK_OFFSTACK\n\tfor_each_possible_cpu(i) {\n\t\tper_cpu(load_balance_mask, i) = (cpumask_var_t)kzalloc_node(\n\t\t\tcpumask_size(), GFP_KERNEL, cpu_to_node(i));\n\t\tper_cpu(select_idle_mask, i) = (cpumask_var_t)kzalloc_node(\n\t\t\tcpumask_size(), GFP_KERNEL, cpu_to_node(i));\n\t}\n#endif /* CONFIG_CPUMASK_OFFSTACK */\n\n\tinit_rt_bandwidth(&def_rt_bandwidth, global_rt_period(), global_rt_runtime());\n\tinit_dl_bandwidth(&def_dl_bandwidth, global_rt_period(), global_rt_runtime());\n\n#ifdef CONFIG_SMP\n\tinit_defrootdomain();\n#endif\n\n#ifdef CONFIG_RT_GROUP_SCHED\n\tinit_rt_bandwidth(&root_task_group.rt_bandwidth,\n\t\t\tglobal_rt_period(), global_rt_runtime());\n#endif /* CONFIG_RT_GROUP_SCHED */\n\n#ifdef CONFIG_CGROUP_SCHED\n\ttask_group_cache = KMEM_CACHE(task_group, 0);\n\n\tlist_add(&root_task_group.list, &task_groups);\n\tINIT_LIST_HEAD(&root_task_group.children);\n\tINIT_LIST_HEAD(&root_task_group.siblings);\n\tautogroup_init(&init_task);\n#endif /* CONFIG_CGROUP_SCHED */\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct rq *rq;\n\n\t\trq = cpu_rq(i);\n\t\traw_spin_lock_init(&rq->lock);\n\t\trq->nr_running = 0;\n\t\trq->calc_load_active = 0;\n\t\trq->calc_load_update = jiffies + LOAD_FREQ;\n\t\tinit_cfs_rq(&rq->cfs);\n\t\tinit_rt_rq(&rq->rt);\n\t\tinit_dl_rq(&rq->dl);\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t\troot_task_group.shares = ROOT_TASK_GROUP_LOAD;\n\t\tINIT_LIST_HEAD(&rq->leaf_cfs_rq_list);\n\t\trq->tmp_alone_branch = &rq->leaf_cfs_rq_list;\n\t\t/*\n\t\t * How much CPU bandwidth does root_task_group get?\n\t\t *\n\t\t * In case of task-groups formed thr' the cgroup filesystem, it\n\t\t * gets 100% of the CPU resources in the system. This overall\n\t\t * system CPU resource is divided among the tasks of\n\t\t * root_task_group and its child task-groups in a fair manner,\n\t\t * based on each entity's (task or task-group's) weight\n\t\t * (se->load.weight).\n\t\t *\n\t\t * In other words, if root_task_group has 10 tasks of weight\n\t\t * 1024) and two child groups A0 and A1 (of weight 1024 each),\n\t\t * then A0's share of the CPU resource is:\n\t\t *\n\t\t *\tA0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33%\n\t\t *\n\t\t * We achieve this by letting root_task_group's tasks sit\n\t\t * directly in rq->cfs (i.e root_task_group->se[] = NULL).\n\t\t */\n\t\tinit_cfs_bandwidth(&root_task_group.cfs_bandwidth);\n\t\tinit_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL);\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n\n\t\trq->rt.rt_runtime = def_rt_bandwidth.rt_runtime;\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\tinit_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL);\n#endif\n\n\t\tfor (j = 0; j < CPU_LOAD_IDX_MAX; j++)\n\t\t\trq->cpu_load[j] = 0;\n\n#ifdef CONFIG_SMP\n\t\trq->sd = NULL;\n\t\trq->rd = NULL;\n\t\trq->cpu_capacity = rq->cpu_capacity_orig = SCHED_CAPACITY_SCALE;\n\t\trq->balance_callback = NULL;\n\t\trq->active_balance = 0;\n\t\trq->next_balance = jiffies;\n\t\trq->push_cpu = 0;\n\t\trq->cpu = i;\n\t\trq->online = 0;\n\t\trq->idle_stamp = 0;\n\t\trq->avg_idle = 2*sysctl_sched_migration_cost;\n\t\trq->max_idle_balance_cost = sysctl_sched_migration_cost;\n\n\t\tINIT_LIST_HEAD(&rq->cfs_tasks);\n\n\t\trq_attach_root(rq, &def_root_domain);\n#ifdef CONFIG_NO_HZ_COMMON\n\t\trq->last_load_update_tick = jiffies;\n\t\trq->last_blocked_load_update_tick = jiffies;\n\t\tatomic_set(&rq->nohz_flags, 0);\n#endif\n#endif /* CONFIG_SMP */\n\t\thrtick_rq_init(rq);\n\t\tatomic_set(&rq->nr_iowait, 0);\n\t}\n\n\tset_load_weight(&init_task, false);\n\n\t/*\n\t * The boot idle thread does lazy MMU switching as well:\n\t */\n\tmmgrab(&init_mm);\n\tenter_lazy_tlb(&init_mm, current);\n\n\t/*\n\t * Make us the idle thread. Technically, schedule() should not be\n\t * called from this thread, however somewhere below it might be,\n\t * but because we are the idle thread, we just pick up running again\n\t * when this runqueue becomes \"idle\".\n\t */\n\tinit_idle(current, smp_processor_id());\n\n\tcalc_load_update = jiffies + LOAD_FREQ;\n\n#ifdef CONFIG_SMP\n\tidle_thread_set_boot_cpu();\n#endif\n\tinit_sched_fair_class();\n\n\tinit_schedstats();\n\n\tpsi_init();\n\n\tscheduler_running = 1;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "__read_mostly int scheduler_running;",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psi_init",
          "args": [],
          "line": 6068
        },
        "resolved": true,
        "details": {
          "function_name": "psi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/psi.c",
          "lines": "170-177",
          "snippet": "void __init psi_init(void)\n{\n\tif (psi_disabled)\n\t\treturn;\n\n\tpsi_period = jiffies_to_nsecs(PSI_FREQ);\n\tgroup_init(&psi_system);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/psi.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/loadavg.h>"
          ],
          "macros_used": [
            "#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */"
          ],
          "globals_used": [
            "bool psi_disabled",
            "static u64 psi_period",
            "static struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/psi.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/cgroup.h>\n#include <linux/seqlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/loadavg.h>\n\n#define PSI_FREQ\t(2*HZ+1)\t/* 2 sec intervals */\n\nbool psi_disabled;\nstatic u64 psi_period;\nstatic struct psi_group psi_system = {\n\t.pcpu = &system_group_pcpu,\n};\n\nvoid __init psi_init(void)\n{\n\tif (psi_disabled)\n\t\treturn;\n\n\tpsi_period = jiffies_to_nsecs(PSI_FREQ);\n\tgroup_init(&psi_system);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_schedstats",
          "args": [],
          "line": 6066
        },
        "resolved": true,
        "details": {
          "function_name": "init_schedstats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2292-2292",
          "snippet": "static inline void init_schedstats(void) {}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic inline void init_schedstats(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "init_sched_fair_class",
          "args": [],
          "line": 6064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_thread_set_boot_cpu",
          "args": [],
          "line": 6062
        },
        "resolved": true,
        "details": {
          "function_name": "idle_thread_set_boot_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/smpboot.c",
          "lines": "39-42",
          "snippet": "void __init idle_thread_set_boot_cpu(void)\n{\n\tper_cpu(idle_threads, smp_processor_id()) = current;\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init idle_thread_set_boot_cpu(void)\n{\n\tper_cpu(idle_threads, smp_processor_id()) = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_idle",
          "args": [
            "current",
            "smp_processor_id()"
          ],
          "line": 6057
        },
        "resolved": true,
        "details": {
          "function_name": "init_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5366-5424",
          "snippet": "void init_idle(struct task_struct *idle, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&idle->pi_lock, flags);\n\traw_spin_lock(&rq->lock);\n\n\t__sched_fork(0, idle);\n\tidle->state = TASK_RUNNING;\n\tidle->se.exec_start = sched_clock();\n\tidle->flags |= PF_IDLE;\n\n\tkasan_unpoison_task_stack(idle);\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Its possible that init_idle() gets called multiple times on a task,\n\t * in that case do_set_cpus_allowed() will not do the right thing.\n\t *\n\t * And since this is boot we can forgo the serialization.\n\t */\n\tset_cpus_allowed_common(idle, cpumask_of(cpu));\n#endif\n\t/*\n\t * We're having a chicken and egg problem, even though we are\n\t * holding rq->lock, the CPU isn't yet set to this CPU so the\n\t * lockdep check in task_group() will fail.\n\t *\n\t * Similar case to sched_fork(). / Alternatively we could\n\t * use task_rq_lock() here and obtain the other rq->lock.\n\t *\n\t * Silence PROVE_RCU\n\t */\n\trcu_read_lock();\n\t__set_task_cpu(idle, cpu);\n\trcu_read_unlock();\n\n\trq->curr = rq->idle = idle;\n\tidle->on_rq = TASK_ON_RQ_QUEUED;\n#ifdef CONFIG_SMP\n\tidle->on_cpu = 1;\n#endif\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&idle->pi_lock, flags);\n\n\t/* Set the preempt count _outside_ the spinlocks! */\n\tinit_idle_preempt_count(idle, cpu);\n\n\t/*\n\t * The idle tasks have their own, simple scheduling class:\n\t */\n\tidle->sched_class = &idle_sched_class;\n\tftrace_graph_init_idle_task(idle, cpu);\n\tvtime_init_idle(idle, cpu);\n#ifdef CONFIG_SMP\n\tsprintf(idle->comm, \"%s/%d\", INIT_TASK_COMM, cpu);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid init_idle(struct task_struct *idle, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&idle->pi_lock, flags);\n\traw_spin_lock(&rq->lock);\n\n\t__sched_fork(0, idle);\n\tidle->state = TASK_RUNNING;\n\tidle->se.exec_start = sched_clock();\n\tidle->flags |= PF_IDLE;\n\n\tkasan_unpoison_task_stack(idle);\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Its possible that init_idle() gets called multiple times on a task,\n\t * in that case do_set_cpus_allowed() will not do the right thing.\n\t *\n\t * And since this is boot we can forgo the serialization.\n\t */\n\tset_cpus_allowed_common(idle, cpumask_of(cpu));\n#endif\n\t/*\n\t * We're having a chicken and egg problem, even though we are\n\t * holding rq->lock, the CPU isn't yet set to this CPU so the\n\t * lockdep check in task_group() will fail.\n\t *\n\t * Similar case to sched_fork(). / Alternatively we could\n\t * use task_rq_lock() here and obtain the other rq->lock.\n\t *\n\t * Silence PROVE_RCU\n\t */\n\trcu_read_lock();\n\t__set_task_cpu(idle, cpu);\n\trcu_read_unlock();\n\n\trq->curr = rq->idle = idle;\n\tidle->on_rq = TASK_ON_RQ_QUEUED;\n#ifdef CONFIG_SMP\n\tidle->on_cpu = 1;\n#endif\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&idle->pi_lock, flags);\n\n\t/* Set the preempt count _outside_ the spinlocks! */\n\tinit_idle_preempt_count(idle, cpu);\n\n\t/*\n\t * The idle tasks have their own, simple scheduling class:\n\t */\n\tidle->sched_class = &idle_sched_class;\n\tftrace_graph_init_idle_task(idle, cpu);\n\tvtime_init_idle(idle, cpu);\n#ifdef CONFIG_SMP\n\tsprintf(idle->comm, \"%s/%d\", INIT_TASK_COMM, cpu);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 6057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_lazy_tlb",
          "args": [
            "&init_mm",
            "current"
          ],
          "line": 6049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "&init_mm"
          ],
          "line": 6048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_load_weight",
          "args": [
            "&init_task",
            "false"
          ],
          "line": 6043
        },
        "resolved": true,
        "details": {
          "function_name": "set_load_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "692-718",
          "snippet": "static void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (idle_policy(p->policy)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\tp->se.runnable_weight = load->weight;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t\tp->se.runnable_weight = load->weight;\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "const int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};",
            "const u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nconst int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};\nconst u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};\n\nstatic void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (idle_policy(p->policy)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\tp->se.runnable_weight = load->weight;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t\tp->se.runnable_weight = load->weight;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rq->nr_iowait",
            "0"
          ],
          "line": 6040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtick_rq_init",
          "args": [
            "rq"
          ],
          "line": 6039
        },
        "resolved": true,
        "details": {
          "function_name": "hrtick_rq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "325-327",
          "snippet": "static inline void hrtick_rq_init(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void hrtick_rq_init(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rq->nohz_flags",
            "0"
          ],
          "line": 6036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_attach_root",
          "args": [
            "rq",
            "&def_root_domain"
          ],
          "line": 6032
        },
        "resolved": true,
        "details": {
          "function_name": "rq_attach_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "217-252",
          "snippet": "void rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\n\tif (old_rd)\n\t\tcall_rcu_sched(&old_rd->rcu, free_rootdomain);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\n\tif (old_rd)\n\t\tcall_rcu_sched(&old_rd->rcu, free_rootdomain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rq->cfs_tasks"
          ],
          "line": 6030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_tg_rt_entry",
          "args": [
            "&root_task_group",
            "&rq->rt",
            "NULL",
            "i",
            "NULL"
          ],
          "line": 6010
        },
        "resolved": true,
        "details": {
          "function_name": "init_tg_rt_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "155-180",
          "snippet": "void init_tg_rt_entry(struct task_group *tg, struct rt_rq *rt_rq,\n\t\tstruct sched_rt_entity *rt_se, int cpu,\n\t\tstruct sched_rt_entity *parent)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\trt_rq->highest_prio.curr = MAX_RT_PRIO;\n\trt_rq->rt_nr_boosted = 0;\n\trt_rq->rq = rq;\n\trt_rq->tg = tg;\n\n\ttg->rt_rq[cpu] = rt_rq;\n\ttg->rt_se[cpu] = rt_se;\n\n\tif (!rt_se)\n\t\treturn;\n\n\tif (!parent)\n\t\trt_se->rt_rq = &rq->rt;\n\telse\n\t\trt_se->rt_rq = parent->my_q;\n\n\trt_se->my_q = rt_rq;\n\trt_se->parent = parent;\n\tINIT_LIST_HEAD(&rt_se->run_list);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_top_rt_rq(struct rt_rq *rt_rq);",
            "static void dequeue_top_rt_rq(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_top_rt_rq(struct rt_rq *rt_rq);\nstatic void dequeue_top_rt_rq(struct rt_rq *rt_rq);\n\nvoid init_tg_rt_entry(struct task_group *tg, struct rt_rq *rt_rq,\n\t\tstruct sched_rt_entity *rt_se, int cpu,\n\t\tstruct sched_rt_entity *parent)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\trt_rq->highest_prio.curr = MAX_RT_PRIO;\n\trt_rq->rt_nr_boosted = 0;\n\trt_rq->rq = rq;\n\trt_rq->tg = tg;\n\n\ttg->rt_rq[cpu] = rt_rq;\n\ttg->rt_se[cpu] = rt_se;\n\n\tif (!rt_se)\n\t\treturn;\n\n\tif (!parent)\n\t\trt_se->rt_rq = &rq->rt;\n\telse\n\t\trt_se->rt_rq = parent->my_q;\n\n\trt_se->my_q = rt_rq;\n\trt_se->parent = parent;\n\tINIT_LIST_HEAD(&rt_se->run_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_tg_cfs_entry",
          "args": [
            "&root_task_group",
            "&rq->cfs",
            "NULL",
            "i",
            "NULL"
          ],
          "line": 6005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cfs_bandwidth",
          "args": [
            "&root_task_group.cfs_bandwidth"
          ],
          "line": 6004
        },
        "resolved": true,
        "details": {
          "function_name": "init_cfs_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "5007-5007",
          "snippet": "void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b) {}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nvoid init_cfs_bandwidth(struct cfs_bandwidth *cfs_b) {}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rq->leaf_cfs_rq_list"
          ],
          "line": 5983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_dl_rq",
          "args": [
            "&rq->dl"
          ],
          "line": 5980
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_rq_bw_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2465-2476",
          "snippet": "void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rt_rq",
          "args": [
            "&rq->rt"
          ],
          "line": 5979
        },
        "resolved": true,
        "details": {
          "function_name": "init_rt_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "75-102",
          "snippet": "void init_rt_rq(struct rt_rq *rt_rq)\n{\n\tstruct rt_prio_array *array;\n\tint i;\n\n\tarray = &rt_rq->active;\n\tfor (i = 0; i < MAX_RT_PRIO; i++) {\n\t\tINIT_LIST_HEAD(array->queue + i);\n\t\t__clear_bit(i, array->bitmap);\n\t}\n\t/* delimiter for bitsearch: */\n\t__set_bit(MAX_RT_PRIO, array->bitmap);\n\n#if defined CONFIG_SMP\n\trt_rq->highest_prio.curr = MAX_RT_PRIO;\n\trt_rq->highest_prio.next = MAX_RT_PRIO;\n\trt_rq->rt_nr_migratory = 0;\n\trt_rq->overloaded = 0;\n\tplist_head_init(&rt_rq->pushable_tasks);\n#endif /* CONFIG_SMP */\n\t/* We start is dequeued state, because no RT tasks are queued */\n\trt_rq->rt_queued = 0;\n\n\trt_rq->rt_time = 0;\n\trt_rq->rt_throttled = 0;\n\trt_rq->rt_runtime = 0;\n\traw_spin_lock_init(&rt_rq->rt_runtime_lock);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_top_rt_rq(struct rt_rq *rt_rq);",
            "static void dequeue_top_rt_rq(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_top_rt_rq(struct rt_rq *rt_rq);\nstatic void dequeue_top_rt_rq(struct rt_rq *rt_rq);\n\nvoid init_rt_rq(struct rt_rq *rt_rq)\n{\n\tstruct rt_prio_array *array;\n\tint i;\n\n\tarray = &rt_rq->active;\n\tfor (i = 0; i < MAX_RT_PRIO; i++) {\n\t\tINIT_LIST_HEAD(array->queue + i);\n\t\t__clear_bit(i, array->bitmap);\n\t}\n\t/* delimiter for bitsearch: */\n\t__set_bit(MAX_RT_PRIO, array->bitmap);\n\n#if defined CONFIG_SMP\n\trt_rq->highest_prio.curr = MAX_RT_PRIO;\n\trt_rq->highest_prio.next = MAX_RT_PRIO;\n\trt_rq->rt_nr_migratory = 0;\n\trt_rq->overloaded = 0;\n\tplist_head_init(&rt_rq->pushable_tasks);\n#endif /* CONFIG_SMP */\n\t/* We start is dequeued state, because no RT tasks are queued */\n\trt_rq->rt_queued = 0;\n\n\trt_rq->rt_time = 0;\n\trt_rq->rt_throttled = 0;\n\trt_rq->rt_runtime = 0;\n\traw_spin_lock_init(&rt_rq->rt_runtime_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_cfs_rq",
          "args": [
            "&rq->cfs"
          ],
          "line": 5978
        },
        "resolved": true,
        "details": {
          "function_name": "init_cfs_rq_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "5010-5010",
          "snippet": "static void init_cfs_rq_runtime(struct cfs_rq *cfs_rq) {}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic void init_cfs_rq_runtime(struct cfs_rq *cfs_rq) {}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&rq->lock"
          ],
          "line": 5974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 5973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autogroup_init",
          "args": [
            "&init_task"
          ],
          "line": 5967
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/autogroup.h",
          "lines": "42-42",
          "snippet": "static inline void autogroup_init(struct task_struct *init_task) {  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void autogroup_init(struct task_struct *init_task) {  }"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root_task_group.siblings"
          ],
          "line": 5966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root_task_group.children"
          ],
          "line": 5965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&root_task_group.list",
            "&task_groups"
          ],
          "line": 5964
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "task_group",
            "0"
          ],
          "line": 5962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rt_bandwidth",
          "args": [
            "&root_task_group.rt_bandwidth",
            "global_rt_period()",
            "global_rt_runtime()"
          ],
          "line": 5957
        },
        "resolved": true,
        "details": {
          "function_name": "init_rt_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "41-51",
          "snippet": "void init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime)\n{\n\trt_b->rt_period = ns_to_ktime(period);\n\trt_b->rt_runtime = runtime;\n\n\traw_spin_lock_init(&rt_b->rt_runtime_lock);\n\n\thrtimer_init(&rt_b->rt_period_timer,\n\t\t\tCLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\trt_b->rt_period_timer.function = sched_rt_period_timer;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime)\n{\n\trt_b->rt_period = ns_to_ktime(period);\n\trt_b->rt_runtime = runtime;\n\n\traw_spin_lock_init(&rt_b->rt_runtime_lock);\n\n\thrtimer_init(&rt_b->rt_period_timer,\n\t\t\tCLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\trt_b->rt_period_timer.function = sched_rt_period_timer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_runtime",
          "args": [],
          "line": 5958
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1513-1519",
          "snippet": "static inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RUNTIME_INF\t\t((u64)~0ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RUNTIME_INF\t\t((u64)~0ULL)\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_period",
          "args": [],
          "line": 5958
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1508-1511",
          "snippet": "static inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_defrootdomain",
          "args": [],
          "line": 5953
        },
        "resolved": true,
        "details": {
          "function_name": "init_defrootdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "312-317",
          "snippet": "void init_defrootdomain(void)\n{\n\tinit_rootdomain(&def_root_domain);\n\n\tatomic_set(&def_root_domain.refcount, 1);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct root_domain def_root_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstruct root_domain def_root_domain;\n\nvoid init_defrootdomain(void)\n{\n\tinit_rootdomain(&def_root_domain);\n\n\tatomic_set(&def_root_domain.refcount, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dl_bandwidth",
          "args": [
            "&def_dl_bandwidth",
            "global_rt_period()",
            "global_rt_runtime()"
          ],
          "line": 5950
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_bandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "338-343",
          "snippet": "void init_dl_bandwidth(struct dl_bandwidth *dl_b, u64 period, u64 runtime)\n{\n\traw_spin_lock_init(&dl_b->dl_runtime_lock);\n\tdl_b->dl_period = period;\n\tdl_b->dl_runtime = runtime;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_bandwidth(struct dl_bandwidth *dl_b, u64 period, u64 runtime)\n{\n\traw_spin_lock_init(&dl_b->dl_runtime_lock);\n\tdl_b->dl_period = period;\n\tdl_b->dl_runtime = runtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "cpumask_size()",
            "GFP_KERNEL",
            "cpu_to_node(i)"
          ],
          "line": 5944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "i"
          ],
          "line": 5945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 5945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "select_idle_mask",
            "i"
          ],
          "line": 5944
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "cpumask_size()",
            "GFP_KERNEL",
            "cpu_to_node(i)"
          ],
          "line": 5942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "i"
          ],
          "line": 5943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 5943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "alloc_size",
            "GFP_NOWAIT"
          ],
          "line": 5921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_bit_init",
          "args": [],
          "line": 5912
        },
        "resolved": true,
        "details": {
          "function_name": "wait_bit_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "243-249",
          "snippet": "void __init wait_bit_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < WAIT_TABLE_SIZE; i++)\n\t\tinit_waitqueue_head(bit_wait_table + i);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_SIZE (1 << WAIT_TABLE_BITS)"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_SIZE (1 << WAIT_TABLE_BITS)\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nvoid __init wait_bit_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < WAIT_TABLE_SIZE; i++)\n\t\tinit_waitqueue_head(bit_wait_table + i);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\n__read_mostly int scheduler_running;\nstatic __always_inline struct;\n\nvoid __init sched_init(void)\n{\n\tint i, j;\n\tunsigned long alloc_size = 0, ptr;\n\n\twait_bit_init();\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\talloc_size += 2 * nr_cpu_ids * sizeof(void **);\n#endif\n#ifdef CONFIG_RT_GROUP_SCHED\n\talloc_size += 2 * nr_cpu_ids * sizeof(void **);\n#endif\n\tif (alloc_size) {\n\t\tptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t\troot_task_group.se = (struct sched_entity **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.cfs_rq = (struct cfs_rq **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\troot_task_group.rt_se = (struct sched_rt_entity **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.rt_rq = (struct rt_rq **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n#endif /* CONFIG_RT_GROUP_SCHED */\n\t}\n#ifdef CONFIG_CPUMASK_OFFSTACK\n\tfor_each_possible_cpu(i) {\n\t\tper_cpu(load_balance_mask, i) = (cpumask_var_t)kzalloc_node(\n\t\t\tcpumask_size(), GFP_KERNEL, cpu_to_node(i));\n\t\tper_cpu(select_idle_mask, i) = (cpumask_var_t)kzalloc_node(\n\t\t\tcpumask_size(), GFP_KERNEL, cpu_to_node(i));\n\t}\n#endif /* CONFIG_CPUMASK_OFFSTACK */\n\n\tinit_rt_bandwidth(&def_rt_bandwidth, global_rt_period(), global_rt_runtime());\n\tinit_dl_bandwidth(&def_dl_bandwidth, global_rt_period(), global_rt_runtime());\n\n#ifdef CONFIG_SMP\n\tinit_defrootdomain();\n#endif\n\n#ifdef CONFIG_RT_GROUP_SCHED\n\tinit_rt_bandwidth(&root_task_group.rt_bandwidth,\n\t\t\tglobal_rt_period(), global_rt_runtime());\n#endif /* CONFIG_RT_GROUP_SCHED */\n\n#ifdef CONFIG_CGROUP_SCHED\n\ttask_group_cache = KMEM_CACHE(task_group, 0);\n\n\tlist_add(&root_task_group.list, &task_groups);\n\tINIT_LIST_HEAD(&root_task_group.children);\n\tINIT_LIST_HEAD(&root_task_group.siblings);\n\tautogroup_init(&init_task);\n#endif /* CONFIG_CGROUP_SCHED */\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct rq *rq;\n\n\t\trq = cpu_rq(i);\n\t\traw_spin_lock_init(&rq->lock);\n\t\trq->nr_running = 0;\n\t\trq->calc_load_active = 0;\n\t\trq->calc_load_update = jiffies + LOAD_FREQ;\n\t\tinit_cfs_rq(&rq->cfs);\n\t\tinit_rt_rq(&rq->rt);\n\t\tinit_dl_rq(&rq->dl);\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t\troot_task_group.shares = ROOT_TASK_GROUP_LOAD;\n\t\tINIT_LIST_HEAD(&rq->leaf_cfs_rq_list);\n\t\trq->tmp_alone_branch = &rq->leaf_cfs_rq_list;\n\t\t/*\n\t\t * How much CPU bandwidth does root_task_group get?\n\t\t *\n\t\t * In case of task-groups formed thr' the cgroup filesystem, it\n\t\t * gets 100% of the CPU resources in the system. This overall\n\t\t * system CPU resource is divided among the tasks of\n\t\t * root_task_group and its child task-groups in a fair manner,\n\t\t * based on each entity's (task or task-group's) weight\n\t\t * (se->load.weight).\n\t\t *\n\t\t * In other words, if root_task_group has 10 tasks of weight\n\t\t * 1024) and two child groups A0 and A1 (of weight 1024 each),\n\t\t * then A0's share of the CPU resource is:\n\t\t *\n\t\t *\tA0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33%\n\t\t *\n\t\t * We achieve this by letting root_task_group's tasks sit\n\t\t * directly in rq->cfs (i.e root_task_group->se[] = NULL).\n\t\t */\n\t\tinit_cfs_bandwidth(&root_task_group.cfs_bandwidth);\n\t\tinit_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL);\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n\n\t\trq->rt.rt_runtime = def_rt_bandwidth.rt_runtime;\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\tinit_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL);\n#endif\n\n\t\tfor (j = 0; j < CPU_LOAD_IDX_MAX; j++)\n\t\t\trq->cpu_load[j] = 0;\n\n#ifdef CONFIG_SMP\n\t\trq->sd = NULL;\n\t\trq->rd = NULL;\n\t\trq->cpu_capacity = rq->cpu_capacity_orig = SCHED_CAPACITY_SCALE;\n\t\trq->balance_callback = NULL;\n\t\trq->active_balance = 0;\n\t\trq->next_balance = jiffies;\n\t\trq->push_cpu = 0;\n\t\trq->cpu = i;\n\t\trq->online = 0;\n\t\trq->idle_stamp = 0;\n\t\trq->avg_idle = 2*sysctl_sched_migration_cost;\n\t\trq->max_idle_balance_cost = sysctl_sched_migration_cost;\n\n\t\tINIT_LIST_HEAD(&rq->cfs_tasks);\n\n\t\trq_attach_root(rq, &def_root_domain);\n#ifdef CONFIG_NO_HZ_COMMON\n\t\trq->last_load_update_tick = jiffies;\n\t\trq->last_blocked_load_update_tick = jiffies;\n\t\tatomic_set(&rq->nohz_flags, 0);\n#endif\n#endif /* CONFIG_SMP */\n\t\thrtick_rq_init(rq);\n\t\tatomic_set(&rq->nr_iowait, 0);\n\t}\n\n\tset_load_weight(&init_task, false);\n\n\t/*\n\t * The boot idle thread does lazy MMU switching as well:\n\t */\n\tmmgrab(&init_mm);\n\tenter_lazy_tlb(&init_mm, current);\n\n\t/*\n\t * Make us the idle thread. Technically, schedule() should not be\n\t * called from this thread, however somewhere below it might be,\n\t * but because we are the idle thread, we just pick up running again\n\t * when this runqueue becomes \"idle\".\n\t */\n\tinit_idle(current, smp_processor_id());\n\n\tcalc_load_update = jiffies + LOAD_FREQ;\n\n#ifdef CONFIG_SMP\n\tidle_thread_set_boot_cpu();\n#endif\n\tinit_sched_fair_class();\n\n\tinit_schedstats();\n\n\tpsi_init();\n\n\tscheduler_running = 1;\n}"
  },
  {
    "function_name": "in_sched_functions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5885-5890",
    "snippet": "int in_sched_functions(unsigned long addr)\n{\n\treturn in_lock_functions(addr) ||\n\t\t(addr >= (unsigned long)__sched_text_start\n\t\t&& addr < (unsigned long)__sched_text_end);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_lock_functions",
          "args": [
            "addr"
          ],
          "line": 5887
        },
        "resolved": true,
        "details": {
          "function_name": "in_lock_functions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "384-391",
          "snippet": "notrace int in_lock_functions(unsigned long addr)\n{\n\t/* Linker adds these: start and end of __lockfunc functions */\n\textern char __lock_text_start[], __lock_text_end[];\n\n\treturn addr >= (unsigned long)__lock_text_start\n\t&& addr < (unsigned long)__lock_text_end;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nnotrace int in_lock_functions(unsigned long addr)\n{\n\t/* Linker adds these: start and end of __lockfunc functions */\n\textern char __lock_text_start[], __lock_text_end[];\n\n\treturn addr >= (unsigned long)__lock_text_start\n\t&& addr < (unsigned long)__lock_text_end;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint in_sched_functions(unsigned long addr)\n{\n\treturn in_lock_functions(addr) ||\n\t\t(addr >= (unsigned long)__sched_text_start\n\t\t&& addr < (unsigned long)__sched_text_end);\n}"
  },
  {
    "function_name": "sched_init_smp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5879-5882",
    "snippet": "void __init sched_init_smp(void)\n{\n\tsched_init_granularity();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_init_granularity",
          "args": [],
          "line": 5881
        },
        "resolved": true,
        "details": {
          "function_name": "sched_init_granularity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "181-184",
          "snippet": "void sched_init_granularity(void)\n{\n\tupdate_sysctl();\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nvoid sched_init_granularity(void)\n{\n\tupdate_sysctl();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid __init sched_init_smp(void)\n{\n\tsched_init_granularity();\n}"
  },
  {
    "function_name": "migration_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5871-5875",
    "snippet": "static int __init migration_init(void)\n{\n\tsched_rq_cpu_starting(smp_processor_id());\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_rq_cpu_starting",
          "args": [
            "smp_processor_id()"
          ],
          "line": 5873
        },
        "resolved": true,
        "details": {
          "function_name": "sched_rq_cpu_starting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5805-5811",
          "snippet": "static void sched_rq_cpu_starting(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\trq->calc_load_update = calc_load_update;\n\tupdate_max_interval();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void sched_rq_cpu_starting(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\trq->calc_load_update = calc_load_update;\n\tupdate_max_interval();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 5873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic int __init migration_init(void)\n{\n\tsched_rq_cpu_starting(smp_processor_id());\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_init_smp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5847-5869",
    "snippet": "void __init sched_init_smp(void)\n{\n\tsched_init_numa();\n\n\t/*\n\t * There's no userspace yet to cause hotplug operations; hence all the\n\t * CPU masks are stable and all blatant races in the below code cannot\n\t * happen.\n\t */\n\tmutex_lock(&sched_domains_mutex);\n\tsched_init_domains(cpu_active_mask);\n\tmutex_unlock(&sched_domains_mutex);\n\n\t/* Move init over to a non-isolated CPU */\n\tif (set_cpus_allowed_ptr(current, housekeeping_cpumask(HK_FLAG_DOMAIN)) < 0)\n\t\tBUG();\n\tsched_init_granularity();\n\n\tinit_sched_rt_class();\n\tinit_sched_dl_class();\n\n\tsched_smp_initialized = true;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_sched_dl_class",
          "args": [],
          "line": 5866
        },
        "resolved": true,
        "details": {
          "function_name": "init_sched_dl_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2279-2286",
          "snippet": "void __init init_sched_dl_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask_dl, i),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(i));\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid __init init_sched_dl_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask_dl, i),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(i));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_sched_rt_class",
          "args": [],
          "line": 5865
        },
        "resolved": true,
        "details": {
          "function_name": "init_sched_rt_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2212-2220",
          "snippet": "void __init init_sched_rt_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i) {\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask, i),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(i));\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid __init init_sched_rt_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i) {\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask, i),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(i));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_init_granularity",
          "args": [],
          "line": 5863
        },
        "resolved": true,
        "details": {
          "function_name": "sched_init_granularity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "181-184",
          "snippet": "void sched_init_granularity(void)\n{\n\tupdate_sysctl();\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nvoid sched_init_granularity(void)\n{\n\tupdate_sysctl();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 5862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 5861
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1126-1129",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_DOMAIN"
          ],
          "line": 5861
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/isolation.c",
          "lines": "25-31",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 5858
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_init_domains",
          "args": [
            "cpu_active_mask"
          ],
          "line": 5857
        },
        "resolved": true,
        "details": {
          "function_name": "sched_init_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1857-1875",
          "snippet": "int sched_init_domains(const struct cpumask *cpu_map)\n{\n\tint err;\n\n\tzalloc_cpumask_var(&sched_domains_tmpmask, GFP_KERNEL);\n\tzalloc_cpumask_var(&sched_domains_tmpmask2, GFP_KERNEL);\n\tzalloc_cpumask_var(&fallback_doms, GFP_KERNEL);\n\n\tarch_update_cpu_topology();\n\tndoms_cur = 1;\n\tdoms_cur = alloc_sched_domains(ndoms_cur);\n\tif (!doms_cur)\n\t\tdoms_cur = &fallback_doms;\n\tcpumask_and(doms_cur[0], cpu_map, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\terr = build_sched_domains(doms_cur[0], NULL);\n\tregister_sched_domain_sysctl();\n\n\treturn err;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t sched_domains_tmpmask;",
            "static cpumask_var_t sched_domains_tmpmask2;",
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);",
            "static cpumask_var_t\t\t\t*doms_cur;",
            "static int\t\t\t\tndoms_cur;",
            "static cpumask_var_t\t\t\tfallback_doms;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\nstatic cpumask_var_t sched_domains_tmpmask2;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\nstatic cpumask_var_t\t\t\t*doms_cur;\nstatic int\t\t\t\tndoms_cur;\nstatic cpumask_var_t\t\t\tfallback_doms;\n\nint sched_init_domains(const struct cpumask *cpu_map)\n{\n\tint err;\n\n\tzalloc_cpumask_var(&sched_domains_tmpmask, GFP_KERNEL);\n\tzalloc_cpumask_var(&sched_domains_tmpmask2, GFP_KERNEL);\n\tzalloc_cpumask_var(&fallback_doms, GFP_KERNEL);\n\n\tarch_update_cpu_topology();\n\tndoms_cur = 1;\n\tdoms_cur = alloc_sched_domains(ndoms_cur);\n\tif (!doms_cur)\n\t\tdoms_cur = &fallback_doms;\n\tcpumask_and(doms_cur[0], cpu_map, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\terr = build_sched_domains(doms_cur[0], NULL);\n\tregister_sched_domain_sysctl();\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 5856
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_init_numa",
          "args": [],
          "line": 5849
        },
        "resolved": true,
        "details": {
          "function_name": "sched_init_numa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1333-1481",
          "snippet": "void sched_init_numa(void)\n{\n\tint next_distance, curr_distance = node_distance(0, 0);\n\tstruct sched_domain_topology_level *tl;\n\tint level = 0;\n\tint i, j, k;\n\n\tsched_domains_numa_distance = kzalloc(sizeof(int) * (nr_node_ids + 1), GFP_KERNEL);\n\tif (!sched_domains_numa_distance)\n\t\treturn;\n\n\t/* Includes NUMA identity node at level 0. */\n\tsched_domains_numa_distance[level++] = curr_distance;\n\tsched_domains_numa_levels = level;\n\n\t/*\n\t * O(nr_nodes^2) deduplicating selection sort -- in order to find the\n\t * unique distances in the node_distance() table.\n\t *\n\t * Assumes node_distance(0,j) includes all distances in\n\t * node_distance(i,j) in order to avoid cubic time.\n\t */\n\tnext_distance = curr_distance;\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tfor (k = 0; k < nr_node_ids; k++) {\n\t\t\t\tint distance = node_distance(i, k);\n\n\t\t\t\tif (distance > curr_distance &&\n\t\t\t\t    (distance < next_distance ||\n\t\t\t\t     next_distance == curr_distance))\n\t\t\t\t\tnext_distance = distance;\n\n\t\t\t\t/*\n\t\t\t\t * While not a strong assumption it would be nice to know\n\t\t\t\t * about cases where if node A is connected to B, B is not\n\t\t\t\t * equally connected to A.\n\t\t\t\t */\n\t\t\t\tif (sched_debug() && node_distance(k, i) != distance)\n\t\t\t\t\tsched_numa_warn(\"Node-distance not symmetric\");\n\n\t\t\t\tif (sched_debug() && i && !find_numa_distance(distance))\n\t\t\t\t\tsched_numa_warn(\"Node-0 not representative\");\n\t\t\t}\n\t\t\tif (next_distance != curr_distance) {\n\t\t\t\tsched_domains_numa_distance[level++] = next_distance;\n\t\t\t\tsched_domains_numa_levels = level;\n\t\t\t\tcurr_distance = next_distance;\n\t\t\t} else break;\n\t\t}\n\n\t\t/*\n\t\t * In case of sched_debug() we verify the above assumption.\n\t\t */\n\t\tif (!sched_debug())\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * 'level' contains the number of unique distances\n\t *\n\t * The sched_domains_numa_distance[] array includes the actual distance\n\t * numbers.\n\t */\n\n\t/*\n\t * Here, we should temporarily reset sched_domains_numa_levels to 0.\n\t * If it fails to allocate memory for array sched_domains_numa_masks[][],\n\t * the array will contain less then 'level' members. This could be\n\t * dangerous when we use it to iterate array sched_domains_numa_masks[][]\n\t * in other functions.\n\t *\n\t * We reset it to 'level' at the end of this function.\n\t */\n\tsched_domains_numa_levels = 0;\n\n\tsched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL);\n\tif (!sched_domains_numa_masks)\n\t\treturn;\n\n\t/*\n\t * Now for each level, construct a mask per node which contains all\n\t * CPUs of nodes that are that many hops away from us.\n\t */\n\tfor (i = 0; i < level; i++) {\n\t\tsched_domains_numa_masks[i] =\n\t\t\tkzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL);\n\t\tif (!sched_domains_numa_masks[i])\n\t\t\treturn;\n\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tstruct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL);\n\t\t\tif (!mask)\n\t\t\t\treturn;\n\n\t\t\tsched_domains_numa_masks[i][j] = mask;\n\n\t\t\tfor_each_node(k) {\n\t\t\t\tif (node_distance(j, k) > sched_domains_numa_distance[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcpumask_or(mask, mask, cpumask_of_node(k));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compute default topology size */\n\tfor (i = 0; sched_domain_topology[i].mask; i++);\n\n\ttl = kzalloc((i + level + 1) *\n\t\t\tsizeof(struct sched_domain_topology_level), GFP_KERNEL);\n\tif (!tl)\n\t\treturn;\n\n\t/*\n\t * Copy the default topology bits..\n\t */\n\tfor (i = 0; sched_domain_topology[i].mask; i++)\n\t\ttl[i] = sched_domain_topology[i];\n\n\t/*\n\t * Add the NUMA identity distance, aka single NODE.\n\t */\n\ttl[i++] = (struct sched_domain_topology_level){\n\t\t.mask = sd_numa_mask,\n\t\t.numa_level = 0,\n\t\tSD_INIT_NAME(NODE)\n\t};\n\n\t/*\n\t * .. and append 'j' levels of NUMA goodness.\n\t */\n\tfor (j = 1; j < level; i++, j++) {\n\t\ttl[i] = (struct sched_domain_topology_level){\n\t\t\t.mask = sd_numa_mask,\n\t\t\t.sd_flags = cpu_numa_flags,\n\t\t\t.flags = SDTL_OVERLAP,\n\t\t\t.numa_level = j,\n\t\t\tSD_INIT_NAME(NUMA)\n\t\t};\n\t}\n\n\tsched_domain_topology = tl;\n\n\tsched_domains_numa_levels = level;\n\tsched_max_numa_distance = sched_domains_numa_distance[level - 1];\n\n\tinit_numa_topology_type();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nvoid sched_init_numa(void)\n{\n\tint next_distance, curr_distance = node_distance(0, 0);\n\tstruct sched_domain_topology_level *tl;\n\tint level = 0;\n\tint i, j, k;\n\n\tsched_domains_numa_distance = kzalloc(sizeof(int) * (nr_node_ids + 1), GFP_KERNEL);\n\tif (!sched_domains_numa_distance)\n\t\treturn;\n\n\t/* Includes NUMA identity node at level 0. */\n\tsched_domains_numa_distance[level++] = curr_distance;\n\tsched_domains_numa_levels = level;\n\n\t/*\n\t * O(nr_nodes^2) deduplicating selection sort -- in order to find the\n\t * unique distances in the node_distance() table.\n\t *\n\t * Assumes node_distance(0,j) includes all distances in\n\t * node_distance(i,j) in order to avoid cubic time.\n\t */\n\tnext_distance = curr_distance;\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tfor (k = 0; k < nr_node_ids; k++) {\n\t\t\t\tint distance = node_distance(i, k);\n\n\t\t\t\tif (distance > curr_distance &&\n\t\t\t\t    (distance < next_distance ||\n\t\t\t\t     next_distance == curr_distance))\n\t\t\t\t\tnext_distance = distance;\n\n\t\t\t\t/*\n\t\t\t\t * While not a strong assumption it would be nice to know\n\t\t\t\t * about cases where if node A is connected to B, B is not\n\t\t\t\t * equally connected to A.\n\t\t\t\t */\n\t\t\t\tif (sched_debug() && node_distance(k, i) != distance)\n\t\t\t\t\tsched_numa_warn(\"Node-distance not symmetric\");\n\n\t\t\t\tif (sched_debug() && i && !find_numa_distance(distance))\n\t\t\t\t\tsched_numa_warn(\"Node-0 not representative\");\n\t\t\t}\n\t\t\tif (next_distance != curr_distance) {\n\t\t\t\tsched_domains_numa_distance[level++] = next_distance;\n\t\t\t\tsched_domains_numa_levels = level;\n\t\t\t\tcurr_distance = next_distance;\n\t\t\t} else break;\n\t\t}\n\n\t\t/*\n\t\t * In case of sched_debug() we verify the above assumption.\n\t\t */\n\t\tif (!sched_debug())\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * 'level' contains the number of unique distances\n\t *\n\t * The sched_domains_numa_distance[] array includes the actual distance\n\t * numbers.\n\t */\n\n\t/*\n\t * Here, we should temporarily reset sched_domains_numa_levels to 0.\n\t * If it fails to allocate memory for array sched_domains_numa_masks[][],\n\t * the array will contain less then 'level' members. This could be\n\t * dangerous when we use it to iterate array sched_domains_numa_masks[][]\n\t * in other functions.\n\t *\n\t * We reset it to 'level' at the end of this function.\n\t */\n\tsched_domains_numa_levels = 0;\n\n\tsched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL);\n\tif (!sched_domains_numa_masks)\n\t\treturn;\n\n\t/*\n\t * Now for each level, construct a mask per node which contains all\n\t * CPUs of nodes that are that many hops away from us.\n\t */\n\tfor (i = 0; i < level; i++) {\n\t\tsched_domains_numa_masks[i] =\n\t\t\tkzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL);\n\t\tif (!sched_domains_numa_masks[i])\n\t\t\treturn;\n\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tstruct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL);\n\t\t\tif (!mask)\n\t\t\t\treturn;\n\n\t\t\tsched_domains_numa_masks[i][j] = mask;\n\n\t\t\tfor_each_node(k) {\n\t\t\t\tif (node_distance(j, k) > sched_domains_numa_distance[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcpumask_or(mask, mask, cpumask_of_node(k));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compute default topology size */\n\tfor (i = 0; sched_domain_topology[i].mask; i++);\n\n\ttl = kzalloc((i + level + 1) *\n\t\t\tsizeof(struct sched_domain_topology_level), GFP_KERNEL);\n\tif (!tl)\n\t\treturn;\n\n\t/*\n\t * Copy the default topology bits..\n\t */\n\tfor (i = 0; sched_domain_topology[i].mask; i++)\n\t\ttl[i] = sched_domain_topology[i];\n\n\t/*\n\t * Add the NUMA identity distance, aka single NODE.\n\t */\n\ttl[i++] = (struct sched_domain_topology_level){\n\t\t.mask = sd_numa_mask,\n\t\t.numa_level = 0,\n\t\tSD_INIT_NAME(NODE)\n\t};\n\n\t/*\n\t * .. and append 'j' levels of NUMA goodness.\n\t */\n\tfor (j = 1; j < level; i++, j++) {\n\t\ttl[i] = (struct sched_domain_topology_level){\n\t\t\t.mask = sd_numa_mask,\n\t\t\t.sd_flags = cpu_numa_flags,\n\t\t\t.flags = SDTL_OVERLAP,\n\t\t\t.numa_level = j,\n\t\t\tSD_INIT_NAME(NUMA)\n\t\t};\n\t}\n\n\tsched_domain_topology = tl;\n\n\tsched_domains_numa_levels = level;\n\tsched_max_numa_distance = sched_domains_numa_distance[level - 1];\n\n\tinit_numa_topology_type();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid __init sched_init_smp(void)\n{\n\tsched_init_numa();\n\n\t/*\n\t * There's no userspace yet to cause hotplug operations; hence all the\n\t * CPU masks are stable and all blatant races in the below code cannot\n\t * happen.\n\t */\n\tmutex_lock(&sched_domains_mutex);\n\tsched_init_domains(cpu_active_mask);\n\tmutex_unlock(&sched_domains_mutex);\n\n\t/* Move init over to a non-isolated CPU */\n\tif (set_cpus_allowed_ptr(current, housekeeping_cpumask(HK_FLAG_DOMAIN)) < 0)\n\t\tBUG();\n\tsched_init_granularity();\n\n\tinit_sched_rt_class();\n\tinit_sched_dl_class();\n\n\tsched_smp_initialized = true;\n}"
  },
  {
    "function_name": "sched_cpu_dying",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5821-5844",
    "snippet": "int sched_cpu_dying(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\t/* Handle pending wakeups and then migrate everything off */\n\tsched_ttwu_pending();\n\tsched_tick_stop(cpu);\n\n\trq_lock_irqsave(rq, &rf);\n\tif (rq->rd) {\n\t\tBUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));\n\t\tset_rq_offline(rq);\n\t}\n\tmigrate_tasks(rq, &rf);\n\tBUG_ON(rq->nr_running != 1);\n\trq_unlock_irqrestore(rq, &rf);\n\n\tcalc_load_migrate(rq);\n\tupdate_max_interval();\n\tnohz_balance_exit_idle(rq);\n\thrtick_clear(rq);\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtick_clear",
          "args": [
            "rq"
          ],
          "line": 5842
        },
        "resolved": true,
        "details": {
          "function_name": "hrtick_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "321-323",
          "snippet": "static inline void hrtick_clear(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void hrtick_clear(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "nohz_balance_exit_idle",
          "args": [
            "rq"
          ],
          "line": 5841
        },
        "resolved": true,
        "details": {
          "function_name": "nohz_balance_exit_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2105-2105",
          "snippet": "static inline void nohz_balance_exit_idle(struct rq *rq) { }",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void nohz_balance_exit_idle(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "update_max_interval",
          "args": [],
          "line": 5840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load_migrate",
          "args": [
            "rq"
          ],
          "line": 5839
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5546-5551",
          "snippet": "static void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq, 1);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq, 1);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unlock_irqrestore",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 5837
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1138-1144",
          "snippet": "static inline void\nrq_unlock_irqrestore(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irqrestore(&rq->lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nrq_unlock_irqrestore(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irqrestore(&rq->lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rq->nr_running != 1"
          ],
          "line": 5836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_tasks",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 5835
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5577-5653",
          "snippet": "static void migrate_tasks(struct rq *dead_rq, struct rq_flags *rf)\n{\n\tstruct rq *rq = dead_rq;\n\tstruct task_struct *next, *stop = rq->stop;\n\tstruct rq_flags orf = *rf;\n\tint dest_cpu;\n\n\t/*\n\t * Fudge the rq selection such that the below task selection loop\n\t * doesn't get stuck on the currently eligible stop task.\n\t *\n\t * We're currently inside stop_machine() and the rq is either stuck\n\t * in the stop_machine_cpu_stop() loop, or we're executing this code,\n\t * either way we should never end up calling schedule() until we're\n\t * done here.\n\t */\n\trq->stop = NULL;\n\n\t/*\n\t * put_prev_task() and pick_next_task() sched\n\t * class method both need to have an up-to-date\n\t * value of rq->clock[_task]\n\t */\n\tupdate_rq_clock(rq);\n\n\tfor (;;) {\n\t\t/*\n\t\t * There's this thread running, bail when that's the only\n\t\t * remaining thread:\n\t\t */\n\t\tif (rq->nr_running == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * pick_next_task() assumes pinned rq->lock:\n\t\t */\n\t\tnext = pick_next_task(rq, &fake_task, rf);\n\t\tBUG_ON(!next);\n\t\tput_prev_task(rq, next);\n\n\t\t/*\n\t\t * Rules for changing task_struct::cpus_allowed are holding\n\t\t * both pi_lock and rq->lock, such that holding either\n\t\t * stabilizes the mask.\n\t\t *\n\t\t * Drop rq->lock is not quite as disastrous as it usually is\n\t\t * because !cpu_active at this point, which means load-balance\n\t\t * will not interfere. Also, stop-machine.\n\t\t */\n\t\trq_unlock(rq, rf);\n\t\traw_spin_lock(&next->pi_lock);\n\t\trq_relock(rq, rf);\n\n\t\t/*\n\t\t * Since we're inside stop-machine, _nothing_ should have\n\t\t * changed the task, WARN if weird stuff happened, because in\n\t\t * that case the above rq->lock drop is a fail too.\n\t\t */\n\t\tif (WARN_ON(task_rq(next) != rq || !task_on_rq_queued(next))) {\n\t\t\traw_spin_unlock(&next->pi_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find suitable destination for @next, with force if needed. */\n\t\tdest_cpu = select_fallback_rq(dead_rq->cpu, next);\n\t\trq = __migrate_task(rq, rf, next, dest_cpu);\n\t\tif (rq != dead_rq) {\n\t\t\trq_unlock(rq, rf);\n\t\t\trq = dead_rq;\n\t\t\t*rf = orf;\n\t\t\trq_relock(rq, rf);\n\t\t}\n\t\traw_spin_unlock(&next->pi_lock);\n\t}\n\n\trq->stop = stop;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void migrate_tasks(struct rq *dead_rq, struct rq_flags *rf)\n{\n\tstruct rq *rq = dead_rq;\n\tstruct task_struct *next, *stop = rq->stop;\n\tstruct rq_flags orf = *rf;\n\tint dest_cpu;\n\n\t/*\n\t * Fudge the rq selection such that the below task selection loop\n\t * doesn't get stuck on the currently eligible stop task.\n\t *\n\t * We're currently inside stop_machine() and the rq is either stuck\n\t * in the stop_machine_cpu_stop() loop, or we're executing this code,\n\t * either way we should never end up calling schedule() until we're\n\t * done here.\n\t */\n\trq->stop = NULL;\n\n\t/*\n\t * put_prev_task() and pick_next_task() sched\n\t * class method both need to have an up-to-date\n\t * value of rq->clock[_task]\n\t */\n\tupdate_rq_clock(rq);\n\n\tfor (;;) {\n\t\t/*\n\t\t * There's this thread running, bail when that's the only\n\t\t * remaining thread:\n\t\t */\n\t\tif (rq->nr_running == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * pick_next_task() assumes pinned rq->lock:\n\t\t */\n\t\tnext = pick_next_task(rq, &fake_task, rf);\n\t\tBUG_ON(!next);\n\t\tput_prev_task(rq, next);\n\n\t\t/*\n\t\t * Rules for changing task_struct::cpus_allowed are holding\n\t\t * both pi_lock and rq->lock, such that holding either\n\t\t * stabilizes the mask.\n\t\t *\n\t\t * Drop rq->lock is not quite as disastrous as it usually is\n\t\t * because !cpu_active at this point, which means load-balance\n\t\t * will not interfere. Also, stop-machine.\n\t\t */\n\t\trq_unlock(rq, rf);\n\t\traw_spin_lock(&next->pi_lock);\n\t\trq_relock(rq, rf);\n\n\t\t/*\n\t\t * Since we're inside stop-machine, _nothing_ should have\n\t\t * changed the task, WARN if weird stuff happened, because in\n\t\t * that case the above rq->lock drop is a fail too.\n\t\t */\n\t\tif (WARN_ON(task_rq(next) != rq || !task_on_rq_queued(next))) {\n\t\t\traw_spin_unlock(&next->pi_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find suitable destination for @next, with force if needed. */\n\t\tdest_cpu = select_fallback_rq(dead_rq->cpu, next);\n\t\trq = __migrate_task(rq, rf, next, dest_cpu);\n\t\tif (rq != dead_rq) {\n\t\t\trq_unlock(rq, rf);\n\t\t\trq = dead_rq;\n\t\t\t*rf = orf;\n\t\t\trq_relock(rq, rf);\n\t\t}\n\t\traw_spin_unlock(&next->pi_lock);\n\t}\n\n\trq->stop = stop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rq_offline",
          "args": [
            "rq"
          ],
          "line": 5833
        },
        "resolved": true,
        "details": {
          "function_name": "set_rq_offline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5671-5684",
          "snippet": "void set_rq_offline(struct rq *rq)\n{\n\tif (rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_offline)\n\t\t\t\tclass->rq_offline(rq);\n\t\t}\n\n\t\tcpumask_clear_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 0;\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_rq_offline(struct rq *rq)\n{\n\tif (rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_offline)\n\t\t\t\tclass->rq_offline(rq);\n\t\t}\n\n\t\tcpumask_clear_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cpumask_test_cpu(cpu, rq->rd->span)"
          ],
          "line": 5832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "rq->rd->span"
          ],
          "line": 5832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_lock_irqsave",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 5830
        },
        "resolved": true,
        "details": {
          "function_name": "rq_lock_irqsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1106-1112",
          "snippet": "static inline void\nrq_lock_irqsave(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irqsave(&rq->lock, rf->flags);\n\trq_pin_lock(rq, rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nrq_lock_irqsave(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irqsave(&rq->lock, rf->flags);\n\trq_pin_lock(rq, rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_tick_stop",
          "args": [
            "cpu"
          ],
          "line": 5828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_ttwu_pending",
          "args": [],
          "line": 5827
        },
        "resolved": true,
        "details": {
          "function_name": "sched_ttwu_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1731-1748",
          "snippet": "void sched_ttwu_pending(void)\n{\n\tstruct rq *rq = this_rq();\n\tstruct llist_node *llist = llist_del_all(&rq->wake_list);\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry)\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\n\trq_unlock_irqrestore(rq, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_ttwu_pending(void)\n{\n\tstruct rq *rq = this_rq();\n\tstruct llist_node *llist = llist_del_all(&rq->wake_list);\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry)\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\n\trq_unlock_irqrestore(rq, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 5823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_cpu_dying(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\t/* Handle pending wakeups and then migrate everything off */\n\tsched_ttwu_pending();\n\tsched_tick_stop(cpu);\n\n\trq_lock_irqsave(rq, &rf);\n\tif (rq->rd) {\n\t\tBUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));\n\t\tset_rq_offline(rq);\n\t}\n\tmigrate_tasks(rq, &rf);\n\tBUG_ON(rq->nr_running != 1);\n\trq_unlock_irqrestore(rq, &rf);\n\n\tcalc_load_migrate(rq);\n\tupdate_max_interval();\n\tnohz_balance_exit_idle(rq);\n\thrtick_clear(rq);\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_cpu_starting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5813-5818",
    "snippet": "int sched_cpu_starting(unsigned int cpu)\n{\n\tsched_rq_cpu_starting(cpu);\n\tsched_tick_start(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_tick_start",
          "args": [
            "cpu"
          ],
          "line": 5816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_rq_cpu_starting",
          "args": [
            "cpu"
          ],
          "line": 5815
        },
        "resolved": true,
        "details": {
          "function_name": "sched_rq_cpu_starting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5805-5811",
          "snippet": "static void sched_rq_cpu_starting(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\trq->calc_load_update = calc_load_update;\n\tupdate_max_interval();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void sched_rq_cpu_starting(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\trq->calc_load_update = calc_load_update;\n\tupdate_max_interval();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint sched_cpu_starting(unsigned int cpu)\n{\n\tsched_rq_cpu_starting(cpu);\n\tsched_tick_start(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_rq_cpu_starting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5805-5811",
    "snippet": "static void sched_rq_cpu_starting(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\trq->calc_load_update = calc_load_update;\n\tupdate_max_interval();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_max_interval",
          "args": [],
          "line": 5810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 5807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void sched_rq_cpu_starting(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\trq->calc_load_update = calc_load_update;\n\tupdate_max_interval();\n}"
  },
  {
    "function_name": "sched_cpu_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5779-5803",
    "snippet": "int sched_cpu_deactivate(unsigned int cpu)\n{\n\tint ret;\n\n\tset_cpu_active(cpu, false);\n\t/*\n\t * We've cleared cpu_active_mask, wait for all preempt-disabled and RCU\n\t * users of this state to go away such that all new such users will\n\t * observe it.\n\t *\n\t * Do sync before park smpboot threads to take care the rcu boost case.\n\t */\n\tsynchronize_rcu_mult(call_rcu, call_rcu_sched);\n\n\tif (!sched_smp_initialized)\n\t\treturn 0;\n\n\tret = cpuset_cpu_inactive(cpu);\n\tif (ret) {\n\t\tset_cpu_active(cpu, true);\n\t\treturn ret;\n\t}\n\tsched_domains_numa_masks_clear(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_domains_numa_masks_clear",
          "args": [
            "cpu"
          ],
          "line": 5801
        },
        "resolved": true,
        "details": {
          "function_name": "sched_domains_numa_masks_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1496-1504",
          "snippet": "void sched_domains_numa_masks_clear(unsigned int cpu)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tcpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid sched_domains_numa_masks_clear(unsigned int cpu)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tcpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_active",
          "args": [
            "cpu",
            "true"
          ],
          "line": 5798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_cpu_inactive",
          "args": [
            "cpu"
          ],
          "line": 5796
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_cpu_inactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5721-5732",
          "snippet": "static int cpuset_cpu_inactive(unsigned int cpu)\n{\n\tif (!cpuhp_tasks_frozen) {\n\t\tif (dl_cpu_busy(cpu))\n\t\t\treturn -EBUSY;\n\t\tcpuset_update_active_cpus();\n\t} else {\n\t\tnum_cpus_frozen++;\n\t\tpartition_sched_domains(1, NULL, NULL);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic int cpuset_cpu_inactive(unsigned int cpu)\n{\n\tif (!cpuhp_tasks_frozen) {\n\t\tif (dl_cpu_busy(cpu))\n\t\t\treturn -EBUSY;\n\t\tcpuset_update_active_cpus();\n\t} else {\n\t\tnum_cpus_frozen++;\n\t\tpartition_sched_domains(1, NULL, NULL);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_mult",
          "args": [
            "call_rcu",
            "call_rcu_sched"
          ],
          "line": 5791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_active",
          "args": [
            "cpu",
            "false"
          ],
          "line": 5783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint sched_cpu_deactivate(unsigned int cpu)\n{\n\tint ret;\n\n\tset_cpu_active(cpu, false);\n\t/*\n\t * We've cleared cpu_active_mask, wait for all preempt-disabled and RCU\n\t * users of this state to go away such that all new such users will\n\t * observe it.\n\t *\n\t * Do sync before park smpboot threads to take care the rcu boost case.\n\t */\n\tsynchronize_rcu_mult(call_rcu, call_rcu_sched);\n\n\tif (!sched_smp_initialized)\n\t\treturn 0;\n\n\tret = cpuset_cpu_inactive(cpu);\n\tif (ret) {\n\t\tset_cpu_active(cpu, true);\n\t\treturn ret;\n\t}\n\tsched_domains_numa_masks_clear(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_cpu_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5734-5777",
    "snippet": "int sched_cpu_activate(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n#ifdef CONFIG_SCHED_SMT\n\t/*\n\t * The sched_smt_present static key needs to be evaluated on every\n\t * hotplug event because at boot time SMT might be disabled when\n\t * the number of booted CPUs is limited.\n\t *\n\t * If then later a sibling gets hotplugged, then the key would stay\n\t * off and SMT scheduling would never be functional.\n\t */\n\tif (cpumask_weight(cpu_smt_mask(cpu)) > 1)\n\t\tstatic_branch_enable_cpuslocked(&sched_smt_present);\n#endif\n\tset_cpu_active(cpu, true);\n\n\tif (sched_smp_initialized) {\n\t\tsched_domains_numa_masks_set(cpu);\n\t\tcpuset_cpu_active();\n\t}\n\n\t/*\n\t * Put the rq online, if not already. This happens:\n\t *\n\t * 1) In the early boot process, because we build the real domains\n\t *    after all CPUs have been brought up.\n\t *\n\t * 2) At runtime, if cpuset_cpu_active() fails to rebuild the\n\t *    domains.\n\t */\n\trq_lock_irqsave(rq, &rf);\n\tif (rq->rd) {\n\t\tBUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));\n\t\tset_rq_online(rq);\n\t}\n\trq_unlock_irqrestore(rq, &rf);\n\n\tupdate_max_interval();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_max_interval",
          "args": [],
          "line": 5774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_unlock_irqrestore",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 5772
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1138-1144",
          "snippet": "static inline void\nrq_unlock_irqrestore(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irqrestore(&rq->lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nrq_unlock_irqrestore(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irqrestore(&rq->lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rq_online",
          "args": [
            "rq"
          ],
          "line": 5770
        },
        "resolved": true,
        "details": {
          "function_name": "set_rq_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5656-5669",
          "snippet": "void set_rq_online(struct rq *rq)\n{\n\tif (!rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tcpumask_set_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 1;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_online)\n\t\t\t\tclass->rq_online(rq);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_rq_online(struct rq *rq)\n{\n\tif (!rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tcpumask_set_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 1;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_online)\n\t\t\t\tclass->rq_online(rq);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cpumask_test_cpu(cpu, rq->rd->span)"
          ],
          "line": 5769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "rq->rd->span"
          ],
          "line": 5769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_lock_irqsave",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 5767
        },
        "resolved": true,
        "details": {
          "function_name": "rq_lock_irqsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1106-1112",
          "snippet": "static inline void\nrq_lock_irqsave(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irqsave(&rq->lock, rf->flags);\n\trq_pin_lock(rq, rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nrq_lock_irqsave(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irqsave(&rq->lock, rf->flags);\n\trq_pin_lock(rq, rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_cpu_active",
          "args": [],
          "line": 5755
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_cpu_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5699-5719",
          "snippet": "static void cpuset_cpu_active(void)\n{\n\tif (cpuhp_tasks_frozen) {\n\t\t/*\n\t\t * num_cpus_frozen tracks how many CPUs are involved in suspend\n\t\t * resume sequence. As long as this is not the last online\n\t\t * operation in the resume sequence, just build a single sched\n\t\t * domain, ignoring cpusets.\n\t\t */\n\t\tpartition_sched_domains(1, NULL, NULL);\n\t\tif (--num_cpus_frozen)\n\t\t\treturn;\n\t\t/*\n\t\t * This is the last CPU online operation. So fall through and\n\t\t * restore the original sched domains by considering the\n\t\t * cpuset configurations.\n\t\t */\n\t\tcpuset_force_rebuild();\n\t}\n\tcpuset_update_active_cpus();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void cpuset_cpu_active(void)\n{\n\tif (cpuhp_tasks_frozen) {\n\t\t/*\n\t\t * num_cpus_frozen tracks how many CPUs are involved in suspend\n\t\t * resume sequence. As long as this is not the last online\n\t\t * operation in the resume sequence, just build a single sched\n\t\t * domain, ignoring cpusets.\n\t\t */\n\t\tpartition_sched_domains(1, NULL, NULL);\n\t\tif (--num_cpus_frozen)\n\t\t\treturn;\n\t\t/*\n\t\t * This is the last CPU online operation. So fall through and\n\t\t * restore the original sched domains by considering the\n\t\t * cpuset configurations.\n\t\t */\n\t\tcpuset_force_rebuild();\n\t}\n\tcpuset_update_active_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_domains_numa_masks_set",
          "args": [
            "cpu"
          ],
          "line": 5754
        },
        "resolved": true,
        "details": {
          "function_name": "sched_domains_numa_masks_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1483-1494",
          "snippet": "void sched_domains_numa_masks_set(unsigned int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (node_distance(j, node) <= sched_domains_numa_distance[i])\n\t\t\t\tcpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid sched_domains_numa_masks_set(unsigned int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (node_distance(j, node) <= sched_domains_numa_distance[i])\n\t\t\t\tcpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_active",
          "args": [
            "cpu",
            "true"
          ],
          "line": 5751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable_cpuslocked",
          "args": [
            "&sched_smt_present"
          ],
          "line": 5749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cpu_smt_mask(cpu)"
          ],
          "line": 5748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_smt_mask",
          "args": [
            "cpu"
          ],
          "line": 5748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 5736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_cpu_activate(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n#ifdef CONFIG_SCHED_SMT\n\t/*\n\t * The sched_smt_present static key needs to be evaluated on every\n\t * hotplug event because at boot time SMT might be disabled when\n\t * the number of booted CPUs is limited.\n\t *\n\t * If then later a sibling gets hotplugged, then the key would stay\n\t * off and SMT scheduling would never be functional.\n\t */\n\tif (cpumask_weight(cpu_smt_mask(cpu)) > 1)\n\t\tstatic_branch_enable_cpuslocked(&sched_smt_present);\n#endif\n\tset_cpu_active(cpu, true);\n\n\tif (sched_smp_initialized) {\n\t\tsched_domains_numa_masks_set(cpu);\n\t\tcpuset_cpu_active();\n\t}\n\n\t/*\n\t * Put the rq online, if not already. This happens:\n\t *\n\t * 1) In the early boot process, because we build the real domains\n\t *    after all CPUs have been brought up.\n\t *\n\t * 2) At runtime, if cpuset_cpu_active() fails to rebuild the\n\t *    domains.\n\t */\n\trq_lock_irqsave(rq, &rf);\n\tif (rq->rd) {\n\t\tBUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));\n\t\tset_rq_online(rq);\n\t}\n\trq_unlock_irqrestore(rq, &rf);\n\n\tupdate_max_interval();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuset_cpu_inactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5721-5732",
    "snippet": "static int cpuset_cpu_inactive(unsigned int cpu)\n{\n\tif (!cpuhp_tasks_frozen) {\n\t\tif (dl_cpu_busy(cpu))\n\t\t\treturn -EBUSY;\n\t\tcpuset_update_active_cpus();\n\t} else {\n\t\tnum_cpus_frozen++;\n\t\tpartition_sched_domains(1, NULL, NULL);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "partition_sched_domains",
          "args": [
            "1",
            "NULL",
            "NULL"
          ],
          "line": 5729
        },
        "resolved": true,
        "details": {
          "function_name": "partition_sched_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1934-2007",
          "snippet": "void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tint i, j, n;\n\tint new_topology;\n\n\tmutex_lock(&sched_domains_mutex);\n\n\t/* Always unregister in case we don't destroy any domains: */\n\tunregister_sched_domain_sysctl();\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j])\n\t\t\t    && dattrs_equal(dattr_cur, i, dattr_new, j))\n\t\t\t\tgoto match1;\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j])\n\t\t\t    && dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tregister_sched_domain_sysctl();\n\n\tmutex_unlock(&sched_domains_mutex);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t\t\t\t*doms_cur;",
            "static int\t\t\t\tndoms_cur;",
            "static struct sched_domain_attr\t\t*dattr_cur;",
            "static cpumask_var_t\t\t\tfallback_doms;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t\t\t\t*doms_cur;\nstatic int\t\t\t\tndoms_cur;\nstatic struct sched_domain_attr\t\t*dattr_cur;\nstatic cpumask_var_t\t\t\tfallback_doms;\n\nvoid partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tint i, j, n;\n\tint new_topology;\n\n\tmutex_lock(&sched_domains_mutex);\n\n\t/* Always unregister in case we don't destroy any domains: */\n\tunregister_sched_domain_sysctl();\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j])\n\t\t\t    && dattrs_equal(dattr_cur, i, dattr_new, j))\n\t\t\t\tgoto match1;\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j])\n\t\t\t    && dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tregister_sched_domain_sysctl();\n\n\tmutex_unlock(&sched_domains_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_update_active_cpus",
          "args": [],
          "line": 5726
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_update_active_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cpuset.c",
          "lines": "2361-2369",
          "snippet": "void cpuset_update_active_cpus(void)\n{\n\t/*\n\t * We're inside cpu hotplug critical region which usually nests\n\t * inside cgroup synchronization.  Bounce actual hotplug processing\n\t * to a work item to avoid reverse locking order.\n\t */\n\tschedule_work(&cpuset_hotplug_work);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cpuset_hotplug_workfn(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_hotplug_workfn(struct work_struct *work);\n\nvoid cpuset_update_active_cpus(void)\n{\n\t/*\n\t * We're inside cpu hotplug critical region which usually nests\n\t * inside cgroup synchronization.  Bounce actual hotplug processing\n\t * to a work item to avoid reverse locking order.\n\t */\n\tschedule_work(&cpuset_hotplug_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_cpu_busy",
          "args": [
            "cpu"
          ],
          "line": 5724
        },
        "resolved": true,
        "details": {
          "function_name": "dl_cpu_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2733-2749",
          "snippet": "bool dl_cpu_busy(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\tint cpus;\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcpus = dl_bw_cpus(cpu);\n\toverflow = __dl_overflow(dl_b, cpus, 0, 0);\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn overflow;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nbool dl_cpu_busy(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\tint cpus;\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcpus = dl_bw_cpus(cpu);\n\toverflow = __dl_overflow(dl_b, cpus, 0, 0);\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn overflow;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic int cpuset_cpu_inactive(unsigned int cpu)\n{\n\tif (!cpuhp_tasks_frozen) {\n\t\tif (dl_cpu_busy(cpu))\n\t\t\treturn -EBUSY;\n\t\tcpuset_update_active_cpus();\n\t} else {\n\t\tnum_cpus_frozen++;\n\t\tpartition_sched_domains(1, NULL, NULL);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuset_cpu_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5699-5719",
    "snippet": "static void cpuset_cpu_active(void)\n{\n\tif (cpuhp_tasks_frozen) {\n\t\t/*\n\t\t * num_cpus_frozen tracks how many CPUs are involved in suspend\n\t\t * resume sequence. As long as this is not the last online\n\t\t * operation in the resume sequence, just build a single sched\n\t\t * domain, ignoring cpusets.\n\t\t */\n\t\tpartition_sched_domains(1, NULL, NULL);\n\t\tif (--num_cpus_frozen)\n\t\t\treturn;\n\t\t/*\n\t\t * This is the last CPU online operation. So fall through and\n\t\t * restore the original sched domains by considering the\n\t\t * cpuset configurations.\n\t\t */\n\t\tcpuset_force_rebuild();\n\t}\n\tcpuset_update_active_cpus();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuset_update_active_cpus",
          "args": [],
          "line": 5718
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_update_active_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cpuset.c",
          "lines": "2361-2369",
          "snippet": "void cpuset_update_active_cpus(void)\n{\n\t/*\n\t * We're inside cpu hotplug critical region which usually nests\n\t * inside cgroup synchronization.  Bounce actual hotplug processing\n\t * to a work item to avoid reverse locking order.\n\t */\n\tschedule_work(&cpuset_hotplug_work);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cpuset_hotplug_workfn(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_hotplug_workfn(struct work_struct *work);\n\nvoid cpuset_update_active_cpus(void)\n{\n\t/*\n\t * We're inside cpu hotplug critical region which usually nests\n\t * inside cgroup synchronization.  Bounce actual hotplug processing\n\t * to a work item to avoid reverse locking order.\n\t */\n\tschedule_work(&cpuset_hotplug_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_force_rebuild",
          "args": [],
          "line": 5716
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_force_rebuild",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cpuset.c",
          "lines": "2276-2279",
          "snippet": "void cpuset_force_rebuild(void)\n{\n\tforce_rebuild = true;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool force_rebuild;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic bool force_rebuild;\n\nvoid cpuset_force_rebuild(void)\n{\n\tforce_rebuild = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "partition_sched_domains",
          "args": [
            "1",
            "NULL",
            "NULL"
          ],
          "line": 5708
        },
        "resolved": true,
        "details": {
          "function_name": "partition_sched_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1934-2007",
          "snippet": "void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tint i, j, n;\n\tint new_topology;\n\n\tmutex_lock(&sched_domains_mutex);\n\n\t/* Always unregister in case we don't destroy any domains: */\n\tunregister_sched_domain_sysctl();\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j])\n\t\t\t    && dattrs_equal(dattr_cur, i, dattr_new, j))\n\t\t\t\tgoto match1;\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j])\n\t\t\t    && dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tregister_sched_domain_sysctl();\n\n\tmutex_unlock(&sched_domains_mutex);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t\t\t\t*doms_cur;",
            "static int\t\t\t\tndoms_cur;",
            "static struct sched_domain_attr\t\t*dattr_cur;",
            "static cpumask_var_t\t\t\tfallback_doms;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t\t\t\t*doms_cur;\nstatic int\t\t\t\tndoms_cur;\nstatic struct sched_domain_attr\t\t*dattr_cur;\nstatic cpumask_var_t\t\t\tfallback_doms;\n\nvoid partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tint i, j, n;\n\tint new_topology;\n\n\tmutex_lock(&sched_domains_mutex);\n\n\t/* Always unregister in case we don't destroy any domains: */\n\tunregister_sched_domain_sysctl();\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j])\n\t\t\t    && dattrs_equal(dattr_cur, i, dattr_new, j))\n\t\t\t\tgoto match1;\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j])\n\t\t\t    && dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tregister_sched_domain_sysctl();\n\n\tmutex_unlock(&sched_domains_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void cpuset_cpu_active(void)\n{\n\tif (cpuhp_tasks_frozen) {\n\t\t/*\n\t\t * num_cpus_frozen tracks how many CPUs are involved in suspend\n\t\t * resume sequence. As long as this is not the last online\n\t\t * operation in the resume sequence, just build a single sched\n\t\t * domain, ignoring cpusets.\n\t\t */\n\t\tpartition_sched_domains(1, NULL, NULL);\n\t\tif (--num_cpus_frozen)\n\t\t\treturn;\n\t\t/*\n\t\t * This is the last CPU online operation. So fall through and\n\t\t * restore the original sched domains by considering the\n\t\t * cpuset configurations.\n\t\t */\n\t\tcpuset_force_rebuild();\n\t}\n\tcpuset_update_active_cpus();\n}"
  },
  {
    "function_name": "set_rq_offline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5671-5684",
    "snippet": "void set_rq_offline(struct rq *rq)\n{\n\tif (rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_offline)\n\t\t\t\tclass->rq_offline(rq);\n\t\t}\n\n\t\tcpumask_clear_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 0;\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "rq->cpu",
            "rq->rd->online"
          ],
          "line": 5681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "class->rq_offline",
          "args": [
            "rq"
          ],
          "line": 5678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_rq_offline(struct rq *rq)\n{\n\tif (rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_offline)\n\t\t\t\tclass->rq_offline(rq);\n\t\t}\n\n\t\tcpumask_clear_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 0;\n\t}\n}"
  },
  {
    "function_name": "set_rq_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5656-5669",
    "snippet": "void set_rq_online(struct rq *rq)\n{\n\tif (!rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tcpumask_set_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 1;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_online)\n\t\t\t\tclass->rq_online(rq);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "class->rq_online",
          "args": [
            "rq"
          ],
          "line": 5666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "rq->cpu",
            "rq->rd->online"
          ],
          "line": 5661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_rq_online(struct rq *rq)\n{\n\tif (!rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tcpumask_set_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 1;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_online)\n\t\t\t\tclass->rq_online(rq);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "migrate_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5577-5653",
    "snippet": "static void migrate_tasks(struct rq *dead_rq, struct rq_flags *rf)\n{\n\tstruct rq *rq = dead_rq;\n\tstruct task_struct *next, *stop = rq->stop;\n\tstruct rq_flags orf = *rf;\n\tint dest_cpu;\n\n\t/*\n\t * Fudge the rq selection such that the below task selection loop\n\t * doesn't get stuck on the currently eligible stop task.\n\t *\n\t * We're currently inside stop_machine() and the rq is either stuck\n\t * in the stop_machine_cpu_stop() loop, or we're executing this code,\n\t * either way we should never end up calling schedule() until we're\n\t * done here.\n\t */\n\trq->stop = NULL;\n\n\t/*\n\t * put_prev_task() and pick_next_task() sched\n\t * class method both need to have an up-to-date\n\t * value of rq->clock[_task]\n\t */\n\tupdate_rq_clock(rq);\n\n\tfor (;;) {\n\t\t/*\n\t\t * There's this thread running, bail when that's the only\n\t\t * remaining thread:\n\t\t */\n\t\tif (rq->nr_running == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * pick_next_task() assumes pinned rq->lock:\n\t\t */\n\t\tnext = pick_next_task(rq, &fake_task, rf);\n\t\tBUG_ON(!next);\n\t\tput_prev_task(rq, next);\n\n\t\t/*\n\t\t * Rules for changing task_struct::cpus_allowed are holding\n\t\t * both pi_lock and rq->lock, such that holding either\n\t\t * stabilizes the mask.\n\t\t *\n\t\t * Drop rq->lock is not quite as disastrous as it usually is\n\t\t * because !cpu_active at this point, which means load-balance\n\t\t * will not interfere. Also, stop-machine.\n\t\t */\n\t\trq_unlock(rq, rf);\n\t\traw_spin_lock(&next->pi_lock);\n\t\trq_relock(rq, rf);\n\n\t\t/*\n\t\t * Since we're inside stop-machine, _nothing_ should have\n\t\t * changed the task, WARN if weird stuff happened, because in\n\t\t * that case the above rq->lock drop is a fail too.\n\t\t */\n\t\tif (WARN_ON(task_rq(next) != rq || !task_on_rq_queued(next))) {\n\t\t\traw_spin_unlock(&next->pi_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find suitable destination for @next, with force if needed. */\n\t\tdest_cpu = select_fallback_rq(dead_rq->cpu, next);\n\t\trq = __migrate_task(rq, rf, next, dest_cpu);\n\t\tif (rq != dead_rq) {\n\t\t\trq_unlock(rq, rf);\n\t\t\trq = dead_rq;\n\t\t\t*rf = orf;\n\t\t\trq_relock(rq, rf);\n\t\t}\n\t\traw_spin_unlock(&next->pi_lock);\n\t}\n\n\trq->stop = stop;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&next->pi_lock"
          ],
          "line": 5649
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_relock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 5647
        },
        "resolved": true,
        "details": {
          "function_name": "rq_relock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1130-1136",
          "snippet": "static inline void\nrq_relock(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock(&rq->lock);\n\trq_repin_lock(rq, rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_relock(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock(&rq->lock);\n\trq_repin_lock(rq, rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unlock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 5644
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__migrate_task",
          "args": [
            "rq",
            "rf",
            "next",
            "dest_cpu"
          ],
          "line": 5642
        },
        "resolved": true,
        "details": {
          "function_name": "__migrate_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "948-959",
          "snippet": "static struct rq *__migrate_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t struct task_struct *p, int dest_cpu)\n{\n\t/* Affinity changed (again). */\n\tif (!is_cpu_allowed(p, dest_cpu))\n\t\treturn rq;\n\n\tupdate_rq_clock(rq);\n\trq = move_queued_task(rq, rf, p, dest_cpu);\n\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct rq *__migrate_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t struct task_struct *p, int dest_cpu)\n{\n\t/* Affinity changed (again). */\n\tif (!is_cpu_allowed(p, dest_cpu))\n\t\treturn rq;\n\n\tupdate_rq_clock(rq);\n\trq = move_queued_task(rq, rf, p, dest_cpu);\n\n\treturn rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_fallback_rq",
          "args": [
            "dead_rq->cpu",
            "next"
          ],
          "line": 5641
        },
        "resolved": true,
        "details": {
          "function_name": "select_fallback_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1458-1525",
          "snippet": "static int select_fallback_rq(int cpu, struct task_struct *p)\n{\n\tint nid = cpu_to_node(cpu);\n\tconst struct cpumask *nodemask = NULL;\n\tenum { cpuset, possible, fail } state = cpuset;\n\tint dest_cpu;\n\n\t/*\n\t * If the node that the CPU is on has been offlined, cpu_to_node()\n\t * will return -1. There is no CPU on the node, and we should\n\t * select the CPU on the other node.\n\t */\n\tif (nid != -1) {\n\t\tnodemask = cpumask_of_node(nid);\n\n\t\t/* Look for allowed, online CPU in same node. */\n\t\tfor_each_cpu(dest_cpu, nodemask) {\n\t\t\tif (!cpu_active(dest_cpu))\n\t\t\t\tcontinue;\n\t\t\tif (cpumask_test_cpu(dest_cpu, &p->cpus_allowed))\n\t\t\t\treturn dest_cpu;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t/* Any allowed, online CPU? */\n\t\tfor_each_cpu(dest_cpu, &p->cpus_allowed) {\n\t\t\tif (!is_cpu_allowed(p, dest_cpu))\n\t\t\t\tcontinue;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* No more Mr. Nice Guy. */\n\t\tswitch (state) {\n\t\tcase cpuset:\n\t\t\tif (IS_ENABLED(CONFIG_CPUSETS)) {\n\t\t\t\tcpuset_cpus_allowed_fallback(p);\n\t\t\t\tstate = possible;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall-through */\n\t\tcase possible:\n\t\t\tdo_set_cpus_allowed(p, cpu_possible_mask);\n\t\t\tstate = fail;\n\t\t\tbreak;\n\n\t\tcase fail:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (state != cpuset) {\n\t\t/*\n\t\t * Don't tell them about moving exiting tasks or\n\t\t * kernel threads (both mm NULL), since they never\n\t\t * leave kernel.\n\t\t */\n\t\tif (p->mm && printk_ratelimit()) {\n\t\t\tprintk_deferred(\"process %d (%s) no longer affine to cpu%d\\n\",\n\t\t\t\t\ttask_pid_nr(p), p->comm, cpu);\n\t\t}\n\t}\n\n\treturn dest_cpu;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int select_fallback_rq(int cpu, struct task_struct *p)\n{\n\tint nid = cpu_to_node(cpu);\n\tconst struct cpumask *nodemask = NULL;\n\tenum { cpuset, possible, fail } state = cpuset;\n\tint dest_cpu;\n\n\t/*\n\t * If the node that the CPU is on has been offlined, cpu_to_node()\n\t * will return -1. There is no CPU on the node, and we should\n\t * select the CPU on the other node.\n\t */\n\tif (nid != -1) {\n\t\tnodemask = cpumask_of_node(nid);\n\n\t\t/* Look for allowed, online CPU in same node. */\n\t\tfor_each_cpu(dest_cpu, nodemask) {\n\t\t\tif (!cpu_active(dest_cpu))\n\t\t\t\tcontinue;\n\t\t\tif (cpumask_test_cpu(dest_cpu, &p->cpus_allowed))\n\t\t\t\treturn dest_cpu;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t/* Any allowed, online CPU? */\n\t\tfor_each_cpu(dest_cpu, &p->cpus_allowed) {\n\t\t\tif (!is_cpu_allowed(p, dest_cpu))\n\t\t\t\tcontinue;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* No more Mr. Nice Guy. */\n\t\tswitch (state) {\n\t\tcase cpuset:\n\t\t\tif (IS_ENABLED(CONFIG_CPUSETS)) {\n\t\t\t\tcpuset_cpus_allowed_fallback(p);\n\t\t\t\tstate = possible;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall-through */\n\t\tcase possible:\n\t\t\tdo_set_cpus_allowed(p, cpu_possible_mask);\n\t\t\tstate = fail;\n\t\t\tbreak;\n\n\t\tcase fail:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (state != cpuset) {\n\t\t/*\n\t\t * Don't tell them about moving exiting tasks or\n\t\t * kernel threads (both mm NULL), since they never\n\t\t * leave kernel.\n\t\t */\n\t\tif (p->mm && printk_ratelimit()) {\n\t\t\tprintk_deferred(\"process %d (%s) no longer affine to cpu%d\\n\",\n\t\t\t\t\ttask_pid_nr(p), p->comm, cpu);\n\t\t}\n\t}\n\n\treturn dest_cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "task_rq(next) != rq || !task_on_rq_queued(next)"
          ],
          "line": 5635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "next"
          ],
          "line": 5635
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "next"
          ],
          "line": 5635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&next->pi_lock"
          ],
          "line": 5627
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_prev_task",
          "args": [
            "rq",
            "next"
          ],
          "line": 5615
        },
        "resolved": true,
        "details": {
          "function_name": "put_prev_task_fake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5553-5555",
          "snippet": "static void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!next"
          ],
          "line": 5614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pick_next_task",
          "args": [
            "rq",
            "&fake_task",
            "rf"
          ],
          "line": 5613
        },
        "resolved": true,
        "details": {
          "function_name": "pick_next_task_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "376-384",
          "snippet": "static struct task_struct *\npick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tput_prev_task(rq, prev);\n\tupdate_idle_core(rq);\n\tschedstat_inc(rq->sched_goidle);\n\n\treturn rq->idle;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct task_struct *\npick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tput_prev_task(rq, prev);\n\tupdate_idle_core(rq);\n\tschedstat_inc(rq->sched_goidle);\n\n\treturn rq->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 5600
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void migrate_tasks(struct rq *dead_rq, struct rq_flags *rf)\n{\n\tstruct rq *rq = dead_rq;\n\tstruct task_struct *next, *stop = rq->stop;\n\tstruct rq_flags orf = *rf;\n\tint dest_cpu;\n\n\t/*\n\t * Fudge the rq selection such that the below task selection loop\n\t * doesn't get stuck on the currently eligible stop task.\n\t *\n\t * We're currently inside stop_machine() and the rq is either stuck\n\t * in the stop_machine_cpu_stop() loop, or we're executing this code,\n\t * either way we should never end up calling schedule() until we're\n\t * done here.\n\t */\n\trq->stop = NULL;\n\n\t/*\n\t * put_prev_task() and pick_next_task() sched\n\t * class method both need to have an up-to-date\n\t * value of rq->clock[_task]\n\t */\n\tupdate_rq_clock(rq);\n\n\tfor (;;) {\n\t\t/*\n\t\t * There's this thread running, bail when that's the only\n\t\t * remaining thread:\n\t\t */\n\t\tif (rq->nr_running == 1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * pick_next_task() assumes pinned rq->lock:\n\t\t */\n\t\tnext = pick_next_task(rq, &fake_task, rf);\n\t\tBUG_ON(!next);\n\t\tput_prev_task(rq, next);\n\n\t\t/*\n\t\t * Rules for changing task_struct::cpus_allowed are holding\n\t\t * both pi_lock and rq->lock, such that holding either\n\t\t * stabilizes the mask.\n\t\t *\n\t\t * Drop rq->lock is not quite as disastrous as it usually is\n\t\t * because !cpu_active at this point, which means load-balance\n\t\t * will not interfere. Also, stop-machine.\n\t\t */\n\t\trq_unlock(rq, rf);\n\t\traw_spin_lock(&next->pi_lock);\n\t\trq_relock(rq, rf);\n\n\t\t/*\n\t\t * Since we're inside stop-machine, _nothing_ should have\n\t\t * changed the task, WARN if weird stuff happened, because in\n\t\t * that case the above rq->lock drop is a fail too.\n\t\t */\n\t\tif (WARN_ON(task_rq(next) != rq || !task_on_rq_queued(next))) {\n\t\t\traw_spin_unlock(&next->pi_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Find suitable destination for @next, with force if needed. */\n\t\tdest_cpu = select_fallback_rq(dead_rq->cpu, next);\n\t\trq = __migrate_task(rq, rf, next, dest_cpu);\n\t\tif (rq != dead_rq) {\n\t\t\trq_unlock(rq, rf);\n\t\t\trq = dead_rq;\n\t\t\t*rf = orf;\n\t\t\trq_relock(rq, rf);\n\t\t}\n\t\traw_spin_unlock(&next->pi_lock);\n\t}\n\n\trq->stop = stop;\n}"
  },
  {
    "function_name": "put_prev_task_fake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5553-5555",
    "snippet": "static void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}"
  },
  {
    "function_name": "calc_load_migrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5546-5551",
    "snippet": "static void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq, 1);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "delta",
            "&calc_load_tasks"
          ],
          "line": 5550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_load_fold_active",
          "args": [
            "rq",
            "1"
          ],
          "line": 5548
        },
        "resolved": true,
        "details": {
          "function_name": "calc_load_fold_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/loadavg.c",
          "lines": "79-92",
          "snippet": "long calc_load_fold_active(struct rq *this_rq, long adjust)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->nr_running - adjust;\n\tnr_active += (long)this_rq->nr_uninterruptible;\n\n\tif (nr_active != this_rq->calc_load_active) {\n\t\tdelta = nr_active - this_rq->calc_load_active;\n\t\tthis_rq->calc_load_active = nr_active;\n\t}\n\n\treturn delta;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nlong calc_load_fold_active(struct rq *this_rq, long adjust)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->nr_running - adjust;\n\tnr_active += (long)this_rq->nr_uninterruptible;\n\n\tif (nr_active != this_rq->calc_load_active) {\n\t\tdelta = nr_active - this_rq->calc_load_active;\n\t\tthis_rq->calc_load_active = nr_active;\n\t}\n\n\treturn delta;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq, 1);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}"
  },
  {
    "function_name": "idle_task_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5523-5535",
    "snippet": "void idle_task_exit(void)\n{\n\tstruct mm_struct *mm = current->active_mm;\n\n\tBUG_ON(cpu_online(smp_processor_id()));\n\n\tif (mm != &init_mm) {\n\t\tswitch_mm(mm, &init_mm, current);\n\t\tcurrent->active_mm = &init_mm;\n\t\tfinish_arch_post_lock_switch();\n\t}\n\tmmdrop(mm);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 5534
        },
        "resolved": true,
        "details": {
          "function_name": "mmdrop_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "689-695",
          "snippet": "static void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_arch_post_lock_switch",
          "args": [],
          "line": 5532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_mm",
          "args": [
            "mm",
            "&init_mm",
            "current"
          ],
          "line": 5530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpu_online(smp_processor_id())"
          ],
          "line": 5527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "smp_processor_id()"
          ],
          "line": 5527
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 5527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid idle_task_exit(void)\n{\n\tstruct mm_struct *mm = current->active_mm;\n\n\tBUG_ON(cpu_online(smp_processor_id()));\n\n\tif (mm != &init_mm) {\n\t\tswitch_mm(mm, &init_mm, current);\n\t\tcurrent->active_mm = &init_mm;\n\t\tfinish_arch_post_lock_switch();\n\t}\n\tmmdrop(mm);\n}"
  },
  {
    "function_name": "sched_setnuma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5493-5515",
    "snippet": "void sched_setnuma(struct task_struct *p, int nid)\n{\n\tbool queued, running;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->numa_preferred_nid = nid;\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_curr_task(rq, p);\n\ttask_rq_unlock(rq, p, &rf);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 5514
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_curr_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 5513
        },
        "resolved": true,
        "details": {
          "function_name": "ia64_set_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6228-6231",
          "snippet": "void ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task",
          "args": [
            "rq",
            "p",
            "ENQUEUE_RESTORE | ENQUEUE_NOCLOCK"
          ],
          "line": 5511
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "720-731",
          "snippet": "static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_prev_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 5506
        },
        "resolved": true,
        "details": {
          "function_name": "put_prev_task_fake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5553-5555",
          "snippet": "static void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_task",
          "args": [
            "rq",
            "p",
            "DEQUEUE_SAVE"
          ],
          "line": 5504
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "733-744",
          "snippet": "static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 5501
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1521-1524",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 5500
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 5499
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_setnuma(struct task_struct *p, int nid)\n{\n\tbool queued, running;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->numa_preferred_nid = nid;\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_curr_task(rq, p);\n\ttask_rq_unlock(rq, p, &rf);\n}"
  },
  {
    "function_name": "migrate_task_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5472-5487",
    "snippet": "int migrate_task_to(struct task_struct *p, int target_cpu)\n{\n\tstruct migration_arg arg = { p, target_cpu };\n\tint curr_cpu = task_cpu(p);\n\n\tif (curr_cpu == target_cpu)\n\t\treturn 0;\n\n\tif (!cpumask_test_cpu(target_cpu, &p->cpus_allowed))\n\t\treturn -EINVAL;\n\n\t/* TODO: This is not properly updating schedstats */\n\n\ttrace_sched_move_numa(p, curr_cpu, target_cpu);\n\treturn stop_one_cpu(curr_cpu, migration_cpu_stop, &arg);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_one_cpu",
          "args": [
            "curr_cpu",
            "migration_cpu_stop",
            "&arg"
          ],
          "line": 5486
        },
        "resolved": true,
        "details": {
          "function_name": "stop_one_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "123-138",
          "snippet": "int stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done };\n\n\tcpu_stop_init_done(&done, 1);\n\tif (!cpu_stop_queue_work(cpu, &work))\n\t\treturn -ENOENT;\n\t/*\n\t * In case @cpu == smp_proccessor_id() we can avoid a sleep+wakeup\n\t * cycle by doing a preemption:\n\t */\n\tcond_resched();\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nint stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done };\n\n\tcpu_stop_init_done(&done, 1);\n\tif (!cpu_stop_queue_work(cpu, &work))\n\t\treturn -ENOENT;\n\t/*\n\t * In case @cpu == smp_proccessor_id() we can avoid a sleep+wakeup\n\t * cycle by doing a preemption:\n\t */\n\tcond_resched();\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_move_numa",
          "args": [
            "p",
            "curr_cpu",
            "target_cpu"
          ],
          "line": 5485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "target_cpu",
            "&p->cpus_allowed"
          ],
          "line": 5480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 5475
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint migrate_task_to(struct task_struct *p, int target_cpu)\n{\n\tstruct migration_arg arg = { p, target_cpu };\n\tint curr_cpu = task_cpu(p);\n\n\tif (curr_cpu == target_cpu)\n\t\treturn 0;\n\n\tif (!cpumask_test_cpu(target_cpu, &p->cpus_allowed))\n\t\treturn -EINVAL;\n\n\t/* TODO: This is not properly updating schedstats */\n\n\ttrace_sched_move_numa(p, curr_cpu, target_cpu);\n\treturn stop_one_cpu(curr_cpu, migration_cpu_stop, &arg);\n}"
  },
  {
    "function_name": "task_can_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5441-5466",
    "snippet": "int task_can_attach(struct task_struct *p,\n\t\t    const struct cpumask *cs_cpus_allowed)\n{\n\tint ret = 0;\n\n\t/*\n\t * Kthreads which disallow setaffinity shouldn't be moved\n\t * to a new cpuset; we don't want to change their CPU\n\t * affinity and isolating such threads by their set of\n\t * allowed nodes is unnecessary.  Thus, cpusets are not\n\t * applicable for such threads.  This prevents checking for\n\t * success of set_cpus_allowed_ptr() on all attached tasks\n\t * before cpus_allowed may be changed.\n\t */\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (dl_task(p) && !cpumask_intersects(task_rq(p)->rd->span,\n\t\t\t\t\t      cs_cpus_allowed))\n\t\tret = dl_task_can_attach(p, cs_cpus_allowed);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_task_can_attach",
          "args": [
            "p",
            "cs_cpus_allowed"
          ],
          "line": 5462
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_can_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2679-2710",
          "snippet": "int dl_task_can_attach(struct task_struct *p, const struct cpumask *cs_cpus_allowed)\n{\n\tunsigned int dest_cpu;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\tint cpus, ret;\n\tunsigned long flags;\n\n\tdest_cpu = cpumask_any_and(cpu_active_mask, cs_cpus_allowed);\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(dest_cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcpus = dl_bw_cpus(dest_cpu);\n\toverflow = __dl_overflow(dl_b, cpus, 0, p->dl.dl_bw);\n\tif (overflow) {\n\t\tret = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * We reserve space for this task in the destination\n\t\t * root_domain, as we can't fail after this point.\n\t\t * We will free resources in the source root_domain\n\t\t * later on (see set_cpus_allowed_dl()).\n\t\t */\n\t\t__dl_add(dl_b, p->dl.dl_bw, cpus);\n\t\tret = 0;\n\t}\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nint dl_task_can_attach(struct task_struct *p, const struct cpumask *cs_cpus_allowed)\n{\n\tunsigned int dest_cpu;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\tint cpus, ret;\n\tunsigned long flags;\n\n\tdest_cpu = cpumask_any_and(cpu_active_mask, cs_cpus_allowed);\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(dest_cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcpus = dl_bw_cpus(dest_cpu);\n\toverflow = __dl_overflow(dl_b, cpus, 0, p->dl.dl_bw);\n\tif (overflow) {\n\t\tret = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * We reserve space for this task in the destination\n\t\t * root_domain, as we can't fail after this point.\n\t\t * We will free resources in the source root_domain\n\t\t * later on (see set_cpus_allowed_dl()).\n\t\t */\n\t\t__dl_add(dl_b, p->dl.dl_bw, cpus);\n\t\tret = 0;\n\t}\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "task_rq(p)->rd->span",
            "cs_cpus_allowed"
          ],
          "line": 5460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 5460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 5460
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint task_can_attach(struct task_struct *p,\n\t\t    const struct cpumask *cs_cpus_allowed)\n{\n\tint ret = 0;\n\n\t/*\n\t * Kthreads which disallow setaffinity shouldn't be moved\n\t * to a new cpuset; we don't want to change their CPU\n\t * affinity and isolating such threads by their set of\n\t * allowed nodes is unnecessary.  Thus, cpusets are not\n\t * applicable for such threads.  This prevents checking for\n\t * success of set_cpus_allowed_ptr() on all attached tasks\n\t * before cpus_allowed may be changed.\n\t */\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (dl_task(p) && !cpumask_intersects(task_rq(p)->rd->span,\n\t\t\t\t\t      cs_cpus_allowed))\n\t\tret = dl_task_can_attach(p, cs_cpus_allowed);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuset_cpumask_can_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5428-5439",
    "snippet": "int cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t      const struct cpumask *trial)\n{\n\tint ret = 1;\n\n\tif (!cpumask_weight(cur))\n\t\treturn ret;\n\n\tret = dl_cpuset_cpumask_can_shrink(cur, trial);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_cpuset_cpumask_can_shrink",
          "args": [
            "cur",
            "trial"
          ],
          "line": 5436
        },
        "resolved": true,
        "details": {
          "function_name": "dl_cpuset_cpumask_can_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2712-2731",
          "snippet": "int dl_cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t\t const struct cpumask *trial)\n{\n\tint ret = 1, trial_cpus;\n\tstruct dl_bw *cur_dl_b;\n\tunsigned long flags;\n\n\trcu_read_lock_sched();\n\tcur_dl_b = dl_bw_of(cpumask_any(cur));\n\ttrial_cpus = cpumask_weight(trial);\n\n\traw_spin_lock_irqsave(&cur_dl_b->lock, flags);\n\tif (cur_dl_b->bw != -1 &&\n\t    cur_dl_b->bw * trial_cpus < cur_dl_b->total_bw)\n\t\tret = 0;\n\traw_spin_unlock_irqrestore(&cur_dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nint dl_cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t\t const struct cpumask *trial)\n{\n\tint ret = 1, trial_cpus;\n\tstruct dl_bw *cur_dl_b;\n\tunsigned long flags;\n\n\trcu_read_lock_sched();\n\tcur_dl_b = dl_bw_of(cpumask_any(cur));\n\ttrial_cpus = cpumask_weight(trial);\n\n\traw_spin_lock_irqsave(&cur_dl_b->lock, flags);\n\tif (cur_dl_b->bw != -1 &&\n\t    cur_dl_b->bw * trial_cpus < cur_dl_b->total_bw)\n\t\tret = 0;\n\traw_spin_unlock_irqrestore(&cur_dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cur"
          ],
          "line": 5433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t      const struct cpumask *trial)\n{\n\tint ret = 1;\n\n\tif (!cpumask_weight(cur))\n\t\treturn ret;\n\n\tret = dl_cpuset_cpumask_can_shrink(cur, trial);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "init_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5366-5424",
    "snippet": "void init_idle(struct task_struct *idle, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&idle->pi_lock, flags);\n\traw_spin_lock(&rq->lock);\n\n\t__sched_fork(0, idle);\n\tidle->state = TASK_RUNNING;\n\tidle->se.exec_start = sched_clock();\n\tidle->flags |= PF_IDLE;\n\n\tkasan_unpoison_task_stack(idle);\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Its possible that init_idle() gets called multiple times on a task,\n\t * in that case do_set_cpus_allowed() will not do the right thing.\n\t *\n\t * And since this is boot we can forgo the serialization.\n\t */\n\tset_cpus_allowed_common(idle, cpumask_of(cpu));\n#endif\n\t/*\n\t * We're having a chicken and egg problem, even though we are\n\t * holding rq->lock, the CPU isn't yet set to this CPU so the\n\t * lockdep check in task_group() will fail.\n\t *\n\t * Similar case to sched_fork(). / Alternatively we could\n\t * use task_rq_lock() here and obtain the other rq->lock.\n\t *\n\t * Silence PROVE_RCU\n\t */\n\trcu_read_lock();\n\t__set_task_cpu(idle, cpu);\n\trcu_read_unlock();\n\n\trq->curr = rq->idle = idle;\n\tidle->on_rq = TASK_ON_RQ_QUEUED;\n#ifdef CONFIG_SMP\n\tidle->on_cpu = 1;\n#endif\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&idle->pi_lock, flags);\n\n\t/* Set the preempt count _outside_ the spinlocks! */\n\tinit_idle_preempt_count(idle, cpu);\n\n\t/*\n\t * The idle tasks have their own, simple scheduling class:\n\t */\n\tidle->sched_class = &idle_sched_class;\n\tftrace_graph_init_idle_task(idle, cpu);\n\tvtime_init_idle(idle, cpu);\n#ifdef CONFIG_SMP\n\tsprintf(idle->comm, \"%s/%d\", INIT_TASK_COMM, cpu);\n#endif\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "idle->comm",
            "\"%s/%d\"",
            "INIT_TASK_COMM",
            "cpu"
          ],
          "line": 5422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_init_idle",
          "args": [
            "idle",
            "cpu"
          ],
          "line": 5420
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_init_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "822-833",
          "snippet": "void vtime_init_idle(struct task_struct *t, int cpu)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\twrite_seqcount_end(&vtime->seqcount);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_init_idle(struct task_struct *t, int cpu)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\twrite_seqcount_end(&vtime->seqcount);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_init_idle_task",
          "args": [
            "idle",
            "cpu"
          ],
          "line": 5419
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_init_idle_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "7038-7063",
          "snippet": "void ftrace_graph_init_idle_task(struct task_struct *t, int cpu)\n{\n\tt->curr_ret_stack = -1;\n\t/*\n\t * The idle task has no parent, it either has its own\n\t * stack or no stack at all.\n\t */\n\tif (t->ret_stack)\n\t\tWARN_ON(t->ret_stack != per_cpu(idle_ret_stack, cpu));\n\n\tif (ftrace_graph_active) {\n\t\tstruct ftrace_ret_stack *ret_stack;\n\n\t\tret_stack = per_cpu(idle_ret_stack, cpu);\n\t\tif (!ret_stack) {\n\t\t\tret_stack =\n\t\t\t\tkmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t\t      sizeof(struct ftrace_ret_stack),\n\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!ret_stack)\n\t\t\t\treturn;\n\t\t\tper_cpu(idle_ret_stack, cpu) = ret_stack;\n\t\t}\n\t\tgraph_init_task(t, ret_stack);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_init_idle_task(struct task_struct *t, int cpu)\n{\n\tt->curr_ret_stack = -1;\n\t/*\n\t * The idle task has no parent, it either has its own\n\t * stack or no stack at all.\n\t */\n\tif (t->ret_stack)\n\t\tWARN_ON(t->ret_stack != per_cpu(idle_ret_stack, cpu));\n\n\tif (ftrace_graph_active) {\n\t\tstruct ftrace_ret_stack *ret_stack;\n\n\t\tret_stack = per_cpu(idle_ret_stack, cpu);\n\t\tif (!ret_stack) {\n\t\t\tret_stack =\n\t\t\t\tkmalloc_array(FTRACE_RETFUNC_DEPTH,\n\t\t\t\t\t      sizeof(struct ftrace_ret_stack),\n\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!ret_stack)\n\t\t\t\treturn;\n\t\t\tper_cpu(idle_ret_stack, cpu) = ret_stack;\n\t\t}\n\t\tgraph_init_task(t, ret_stack);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_idle_preempt_count",
          "args": [
            "idle",
            "cpu"
          ],
          "line": 5413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&idle->pi_lock",
            "flags"
          ],
          "line": 5410
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rq->lock"
          ],
          "line": 5409
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5402
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_task_cpu",
          "args": [
            "idle",
            "cpu"
          ],
          "line": 5401
        },
        "resolved": true,
        "details": {
          "function_name": "__set_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1428-1445",
          "snippet": "static inline void __set_task_cpu(struct task_struct *p, unsigned int cpu)\n{\n\tset_task_rq(p, cpu);\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->cpu is set up to a new value, task_rq_lock(p, ...) can be\n\t * successfuly executed on another CPU. We must ensure that updates of\n\t * per-task data have been completed by this moment.\n\t */\n\tsmp_wmb();\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tp->cpu = cpu;\n#else\n\ttask_thread_info(p)->cpu = cpu;\n#endif\n\tp->wake_cpu = cpu;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline void __set_task_cpu(struct task_struct *p, unsigned int cpu)\n{\n\tset_task_rq(p, cpu);\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->cpu is set up to a new value, task_rq_lock(p, ...) can be\n\t * successfuly executed on another CPU. We must ensure that updates of\n\t * per-task data have been completed by this moment.\n\t */\n\tsmp_wmb();\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tp->cpu = cpu;\n#else\n\ttask_thread_info(p)->cpu = cpu;\n#endif\n\tp->wake_cpu = cpu;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5400
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_common",
          "args": [
            "idle",
            "cpumask_of(cpu)"
          ],
          "line": 5388
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1009-1013",
          "snippet": "void set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tcpumask_copy(&p->cpus_allowed, new_mask);\n\tp->nr_cpus_allowed = cpumask_weight(new_mask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tcpumask_copy(&p->cpus_allowed, new_mask);\n\tp->nr_cpus_allowed = cpumask_weight(new_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 5388
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_unpoison_task_stack",
          "args": [
            "idle"
          ],
          "line": 5379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 5376
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sched_fork",
          "args": [
            "0",
            "idle"
          ],
          "line": 5374
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2144-2181",
          "snippet": "static void __sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tp->on_rq\t\t\t= 0;\n\n\tp->se.on_rq\t\t\t= 0;\n\tp->se.exec_start\t\t= 0;\n\tp->se.sum_exec_runtime\t\t= 0;\n\tp->se.prev_sum_exec_runtime\t= 0;\n\tp->se.nr_migrations\t\t= 0;\n\tp->se.vruntime\t\t\t= 0;\n\tINIT_LIST_HEAD(&p->se.group_node);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tp->se.cfs_rq\t\t\t= NULL;\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n\t/* Even if schedstat is disabled, there should not be garbage */\n\tmemset(&p->se.statistics, 0, sizeof(p->se.statistics));\n#endif\n\n\tRB_CLEAR_NODE(&p->dl.rb_node);\n\tinit_dl_task_timer(&p->dl);\n\tinit_dl_inactive_task_timer(&p->dl);\n\t__dl_clear_params(p);\n\n\tINIT_LIST_HEAD(&p->rt.run_list);\n\tp->rt.timeout\t\t= 0;\n\tp->rt.time_slice\t= sched_rr_timeslice;\n\tp->rt.on_rq\t\t= 0;\n\tp->rt.on_list\t\t= 0;\n\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n\tINIT_HLIST_HEAD(&p->preempt_notifiers);\n#endif\n\n\tinit_numa_balancing(clone_flags, p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tp->on_rq\t\t\t= 0;\n\n\tp->se.on_rq\t\t\t= 0;\n\tp->se.exec_start\t\t= 0;\n\tp->se.sum_exec_runtime\t\t= 0;\n\tp->se.prev_sum_exec_runtime\t= 0;\n\tp->se.nr_migrations\t\t= 0;\n\tp->se.vruntime\t\t\t= 0;\n\tINIT_LIST_HEAD(&p->se.group_node);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tp->se.cfs_rq\t\t\t= NULL;\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n\t/* Even if schedstat is disabled, there should not be garbage */\n\tmemset(&p->se.statistics, 0, sizeof(p->se.statistics));\n#endif\n\n\tRB_CLEAR_NODE(&p->dl.rb_node);\n\tinit_dl_task_timer(&p->dl);\n\tinit_dl_inactive_task_timer(&p->dl);\n\t__dl_clear_params(p);\n\n\tINIT_LIST_HEAD(&p->rt.run_list);\n\tp->rt.timeout\t\t= 0;\n\tp->rt.time_slice\t= sched_rr_timeslice;\n\tp->rt.on_rq\t\t= 0;\n\tp->rt.on_list\t\t= 0;\n\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n\tINIT_HLIST_HEAD(&p->preempt_notifiers);\n#endif\n\n\tinit_numa_balancing(clone_flags, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rq->lock"
          ],
          "line": 5372
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&idle->pi_lock",
            "flags"
          ],
          "line": 5371
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 5368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid init_idle(struct task_struct *idle, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&idle->pi_lock, flags);\n\traw_spin_lock(&rq->lock);\n\n\t__sched_fork(0, idle);\n\tidle->state = TASK_RUNNING;\n\tidle->se.exec_start = sched_clock();\n\tidle->flags |= PF_IDLE;\n\n\tkasan_unpoison_task_stack(idle);\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Its possible that init_idle() gets called multiple times on a task,\n\t * in that case do_set_cpus_allowed() will not do the right thing.\n\t *\n\t * And since this is boot we can forgo the serialization.\n\t */\n\tset_cpus_allowed_common(idle, cpumask_of(cpu));\n#endif\n\t/*\n\t * We're having a chicken and egg problem, even though we are\n\t * holding rq->lock, the CPU isn't yet set to this CPU so the\n\t * lockdep check in task_group() will fail.\n\t *\n\t * Similar case to sched_fork(). / Alternatively we could\n\t * use task_rq_lock() here and obtain the other rq->lock.\n\t *\n\t * Silence PROVE_RCU\n\t */\n\trcu_read_lock();\n\t__set_task_cpu(idle, cpu);\n\trcu_read_unlock();\n\n\trq->curr = rq->idle = idle;\n\tidle->on_rq = TASK_ON_RQ_QUEUED;\n#ifdef CONFIG_SMP\n\tidle->on_cpu = 1;\n#endif\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&idle->pi_lock, flags);\n\n\t/* Set the preempt count _outside_ the spinlocks! */\n\tinit_idle_preempt_count(idle, cpu);\n\n\t/*\n\t * The idle tasks have their own, simple scheduling class:\n\t */\n\tidle->sched_class = &idle_sched_class;\n\tftrace_graph_init_idle_task(idle, cpu);\n\tvtime_init_idle(idle, cpu);\n#ifdef CONFIG_SMP\n\tsprintf(idle->comm, \"%s/%d\", INIT_TASK_COMM, cpu);\n#endif\n}"
  },
  {
    "function_name": "show_state_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5320-5356",
    "snippet": "void show_state_filter(unsigned long state_filter)\n{\n\tstruct task_struct *g, *p;\n\n#if BITS_PER_LONG == 32\n\tprintk(KERN_INFO\n\t\t\"  task                PC stack   pid father\\n\");\n#else\n\tprintk(KERN_INFO\n\t\t\"  task                        PC stack   pid father\\n\");\n#endif\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\t/*\n\t\t * reset the NMI-timeout, listing all files on a slow\n\t\t * console might take a lot of time:\n\t\t * Also, reset softlockup watchdogs on all CPUs, because\n\t\t * another CPU might be blocked waiting for us to process\n\t\t * an IPI.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t\tif (state_filter_match(state_filter, p))\n\t\t\tsched_show_task(p);\n\t}\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (!state_filter)\n\t\tsysrq_sched_debug_show();\n#endif\n\trcu_read_unlock();\n\t/*\n\t * Only show locks if all tasks are dumped:\n\t */\n\tif (!state_filter)\n\t\tdebug_show_all_locks();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_show_all_locks",
          "args": [],
          "line": 5355
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_all_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4373-4395",
          "snippet": "void debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_show_all_locks(void)\n{\n\tstruct task_struct *g, *p;\n\n\tif (unlikely(!debug_locks)) {\n\t\tpr_warn(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tpr_warn(\"\\nShowing all locks held in the system:\\n\");\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (!p->lockdep_depth)\n\t\t\tcontinue;\n\t\tlockdep_print_held_locks(p);\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t}\n\trcu_read_unlock();\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"=============================================\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5350
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysrq_sched_debug_show",
          "args": [],
          "line": 5348
        },
        "resolved": true,
        "details": {
          "function_name": "sysrq_sched_debug_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "769-777",
          "snippet": "void sysrq_sched_debug_show(void)\n{\n\tint cpu;\n\n\tsched_debug_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu);\n\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid sysrq_sched_debug_show(void)\n{\n\tint cpu;\n\n\tsched_debug_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "p"
          ],
          "line": 5343
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5268-5295",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "state_filter_match",
          "args": [
            "state_filter",
            "p"
          ],
          "line": 5342
        },
        "resolved": true,
        "details": {
          "function_name": "state_filter_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5298-5317",
          "snippet": "static inline bool\nstate_filter_match(unsigned long state_filter, struct task_struct *p)\n{\n\t/* no filter, everything matches */\n\tif (!state_filter)\n\t\treturn true;\n\n\t/* filter, but doesn't match */\n\tif (!(p->state & state_filter))\n\t\treturn false;\n\n\t/*\n\t * When looking for TASK_UNINTERRUPTIBLE skip TASK_IDLE (allows\n\t * TASK_KILLABLE).\n\t */\n\tif (state_filter == TASK_UNINTERRUPTIBLE && p->state == TASK_IDLE)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline bool\nstate_filter_match(unsigned long state_filter, struct task_struct *p)\n{\n\t/* no filter, everything matches */\n\tif (!state_filter)\n\t\treturn true;\n\n\t/* filter, but doesn't match */\n\tif (!(p->state & state_filter))\n\t\treturn false;\n\n\t/*\n\t * When looking for TASK_UNINTERRUPTIBLE skip TASK_IDLE (allows\n\t * TASK_KILLABLE).\n\t */\n\tif (state_filter == TASK_UNINTERRUPTIBLE && p->state == TASK_IDLE)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_all_softlockup_watchdogs",
          "args": [],
          "line": 5341
        },
        "resolved": true,
        "details": {
          "function_name": "touch_all_softlockup_watchdogs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "280-296",
          "snippet": "void touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t/*\n\t * watchdog_mutex cannpt be taken here, as this might be called\n\t * from (soft)interrupt context, so the access to\n\t * watchdog_allowed_cpumask might race with a concurrent update.\n\t *\n\t * The watchdog time stamp can race against a concurrent real\n\t * update as well, the only side effect might be a cycle delay for\n\t * the softlockup check.\n\t */\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tper_cpu(watchdog_touch_ts, cpu) = 0;\n\twq_watchdog_touch(-1);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);",
            "struct cpumask watchdog_allowed_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nstruct cpumask watchdog_allowed_mask;\n\nvoid touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t/*\n\t * watchdog_mutex cannpt be taken here, as this might be called\n\t * from (soft)interrupt context, so the access to\n\t * watchdog_allowed_cpumask might race with a concurrent update.\n\t *\n\t * The watchdog time stamp can race against a concurrent real\n\t * update as well, the only side effect might be a cycle delay for\n\t * the softlockup check.\n\t */\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tper_cpu(watchdog_touch_ts, cpu) = 0;\n\twq_watchdog_touch(-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 5340
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 5332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5331
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\"  task                        PC stack   pid father\\n\""
          ],
          "line": 5328
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid show_state_filter(unsigned long state_filter)\n{\n\tstruct task_struct *g, *p;\n\n#if BITS_PER_LONG == 32\n\tprintk(KERN_INFO\n\t\t\"  task                PC stack   pid father\\n\");\n#else\n\tprintk(KERN_INFO\n\t\t\"  task                        PC stack   pid father\\n\");\n#endif\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\t/*\n\t\t * reset the NMI-timeout, listing all files on a slow\n\t\t * console might take a lot of time:\n\t\t * Also, reset softlockup watchdogs on all CPUs, because\n\t\t * another CPU might be blocked waiting for us to process\n\t\t * an IPI.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t\tif (state_filter_match(state_filter, p))\n\t\t\tsched_show_task(p);\n\t}\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (!state_filter)\n\t\tsysrq_sched_debug_show();\n#endif\n\trcu_read_unlock();\n\t/*\n\t * Only show locks if all tasks are dumped:\n\t */\n\tif (!state_filter)\n\t\tdebug_show_all_locks();\n}"
  },
  {
    "function_name": "state_filter_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5298-5317",
    "snippet": "static inline bool\nstate_filter_match(unsigned long state_filter, struct task_struct *p)\n{\n\t/* no filter, everything matches */\n\tif (!state_filter)\n\t\treturn true;\n\n\t/* filter, but doesn't match */\n\tif (!(p->state & state_filter))\n\t\treturn false;\n\n\t/*\n\t * When looking for TASK_UNINTERRUPTIBLE skip TASK_IDLE (allows\n\t * TASK_KILLABLE).\n\t */\n\tif (state_filter == TASK_UNINTERRUPTIBLE && p->state == TASK_IDLE)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline bool\nstate_filter_match(unsigned long state_filter, struct task_struct *p)\n{\n\t/* no filter, everything matches */\n\tif (!state_filter)\n\t\treturn true;\n\n\t/* filter, but doesn't match */\n\tif (!(p->state & state_filter))\n\t\treturn false;\n\n\t/*\n\t * When looking for TASK_UNINTERRUPTIBLE skip TASK_IDLE (allows\n\t * TASK_KILLABLE).\n\t */\n\tif (state_filter == TASK_UNINTERRUPTIBLE && p->state == TASK_IDLE)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "sched_show_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5268-5295",
    "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_stack",
          "args": [
            "p"
          ],
          "line": 5294
        },
        "resolved": true,
        "details": {
          "function_name": "put_task_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "429-433",
          "snippet": "void put_task_stack(struct task_struct *tsk)\n{\n\tif (atomic_dec_and_test(&tsk->stack_refcount))\n\t\trelease_task_stack(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid put_task_stack(struct task_struct *tsk)\n{\n\tif (atomic_dec_and_test(&tsk->stack_refcount))\n\t\trelease_task_stack(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_stack",
          "args": [
            "p",
            "NULL"
          ],
          "line": 5293
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_show_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bt.c",
          "lines": "22-41",
          "snippet": "static void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tkdb_set_current_task(p);\n\tif (addr) {\n\t\tshow_stack((struct task_struct *)p, addr);\n\t} else if (kdb_current_regs) {\n#ifdef CONFIG_X86\n\t\tshow_stack(p, &kdb_current_regs->sp);\n#else\n\t\tshow_stack(p, NULL);\n#endif\n\t} else {\n\t\tshow_stack(p, NULL);\n\t}\n\tconsole_loglevel = old_lvl;\n\tkdb_trap_printk--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_worker_info",
          "args": [
            "KERN_INFO",
            "p"
          ],
          "line": 5292
        },
        "resolved": true,
        "details": {
          "function_name": "print_worker_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4395-4429",
          "snippet": "void print_worker_info(const char *log_lvl, struct task_struct *task)\n{\n\twork_func_t *fn = NULL;\n\tchar name[WQ_NAME_LEN] = { };\n\tchar desc[WORKER_DESC_LEN] = { };\n\tstruct pool_workqueue *pwq = NULL;\n\tstruct workqueue_struct *wq = NULL;\n\tstruct worker *worker;\n\n\tif (!(task->flags & PF_WQ_WORKER))\n\t\treturn;\n\n\t/*\n\t * This function is called without any synchronization and @task\n\t * could be in any state.  Be careful with dereferences.\n\t */\n\tworker = kthread_probe_data(task);\n\n\t/*\n\t * Carefully copy the associated workqueue's workfn, name and desc.\n\t * Keep the original last '\\0' in case the original is garbage.\n\t */\n\tprobe_kernel_read(&fn, &worker->current_func, sizeof(fn));\n\tprobe_kernel_read(&pwq, &worker->current_pwq, sizeof(pwq));\n\tprobe_kernel_read(&wq, &pwq->wq, sizeof(wq));\n\tprobe_kernel_read(name, wq->name, sizeof(name) - 1);\n\tprobe_kernel_read(desc, worker->desc, sizeof(desc) - 1);\n\n\tif (fn || name[0] || desc[0]) {\n\t\tprintk(\"%sWorkqueue: %s %pf\", log_lvl, name, fn);\n\t\tif (strcmp(name, desc))\n\t\t\tpr_cont(\" (%s)\", desc);\n\t\tpr_cont(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid print_worker_info(const char *log_lvl, struct task_struct *task)\n{\n\twork_func_t *fn = NULL;\n\tchar name[WQ_NAME_LEN] = { };\n\tchar desc[WORKER_DESC_LEN] = { };\n\tstruct pool_workqueue *pwq = NULL;\n\tstruct workqueue_struct *wq = NULL;\n\tstruct worker *worker;\n\n\tif (!(task->flags & PF_WQ_WORKER))\n\t\treturn;\n\n\t/*\n\t * This function is called without any synchronization and @task\n\t * could be in any state.  Be careful with dereferences.\n\t */\n\tworker = kthread_probe_data(task);\n\n\t/*\n\t * Carefully copy the associated workqueue's workfn, name and desc.\n\t * Keep the original last '\\0' in case the original is garbage.\n\t */\n\tprobe_kernel_read(&fn, &worker->current_func, sizeof(fn));\n\tprobe_kernel_read(&pwq, &worker->current_pwq, sizeof(pwq));\n\tprobe_kernel_read(&wq, &pwq->wq, sizeof(wq));\n\tprobe_kernel_read(name, wq->name, sizeof(name) - 1);\n\tprobe_kernel_read(desc, worker->desc, sizeof(desc) - 1);\n\n\tif (fn || name[0] || desc[0]) {\n\t\tprintk(\"%sWorkqueue: %s %pf\", log_lvl, name, fn);\n\t\tif (strcmp(name, desc))\n\t\t\tpr_cont(\" (%s)\", desc);\n\t\tpr_cont(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\"",
            "free",
            "task_pid_nr(p)",
            "ppid",
            "(unsigned long)task_thread_info(p)->flags"
          ],
          "line": 5288
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_thread_info",
          "args": [
            "p"
          ],
          "line": 5290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "p"
          ],
          "line": 5289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5287
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "rcu_dereference(p->real_parent)"
          ],
          "line": 5286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "p->real_parent"
          ],
          "line": 5286
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_alive",
          "args": [
            "p"
          ],
          "line": 5285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5284
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_not_used",
          "args": [
            "p"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"  running task    \""
          ],
          "line": 5279
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_state_to_char",
          "args": [
            "p"
          ],
          "line": 5276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_get_task_stack",
          "args": [
            "p"
          ],
          "line": 5273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}"
  },
  {
    "function_name": "sched_rr_get_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5195-5229",
    "snippet": "static int sched_rr_get_interval(pid_t pid, struct timespec64 *t)\n{\n\tstruct task_struct *p;\n\tunsigned int time_slice;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint retval;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tretval = -ESRCH;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\trq = task_rq_lock(p, &rf);\n\ttime_slice = 0;\n\tif (p->sched_class->get_rr_interval)\n\t\ttime_slice = p->sched_class->get_rr_interval(rq, p);\n\ttask_rq_unlock(rq, p, &rf);\n\n\trcu_read_unlock();\n\tjiffies_to_timespec64(time_slice, t);\n\treturn 0;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5227
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "jiffies_to_timespec64",
          "args": [
            "time_slice",
            "t"
          ],
          "line": 5223
        },
        "resolved": true,
        "details": {
          "function_name": "jiffies_to_timespec64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "627-638",
          "snippet": "void\njiffies_to_timespec64(const unsigned long jiffies, struct timespec64 *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_nsec = rem;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid\njiffies_to_timespec64(const unsigned long jiffies, struct timespec64 *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_nsec = rem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 5220
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->sched_class->get_rr_interval",
          "args": [
            "rq",
            "p"
          ],
          "line": 5219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 5216
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_getscheduler",
          "args": [
            "p"
          ],
          "line": 5212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_process_by_pid",
          "args": [
            "pid"
          ],
          "line": 5208
        },
        "resolved": true,
        "details": {
          "function_name": "find_process_by_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4040-4043",
          "snippet": "static struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5207
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int sched_rr_get_interval(pid_t pid, struct timespec64 *t)\n{\n\tstruct task_struct *p;\n\tunsigned int time_slice;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint retval;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tretval = -ESRCH;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\trq = task_rq_lock(p, &rf);\n\ttime_slice = 0;\n\tif (p->sched_class->get_rr_interval)\n\t\ttime_slice = p->sched_class->get_rr_interval(rq, p);\n\ttask_rq_unlock(rq, p, &rf);\n\n\trcu_read_unlock();\n\tjiffies_to_timespec64(time_slice, t);\n\treturn 0;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}"
  },
  {
    "function_name": "io_schedule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5132-5139",
    "snippet": "void io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_schedule_finish",
          "args": [
            "token"
          ],
          "line": 5138
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5110-5113",
          "snippet": "void io_schedule_finish(int token)\n{\n\tcurrent->in_iowait = token;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule_finish(int token)\n{\n\tcurrent->in_iowait = token;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 5137
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5132-5139",
          "snippet": "void io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "io_schedule_prepare",
          "args": [],
          "line": 5136
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5100-5108",
          "snippet": "int io_schedule_prepare(void)\n{\n\tint old_iowait = current->in_iowait;\n\n\tcurrent->in_iowait = 1;\n\tblk_schedule_flush_plug(current);\n\n\treturn old_iowait;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint io_schedule_prepare(void)\n{\n\tint old_iowait = current->in_iowait;\n\n\tcurrent->in_iowait = 1;\n\tblk_schedule_flush_plug(current);\n\n\treturn old_iowait;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
  },
  {
    "function_name": "io_schedule_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5119-5129",
    "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sched",
      "static void __sched"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "io_schedule_finish",
          "args": [
            "token"
          ],
          "line": 5126
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5110-5113",
          "snippet": "void io_schedule_finish(int token)\n{\n\tcurrent->in_iowait = token;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule_finish(int token)\n{\n\tcurrent->in_iowait = token;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "timeout"
          ],
          "line": 5125
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5119-5129",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "io_schedule_prepare",
          "args": [],
          "line": 5124
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5100-5108",
          "snippet": "int io_schedule_prepare(void)\n{\n\tint old_iowait = current->in_iowait;\n\n\tcurrent->in_iowait = 1;\n\tblk_schedule_flush_plug(current);\n\n\treturn old_iowait;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint io_schedule_prepare(void)\n{\n\tint old_iowait = current->in_iowait;\n\n\tcurrent->in_iowait = 1;\n\tblk_schedule_flush_plug(current);\n\n\treturn old_iowait;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "io_schedule_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5110-5113",
    "snippet": "void io_schedule_finish(int token)\n{\n\tcurrent->in_iowait = token;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule_finish(int token)\n{\n\tcurrent->in_iowait = token;\n}"
  },
  {
    "function_name": "io_schedule_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5100-5108",
    "snippet": "int io_schedule_prepare(void)\n{\n\tint old_iowait = current->in_iowait;\n\n\tcurrent->in_iowait = 1;\n\tblk_schedule_flush_plug(current);\n\n\treturn old_iowait;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_schedule_flush_plug",
          "args": [
            "current"
          ],
          "line": 5105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint io_schedule_prepare(void)\n{\n\tint old_iowait = current->in_iowait;\n\n\tcurrent->in_iowait = 1;\n\tblk_schedule_flush_plug(current);\n\n\treturn old_iowait;\n}"
  },
  {
    "function_name": "yield_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5041-5097",
    "snippet": "int __sched yield_to(struct task_struct *p, bool preempt)\n{\n\tstruct task_struct *curr = current;\n\tstruct rq *rq, *p_rq;\n\tunsigned long flags;\n\tint yielded = 0;\n\n\tlocal_irq_save(flags);\n\trq = this_rq();\n\nagain:\n\tp_rq = task_rq(p);\n\t/*\n\t * If we're the only runnable task on the rq and target rq also\n\t * has only one task, there's absolutely no point in yielding.\n\t */\n\tif (rq->nr_running == 1 && p_rq->nr_running == 1) {\n\t\tyielded = -ESRCH;\n\t\tgoto out_irq;\n\t}\n\n\tdouble_rq_lock(rq, p_rq);\n\tif (task_rq(p) != p_rq) {\n\t\tdouble_rq_unlock(rq, p_rq);\n\t\tgoto again;\n\t}\n\n\tif (!curr->sched_class->yield_to_task)\n\t\tgoto out_unlock;\n\n\tif (curr->sched_class != p->sched_class)\n\t\tgoto out_unlock;\n\n\tif (task_running(p_rq, p) || p->state)\n\t\tgoto out_unlock;\n\n\tyielded = curr->sched_class->yield_to_task(rq, p, preempt);\n\tif (yielded) {\n\t\tschedstat_inc(rq->yld_count);\n\t\t/*\n\t\t * Make p's CPU reschedule; pick_next_entity takes care of\n\t\t * fairness.\n\t\t */\n\t\tif (preempt && rq != p_rq)\n\t\t\tresched_curr(p_rq);\n\t}\n\nout_unlock:\n\tdouble_rq_unlock(rq, p_rq);\nout_irq:\n\tlocal_irq_restore(flags);\n\n\tif (yielded > 0)\n\t\tschedule();\n\n\treturn yielded;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static void __sched",
      "static void __sched"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 5094
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5132-5139",
          "snippet": "void io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 5091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "double_rq_unlock",
          "args": [
            "rq",
            "p_rq"
          ],
          "line": 5089
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "p_rq"
          ],
          "line": 5085
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedstat_inc",
          "args": [
            "rq->yld_count"
          ],
          "line": 5079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curr->sched_class->yield_to_task",
          "args": [
            "rq",
            "p",
            "preempt"
          ],
          "line": 5077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "p_rq",
            "p"
          ],
          "line": 5074
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1526-1533",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 5063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "double_rq_lock",
          "args": [
            "rq",
            "p_rq"
          ],
          "line": 5062
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2037-2045",
          "snippet": "static inline void double_rq_lock(struct rq *rq1, struct rq *rq2)\n\t__acquires(rq1->lock)\n\t__acquires(rq2->lock)\n{\n\tBUG_ON(!irqs_disabled());\n\tBUG_ON(rq1 != rq2);\n\traw_spin_lock(&rq1->lock);\n\t__acquire(rq2->lock);\t/* Fake it out ;) */\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_lock(struct rq *rq1, struct rq *rq2)\n\t__acquires(rq1->lock)\n\t__acquires(rq2->lock)\n{\n\tBUG_ON(!irqs_disabled());\n\tBUG_ON(rq1 != rq2);\n\traw_spin_lock(&rq1->lock);\n\t__acquire(rq2->lock);\t/* Fake it out ;) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 5052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 5049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 5048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nstatic void __sched;\nstatic void __sched;\n\nint __sched yield_to(struct task_struct *p, bool preempt)\n{\n\tstruct task_struct *curr = current;\n\tstruct rq *rq, *p_rq;\n\tunsigned long flags;\n\tint yielded = 0;\n\n\tlocal_irq_save(flags);\n\trq = this_rq();\n\nagain:\n\tp_rq = task_rq(p);\n\t/*\n\t * If we're the only runnable task on the rq and target rq also\n\t * has only one task, there's absolutely no point in yielding.\n\t */\n\tif (rq->nr_running == 1 && p_rq->nr_running == 1) {\n\t\tyielded = -ESRCH;\n\t\tgoto out_irq;\n\t}\n\n\tdouble_rq_lock(rq, p_rq);\n\tif (task_rq(p) != p_rq) {\n\t\tdouble_rq_unlock(rq, p_rq);\n\t\tgoto again;\n\t}\n\n\tif (!curr->sched_class->yield_to_task)\n\t\tgoto out_unlock;\n\n\tif (curr->sched_class != p->sched_class)\n\t\tgoto out_unlock;\n\n\tif (task_running(p_rq, p) || p->state)\n\t\tgoto out_unlock;\n\n\tyielded = curr->sched_class->yield_to_task(rq, p, preempt);\n\tif (yielded) {\n\t\tschedstat_inc(rq->yld_count);\n\t\t/*\n\t\t * Make p's CPU reschedule; pick_next_entity takes care of\n\t\t * fairness.\n\t\t */\n\t\tif (preempt && rq != p_rq)\n\t\t\tresched_curr(p_rq);\n\t}\n\nout_unlock:\n\tdouble_rq_unlock(rq, p_rq);\nout_irq:\n\tlocal_irq_restore(flags);\n\n\tif (yielded > 0)\n\t\tschedule();\n\n\treturn yielded;\n}"
  },
  {
    "function_name": "yield",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5019-5023",
    "snippet": "void __sched yield(void)\n{\n\tset_current_state(TASK_RUNNING);\n\tdo_sched_yield();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sched",
      "static void __sched"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_sched_yield",
          "args": [],
          "line": 5022
        },
        "resolved": true,
        "details": {
          "function_name": "do_sched_yield",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4929-4948",
          "snippet": "static void do_sched_yield(void)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = this_rq_lock_irq(&rf);\n\n\tschedstat_inc(rq->yld_count);\n\tcurrent->sched_class->yield_task(rq);\n\n\t/*\n\t * Since we are going to call schedule() anyway, there's\n\t * no need to preempt or enable interrupts:\n\t */\n\tpreempt_disable();\n\trq_unlock(rq, &rf);\n\tsched_preempt_enable_no_resched();\n\n\tschedule();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void do_sched_yield(void)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = this_rq_lock_irq(&rf);\n\n\tschedstat_inc(rq->yld_count);\n\tcurrent->sched_class->yield_task(rq);\n\n\t/*\n\t * Since we are going to call schedule() anyway, there's\n\t * no need to preempt or enable interrupts:\n\t */\n\tpreempt_disable();\n\trq_unlock(rq, &rf);\n\tsched_preempt_enable_no_resched();\n\n\tschedule();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 5021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched yield(void)\n{\n\tset_current_state(TASK_RUNNING);\n\tdo_sched_yield();\n}"
  },
  {
    "function_name": "__cond_resched_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4977-4994",
    "snippet": "int __cond_resched_lock(spinlock_t *lock)\n{\n\tint resched = should_resched(PREEMPT_LOCK_OFFSET);\n\tint ret = 0;\n\n\tlockdep_assert_held(lock);\n\n\tif (spin_needbreak(lock) || resched) {\n\t\tspin_unlock(lock);\n\t\tif (resched)\n\t\t\tpreempt_schedule_common();\n\t\telse\n\t\t\tcpu_relax();\n\t\tret = 1;\n\t\tspin_lock(lock);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lock"
          ],
          "line": 4991
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 4989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_schedule_common",
          "args": [],
          "line": 4987
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_schedule_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3578-3605",
          "snippet": "notrace preempt_schedule_common(void)\n{\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t__schedule(true);\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t} while (need_resched());\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nnotrace preempt_schedule_common(void)\n{\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t__schedule(true);\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t} while (need_resched());\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lock"
          ],
          "line": 4985
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "lock"
          ],
          "line": 4984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "lock"
          ],
          "line": 4982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_resched",
          "args": [
            "PREEMPT_LOCK_OFFSET"
          ],
          "line": 4979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint __cond_resched_lock(spinlock_t *lock)\n{\n\tint resched = should_resched(PREEMPT_LOCK_OFFSET);\n\tint ret = 0;\n\n\tlockdep_assert_held(lock);\n\n\tif (spin_needbreak(lock) || resched) {\n\t\tspin_unlock(lock);\n\t\tif (resched)\n\t\t\tpreempt_schedule_common();\n\t\telse\n\t\t\tcpu_relax();\n\t\tret = 1;\n\t\tspin_lock(lock);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "_cond_resched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4957-4965",
    "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sched",
      "static void __sched"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_all_qs",
          "args": [],
          "line": 4963
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_all_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "966-988",
          "snippet": "void rcu_all_qs(void)\n{\n\tunsigned long flags;\n\n\tif (!raw_cpu_read(rcu_data.rcu_urgent_qs))\n\t\treturn;\n\tpreempt_disable();\n\t/* Load rcu_urgent_qs before other flags. */\n\tif (!smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\tpreempt_enable();\n\t\treturn;\n\t}\n\tthis_cpu_write(rcu_data.rcu_urgent_qs, false);\n\tbarrier(); /* Avoid RCU read-side critical sections leaking down. */\n\tif (unlikely(raw_cpu_read(rcu_data.rcu_need_heavy_qs))) {\n\t\tlocal_irq_save(flags);\n\t\trcu_momentary_dyntick_idle();\n\t\tlocal_irq_restore(flags);\n\t}\n\trcu_qs();\n\tbarrier(); /* Avoid RCU read-side critical sections leaking up. */\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid rcu_all_qs(void)\n{\n\tunsigned long flags;\n\n\tif (!raw_cpu_read(rcu_data.rcu_urgent_qs))\n\t\treturn;\n\tpreempt_disable();\n\t/* Load rcu_urgent_qs before other flags. */\n\tif (!smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\tpreempt_enable();\n\t\treturn;\n\t}\n\tthis_cpu_write(rcu_data.rcu_urgent_qs, false);\n\tbarrier(); /* Avoid RCU read-side critical sections leaking down. */\n\tif (unlikely(raw_cpu_read(rcu_data.rcu_need_heavy_qs))) {\n\t\tlocal_irq_save(flags);\n\t\trcu_momentary_dyntick_idle();\n\t\tlocal_irq_restore(flags);\n\t}\n\trcu_qs();\n\tbarrier(); /* Avoid RCU read-side critical sections leaking up. */\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_schedule_common",
          "args": [],
          "line": 4960
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_schedule_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3578-3605",
          "snippet": "notrace preempt_schedule_common(void)\n{\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t__schedule(true);\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t} while (need_resched());\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nnotrace preempt_schedule_common(void)\n{\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t__schedule(true);\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t} while (need_resched());\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_resched",
          "args": [
            "0"
          ],
          "line": 4959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
  },
  {
    "function_name": "do_sched_yield",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4929-4948",
    "snippet": "static void do_sched_yield(void)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = this_rq_lock_irq(&rf);\n\n\tschedstat_inc(rq->yld_count);\n\tcurrent->sched_class->yield_task(rq);\n\n\t/*\n\t * Since we are going to call schedule() anyway, there's\n\t * no need to preempt or enable interrupts:\n\t */\n\tpreempt_disable();\n\trq_unlock(rq, &rf);\n\tsched_preempt_enable_no_resched();\n\n\tschedule();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 4947
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5132-5139",
          "snippet": "void io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_preempt_enable_no_resched",
          "args": [],
          "line": 4945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_unlock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 4944
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 4943
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "current->sched_class->yield_task",
          "args": [
            "rq"
          ],
          "line": 4937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_inc",
          "args": [
            "rq->yld_count"
          ],
          "line": 4936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq_lock_irq",
          "args": [
            "&rf"
          ],
          "line": 4934
        },
        "resolved": true,
        "details": {
          "function_name": "this_rq_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1162-1172",
          "snippet": "static inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void do_sched_yield(void)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = this_rq_lock_irq(&rf);\n\n\tschedstat_inc(rq->yld_count);\n\tcurrent->sched_class->yield_task(rq);\n\n\t/*\n\t * Since we are going to call schedule() anyway, there's\n\t * no need to preempt or enable interrupts:\n\t */\n\tpreempt_disable();\n\trq_unlock(rq, &rf);\n\tsched_preempt_enable_no_resched();\n\n\tschedule();\n}"
  },
  {
    "function_name": "sched_getaffinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4857-4882",
    "snippet": "long sched_getaffinity(pid_t pid, struct cpumask *mask)\n{\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint retval;\n\n\trcu_read_lock();\n\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tcpumask_and(mask, &p->cpus_allowed, cpu_active_mask);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\nout_unlock:\n\trcu_read_unlock();\n\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4879
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 4876
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "mask",
            "&p->cpus_allowed",
            "cpu_active_mask"
          ],
          "line": 4875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 4874
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_getscheduler",
          "args": [
            "p"
          ],
          "line": 4870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_process_by_pid",
          "args": [
            "pid"
          ],
          "line": 4866
        },
        "resolved": true,
        "details": {
          "function_name": "find_process_by_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4040-4043",
          "snippet": "static struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4863
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong sched_getaffinity(pid_t pid, struct cpumask *mask)\n{\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint retval;\n\n\trcu_read_lock();\n\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tcpumask_and(mask, &p->cpus_allowed, cpu_active_mask);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\nout_unlock:\n\trcu_read_unlock();\n\n\treturn retval;\n}"
  },
  {
    "function_name": "get_user_cpu_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4822-4831",
    "snippet": "static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len,\n\t\t\t     struct cpumask *new_mask)\n{\n\tif (len < cpumask_size())\n\t\tcpumask_clear(new_mask);\n\telse if (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\treturn copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "new_mask",
            "user_mask_ptr",
            "len"
          ],
          "line": 4830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 4827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "new_mask"
          ],
          "line": 4826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len,\n\t\t\t     struct cpumask *new_mask)\n{\n\tif (len < cpumask_size())\n\t\tcpumask_clear(new_mask);\n\telse if (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\treturn copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "sched_setaffinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4733-4820",
    "snippet": "long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tcpumask_var_t cpus_allowed, new_mask;\n\tstruct task_struct *p;\n\tint retval;\n\n\trcu_read_lock();\n\n\tp = find_process_by_pid(pid);\n\tif (!p) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/* Prevent p going away */\n\tget_task_struct(p);\n\trcu_read_unlock();\n\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tretval = -EINVAL;\n\t\tgoto out_put_task;\n\t}\n\tif (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_put_task;\n\t}\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_free_cpus_allowed;\n\t}\n\tretval = -EPERM;\n\tif (!check_same_owner(p)) {\n\t\trcu_read_lock();\n\t\tif (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_free_new_mask;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tretval = security_task_setscheduler(p);\n\tif (retval)\n\t\tgoto out_free_new_mask;\n\n\n\tcpuset_cpus_allowed(p, cpus_allowed);\n\tcpumask_and(new_mask, in_mask, cpus_allowed);\n\n\t/*\n\t * Since bandwidth control happens on root_domain basis,\n\t * if admission test is enabled, we only admit -deadline\n\t * tasks allowed to run on all the CPUs in the task's\n\t * root_domain.\n\t */\n#ifdef CONFIG_SMP\n\tif (task_has_dl_policy(p) && dl_bandwidth_enabled()) {\n\t\trcu_read_lock();\n\t\tif (!cpumask_subset(task_rq(p)->rd->span, new_mask)) {\n\t\t\tretval = -EBUSY;\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_free_new_mask;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n#endif\nagain:\n\tretval = __set_cpus_allowed_ptr(p, new_mask, true);\n\n\tif (!retval) {\n\t\tcpuset_cpus_allowed(p, cpus_allowed);\n\t\tif (!cpumask_subset(new_mask, cpus_allowed)) {\n\t\t\t/*\n\t\t\t * We must have raced with a concurrent cpuset\n\t\t\t * update. Just reset the cpus_allowed to the\n\t\t\t * cpuset's cpus_allowed\n\t\t\t */\n\t\t\tcpumask_copy(new_mask, cpus_allowed);\n\t\t\tgoto again;\n\t\t}\n\t}\nout_free_new_mask:\n\tfree_cpumask_var(new_mask);\nout_free_cpus_allowed:\n\tfree_cpumask_var(cpus_allowed);\nout_put_task:\n\tput_task_struct(p);\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 4818
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cpus_allowed"
          ],
          "line": 4816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "new_mask"
          ],
          "line": 4814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "new_mask",
            "cpus_allowed"
          ],
          "line": 4809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "new_mask",
            "cpus_allowed"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_cpus_allowed",
          "args": [
            "p",
            "cpus_allowed"
          ],
          "line": 4802
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_cpus_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cpuset.c",
          "lines": "2424-2433",
          "snippet": "void cpuset_cpus_allowed(struct task_struct *tsk, struct cpumask *pmask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&callback_lock, flags);\n\trcu_read_lock();\n\tguarantee_online_cpus(task_cs(tsk), pmask);\n\trcu_read_unlock();\n\tspin_unlock_irqrestore(&callback_lock, flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nvoid cpuset_cpus_allowed(struct task_struct *tsk, struct cpumask *pmask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&callback_lock, flags);\n\trcu_read_lock();\n\tguarantee_online_cpus(task_cs(tsk), pmask);\n\trcu_read_unlock();\n\tspin_unlock_irqrestore(&callback_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_cpus_allowed_ptr",
          "args": [
            "p",
            "new_mask",
            "true"
          ],
          "line": 4799
        },
        "resolved": true,
        "details": {
          "function_name": "__set_cpus_allowed_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1594-1598",
          "snippet": "static inline int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t\t const struct cpumask *new_mask, bool check)\n{\n\treturn set_cpus_allowed_ptr(p, new_mask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t\t const struct cpumask *new_mask, bool check)\n{\n\treturn set_cpus_allowed_ptr(p, new_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4795
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "task_rq(p)->rd->span",
            "new_mask"
          ],
          "line": 4790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 4790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4789
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bandwidth_enabled",
          "args": [],
          "line": 4788
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bandwidth_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "273-276",
          "snippet": "static inline int dl_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int dl_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_has_dl_policy",
          "args": [
            "p"
          ],
          "line": 4788
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_dl_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "184-187",
          "snippet": "static inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "new_mask",
            "in_mask",
            "cpus_allowed"
          ],
          "line": 4779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_setscheduler",
          "args": [
            "p"
          ],
          "line": 4773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "__task_cred(p)->user_ns",
            "CAP_SYS_NICE"
          ],
          "line": 4766
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "p"
          ],
          "line": 4766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_same_owner",
          "args": [
            "p"
          ],
          "line": 4764
        },
        "resolved": true,
        "details": {
          "function_name": "check_same_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4101-4112",
          "snippet": "static bool check_same_owner(struct task_struct *p)\n{\n\tconst struct cred *cred = current_cred(), *pcred;\n\tbool match;\n\n\trcu_read_lock();\n\tpcred = __task_cred(p);\n\tmatch = (uid_eq(cred->euid, pcred->euid) ||\n\t\t uid_eq(cred->euid, pcred->uid));\n\trcu_read_unlock();\n\treturn match;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool check_same_owner(struct task_struct *p)\n{\n\tconst struct cred *cred = current_cred(), *pcred;\n\tbool match;\n\n\trcu_read_lock();\n\tpcred = __task_cred(p);\n\tmatch = (uid_eq(cred->euid, pcred->euid) ||\n\t\t uid_eq(cred->euid, pcred->uid));\n\trcu_read_unlock();\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&new_mask",
            "GFP_KERNEL"
          ],
          "line": 4759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&cpus_allowed",
            "GFP_KERNEL"
          ],
          "line": 4755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 4748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_process_by_pid",
          "args": [
            "pid"
          ],
          "line": 4741
        },
        "resolved": true,
        "details": {
          "function_name": "find_process_by_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4040-4043",
          "snippet": "static struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nlong sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tcpumask_var_t cpus_allowed, new_mask;\n\tstruct task_struct *p;\n\tint retval;\n\n\trcu_read_lock();\n\n\tp = find_process_by_pid(pid);\n\tif (!p) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/* Prevent p going away */\n\tget_task_struct(p);\n\trcu_read_unlock();\n\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tretval = -EINVAL;\n\t\tgoto out_put_task;\n\t}\n\tif (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_put_task;\n\t}\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_free_cpus_allowed;\n\t}\n\tretval = -EPERM;\n\tif (!check_same_owner(p)) {\n\t\trcu_read_lock();\n\t\tif (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_free_new_mask;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tretval = security_task_setscheduler(p);\n\tif (retval)\n\t\tgoto out_free_new_mask;\n\n\n\tcpuset_cpus_allowed(p, cpus_allowed);\n\tcpumask_and(new_mask, in_mask, cpus_allowed);\n\n\t/*\n\t * Since bandwidth control happens on root_domain basis,\n\t * if admission test is enabled, we only admit -deadline\n\t * tasks allowed to run on all the CPUs in the task's\n\t * root_domain.\n\t */\n#ifdef CONFIG_SMP\n\tif (task_has_dl_policy(p) && dl_bandwidth_enabled()) {\n\t\trcu_read_lock();\n\t\tif (!cpumask_subset(task_rq(p)->rd->span, new_mask)) {\n\t\t\tretval = -EBUSY;\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_free_new_mask;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n#endif\nagain:\n\tretval = __set_cpus_allowed_ptr(p, new_mask, true);\n\n\tif (!retval) {\n\t\tcpuset_cpus_allowed(p, cpus_allowed);\n\t\tif (!cpumask_subset(new_mask, cpus_allowed)) {\n\t\t\t/*\n\t\t\t * We must have raced with a concurrent cpuset\n\t\t\t * update. Just reset the cpus_allowed to the\n\t\t\t * cpuset's cpus_allowed\n\t\t\t */\n\t\t\tcpumask_copy(new_mask, cpus_allowed);\n\t\t\tgoto again;\n\t\t}\n\t}\nout_free_new_mask:\n\tfree_cpumask_var(new_mask);\nout_free_cpus_allowed:\n\tfree_cpumask_var(cpus_allowed);\nout_put_task:\n\tput_task_struct(p);\n\treturn retval;\n}"
  },
  {
    "function_name": "sched_read_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4647-4681",
    "snippet": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we're handed a smaller struct than we know of,\n\t * ensure all the unknown bits are 0 - i.e. old\n\t * user-space does not get uncomplete information.\n\t */\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\treturn -EFBIG;\n\t\t}\n\n\t\tattr->size = usize;\n\t}\n\n\tret = copy_to_user(uattr, attr, attr->size);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uattr",
            "attr",
            "attr->size"
          ],
          "line": 4676
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "uattr",
            "usize"
          ],
          "line": 4653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we're handed a smaller struct than we know of,\n\t * ensure all the unknown bits are 0 - i.e. old\n\t * user-space does not get uncomplete information.\n\t */\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\treturn -EFBIG;\n\t\t}\n\n\t\tattr->size = usize;\n\t}\n\n\tret = copy_to_user(uattr, attr, attr->size);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_copy_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4448-4513",
    "snippet": "static int sched_copy_attr(struct sched_attr __user *uattr, struct sched_attr *attr)\n{\n\tu32 size;\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0))\n\t\treturn -EFAULT;\n\n\t/* Zero the full structure, so that a short copy will be nice: */\n\tmemset(attr, 0, sizeof(*attr));\n\n\tret = get_user(size, &uattr->size);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Bail out on silly large: */\n\tif (size > PAGE_SIZE)\n\t\tgoto err_size;\n\n\t/* ABI compatibility quirk: */\n\tif (!size)\n\t\tsize = SCHED_ATTR_SIZE_VER0;\n\n\tif (size < SCHED_ATTR_SIZE_VER0)\n\t\tgoto err_size;\n\n\t/*\n\t * If we're handed a bigger struct than we know of,\n\t * ensure all the unknown bits are 0 - i.e. new\n\t * user-space does not rely on any kernel feature\n\t * extensions we dont know about yet.\n\t */\n\tif (size > sizeof(*attr)) {\n\t\tunsigned char __user *addr;\n\t\tunsigned char __user *end;\n\t\tunsigned char val;\n\n\t\taddr = (void __user *)uattr + sizeof(*attr);\n\t\tend  = (void __user *)uattr + size;\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tret = get_user(val, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (val)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tsize = sizeof(*attr);\n\t}\n\n\tret = copy_from_user(attr, uattr, size);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\t/*\n\t * XXX: Do we want to be lenient like existing syscalls; or do we want\n\t * to be strict and return an error on out-of-bounds values?\n\t */\n\tattr->sched_nice = clamp(attr->sched_nice, MIN_NICE, MAX_NICE);\n\n\treturn 0;\n\nerr_size:\n\tput_user(sizeof(*attr), &uattr->size);\n\treturn -E2BIG;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "sizeof(*attr)",
            "&uattr->size"
          ],
          "line": 4511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "attr->sched_nice",
            "MIN_NICE",
            "MAX_NICE"
          ],
          "line": 4506
        },
        "resolved": true,
        "details": {
          "function_name": "wq_clamp_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4004-4014",
          "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "attr",
            "uattr",
            "size"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "val",
            "addr"
          ],
          "line": 4489
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "attr",
            "0",
            "sizeof(*attr)"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "uattr",
            "SCHED_ATTR_SIZE_VER0"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int sched_copy_attr(struct sched_attr __user *uattr, struct sched_attr *attr)\n{\n\tu32 size;\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, SCHED_ATTR_SIZE_VER0))\n\t\treturn -EFAULT;\n\n\t/* Zero the full structure, so that a short copy will be nice: */\n\tmemset(attr, 0, sizeof(*attr));\n\n\tret = get_user(size, &uattr->size);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Bail out on silly large: */\n\tif (size > PAGE_SIZE)\n\t\tgoto err_size;\n\n\t/* ABI compatibility quirk: */\n\tif (!size)\n\t\tsize = SCHED_ATTR_SIZE_VER0;\n\n\tif (size < SCHED_ATTR_SIZE_VER0)\n\t\tgoto err_size;\n\n\t/*\n\t * If we're handed a bigger struct than we know of,\n\t * ensure all the unknown bits are 0 - i.e. new\n\t * user-space does not rely on any kernel feature\n\t * extensions we dont know about yet.\n\t */\n\tif (size > sizeof(*attr)) {\n\t\tunsigned char __user *addr;\n\t\tunsigned char __user *end;\n\t\tunsigned char val;\n\n\t\taddr = (void __user *)uattr + sizeof(*attr);\n\t\tend  = (void __user *)uattr + size;\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tret = get_user(val, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (val)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tsize = sizeof(*attr);\n\t}\n\n\tret = copy_from_user(attr, uattr, size);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\t/*\n\t * XXX: Do we want to be lenient like existing syscalls; or do we want\n\t * to be strict and return an error on out-of-bounds values?\n\t */\n\tattr->sched_nice = clamp(attr->sched_nice, MIN_NICE, MAX_NICE);\n\n\treturn 0;\n\nerr_size:\n\tput_user(sizeof(*attr), &uattr->size);\n\treturn -E2BIG;\n}"
  },
  {
    "function_name": "do_sched_setscheduler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4423-4443",
    "snippet": "static int\ndo_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)\n{\n\tstruct sched_param lparam;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))\n\t\treturn -EFAULT;\n\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setscheduler(p, policy, &lparam);\n\trcu_read_unlock();\n\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4440
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_setscheduler",
          "args": [
            "p",
            "policy",
            "&lparam"
          ],
          "line": 4439
        },
        "resolved": true,
        "details": {
          "function_name": "do_sched_setscheduler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4423-4443",
          "snippet": "static int\ndo_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)\n{\n\tstruct sched_param lparam;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))\n\t\treturn -EFAULT;\n\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setscheduler(p, policy, &lparam);\n\trcu_read_unlock();\n\n\treturn retval;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "find_process_by_pid",
          "args": [
            "pid"
          ],
          "line": 4437
        },
        "resolved": true,
        "details": {
          "function_name": "find_process_by_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4040-4043",
          "snippet": "static struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4435
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&lparam",
            "param",
            "sizeof(struct sched_param)"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int\ndo_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)\n{\n\tstruct sched_param lparam;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))\n\t\treturn -EFAULT;\n\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setscheduler(p, policy, &lparam);\n\trcu_read_unlock();\n\n\treturn retval;\n}"
  },
  {
    "function_name": "sched_setscheduler_nocheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4416-4420",
    "snippet": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_sched_setscheduler",
          "args": [
            "p",
            "policy",
            "param",
            "false"
          ],
          "line": 4419
        },
        "resolved": true,
        "details": {
          "function_name": "_sched_setscheduler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4357-4374",
          "snippet": "static int _sched_setscheduler(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param, bool check)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy   = policy,\n\t\t.sched_priority = param->sched_priority,\n\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),\n\t};\n\n\t/* Fixup the legacy SCHED_RESET_ON_FORK hack. */\n\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\t\tpolicy &= ~SCHED_RESET_ON_FORK;\n\t\tattr.sched_policy = policy;\n\t}\n\n\treturn __sched_setscheduler(p, &attr, check, true);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define SETPARAM_POLICY\t-1"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\n#define SETPARAM_POLICY\t-1\n\nstatic __always_inline struct;\n\nstatic int _sched_setscheduler(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param, bool check)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy   = policy,\n\t\t.sched_priority = param->sched_priority,\n\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),\n\t};\n\n\t/* Fixup the legacy SCHED_RESET_ON_FORK hack. */\n\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\t\tpolicy &= ~SCHED_RESET_ON_FORK;\n\t\tattr.sched_policy = policy;\n\t}\n\n\treturn __sched_setscheduler(p, &attr, check, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}"
  },
  {
    "function_name": "sched_setattr_nocheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4398-4401",
    "snippet": "int sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, false, true);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sched_setscheduler",
          "args": [
            "p",
            "attr",
            "false",
            "true"
          ],
          "line": 4400
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_setscheduler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4114-4355",
          "snippet": "static int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (idle_policy(p->policy) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn 0;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\treturn -EPERM;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, &p->cpus_allowed) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EBUSY;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\t__setscheduler(rq, p, attr, pi);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi)\n\t\trt_mutex_adjust_pi(p);\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (idle_policy(p->policy) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn 0;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\treturn -EPERM;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, &p->cpus_allowed) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EBUSY;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\t__setscheduler(rq, p, attr, pi);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi)\n\t\trt_mutex_adjust_pi(p);\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, false, true);\n}"
  },
  {
    "function_name": "sched_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4392-4395",
    "snippet": "int sched_setattr(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, true, true);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sched_setscheduler",
          "args": [
            "p",
            "attr",
            "true",
            "true"
          ],
          "line": 4394
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_setscheduler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4114-4355",
          "snippet": "static int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (idle_policy(p->policy) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn 0;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\treturn -EPERM;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, &p->cpus_allowed) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EBUSY;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\t__setscheduler(rq, p, attr, pi);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi)\n\t\trt_mutex_adjust_pi(p);\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (idle_policy(p->policy) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn 0;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\treturn -EPERM;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, &p->cpus_allowed) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EBUSY;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\t__setscheduler(rq, p, attr, pi);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi)\n\t\trt_mutex_adjust_pi(p);\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setattr(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, true, true);\n}"
  },
  {
    "function_name": "sched_setscheduler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4385-4389",
    "snippet": "int sched_setscheduler(struct task_struct *p, int policy,\n\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, true);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_sched_setscheduler",
          "args": [
            "p",
            "policy",
            "param",
            "true"
          ],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "_sched_setscheduler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4357-4374",
          "snippet": "static int _sched_setscheduler(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param, bool check)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy   = policy,\n\t\t.sched_priority = param->sched_priority,\n\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),\n\t};\n\n\t/* Fixup the legacy SCHED_RESET_ON_FORK hack. */\n\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\t\tpolicy &= ~SCHED_RESET_ON_FORK;\n\t\tattr.sched_policy = policy;\n\t}\n\n\treturn __sched_setscheduler(p, &attr, check, true);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define SETPARAM_POLICY\t-1"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\n#define SETPARAM_POLICY\t-1\n\nstatic __always_inline struct;\n\nstatic int _sched_setscheduler(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param, bool check)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy   = policy,\n\t\t.sched_priority = param->sched_priority,\n\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),\n\t};\n\n\t/* Fixup the legacy SCHED_RESET_ON_FORK hack. */\n\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\t\tpolicy &= ~SCHED_RESET_ON_FORK;\n\t\tattr.sched_policy = policy;\n\t}\n\n\treturn __sched_setscheduler(p, &attr, check, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setscheduler(struct task_struct *p, int policy,\n\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, true);\n}"
  },
  {
    "function_name": "_sched_setscheduler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4357-4374",
    "snippet": "static int _sched_setscheduler(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param, bool check)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy   = policy,\n\t\t.sched_priority = param->sched_priority,\n\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),\n\t};\n\n\t/* Fixup the legacy SCHED_RESET_ON_FORK hack. */\n\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\t\tpolicy &= ~SCHED_RESET_ON_FORK;\n\t\tattr.sched_policy = policy;\n\t}\n\n\treturn __sched_setscheduler(p, &attr, check, true);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define SETPARAM_POLICY\t-1"
    ],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sched_setscheduler",
          "args": [
            "p",
            "&attr",
            "check",
            "true"
          ],
          "line": 4373
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_setscheduler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4114-4355",
          "snippet": "static int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (idle_policy(p->policy) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn 0;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\treturn -EPERM;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, &p->cpus_allowed) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EBUSY;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\t__setscheduler(rq, p, attr, pi);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi)\n\t\trt_mutex_adjust_pi(p);\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (idle_policy(p->policy) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn 0;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\treturn -EPERM;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, &p->cpus_allowed) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EBUSY;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\t__setscheduler(rq, p, attr, pi);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi)\n\t\trt_mutex_adjust_pi(p);\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRIO_TO_NICE",
          "args": [
            "p->static_prio"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\n#define SETPARAM_POLICY\t-1\n\nstatic __always_inline struct;\n\nstatic int _sched_setscheduler(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param, bool check)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy   = policy,\n\t\t.sched_priority = param->sched_priority,\n\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),\n\t};\n\n\t/* Fixup the legacy SCHED_RESET_ON_FORK hack. */\n\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\t\tpolicy &= ~SCHED_RESET_ON_FORK;\n\t\tattr.sched_policy = policy;\n\t}\n\n\treturn __sched_setscheduler(p, &attr, check, true);\n}"
  },
  {
    "function_name": "__sched_setscheduler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4114-4355",
    "snippet": "static int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (idle_policy(p->policy) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn 0;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\treturn -EPERM;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, &p->cpus_allowed) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EBUSY;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\t__setscheduler(rq, p, attr, pi);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi)\n\t\trt_mutex_adjust_pi(p);\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 4352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_callback",
          "args": [
            "rq"
          ],
          "line": 4351
        },
        "resolved": true,
        "details": {
          "function_name": "balance_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2753-2755",
          "snippet": "static inline void balance_callback(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void balance_callback(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_adjust_pi",
          "args": [
            "p"
          ],
          "line": 4348
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_adjust_pi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1126-1147",
          "snippet": "void rt_mutex_adjust_pi(struct task_struct *task)\n{\n\tstruct rt_mutex_waiter *waiter;\n\tstruct rt_mutex *next_lock;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\n\twaiter = task->pi_blocked_on;\n\tif (!waiter || rt_mutex_waiter_equal(waiter, task_to_waiter(task))) {\n\t\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\t\treturn;\n\t}\n\tnext_lock = waiter->lock;\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\n\t/* gets dropped in rt_mutex_adjust_prio_chain()! */\n\tget_task_struct(task);\n\n\trt_mutex_adjust_prio_chain(task, RT_MUTEX_MIN_CHAINWALK, NULL,\n\t\t\t\t   next_lock, NULL, task);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid rt_mutex_adjust_pi(struct task_struct *task)\n{\n\tstruct rt_mutex_waiter *waiter;\n\tstruct rt_mutex *next_lock;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\n\twaiter = task->pi_blocked_on;\n\tif (!waiter || rt_mutex_waiter_equal(waiter, task_to_waiter(task))) {\n\t\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\t\treturn;\n\t}\n\tnext_lock = waiter->lock;\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\n\t/* gets dropped in rt_mutex_adjust_prio_chain()! */\n\tget_task_struct(task);\n\n\trt_mutex_adjust_prio_chain(task, RT_MUTEX_MIN_CHAINWALK, NULL,\n\t\t\t\t   next_lock, NULL, task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 4345
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 4344
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_class_changed",
          "args": [
            "rq",
            "p",
            "prev_class",
            "oldprio"
          ],
          "line": 4341
        },
        "resolved": true,
        "details": {
          "function_name": "check_class_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "828-839",
          "snippet": "static inline void check_class_changed(struct rq *rq, struct task_struct *p,\n\t\t\t\t       const struct sched_class *prev_class,\n\t\t\t\t       int oldprio)\n{\n\tif (prev_class != p->sched_class) {\n\t\tif (prev_class->switched_from)\n\t\t\tprev_class->switched_from(rq, p);\n\n\t\tp->sched_class->switched_to(rq, p);\n\t} else if (oldprio != p->prio || dl_task(p))\n\t\tp->sched_class->prio_changed(rq, p, oldprio);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void check_class_changed(struct rq *rq, struct task_struct *p,\n\t\t\t\t       const struct sched_class *prev_class,\n\t\t\t\t       int oldprio)\n{\n\tif (prev_class != p->sched_class) {\n\t\tif (prev_class->switched_from)\n\t\t\tprev_class->switched_from(rq, p);\n\n\t\tp->sched_class->switched_to(rq, p);\n\t} else if (oldprio != p->prio || dl_task(p))\n\t\tp->sched_class->prio_changed(rq, p, oldprio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_curr_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 4339
        },
        "resolved": true,
        "details": {
          "function_name": "ia64_set_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6228-6231",
          "snippet": "void ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task",
          "args": [
            "rq",
            "p",
            "queue_flags"
          ],
          "line": 4336
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "720-731",
          "snippet": "static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setscheduler",
          "args": [
            "rq",
            "p",
            "attr",
            "pi"
          ],
          "line": 4326
        },
        "resolved": true,
        "details": {
          "function_name": "__setscheduler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4077-4096",
          "snippet": "static void __setscheduler(struct rq *rq, struct task_struct *p,\n\t\t\t   const struct sched_attr *attr, bool keep_boost)\n{\n\t__setscheduler_params(p, attr);\n\n\t/*\n\t * Keep a potential priority boosting if called from\n\t * sched_setscheduler().\n\t */\n\tp->prio = normal_prio(p);\n\tif (keep_boost)\n\t\tp->prio = rt_effective_prio(p, p->prio);\n\n\tif (dl_prio(p->prio))\n\t\tp->sched_class = &dl_sched_class;\n\telse if (rt_prio(p->prio))\n\t\tp->sched_class = &rt_sched_class;\n\telse\n\t\tp->sched_class = &fair_sched_class;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __setscheduler(struct rq *rq, struct task_struct *p,\n\t\t\t   const struct sched_attr *attr, bool keep_boost)\n{\n\t__setscheduler_params(p, attr);\n\n\t/*\n\t * Keep a potential priority boosting if called from\n\t * sched_setscheduler().\n\t */\n\tp->prio = normal_prio(p);\n\tif (keep_boost)\n\t\tp->prio = rt_effective_prio(p, p->prio);\n\n\tif (dl_prio(p->prio))\n\t\tp->sched_class = &dl_sched_class;\n\telse if (rt_prio(p->prio))\n\t\tp->sched_class = &rt_sched_class;\n\telse\n\t\tp->sched_class = &fair_sched_class;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_prev_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 4323
        },
        "resolved": true,
        "details": {
          "function_name": "put_prev_task_fake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5553-5555",
          "snippet": "static void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_task",
          "args": [
            "rq",
            "p",
            "queue_flags"
          ],
          "line": 4321
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "733-744",
          "snippet": "static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1521-1524",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 4318
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_effective_prio",
          "args": [
            "p",
            "newprio"
          ],
          "line": 4313
        },
        "resolved": true,
        "details": {
          "function_name": "rt_effective_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3859-3862",
          "snippet": "static inline int rt_effective_prio(struct task_struct *p, int prio)\n{\n\treturn prio;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int rt_effective_prio(struct task_struct *p, int prio)\n{\n\treturn prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_dl_overflow",
          "args": [
            "p",
            "policy",
            "attr"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "sched_dl_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2515-2568",
          "snippet": "int sched_dl_overflow(struct task_struct *p, int policy,\n\t\t      const struct sched_attr *attr)\n{\n\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\tu64 period = attr->sched_period ?: attr->sched_deadline;\n\tu64 runtime = attr->sched_runtime;\n\tu64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0;\n\tint cpus, err = -1;\n\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn 0;\n\n\t/* !deadline task may carry old deadline bandwidth */\n\tif (new_bw == p->dl.dl_bw && task_has_dl_policy(p))\n\t\treturn 0;\n\n\t/*\n\t * Either if a task, enters, leave, or stays -deadline but changes\n\t * its parameters, we may need to update accordingly the total\n\t * allocated bandwidth of the container.\n\t */\n\traw_spin_lock(&dl_b->lock);\n\tcpus = dl_bw_cpus(task_cpu(p));\n\tif (dl_policy(policy) && !task_has_dl_policy(p) &&\n\t    !__dl_overflow(dl_b, cpus, 0, new_bw)) {\n\t\tif (hrtimer_active(&p->dl.inactive_timer))\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\terr = 0;\n\t} else if (dl_policy(policy) && task_has_dl_policy(p) &&\n\t\t   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) {\n\t\t/*\n\t\t * XXX this is slightly incorrect: when the task\n\t\t * utilization decreases, we should delay the total\n\t\t * utilization change until the task's 0-lag point.\n\t\t * But this would require to set the task's \"inactive\n\t\t * timer\" when the task is not inactive.\n\t\t */\n\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\tdl_change_utilization(p, new_bw);\n\t\terr = 0;\n\t} else if (!dl_policy(policy) && task_has_dl_policy(p)) {\n\t\t/*\n\t\t * Do not decrease the total deadline utilization here,\n\t\t * switched_from_dl() will take care to do it at the correct\n\t\t * (0-lag) time.\n\t\t */\n\t\terr = 0;\n\t}\n\traw_spin_unlock(&dl_b->lock);\n\n\treturn err;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nint sched_dl_overflow(struct task_struct *p, int policy,\n\t\t      const struct sched_attr *attr)\n{\n\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\tu64 period = attr->sched_period ?: attr->sched_deadline;\n\tu64 runtime = attr->sched_runtime;\n\tu64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0;\n\tint cpus, err = -1;\n\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn 0;\n\n\t/* !deadline task may carry old deadline bandwidth */\n\tif (new_bw == p->dl.dl_bw && task_has_dl_policy(p))\n\t\treturn 0;\n\n\t/*\n\t * Either if a task, enters, leave, or stays -deadline but changes\n\t * its parameters, we may need to update accordingly the total\n\t * allocated bandwidth of the container.\n\t */\n\traw_spin_lock(&dl_b->lock);\n\tcpus = dl_bw_cpus(task_cpu(p));\n\tif (dl_policy(policy) && !task_has_dl_policy(p) &&\n\t    !__dl_overflow(dl_b, cpus, 0, new_bw)) {\n\t\tif (hrtimer_active(&p->dl.inactive_timer))\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\terr = 0;\n\t} else if (dl_policy(policy) && task_has_dl_policy(p) &&\n\t\t   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) {\n\t\t/*\n\t\t * XXX this is slightly incorrect: when the task\n\t\t * utilization decreases, we should delay the total\n\t\t * utilization change until the task's 0-lag point.\n\t\t * But this would require to set the task's \"inactive\n\t\t * timer\" when the task is not inactive.\n\t\t */\n\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\tdl_change_utilization(p, new_bw);\n\t\terr = 0;\n\t} else if (!dl_policy(policy) && task_has_dl_policy(p)) {\n\t\t/*\n\t\t * Do not decrease the total deadline utilization here,\n\t\t * switched_from_dl() will take care to do it at the correct\n\t\t * (0-lag) time.\n\t\t */\n\t\terr = 0;\n\t}\n\traw_spin_unlock(&dl_b->lock);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_policy",
          "args": [
            "policy"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_dl_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "184-187",
          "snippet": "static inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "oldpolicy != -1 && oldpolicy != p->policy"
          ],
          "line": 4286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "span",
            "&p->cpus_allowed"
          ],
          "line": 4276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_bandwidth_enabled",
          "args": [],
          "line": 4267
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bandwidth_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "273-276",
          "snippet": "static inline int dl_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int dl_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_group_is_autogroup",
          "args": [
            "task_group(p)"
          ],
          "line": 4261
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_is_autogroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/autogroup.h",
          "lines": "44-47",
          "snippet": "static inline bool task_group_is_autogroup(struct task_group *tg)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool task_group_is_autogroup(struct task_group *tg)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_policy",
          "args": [
            "policy"
          ],
          "line": 4259
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_rt_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "179-182",
          "snippet": "static inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_bandwidth_enabled",
          "args": [],
          "line": 4259
        },
        "resolved": true,
        "details": {
          "function_name": "rt_bandwidth_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "572-575",
          "snippet": "static inline int rt_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int rt_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_param_changed",
          "args": [
            "p",
            "attr"
          ],
          "line": 4244
        },
        "resolved": true,
        "details": {
          "function_name": "dl_param_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2665-2676",
          "snippet": "bool dl_param_changed(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tif (dl_se->dl_runtime != attr->sched_runtime ||\n\t    dl_se->dl_deadline != attr->sched_deadline ||\n\t    dl_se->dl_period != attr->sched_period ||\n\t    dl_se->flags != attr->sched_flags)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nbool dl_param_changed(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tif (dl_se->dl_runtime != attr->sched_runtime ||\n\t    dl_se->dl_deadline != attr->sched_deadline ||\n\t    dl_se->dl_period != attr->sched_period ||\n\t    dl_se->flags != attr->sched_flags)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 4240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fair_policy",
          "args": [
            "policy"
          ],
          "line": 4240
        },
        "resolved": true,
        "details": {
          "function_name": "fair_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "159-162",
          "snippet": "static inline int fair_policy(int policy)\n{\n\treturn policy == SCHED_NORMAL || policy == SCHED_BATCH;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int fair_policy(int policy)\n{\n\treturn policy == SCHED_NORMAL || policy == SCHED_BATCH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "policy == p->policy"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 4225
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 4224
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_setscheduler",
          "args": [
            "p"
          ],
          "line": 4212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_same_owner",
          "args": [
            "p"
          ],
          "line": 4200
        },
        "resolved": true,
        "details": {
          "function_name": "check_same_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4101-4112",
          "snippet": "static bool check_same_owner(struct task_struct *p)\n{\n\tconst struct cred *cred = current_cred(), *pcred;\n\tbool match;\n\n\trcu_read_lock();\n\tpcred = __task_cred(p);\n\tmatch = (uid_eq(cred->euid, pcred->euid) ||\n\t\t uid_eq(cred->euid, pcred->uid));\n\trcu_read_unlock();\n\treturn match;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool check_same_owner(struct task_struct *p)\n{\n\tconst struct cred *cred = current_cred(), *pcred;\n\tbool match;\n\n\trcu_read_lock();\n\tpcred = __task_cred(p);\n\tmatch = (uid_eq(cred->euid, pcred->euid) ||\n\t\t uid_eq(cred->euid, pcred->uid));\n\trcu_read_unlock();\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_nice",
          "args": [
            "p",
            "task_nice(p)"
          ],
          "line": 4195
        },
        "resolved": true,
        "details": {
          "function_name": "can_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3925-3932",
          "snippet": "int can_nice(const struct task_struct *p, const int nice)\n{\n\t/* Convert nice value [19,-20] to rlimit style value [1,40]: */\n\tint nice_rlim = nice_to_rlimit(nice);\n\n\treturn (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||\n\t\tcapable(CAP_SYS_NICE));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint can_nice(const struct task_struct *p, const int nice)\n{\n\t/* Convert nice value [19,-20] to rlimit style value [1,40]: */\n\tint nice_rlim = nice_to_rlimit(nice);\n\n\treturn (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||\n\t\tcapable(CAP_SYS_NICE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 4195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_policy",
          "args": [
            "policy"
          ],
          "line": 4194
        },
        "resolved": true,
        "details": {
          "function_name": "idle_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "155-158",
          "snippet": "static inline int idle_policy(int policy)\n{\n\treturn policy == SCHED_IDLE;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int idle_policy(int policy)\n{\n\treturn policy == SCHED_IDLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rlimit",
          "args": [
            "p",
            "RLIMIT_RTPRIO"
          ],
          "line": 4169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_NICE"
          ],
          "line": 4160
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__checkparam_dl",
          "args": [
            "attr"
          ],
          "line": 4153
        },
        "resolved": true,
        "details": {
          "function_name": "__checkparam_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2611-2643",
          "snippet": "bool __checkparam_dl(const struct sched_attr *attr)\n{\n\t/* special dl tasks don't actually use any parameter */\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn true;\n\n\t/* deadline != 0 */\n\tif (attr->sched_deadline == 0)\n\t\treturn false;\n\n\t/*\n\t * Since we truncate DL_SCALE bits, make sure we're at least\n\t * that big.\n\t */\n\tif (attr->sched_runtime < (1ULL << DL_SCALE))\n\t\treturn false;\n\n\t/*\n\t * Since we use the MSB for wrap-around and sign issues, make\n\t * sure it's not set (mind that period can be equal to zero).\n\t */\n\tif (attr->sched_deadline & (1ULL << 63) ||\n\t    attr->sched_period & (1ULL << 63))\n\t\treturn false;\n\n\t/* runtime <= deadline <= period (if period != 0) */\n\tif ((attr->sched_period != 0 &&\n\t     attr->sched_period < attr->sched_deadline) ||\n\t    attr->sched_deadline < attr->sched_runtime)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nbool __checkparam_dl(const struct sched_attr *attr)\n{\n\t/* special dl tasks don't actually use any parameter */\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn true;\n\n\t/* deadline != 0 */\n\tif (attr->sched_deadline == 0)\n\t\treturn false;\n\n\t/*\n\t * Since we truncate DL_SCALE bits, make sure we're at least\n\t * that big.\n\t */\n\tif (attr->sched_runtime < (1ULL << DL_SCALE))\n\t\treturn false;\n\n\t/*\n\t * Since we use the MSB for wrap-around and sign issues, make\n\t * sure it's not set (mind that period can be equal to zero).\n\t */\n\tif (attr->sched_deadline & (1ULL << 63) ||\n\t    attr->sched_period & (1ULL << 63))\n\t\treturn false;\n\n\t/* runtime <= deadline <= period (if period != 0) */\n\tif ((attr->sched_period != 0 &&\n\t     attr->sched_period < attr->sched_deadline) ||\n\t    attr->sched_deadline < attr->sched_runtime)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_policy",
          "args": [
            "policy"
          ],
          "line": 4138
        },
        "resolved": true,
        "details": {
          "function_name": "valid_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "173-177",
          "snippet": "static inline bool valid_policy(int policy)\n{\n\treturn idle_policy(policy) || fair_policy(policy) ||\n\t\trt_policy(policy) || dl_policy(policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool valid_policy(int policy)\n{\n\treturn idle_policy(policy) || fair_policy(policy) ||\n\t\trt_policy(policy) || dl_policy(policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pi && in_interrupt()"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (idle_policy(p->policy) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn 0;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\treturn -EPERM;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, &p->cpus_allowed) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\ttask_rq_unlock(rq, p, &rf);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\treturn -EBUSY;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\t__setscheduler(rq, p, attr, pi);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi)\n\t\trt_mutex_adjust_pi(p);\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_same_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4101-4112",
    "snippet": "static bool check_same_owner(struct task_struct *p)\n{\n\tconst struct cred *cred = current_cred(), *pcred;\n\tbool match;\n\n\trcu_read_lock();\n\tpcred = __task_cred(p);\n\tmatch = (uid_eq(cred->euid, pcred->euid) ||\n\t\t uid_eq(cred->euid, pcred->uid));\n\trcu_read_unlock();\n\treturn match;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "pcred->uid"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "pcred->euid"
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "p"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4106
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool check_same_owner(struct task_struct *p)\n{\n\tconst struct cred *cred = current_cred(), *pcred;\n\tbool match;\n\n\trcu_read_lock();\n\tpcred = __task_cred(p);\n\tmatch = (uid_eq(cred->euid, pcred->euid) ||\n\t\t uid_eq(cred->euid, pcred->uid));\n\trcu_read_unlock();\n\treturn match;\n}"
  },
  {
    "function_name": "__setscheduler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4077-4096",
    "snippet": "static void __setscheduler(struct rq *rq, struct task_struct *p,\n\t\t\t   const struct sched_attr *attr, bool keep_boost)\n{\n\t__setscheduler_params(p, attr);\n\n\t/*\n\t * Keep a potential priority boosting if called from\n\t * sched_setscheduler().\n\t */\n\tp->prio = normal_prio(p);\n\tif (keep_boost)\n\t\tp->prio = rt_effective_prio(p, p->prio);\n\n\tif (dl_prio(p->prio))\n\t\tp->sched_class = &dl_sched_class;\n\telse if (rt_prio(p->prio))\n\t\tp->sched_class = &rt_sched_class;\n\telse\n\t\tp->sched_class = &fair_sched_class;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rt_prio",
          "args": [
            "p->prio"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "convert_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
          "lines": "32-46",
          "snippet": "static int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "p->prio"
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_effective_prio",
          "args": [
            "p",
            "p->prio"
          ],
          "line": 4088
        },
        "resolved": true,
        "details": {
          "function_name": "rt_effective_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3859-3862",
          "snippet": "static inline int rt_effective_prio(struct task_struct *p, int prio)\n{\n\treturn prio;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int rt_effective_prio(struct task_struct *p, int prio)\n{\n\treturn prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "normal_prio",
          "args": [
            "p"
          ],
          "line": 4086
        },
        "resolved": true,
        "details": {
          "function_name": "normal_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "777-788",
          "snippet": "static inline int normal_prio(struct task_struct *p)\n{\n\tint prio;\n\n\tif (task_has_dl_policy(p))\n\t\tprio = MAX_DL_PRIO-1;\n\telse if (task_has_rt_policy(p))\n\t\tprio = MAX_RT_PRIO-1 - p->rt_priority;\n\telse\n\t\tprio = __normal_prio(p);\n\treturn prio;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int normal_prio(struct task_struct *p)\n{\n\tint prio;\n\n\tif (task_has_dl_policy(p))\n\t\tprio = MAX_DL_PRIO-1;\n\telse if (task_has_rt_policy(p))\n\t\tprio = MAX_RT_PRIO-1 - p->rt_priority;\n\telse\n\t\tprio = __normal_prio(p);\n\treturn prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setscheduler_params",
          "args": [
            "p",
            "attr"
          ],
          "line": 4080
        },
        "resolved": true,
        "details": {
          "function_name": "__setscheduler_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4051-4074",
          "snippet": "static void __setscheduler_params(struct task_struct *p,\n\t\tconst struct sched_attr *attr)\n{\n\tint policy = attr->sched_policy;\n\n\tif (policy == SETPARAM_POLICY)\n\t\tpolicy = p->policy;\n\n\tp->policy = policy;\n\n\tif (dl_policy(policy))\n\t\t__setparam_dl(p, attr);\n\telse if (fair_policy(policy))\n\t\tp->static_prio = NICE_TO_PRIO(attr->sched_nice);\n\n\t/*\n\t * __sched_setscheduler() ensures attr->sched_priority == 0 when\n\t * !rt_policy. Always setting this ensures that things like\n\t * getparam()/getattr() don't report silly values for !rt tasks.\n\t */\n\tp->rt_priority = attr->sched_priority;\n\tp->normal_prio = normal_prio(p);\n\tset_load_weight(p, true);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define SETPARAM_POLICY\t-1"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\n#define SETPARAM_POLICY\t-1\n\nstatic __always_inline struct;\n\nstatic void __setscheduler_params(struct task_struct *p,\n\t\tconst struct sched_attr *attr)\n{\n\tint policy = attr->sched_policy;\n\n\tif (policy == SETPARAM_POLICY)\n\t\tpolicy = p->policy;\n\n\tp->policy = policy;\n\n\tif (dl_policy(policy))\n\t\t__setparam_dl(p, attr);\n\telse if (fair_policy(policy))\n\t\tp->static_prio = NICE_TO_PRIO(attr->sched_nice);\n\n\t/*\n\t * __sched_setscheduler() ensures attr->sched_priority == 0 when\n\t * !rt_policy. Always setting this ensures that things like\n\t * getparam()/getattr() don't report silly values for !rt tasks.\n\t */\n\tp->rt_priority = attr->sched_priority;\n\tp->normal_prio = normal_prio(p);\n\tset_load_weight(p, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __setscheduler(struct rq *rq, struct task_struct *p,\n\t\t\t   const struct sched_attr *attr, bool keep_boost)\n{\n\t__setscheduler_params(p, attr);\n\n\t/*\n\t * Keep a potential priority boosting if called from\n\t * sched_setscheduler().\n\t */\n\tp->prio = normal_prio(p);\n\tif (keep_boost)\n\t\tp->prio = rt_effective_prio(p, p->prio);\n\n\tif (dl_prio(p->prio))\n\t\tp->sched_class = &dl_sched_class;\n\telse if (rt_prio(p->prio))\n\t\tp->sched_class = &rt_sched_class;\n\telse\n\t\tp->sched_class = &fair_sched_class;\n}"
  },
  {
    "function_name": "__setscheduler_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4051-4074",
    "snippet": "static void __setscheduler_params(struct task_struct *p,\n\t\tconst struct sched_attr *attr)\n{\n\tint policy = attr->sched_policy;\n\n\tif (policy == SETPARAM_POLICY)\n\t\tpolicy = p->policy;\n\n\tp->policy = policy;\n\n\tif (dl_policy(policy))\n\t\t__setparam_dl(p, attr);\n\telse if (fair_policy(policy))\n\t\tp->static_prio = NICE_TO_PRIO(attr->sched_nice);\n\n\t/*\n\t * __sched_setscheduler() ensures attr->sched_priority == 0 when\n\t * !rt_policy. Always setting this ensures that things like\n\t * getparam()/getattr() don't report silly values for !rt tasks.\n\t */\n\tp->rt_priority = attr->sched_priority;\n\tp->normal_prio = normal_prio(p);\n\tset_load_weight(p, true);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define SETPARAM_POLICY\t-1"
    ],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_load_weight",
          "args": [
            "p",
            "true"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "set_load_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "692-718",
          "snippet": "static void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (idle_policy(p->policy)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\tp->se.runnable_weight = load->weight;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t\tp->se.runnable_weight = load->weight;\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "const int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};",
            "const u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nconst int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};\nconst u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};\n\nstatic void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (idle_policy(p->policy)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\tp->se.runnable_weight = load->weight;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t\tp->se.runnable_weight = load->weight;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "normal_prio",
          "args": [
            "p"
          ],
          "line": 4072
        },
        "resolved": true,
        "details": {
          "function_name": "normal_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "777-788",
          "snippet": "static inline int normal_prio(struct task_struct *p)\n{\n\tint prio;\n\n\tif (task_has_dl_policy(p))\n\t\tprio = MAX_DL_PRIO-1;\n\telse if (task_has_rt_policy(p))\n\t\tprio = MAX_RT_PRIO-1 - p->rt_priority;\n\telse\n\t\tprio = __normal_prio(p);\n\treturn prio;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int normal_prio(struct task_struct *p)\n{\n\tint prio;\n\n\tif (task_has_dl_policy(p))\n\t\tprio = MAX_DL_PRIO-1;\n\telse if (task_has_rt_policy(p))\n\t\tprio = MAX_RT_PRIO-1 - p->rt_priority;\n\telse\n\t\tprio = __normal_prio(p);\n\treturn prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NICE_TO_PRIO",
          "args": [
            "attr->sched_nice"
          ],
          "line": 4064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fair_policy",
          "args": [
            "policy"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "fair_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "159-162",
          "snippet": "static inline int fair_policy(int policy)\n{\n\treturn policy == SCHED_NORMAL || policy == SCHED_BATCH;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int fair_policy(int policy)\n{\n\treturn policy == SCHED_NORMAL || policy == SCHED_BATCH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__setparam_dl",
          "args": [
            "p",
            "attr"
          ],
          "line": 4062
        },
        "resolved": true,
        "details": {
          "function_name": "__setparam_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2578-2588",
          "snippet": "void __setparam_dl(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime = attr->sched_runtime;\n\tdl_se->dl_deadline = attr->sched_deadline;\n\tdl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;\n\tdl_se->flags = attr->sched_flags;\n\tdl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);\n\tdl_se->dl_density = to_ratio(dl_se->dl_deadline, dl_se->dl_runtime);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid __setparam_dl(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime = attr->sched_runtime;\n\tdl_se->dl_deadline = attr->sched_deadline;\n\tdl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;\n\tdl_se->flags = attr->sched_flags;\n\tdl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);\n\tdl_se->dl_density = to_ratio(dl_se->dl_deadline, dl_se->dl_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_policy",
          "args": [
            "policy"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_dl_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "184-187",
          "snippet": "static inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\n#define SETPARAM_POLICY\t-1\n\nstatic __always_inline struct;\n\nstatic void __setscheduler_params(struct task_struct *p,\n\t\tconst struct sched_attr *attr)\n{\n\tint policy = attr->sched_policy;\n\n\tif (policy == SETPARAM_POLICY)\n\t\tpolicy = p->policy;\n\n\tp->policy = policy;\n\n\tif (dl_policy(policy))\n\t\t__setparam_dl(p, attr);\n\telse if (fair_policy(policy))\n\t\tp->static_prio = NICE_TO_PRIO(attr->sched_nice);\n\n\t/*\n\t * __sched_setscheduler() ensures attr->sched_priority == 0 when\n\t * !rt_policy. Always setting this ensures that things like\n\t * getparam()/getattr() don't report silly values for !rt tasks.\n\t */\n\tp->rt_priority = attr->sched_priority;\n\tp->normal_prio = normal_prio(p);\n\tset_load_weight(p, true);\n}"
  },
  {
    "function_name": "find_process_by_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4040-4043",
    "snippet": "static struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 4042
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "348-351",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}"
  },
  {
    "function_name": "idle_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4029-4032",
    "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
  },
  {
    "function_name": "available_idle_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4012-4021",
    "snippet": "int available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_is_preempted",
          "args": [
            "cpu"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_cpu",
          "args": [
            "cpu"
          ],
          "line": 4014
        },
        "resolved": true,
        "details": {
          "function_name": "available_idle_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4012-4021",
          "snippet": "int available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "idle_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3988-4004",
    "snippet": "int idle_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (rq->curr != rq->idle)\n\t\treturn 0;\n\n\tif (rq->nr_running)\n\t\treturn 0;\n\n#ifdef CONFIG_SMP\n\tif (!llist_empty(&rq->wake_list))\n\t\treturn 0;\n#endif\n\n\treturn 1;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "&rq->wake_list"
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint idle_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (rq->curr != rq->idle)\n\t\treturn 0;\n\n\tif (rq->nr_running)\n\t\treturn 0;\n\n#ifdef CONFIG_SMP\n\tif (!llist_empty(&rq->wake_list))\n\t\treturn 0;\n#endif\n\n\treturn 1;\n}"
  },
  {
    "function_name": "task_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3977-3980",
    "snippet": "int task_prio(const struct task_struct *p)\n{\n\treturn p->prio - MAX_RT_PRIO;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint task_prio(const struct task_struct *p)\n{\n\treturn p->prio - MAX_RT_PRIO;\n}"
  },
  {
    "function_name": "can_nice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3925-3932",
    "snippet": "int can_nice(const struct task_struct *p, const int nice)\n{\n\t/* Convert nice value [19,-20] to rlimit style value [1,40]: */\n\tint nice_rlim = nice_to_rlimit(nice);\n\n\treturn (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||\n\t\tcapable(CAP_SYS_NICE));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_NICE"
          ],
          "line": 3931
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rlimit",
          "args": [
            "p",
            "RLIMIT_NICE"
          ],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nice_to_rlimit",
          "args": [
            "nice"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint can_nice(const struct task_struct *p, const int nice)\n{\n\t/* Convert nice value [19,-20] to rlimit style value [1,40]: */\n\tint nice_rlim = nice_to_rlimit(nice);\n\n\treturn (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||\n\t\tcapable(CAP_SYS_NICE));\n}"
  },
  {
    "function_name": "set_user_nice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3865-3917",
    "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_curr_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 3914
        },
        "resolved": true,
        "details": {
          "function_name": "ia64_set_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6228-6231",
          "snippet": "void ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 3911
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "p"
          ],
          "line": 3910
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1526-1533",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task",
          "args": [
            "rq",
            "p",
            "ENQUEUE_RESTORE | ENQUEUE_NOCLOCK"
          ],
          "line": 3905
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "720-731",
          "snippet": "static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "effective_prio",
          "args": [
            "p"
          ],
          "line": 3901
        },
        "resolved": true,
        "details": {
          "function_name": "effective_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "797-808",
          "snippet": "static int effective_prio(struct task_struct *p)\n{\n\tp->normal_prio = normal_prio(p);\n\t/*\n\t * If we are RT tasks or we were boosted to RT priority,\n\t * keep the priority unchanged. Otherwise, update priority\n\t * to the normal priority:\n\t */\n\tif (!rt_prio(p->prio))\n\t\treturn p->normal_prio;\n\treturn p->prio;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int effective_prio(struct task_struct *p)\n{\n\tp->normal_prio = normal_prio(p);\n\t/*\n\t * If we are RT tasks or we were boosted to RT priority,\n\t * keep the priority unchanged. Otherwise, update priority\n\t * to the normal priority:\n\t */\n\tif (!rt_prio(p->prio))\n\t\treturn p->normal_prio;\n\treturn p->prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_load_weight",
          "args": [
            "p",
            "true"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "set_load_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "692-718",
          "snippet": "static void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (idle_policy(p->policy)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\tp->se.runnable_weight = load->weight;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t\tp->se.runnable_weight = load->weight;\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "const int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};",
            "const u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nconst int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};\nconst u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};\n\nstatic void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (idle_policy(p->policy)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\tp->se.runnable_weight = load->weight;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t\tp->se.runnable_weight = load->weight;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NICE_TO_PRIO",
          "args": [
            "nice"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_prev_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "put_prev_task_fake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5553-5555",
          "snippet": "static void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_task",
          "args": [
            "rq",
            "p",
            "DEQUEUE_SAVE | DEQUEUE_NOCLOCK"
          ],
          "line": 3894
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "733-744",
          "snippet": "static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 3892
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1521-1524",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 3891
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NICE_TO_PRIO",
          "args": [
            "nice"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_has_rt_policy",
          "args": [
            "p"
          ],
          "line": 3887
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_rt_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "179-182",
          "snippet": "static inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_has_dl_policy",
          "args": [
            "p"
          ],
          "line": 3887
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_dl_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "184-187",
          "snippet": "static inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 3879
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 3878
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
  },
  {
    "function_name": "rt_effective_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3859-3862",
    "snippet": "static inline int rt_effective_prio(struct task_struct *p, int prio)\n{\n\treturn prio;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int rt_effective_prio(struct task_struct *p, int prio)\n{\n\treturn prio;\n}"
  },
  {
    "function_name": "rt_mutex_setprio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3742-3857",
    "snippet": "void rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task)\n{\n\tint prio, oldprio, queued, running, queue_flag =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\t/* XXX used to be waiter->prio, not waiter->task->prio */\n\tprio = __rt_effective_prio(pi_task, p->normal_prio);\n\n\t/*\n\t * If nothing changed; bail early.\n\t */\n\tif (p->pi_top_task == pi_task && prio == p->prio && !dl_prio(prio))\n\t\treturn;\n\n\trq = __task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\t/*\n\t * Set under pi_lock && rq->lock, such that the value can be used under\n\t * either lock.\n\t *\n\t * Note that there is loads of tricky to make this pointer cache work\n\t * right. rt_mutex_slowunlock()+rt_mutex_postunlock() work together to\n\t * ensure a task is de-boosted (pi_task is set to NULL) before the\n\t * task is allowed to run again (and can exit). This ensures the pointer\n\t * points to a blocked task -- which guaratees the task is present.\n\t */\n\tp->pi_top_task = pi_task;\n\n\t/*\n\t * For FIFO/RR we only need to set prio, if that matches we're done.\n\t */\n\tif (prio == p->prio && !dl_prio(prio))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Idle task boosting is a nono in general. There is one\n\t * exception, when PREEMPT_RT and NOHZ is active:\n\t *\n\t * The idle task calls get_next_timer_interrupt() and holds\n\t * the timer wheel base->lock on the CPU and another CPU wants\n\t * to access the timer (probably to cancel it). We can safely\n\t * ignore the boosting request, as the idle CPU runs this code\n\t * with interrupts disabled and will complete the lock\n\t * protected section without being interrupted. So there is no\n\t * real need to boost.\n\t */\n\tif (unlikely(p == rq->idle)) {\n\t\tWARN_ON(p != rq->curr);\n\t\tWARN_ON(p->pi_blocked_on);\n\t\tgoto out_unlock;\n\t}\n\n\ttrace_sched_pi_setprio(p, pi_task);\n\toldprio = p->prio;\n\n\tif (oldprio == prio)\n\t\tqueue_flag &= ~DEQUEUE_MOVE;\n\n\tprev_class = p->sched_class;\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flag);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\t/*\n\t * Boosting condition are:\n\t * 1. -rt task is running and holds mutex A\n\t *      --> -dl task blocks on mutex A\n\t *\n\t * 2. -dl task is running and holds mutex A\n\t *      --> -dl task blocks on mutex A and could preempt the\n\t *          running task\n\t */\n\tif (dl_prio(prio)) {\n\t\tif (!dl_prio(p->normal_prio) ||\n\t\t    (pi_task && dl_entity_preempt(&pi_task->dl, &p->dl))) {\n\t\t\tp->dl.dl_boosted = 1;\n\t\t\tqueue_flag |= ENQUEUE_REPLENISH;\n\t\t} else\n\t\t\tp->dl.dl_boosted = 0;\n\t\tp->sched_class = &dl_sched_class;\n\t} else if (rt_prio(prio)) {\n\t\tif (dl_prio(oldprio))\n\t\t\tp->dl.dl_boosted = 0;\n\t\tif (oldprio < prio)\n\t\t\tqueue_flag |= ENQUEUE_HEAD;\n\t\tp->sched_class = &rt_sched_class;\n\t} else {\n\t\tif (dl_prio(oldprio))\n\t\t\tp->dl.dl_boosted = 0;\n\t\tif (rt_prio(oldprio))\n\t\t\tp->rt.timeout = 0;\n\t\tp->sched_class = &fair_sched_class;\n\t}\n\n\tp->prio = prio;\n\n\tif (queued)\n\t\tenqueue_task(rq, p, queue_flag);\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\nout_unlock:\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\t__task_rq_unlock(rq, &rf);\n\n\tbalance_callback(rq);\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_callback",
          "args": [
            "rq"
          ],
          "line": 3855
        },
        "resolved": true,
        "details": {
          "function_name": "balance_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2753-2755",
          "snippet": "static inline void balance_callback(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void balance_callback(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_rq_unlock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 3853
        },
        "resolved": true,
        "details": {
          "function_name": "__task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1089-1094",
          "snippet": "static inline void __task_rq_unlock(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void __task_rq_unlock(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3852
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_class_changed",
          "args": [
            "rq",
            "p",
            "prev_class",
            "oldprio"
          ],
          "line": 3849
        },
        "resolved": true,
        "details": {
          "function_name": "check_class_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "828-839",
          "snippet": "static inline void check_class_changed(struct rq *rq, struct task_struct *p,\n\t\t\t\t       const struct sched_class *prev_class,\n\t\t\t\t       int oldprio)\n{\n\tif (prev_class != p->sched_class) {\n\t\tif (prev_class->switched_from)\n\t\t\tprev_class->switched_from(rq, p);\n\n\t\tp->sched_class->switched_to(rq, p);\n\t} else if (oldprio != p->prio || dl_task(p))\n\t\tp->sched_class->prio_changed(rq, p, oldprio);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void check_class_changed(struct rq *rq, struct task_struct *p,\n\t\t\t\t       const struct sched_class *prev_class,\n\t\t\t\t       int oldprio)\n{\n\tif (prev_class != p->sched_class) {\n\t\tif (prev_class->switched_from)\n\t\t\tprev_class->switched_from(rq, p);\n\n\t\tp->sched_class->switched_to(rq, p);\n\t} else if (oldprio != p->prio || dl_task(p))\n\t\tp->sched_class->prio_changed(rq, p, oldprio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_curr_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 3847
        },
        "resolved": true,
        "details": {
          "function_name": "ia64_set_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6228-6231",
          "snippet": "void ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task",
          "args": [
            "rq",
            "p",
            "queue_flag"
          ],
          "line": 3845
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "720-731",
          "snippet": "static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_prio",
          "args": [
            "oldprio"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "convert_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
          "lines": "32-46",
          "snippet": "static int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "oldprio"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "oldprio"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_entity_preempt",
          "args": [
            "&pi_task->dl",
            "&p->dl"
          ],
          "line": 3822
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_preempt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "217-222",
          "snippet": "static inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "p->normal_prio"
          ],
          "line": 3821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "prio"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_prev_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 3809
        },
        "resolved": true,
        "details": {
          "function_name": "put_prev_task_fake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5553-5555",
          "snippet": "static void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_task",
          "args": [
            "rq",
            "p",
            "queue_flag"
          ],
          "line": 3807
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "733-744",
          "snippet": "static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 3805
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1521-1524",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_pi_setprio",
          "args": [
            "p",
            "pi_task"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "p->pi_blocked_on"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "p != rq->curr"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == rq->idle"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "prio"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 3760
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 3759
        },
        "resolved": true,
        "details": {
          "function_name": "__task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "66-85",
          "snippet": "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "prio"
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rt_effective_prio",
          "args": [
            "pi_task",
            "p->normal_prio"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_effective_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3716-3722",
          "snippet": "static inline int __rt_effective_prio(struct task_struct *pi_task, int prio)\n{\n\tif (pi_task)\n\t\tprio = min(prio, pi_task->prio);\n\n\treturn prio;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int __rt_effective_prio(struct task_struct *pi_task, int prio)\n{\n\tif (pi_task)\n\t\tprio = min(prio, pi_task->prio);\n\n\treturn prio;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task)\n{\n\tint prio, oldprio, queued, running, queue_flag =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\t/* XXX used to be waiter->prio, not waiter->task->prio */\n\tprio = __rt_effective_prio(pi_task, p->normal_prio);\n\n\t/*\n\t * If nothing changed; bail early.\n\t */\n\tif (p->pi_top_task == pi_task && prio == p->prio && !dl_prio(prio))\n\t\treturn;\n\n\trq = __task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\t/*\n\t * Set under pi_lock && rq->lock, such that the value can be used under\n\t * either lock.\n\t *\n\t * Note that there is loads of tricky to make this pointer cache work\n\t * right. rt_mutex_slowunlock()+rt_mutex_postunlock() work together to\n\t * ensure a task is de-boosted (pi_task is set to NULL) before the\n\t * task is allowed to run again (and can exit). This ensures the pointer\n\t * points to a blocked task -- which guaratees the task is present.\n\t */\n\tp->pi_top_task = pi_task;\n\n\t/*\n\t * For FIFO/RR we only need to set prio, if that matches we're done.\n\t */\n\tif (prio == p->prio && !dl_prio(prio))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Idle task boosting is a nono in general. There is one\n\t * exception, when PREEMPT_RT and NOHZ is active:\n\t *\n\t * The idle task calls get_next_timer_interrupt() and holds\n\t * the timer wheel base->lock on the CPU and another CPU wants\n\t * to access the timer (probably to cancel it). We can safely\n\t * ignore the boosting request, as the idle CPU runs this code\n\t * with interrupts disabled and will complete the lock\n\t * protected section without being interrupted. So there is no\n\t * real need to boost.\n\t */\n\tif (unlikely(p == rq->idle)) {\n\t\tWARN_ON(p != rq->curr);\n\t\tWARN_ON(p->pi_blocked_on);\n\t\tgoto out_unlock;\n\t}\n\n\ttrace_sched_pi_setprio(p, pi_task);\n\toldprio = p->prio;\n\n\tif (oldprio == prio)\n\t\tqueue_flag &= ~DEQUEUE_MOVE;\n\n\tprev_class = p->sched_class;\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flag);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\t/*\n\t * Boosting condition are:\n\t * 1. -rt task is running and holds mutex A\n\t *      --> -dl task blocks on mutex A\n\t *\n\t * 2. -dl task is running and holds mutex A\n\t *      --> -dl task blocks on mutex A and could preempt the\n\t *          running task\n\t */\n\tif (dl_prio(prio)) {\n\t\tif (!dl_prio(p->normal_prio) ||\n\t\t    (pi_task && dl_entity_preempt(&pi_task->dl, &p->dl))) {\n\t\t\tp->dl.dl_boosted = 1;\n\t\t\tqueue_flag |= ENQUEUE_REPLENISH;\n\t\t} else\n\t\t\tp->dl.dl_boosted = 0;\n\t\tp->sched_class = &dl_sched_class;\n\t} else if (rt_prio(prio)) {\n\t\tif (dl_prio(oldprio))\n\t\t\tp->dl.dl_boosted = 0;\n\t\tif (oldprio < prio)\n\t\t\tqueue_flag |= ENQUEUE_HEAD;\n\t\tp->sched_class = &rt_sched_class;\n\t} else {\n\t\tif (dl_prio(oldprio))\n\t\t\tp->dl.dl_boosted = 0;\n\t\tif (rt_prio(oldprio))\n\t\t\tp->rt.timeout = 0;\n\t\tp->sched_class = &fair_sched_class;\n\t}\n\n\tp->prio = prio;\n\n\tif (queued)\n\t\tenqueue_task(rq, p, queue_flag);\n\tif (running)\n\t\tset_curr_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\nout_unlock:\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\t__task_rq_unlock(rq, &rf);\n\n\tbalance_callback(rq);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "rt_effective_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3724-3729",
    "snippet": "static inline int rt_effective_prio(struct task_struct *p, int prio)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\n\treturn __rt_effective_prio(pi_task, prio);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rt_effective_prio",
          "args": [
            "pi_task",
            "prio"
          ],
          "line": 3728
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_effective_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3716-3722",
          "snippet": "static inline int __rt_effective_prio(struct task_struct *pi_task, int prio)\n{\n\tif (pi_task)\n\t\tprio = min(prio, pi_task->prio);\n\n\treturn prio;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int __rt_effective_prio(struct task_struct *pi_task, int prio)\n{\n\tif (pi_task)\n\t\tprio = min(prio, pi_task->prio);\n\n\treturn prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_mutex_get_top_task",
          "args": [
            "p"
          ],
          "line": 3726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int rt_effective_prio(struct task_struct *p, int prio)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\n\treturn __rt_effective_prio(pi_task, prio);\n}"
  },
  {
    "function_name": "__rt_effective_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3716-3722",
    "snippet": "static inline int __rt_effective_prio(struct task_struct *pi_task, int prio)\n{\n\tif (pi_task)\n\t\tprio = min(prio, pi_task->prio);\n\n\treturn prio;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "prio",
            "pi_task->prio"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "sched_get_priority_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5177-5193",
          "snippet": "SYSCALL_DEFINE1(sched_get_priority_min, int, policy)\n{\n\tint ret = -EINVAL;\n\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = 1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nSYSCALL_DEFINE1(sched_get_priority_min, int, policy)\n{\n\tint ret = -EINVAL;\n\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = 1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int __rt_effective_prio(struct task_struct *pi_task, int prio)\n{\n\tif (pi_task)\n\t\tprio = min(prio, pi_task->prio);\n\n\treturn prio;\n}"
  },
  {
    "function_name": "default_wake_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3707-3711",
    "snippet": "int default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_wake_up",
          "args": [
            "curr->private",
            "mode",
            "wake_flags"
          ],
          "line": 3710
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_wake_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1953-2064",
          "snippet": "static int\ntry_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with mb() in\n\t * set_current_state() the waiting thread does.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tsmp_mb__after_spinlock();\n\tif (!(p->state & state))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\t/* We're going to change ->state: */\n\tsuccess = 1;\n\tcpu = task_cpu(p);\n\n\t/*\n\t * Ensure we load p->on_rq _after_ p->state, otherwise it would\n\t * be possible to, falsely, observe p->on_rq == 0 and get stuck\n\t * in smp_cond_load_acquire() below.\n\t *\n\t * sched_ttwu_pending()\t\t\ttry_to_wake_up()\n\t *   STORE p->on_rq = 1\t\t\t  LOAD p->state\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   UNLOCK rq->lock\n\t *\n\t * [task p]\n\t *   STORE p->state = UNINTERRUPTIBLE\t  LOAD p->on_rq\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\tif (p->on_rq && ttwu_remote(p, wake_flags))\n\t\tgoto stat;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Ensure we load p->on_cpu _after_ p->on_rq, otherwise it would be\n\t * possible to, falsely, observe p->on_cpu == 0.\n\t *\n\t * One must be running (->on_cpu == 1) in order to remove oneself\n\t * from the runqueue.\n\t *\n\t * __schedule() (switch to task 'p')\ttry_to_wake_up()\n\t *   STORE p->on_cpu = 1\t\t  LOAD p->on_rq\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (put 'p' to sleep)\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   STORE p->on_rq = 0\t\t\t  LOAD p->on_cpu\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the owning (remote) CPU is still in the middle of schedule() with\n\t * this task as prev, wait until its done referencing the task.\n\t *\n\t * Pairs with the smp_store_release() in finish_task().\n\t *\n\t * This ensures that tasks getting woken will be fully ordered against\n\t * their previous state and preserve Program Order.\n\t */\n\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\tp->sched_contributes_to_load = !!task_contributes_to_load(p);\n\tp->state = TASK_WAKING;\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n\tcpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);\n\tif (task_cpu(p) != cpu) {\n\t\twake_flags |= WF_MIGRATED;\n\t\tpsi_ttwu_dequeue(p);\n\t\tset_task_cpu(p, cpu);\n\t}\n\n#else /* CONFIG_SMP */\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu, wake_flags);\nstat:\n\tttwu_stat(p, cpu, wake_flags);\nout:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn success;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int\ntry_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with mb() in\n\t * set_current_state() the waiting thread does.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tsmp_mb__after_spinlock();\n\tif (!(p->state & state))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\t/* We're going to change ->state: */\n\tsuccess = 1;\n\tcpu = task_cpu(p);\n\n\t/*\n\t * Ensure we load p->on_rq _after_ p->state, otherwise it would\n\t * be possible to, falsely, observe p->on_rq == 0 and get stuck\n\t * in smp_cond_load_acquire() below.\n\t *\n\t * sched_ttwu_pending()\t\t\ttry_to_wake_up()\n\t *   STORE p->on_rq = 1\t\t\t  LOAD p->state\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   UNLOCK rq->lock\n\t *\n\t * [task p]\n\t *   STORE p->state = UNINTERRUPTIBLE\t  LOAD p->on_rq\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\tif (p->on_rq && ttwu_remote(p, wake_flags))\n\t\tgoto stat;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Ensure we load p->on_cpu _after_ p->on_rq, otherwise it would be\n\t * possible to, falsely, observe p->on_cpu == 0.\n\t *\n\t * One must be running (->on_cpu == 1) in order to remove oneself\n\t * from the runqueue.\n\t *\n\t * __schedule() (switch to task 'p')\ttry_to_wake_up()\n\t *   STORE p->on_cpu = 1\t\t  LOAD p->on_rq\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (put 'p' to sleep)\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   STORE p->on_rq = 0\t\t\t  LOAD p->on_cpu\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the owning (remote) CPU is still in the middle of schedule() with\n\t * this task as prev, wait until its done referencing the task.\n\t *\n\t * Pairs with the smp_store_release() in finish_task().\n\t *\n\t * This ensures that tasks getting woken will be fully ordered against\n\t * their previous state and preserve Program Order.\n\t */\n\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\tp->sched_contributes_to_load = !!task_contributes_to_load(p);\n\tp->state = TASK_WAKING;\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n\tcpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);\n\tif (task_cpu(p) != cpu) {\n\t\twake_flags |= WF_MIGRATED;\n\t\tpsi_ttwu_dequeue(p);\n\t\tset_task_cpu(p, cpu);\n\t}\n\n#else /* CONFIG_SMP */\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu, wake_flags);\nstat:\n\tttwu_stat(p, cpu, wake_flags);\nout:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn success;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}"
  },
  {
    "function_name": "preempt_schedule_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3687-3705",
    "snippet": "void __sched preempt_schedule_irq(void)\n{\n\tenum ctx_state prev_state;\n\n\t/* Catch callers which need to be fixed */\n\tBUG_ON(preempt_count() || !irqs_disabled());\n\n\tprev_state = exception_enter();\n\n\tdo {\n\t\tpreempt_disable();\n\t\tlocal_irq_enable();\n\t\t__schedule(true);\n\t\tlocal_irq_disable();\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sched",
      "static void __sched"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_preempt_enable_no_resched",
          "args": [],
          "line": 3701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 3700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedule",
          "args": [
            "true"
          ],
          "line": 3699
        },
        "resolved": true,
        "details": {
          "function_name": "__schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3382-3479",
          "snippet": "notrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nnotrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 3698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3697
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 3694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "preempt_count() || !irqs_disabled()"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched preempt_schedule_irq(void)\n{\n\tenum ctx_state prev_state;\n\n\t/* Catch callers which need to be fixed */\n\tBUG_ON(preempt_count() || !irqs_disabled());\n\n\tprev_state = exception_enter();\n\n\tdo {\n\t\tpreempt_disable();\n\t\tlocal_irq_enable();\n\t\t__schedule(true);\n\t\tlocal_irq_disable();\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "preempt_schedule_notrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3641-3676",
    "snippet": "notrace preempt_schedule_notrace(void)\n{\n\tenum ctx_state prev_ctx;\n\n\tif (likely(!preemptible()))\n\t\treturn;\n\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t/*\n\t\t * Needs preempt disabled in case user_exit() is traced\n\t\t * and the tracer calls preempt_enable_notrace() causing\n\t\t * an infinite recursion.\n\t\t */\n\t\tprev_ctx = exception_enter();\n\t\t__schedule(true);\n\t\texception_exit(prev_ctx);\n\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\t} while (need_resched());\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched_notrace",
          "args": [],
          "line": 3674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_latency_stop",
          "args": [
            "1"
          ],
          "line": 3673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_ctx"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedule",
          "args": [
            "true"
          ],
          "line": 3670
        },
        "resolved": true,
        "details": {
          "function_name": "__schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3382-3479",
          "snippet": "notrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nnotrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_latency_start",
          "args": [
            "1"
          ],
          "line": 3663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!preemptible()"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nnotrace preempt_schedule_notrace(void)\n{\n\tenum ctx_state prev_ctx;\n\n\tif (likely(!preemptible()))\n\t\treturn;\n\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t/*\n\t\t * Needs preempt disabled in case user_exit() is traced\n\t\t * and the tracer calls preempt_enable_notrace() causing\n\t\t * an infinite recursion.\n\t\t */\n\t\tprev_ctx = exception_enter();\n\t\t__schedule(true);\n\t\texception_exit(prev_ctx);\n\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\t} while (need_resched());\n}"
  },
  {
    "function_name": "preempt_schedule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3613-3623",
    "snippet": "notrace preempt_schedule(void)\n{\n\t/*\n\t * If there is a non-zero preempt_count or interrupts are disabled,\n\t * we do not want to preempt the current task. Just return..\n\t */\n\tif (likely(!preemptible()))\n\t\treturn;\n\n\tpreempt_schedule_common();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_schedule_common",
          "args": [],
          "line": 3622
        },
        "resolved": true,
        "details": {
          "function_name": "preempt_schedule_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3578-3605",
          "snippet": "notrace preempt_schedule_common(void)\n{\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t__schedule(true);\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t} while (need_resched());\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nnotrace preempt_schedule_common(void)\n{\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t__schedule(true);\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t} while (need_resched());\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!preemptible()"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nnotrace preempt_schedule(void)\n{\n\t/*\n\t * If there is a non-zero preempt_count or interrupts are disabled,\n\t * we do not want to preempt the current task. Just return..\n\t */\n\tif (likely(!preemptible()))\n\t\treturn;\n\n\tpreempt_schedule_common();\n}"
  },
  {
    "function_name": "preempt_schedule_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3578-3605",
    "snippet": "notrace preempt_schedule_common(void)\n{\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t__schedule(true);\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t} while (need_resched());\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched_notrace",
          "args": [],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_latency_stop",
          "args": [
            "1"
          ],
          "line": 3597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedule",
          "args": [
            "true"
          ],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "__schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3382-3479",
          "snippet": "notrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nnotrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_latency_start",
          "args": [
            "1"
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nnotrace preempt_schedule_common(void)\n{\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t__schedule(true);\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t} while (need_resched());\n}"
  },
  {
    "function_name": "schedule_preempt_disabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3571-3576",
    "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sched",
      "static void __sched"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3575
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 3574
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5132-5139",
          "snippet": "void io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_preempt_enable_no_resched",
          "args": [],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
  },
  {
    "function_name": "schedule_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3548-3563",
    "snippet": "void __sched schedule_user(void)\n{\n\t/*\n\t * If we come here after a random call to set_need_resched(),\n\t * or we have been woken up remotely but the IPI has not yet arrived,\n\t * we haven't yet exited the RCU idle mode. Do it here manually until\n\t * we find a better solution.\n\t *\n\t * NB: There are buggy callers of this function.  Ideally we\n\t * should warn if prev_state != CONTEXT_USER, but that will trigger\n\t * too frequently to make sense yet.\n\t */\n\tenum ctx_state prev_state = exception_enter();\n\tschedule();\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sched",
      "static void __sched"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5132-5139",
          "snippet": "void io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_user(void)\n{\n\t/*\n\t * If we come here after a random call to set_need_resched(),\n\t * or we have been woken up remotely but the IPI has not yet arrived,\n\t * we haven't yet exited the RCU idle mode. Do it here manually until\n\t * we find a better solution.\n\t *\n\t * NB: There are buggy callers of this function.  Ideally we\n\t * should warn if prev_state != CONTEXT_USER, but that will trigger\n\t * too frequently to make sense yet.\n\t */\n\tenum ctx_state prev_state = exception_enter();\n\tschedule();\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "schedule_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3532-3545",
    "snippet": "void __sched schedule_idle(void)\n{\n\t/*\n\t * As this skips calling sched_submit_work(), which the idle task does\n\t * regardless because that function is a nop when the task is in a\n\t * TASK_RUNNING state, make sure this isn't used someplace that the\n\t * current task can be in any other state. Note, idle is always in the\n\t * TASK_RUNNING state.\n\t */\n\tWARN_ON_ONCE(current->state);\n\tdo {\n\t\t__schedule(false);\n\t} while (need_resched());\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sched",
      "static void __sched"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 3544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedule",
          "args": [
            "false"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "__schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3382-3479",
          "snippet": "notrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nnotrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->state"
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_idle(void)\n{\n\t/*\n\t * As this skips calling sched_submit_work(), which the idle task does\n\t * regardless because that function is a nop when the task is in a\n\t * TASK_RUNNING state, make sure this isn't used someplace that the\n\t * current task can be in any other state. Note, idle is always in the\n\t * TASK_RUNNING state.\n\t */\n\tWARN_ON_ONCE(current->state);\n\tdo {\n\t\t__schedule(false);\n\t} while (need_resched());\n}"
  },
  {
    "function_name": "schedule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3509-3519",
    "snippet": "void __sched schedule(void)\n{\n\tstruct task_struct *tsk = current;\n\n\tsched_submit_work(tsk);\n\tdo {\n\t\tpreempt_disable();\n\t\t__schedule(false);\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "static void __sched",
      "static void __sched"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_preempt_enable_no_resched",
          "args": [],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedule",
          "args": [
            "false"
          ],
          "line": 3516
        },
        "resolved": true,
        "details": {
          "function_name": "__schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3382-3479",
          "snippet": "notrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nnotrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3515
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_submit_work",
          "args": [
            "tsk"
          ],
          "line": 3513
        },
        "resolved": true,
        "details": {
          "function_name": "sched_submit_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3497-3507",
          "snippet": "static inline void sched_submit_work(struct task_struct *tsk)\n{\n\tif (!tsk->state || tsk_is_pi_blocked(tsk))\n\t\treturn;\n\t/*\n\t * If we are going to sleep and we have plugged IO queued,\n\t * make sure to submit it to avoid deadlocks.\n\t */\n\tif (blk_needs_flush_plug(tsk))\n\t\tblk_schedule_flush_plug(tsk);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void sched_submit_work(struct task_struct *tsk)\n{\n\tif (!tsk->state || tsk_is_pi_blocked(tsk))\n\t\treturn;\n\t/*\n\t * If we are going to sleep and we have plugged IO queued,\n\t * make sure to submit it to avoid deadlocks.\n\t */\n\tif (blk_needs_flush_plug(tsk))\n\t\tblk_schedule_flush_plug(tsk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule(void)\n{\n\tstruct task_struct *tsk = current;\n\n\tsched_submit_work(tsk);\n\tdo {\n\t\tpreempt_disable();\n\t\t__schedule(false);\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n}"
  },
  {
    "function_name": "sched_submit_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3497-3507",
    "snippet": "static inline void sched_submit_work(struct task_struct *tsk)\n{\n\tif (!tsk->state || tsk_is_pi_blocked(tsk))\n\t\treturn;\n\t/*\n\t * If we are going to sleep and we have plugged IO queued,\n\t * make sure to submit it to avoid deadlocks.\n\t */\n\tif (blk_needs_flush_plug(tsk))\n\t\tblk_schedule_flush_plug(tsk);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_schedule_flush_plug",
          "args": [
            "tsk"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_needs_flush_plug",
          "args": [
            "tsk"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsk_is_pi_blocked",
          "args": [
            "tsk"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void sched_submit_work(struct task_struct *tsk)\n{\n\tif (!tsk->state || tsk_is_pi_blocked(tsk))\n\t\treturn;\n\t/*\n\t * If we are going to sleep and we have plugged IO queued,\n\t * make sure to submit it to avoid deadlocks.\n\t */\n\tif (blk_needs_flush_plug(tsk))\n\t\tblk_schedule_flush_plug(tsk);\n}"
  },
  {
    "function_name": "do_task_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3481-3495",
    "snippet": "void __noreturn do_task_dead(void)\n{\n\t/* Causes final put_task_struct in finish_task_switch(): */\n\tset_special_state(TASK_DEAD);\n\n\t/* Tell freezer to ignore us: */\n\tcurrent->flags |= PF_NOFREEZE;\n\n\t__schedule(false);\n\tBUG();\n\n\t/* Avoid \"noreturn function does return\" - but don't continue if BUG() is a NOP: */\n\tfor (;;)\n\t\tcpu_relax();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedule",
          "args": [
            "false"
          ],
          "line": 3489
        },
        "resolved": true,
        "details": {
          "function_name": "__schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3382-3479",
          "snippet": "notrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nnotrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_special_state",
          "args": [
            "TASK_DEAD"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid __noreturn do_task_dead(void)\n{\n\t/* Causes final put_task_struct in finish_task_switch(): */\n\tset_special_state(TASK_DEAD);\n\n\t/* Tell freezer to ignore us: */\n\tcurrent->flags |= PF_NOFREEZE;\n\n\t__schedule(false);\n\tBUG();\n\n\t/* Avoid \"noreturn function does return\" - but don't continue if BUG() is a NOP: */\n\tfor (;;)\n\t\tcpu_relax();\n}"
  },
  {
    "function_name": "__schedule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3382-3479",
    "snippet": "notrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "balance_callback",
          "args": [
            "rq"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "balance_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2753-2755",
          "snippet": "static inline void balance_callback(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void balance_callback(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unlock_irq",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 3475
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1146-1152",
          "snippet": "static inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_switch",
          "args": [
            "rq",
            "prev",
            "next",
            "&rf"
          ],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "context_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2790-2835",
          "snippet": "rq *\ncontext_switch(struct rq *rq, struct task_struct *prev,\n\t       struct task_struct *next, struct rq_flags *rf)\n{\n\tstruct mm_struct *mm, *oldmm;\n\n\tprepare_task_switch(rq, prev, next);\n\n\tmm = next->mm;\n\toldmm = prev->active_mm;\n\t/*\n\t * For paravirt, this is coupled with an exit in switch_to to\n\t * combine the page table reload and the switch backend into\n\t * one hypercall.\n\t */\n\tarch_start_context_switch(prev);\n\n\t/*\n\t * If mm is non-NULL, we pass through switch_mm(). If mm is\n\t * NULL, we will pass through mmdrop() in finish_task_switch().\n\t * Both of these contain the full memory barrier required by\n\t * membarrier after storing to rq->curr, before returning to\n\t * user-space.\n\t */\n\tif (!mm) {\n\t\tnext->active_mm = oldmm;\n\t\tmmgrab(oldmm);\n\t\tenter_lazy_tlb(oldmm, next);\n\t} else\n\t\tswitch_mm_irqs_off(oldmm, mm, next);\n\n\tif (!prev->mm) {\n\t\tprev->active_mm = NULL;\n\t\trq->prev_mm = oldmm;\n\t}\n\n\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\n\tprepare_lock_switch(rq, next, rf);\n\n\t/* Here we just switch the register state and the stack. */\n\tswitch_to(prev, next, prev);\n\tbarrier();\n\n\treturn finish_task_switch(prev);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nrq *\ncontext_switch(struct rq *rq, struct task_struct *prev,\n\t       struct task_struct *next, struct rq_flags *rf)\n{\n\tstruct mm_struct *mm, *oldmm;\n\n\tprepare_task_switch(rq, prev, next);\n\n\tmm = next->mm;\n\toldmm = prev->active_mm;\n\t/*\n\t * For paravirt, this is coupled with an exit in switch_to to\n\t * combine the page table reload and the switch backend into\n\t * one hypercall.\n\t */\n\tarch_start_context_switch(prev);\n\n\t/*\n\t * If mm is non-NULL, we pass through switch_mm(). If mm is\n\t * NULL, we will pass through mmdrop() in finish_task_switch().\n\t * Both of these contain the full memory barrier required by\n\t * membarrier after storing to rq->curr, before returning to\n\t * user-space.\n\t */\n\tif (!mm) {\n\t\tnext->active_mm = oldmm;\n\t\tmmgrab(oldmm);\n\t\tenter_lazy_tlb(oldmm, next);\n\t} else\n\t\tswitch_mm_irqs_off(oldmm, mm, next);\n\n\tif (!prev->mm) {\n\t\tprev->active_mm = NULL;\n\t\trq->prev_mm = oldmm;\n\t}\n\n\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\n\tprepare_lock_switch(rq, next, rf);\n\n\t/* Here we just switch the register state and the stack. */\n\tswitch_to(prev, next, prev);\n\tbarrier();\n\n\treturn finish_task_switch(prev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_switch",
          "args": [
            "preempt",
            "prev",
            "next"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "prev != next"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_preempt_need_resched",
          "args": [],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_tsk_need_resched",
          "args": [
            "prev"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pick_next_task",
          "args": [
            "rq",
            "prev",
            "&rf"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "pick_next_task_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "376-384",
          "snippet": "static struct task_struct *\npick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tput_prev_task(rq, prev);\n\tupdate_idle_core(rq);\n\tschedstat_inc(rq->sched_goidle);\n\n\treturn rq->idle;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct task_struct *\npick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tput_prev_task(rq, prev);\n\tupdate_idle_core(rq);\n\tschedstat_inc(rq->sched_goidle);\n\n\treturn rq->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_wake_up_local",
          "args": [
            "to_wakeup",
            "&rf"
          ],
          "line": 3440
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_wake_up_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2075-2114",
          "snippet": "static void try_to_wake_up_local(struct task_struct *p, struct rq_flags *rf)\n{\n\tstruct rq *rq = task_rq(p);\n\n\tif (WARN_ON_ONCE(rq != this_rq()) ||\n\t    WARN_ON_ONCE(p == current))\n\t\treturn;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (!raw_spin_trylock(&p->pi_lock)) {\n\t\t/*\n\t\t * This is OK, because current is on_cpu, which avoids it being\n\t\t * picked for load-balance and preemption/IRQs are still\n\t\t * disabled avoiding further scheduler activity on it and we've\n\t\t * not yet picked a replacement task.\n\t\t */\n\t\trq_unlock(rq, rf);\n\t\traw_spin_lock(&p->pi_lock);\n\t\trq_relock(rq, rf);\n\t}\n\n\tif (!(p->state & TASK_NORMAL))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\tif (!task_on_rq_queued(p)) {\n\t\tif (p->in_iowait) {\n\t\t\tdelayacct_blkio_end(p);\n\t\t\tatomic_dec(&rq->nr_iowait);\n\t\t}\n\t\tttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK);\n\t}\n\n\tttwu_do_wakeup(rq, p, 0, rf);\n\tttwu_stat(p, smp_processor_id(), 0);\nout:\n\traw_spin_unlock(&p->pi_lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void try_to_wake_up_local(struct task_struct *p, struct rq_flags *rf)\n{\n\tstruct rq *rq = task_rq(p);\n\n\tif (WARN_ON_ONCE(rq != this_rq()) ||\n\t    WARN_ON_ONCE(p == current))\n\t\treturn;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (!raw_spin_trylock(&p->pi_lock)) {\n\t\t/*\n\t\t * This is OK, because current is on_cpu, which avoids it being\n\t\t * picked for load-balance and preemption/IRQs are still\n\t\t * disabled avoiding further scheduler activity on it and we've\n\t\t * not yet picked a replacement task.\n\t\t */\n\t\trq_unlock(rq, rf);\n\t\traw_spin_lock(&p->pi_lock);\n\t\trq_relock(rq, rf);\n\t}\n\n\tif (!(p->state & TASK_NORMAL))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\tif (!task_on_rq_queued(p)) {\n\t\tif (p->in_iowait) {\n\t\t\tdelayacct_blkio_end(p);\n\t\t\tatomic_dec(&rq->nr_iowait);\n\t\t}\n\t\tttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK);\n\t}\n\n\tttwu_do_wakeup(rq, p, 0, rf);\n\tttwu_stat(p, smp_processor_id(), 0);\nout:\n\traw_spin_unlock(&p->pi_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_worker_sleeping",
          "args": [
            "prev"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "wq_worker_sleeping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "876-910",
          "snippet": "struct task_struct *wq_worker_sleeping(struct task_struct *task)\n{\n\tstruct worker *worker = kthread_data(task), *to_wakeup = NULL;\n\tstruct worker_pool *pool;\n\n\t/*\n\t * Rescuers, which may not have all the fields set up like normal\n\t * workers, also reach here, let's not access anything before\n\t * checking NOT_RUNNING.\n\t */\n\tif (worker->flags & WORKER_NOT_RUNNING)\n\t\treturn NULL;\n\n\tpool = worker->pool;\n\n\t/* this can only happen on the local cpu */\n\tif (WARN_ON_ONCE(pool->cpu != raw_smp_processor_id()))\n\t\treturn NULL;\n\n\t/*\n\t * The counterpart of the following dec_and_test, implied mb,\n\t * worklist not empty test sequence is in insert_work().\n\t * Please read comment there.\n\t *\n\t * NOT_RUNNING is clear.  This means that we're bound to and\n\t * running on the local cpu w/ rq lock held and preemption\n\t * disabled, which in turn means that none else could be\n\t * manipulating idle_list, so dereferencing idle_list without pool\n\t * lock is safe.\n\t */\n\tif (atomic_dec_and_test(&pool->nr_running) &&\n\t    !list_empty(&pool->worklist))\n\t\tto_wakeup = first_idle_worker(pool);\n\treturn to_wakeup ? to_wakeup->task : NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstruct task_struct *wq_worker_sleeping(struct task_struct *task)\n{\n\tstruct worker *worker = kthread_data(task), *to_wakeup = NULL;\n\tstruct worker_pool *pool;\n\n\t/*\n\t * Rescuers, which may not have all the fields set up like normal\n\t * workers, also reach here, let's not access anything before\n\t * checking NOT_RUNNING.\n\t */\n\tif (worker->flags & WORKER_NOT_RUNNING)\n\t\treturn NULL;\n\n\tpool = worker->pool;\n\n\t/* this can only happen on the local cpu */\n\tif (WARN_ON_ONCE(pool->cpu != raw_smp_processor_id()))\n\t\treturn NULL;\n\n\t/*\n\t * The counterpart of the following dec_and_test, implied mb,\n\t * worklist not empty test sequence is in insert_work().\n\t * Please read comment there.\n\t *\n\t * NOT_RUNNING is clear.  This means that we're bound to and\n\t * running on the local cpu w/ rq lock held and preemption\n\t * disabled, which in turn means that none else could be\n\t * manipulating idle_list, so dereferencing idle_list without pool\n\t * lock is safe.\n\t */\n\tif (atomic_dec_and_test(&pool->nr_running) &&\n\t    !list_empty(&pool->worklist))\n\t\tto_wakeup = first_idle_worker(pool);\n\treturn to_wakeup ? to_wakeup->task : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayacct_blkio_start",
          "args": [],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "__delayacct_blkio_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/delayacct.c",
          "lines": "68-71",
          "snippet": "void __delayacct_blkio_start(void)\n{\n\tcurrent->delays->blkio_start = ktime_get_ns();\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/time.h>",
            "#include <linux/taskstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/delayacct.h>\n#include <linux/sysctl.h>\n#include <linux/time.h>\n#include <linux/taskstats.h>\n#include <linux/slab.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n\nvoid __delayacct_blkio_start(void)\n{\n\tcurrent->delays->blkio_start = ktime_get_ns();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rq->nr_iowait"
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_task",
          "args": [
            "rq",
            "prev",
            "DEQUEUE_SLEEP | DEQUEUE_NOCLOCK"
          ],
          "line": 3422
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "754-760",
          "snippet": "void deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "signal_pending_state(prev->state, prev)"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "prev->state",
            "prev"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 3415
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_note_context_switch",
          "args": [
            "preempt"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_note_context_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "994-1010",
          "snippet": "void rcu_note_context_switch(bool preempt)\n{\n\tbarrier(); /* Avoid RCU read-side critical sections leaking down. */\n\ttrace_rcu_utilization(TPS(\"Start context switch\"));\n\trcu_qs();\n\t/* Load rcu_urgent_qs before other flags. */\n\tif (!smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs)))\n\t\tgoto out;\n\tthis_cpu_write(rcu_data.rcu_urgent_qs, false);\n\tif (unlikely(raw_cpu_read(rcu_data.rcu_need_heavy_qs)))\n\t\trcu_momentary_dyntick_idle();\n\tif (!preempt)\n\t\trcu_tasks_qs(current);\nout:\n\ttrace_rcu_utilization(TPS(\"End context switch\"));\n\tbarrier(); /* Avoid RCU read-side critical sections leaking up. */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid rcu_note_context_switch(bool preempt)\n{\n\tbarrier(); /* Avoid RCU read-side critical sections leaking down. */\n\ttrace_rcu_utilization(TPS(\"Start context switch\"));\n\trcu_qs();\n\t/* Load rcu_urgent_qs before other flags. */\n\tif (!smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs)))\n\t\tgoto out;\n\tthis_cpu_write(rcu_data.rcu_urgent_qs, false);\n\tif (unlikely(raw_cpu_read(rcu_data.rcu_need_heavy_qs)))\n\t\trcu_momentary_dyntick_idle();\n\tif (!preempt)\n\t\trcu_tasks_qs(current);\nout:\n\ttrace_rcu_utilization(TPS(\"End context switch\"));\n\tbarrier(); /* Avoid RCU read-side critical sections leaking up. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtick_clear",
          "args": [
            "rq"
          ],
          "line": 3397
        },
        "resolved": true,
        "details": {
          "function_name": "hrtick_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "321-323",
          "snippet": "static inline void hrtick_clear(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void hrtick_clear(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_feat",
          "args": [
            "HRTICK"
          ],
          "line": 3396
        },
        "resolved": true,
        "details": {
          "function_name": "sched_feat_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "104-127",
          "snippet": "static int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const sched_feat_names[] = {\n#include \"features.h\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic const char * const sched_feat_names[] = {\n#include \"features.h\"\n};\n\nstatic int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_debug",
          "args": [
            "prev"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nnotrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up().\n\t *\n\t * The membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\tif (!preempt && prev->state) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\t\t\tprev->on_rq = 0;\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a worker went to sleep, notify and ask workqueue\n\t\t\t * whether it wants to wake up a task to maintain\n\t\t\t * concurrency.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup, &rf);\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\n\tbalance_callback(rq);\n}"
  },
  {
    "function_name": "nr_context_switches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2872-3341",
    "snippet": "unsigned long long nr_context_switches(void)\n{\n\tint i;\n\tunsigned long long sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned long nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}\n\n/*\n * IO-wait accounting, and how its mostly bollocks (on SMP).\n *\n * The idea behind IO-wait account is to account the idle time that we could\n * have spend running if it were not for IO. That is, if we were to improve the\n * storage performance, we'd have a proportional reduction in IO-wait time.\n *\n * This all works nicely on UP, where, when a task blocks on IO, we account\n * idle time as IO-wait, because if the storage were faster, it could've been\n * running and we'd not be idle.\n *\n * This has been extended to SMP, by doing the same for each CPU. This however\n * is broken.\n *\n * Imagine for instance the case where two tasks block on one CPU, only the one\n * CPU will have IO-wait accounted, while the other has regular idle. Even\n * though, if the storage were faster, both could've ran at the same time,\n * utilising both CPUs.\n *\n * This means, that when looking globally, the current IO-wait accounting on\n * SMP is a lower bound, by reason of under accounting.\n *\n * Worse, since the numbers are provided per CPU, they are sometimes\n * interpreted per CPU, and that is nonsensical. A blocked task isn't strictly\n * associated with any one particular CPU, it can wake to another CPU than it\n * blocked on. This means the per CPU IO-wait number is meaningless.\n *\n * Task CPU affinities can make all that even more 'interesting'.\n */\n\nunsigned long nr_iowait(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += nr_iowait_cpu(i);\n\n\treturn sum;\n}\n\n#ifdef CONFIG_SMP\n\n/*\n * sched_exec - execve() is a valuable balancing opportunity, because at\n * this point the task has the smallest effective memory and cache footprint.\n */\nvoid sched_exec(void)\n{\n\tstruct task_struct *p = current;\n\tunsigned long flags;\n\tint dest_cpu;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0);\n\tif (dest_cpu == smp_processor_id())\n\t\tgoto unlock;\n\n\tif (likely(cpu_active(dest_cpu))) {\n\t\tstruct migration_arg arg = { p, dest_cpu };\n\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\t\tstop_one_cpu(task_cpu(p), migration_cpu_stop, &arg);\n\t\treturn;\n\t}\nunlock:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}\n\n#endif\n\nDEFINE_PER_CPU(struct kernel_stat, kstat);\nDEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);\n\nEXPORT_PER_CPU_SYMBOL(kstat);\nEXPORT_PER_CPU_SYMBOL(kernel_cpustat);\n\n/*\n * The function fair_sched_class.update_curr accesses the struct curr\n * and its field curr->exec_start; when called from task_sched_runtime(),\n * we observe a high rate of cache misses in practice.\n * Prefetching this data results in improved performance.\n */\nstatic inline void prefetch_curr_exec_start(struct task_struct *p)\n{\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tstruct sched_entity *curr = (&p->se)->cfs_rq->curr;\n#else\n\tstruct sched_entity *curr = (&task_rq(p)->cfs)->curr;\n#endif\n\tprefetch(curr);\n\tprefetch(&curr->exec_start);\n}\n\n/*\n * Return accounted runtime for the task.\n * In case the task is currently running, return the runtime plus current's\n * pending runtime that have not been accounted yet.\n */\nunsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}\n\n/*\n * This function gets called by the timer code, with HZ frequency.\n * We call it with interrupts disabled.\n */\nvoid scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq->curr;\n\tstruct rq_flags rf;\n\n\tsched_clock_tick();\n\n\trq_lock(rq, &rf);\n\n\tupdate_rq_clock(rq);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\tcpu_load_update_active(rq);\n\tcalc_global_load_tick(rq);\n\tpsi_task_tick(rq);\n\n\trq_unlock(rq, &rf);\n\n\tperf_event_task_tick();\n\n#ifdef CONFIG_SMP\n\trq->idle_balance = idle_cpu(cpu);\n\ttrigger_load_balance(rq);\n#endif\n}\n\n#ifdef CONFIG_NO_HZ_FULL\n\nstruct tick_work {\n\tint\t\t\tcpu;\n\tstruct delayed_work\twork;\n};\n\nstatic struct tick_work __percpu *tick_work_cpu;\n\nstatic void sched_tick_remote(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct tick_work *twork = container_of(dwork, struct tick_work, work);\n\tint cpu = twork->cpu;\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr;\n\tstruct rq_flags rf;\n\tu64 delta;\n\n\t/*\n\t * Handle the tick only if it appears the remote CPU is running in full\n\t * dynticks mode. The check is racy by nature, but missing a tick or\n\t * having one too much is no big deal because the scheduler tick updates\n\t * statistics and checks timeslices in a time-independent way, regardless\n\t * of when exactly it is running.\n\t */\n\tif (idle_cpu(cpu) || !tick_nohz_tick_stopped_cpu(cpu))\n\t\tgoto out_requeue;\n\n\trq_lock_irq(rq, &rf);\n\tcurr = rq->curr;\n\tif (is_idle_task(curr))\n\t\tgoto out_unlock;\n\n\tupdate_rq_clock(rq);\n\tdelta = rq_clock_task(rq) - curr->se.exec_start;\n\n\t/*\n\t * Make sure the next tick runs within a reasonable\n\t * amount of time.\n\t */\n\tWARN_ON_ONCE(delta > (u64)NSEC_PER_SEC * 3);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\nout_unlock:\n\trq_unlock_irq(rq, &rf);\n\nout_requeue:\n\t/*\n\t * Run the remote tick once per second (1Hz). This arbitrary\n\t * frequency is large enough to avoid overload but short enough\n\t * to keep scheduler internal stats reasonably up to date.\n\t */\n\tqueue_delayed_work(system_unbound_wq, dwork, HZ);\n}\n\nstatic void sched_tick_start(int cpu)\n{\n\tstruct tick_work *twork;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TICK))\n\t\treturn;\n\n\tWARN_ON_ONCE(!tick_work_cpu);\n\n\ttwork = per_cpu_ptr(tick_work_cpu, cpu);\n\ttwork->cpu = cpu;\n\tINIT_DELAYED_WORK(&twork->work, sched_tick_remote);\n\tqueue_delayed_work(system_unbound_wq, &twork->work, HZ);\n}\n\n#ifdef CONFIG_HOTPLUG_CPU\nstatic void sched_tick_stop(int cpu)\n{\n\tstruct tick_work *twork;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TICK))\n\t\treturn;\n\n\tWARN_ON_ONCE(!tick_work_cpu);\n\n\ttwork = per_cpu_ptr(tick_work_cpu, cpu);\n\tcancel_delayed_work_sync(&twork->work);\n}\n#endif /* CONFIG_HOTPLUG_CPU */\n\nint __init sched_tick_offload_init(void)\n{\n\ttick_work_cpu = alloc_percpu(struct tick_work);\n\tBUG_ON(!tick_work_cpu);\n\n\treturn 0;\n}\n\n#else /* !CONFIG_NO_HZ_FULL */\nstatic inline void sched_tick_start(int cpu) { }\nstatic inline void sched_tick_stop(int cpu) { }\n#endif\n\n#if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \\\n\t\t\t\tdefined(CONFIG_TRACE_PREEMPT_TOGGLE))\n/*\n * If the value passed in is equal to the current preempt count\n * then we just disabled preemption. Start timing the latency.\n */\nstatic inline void preempt_latency_start(int val)\n{\n\tif (preempt_count() == val) {\n\t\tunsigned long ip = get_lock_parent_ip();\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = ip;\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, ip);\n\t}\n}\n\nvoid preempt_count_add(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))\n\t\treturn;\n#endif\n\t__preempt_count_add(val);\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Spinlock count overflowing soon?\n\t */\n\tDEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >=\n\t\t\t\tPREEMPT_MASK - 10);\n#endif\n\tpreempt_latency_start(val);\n}\nEXPORT_SYMBOL(preempt_count_add);\nNOKPROBE_SYMBOL(preempt_count_add);\n\n/*\n * If the value passed in equals to the current preempt count\n * then we just enabled preemption. Stop timing the latency.\n */\nstatic inline void preempt_latency_stop(int val)\n{\n\tif (preempt_count() == val)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n}\n\nvoid preempt_count_sub(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(val > preempt_count()))\n\t\treturn;\n\t/*\n\t * Is the spinlock portion underflowing?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&\n\t\t\t!(preempt_count() & PREEMPT_MASK)))\n\t\treturn;\n#endif\n\n\tpreempt_latency_stop(val);\n\t__preempt_count_sub(val);\n}\nEXPORT_SYMBOL(preempt_count_sub);\nNOKPROBE_SYMBOL(preempt_count_sub);\n\n#else\nstatic inline void preempt_latency_start(int val) { }\nstatic inline void preempt_latency_stop(int val) { }\n#endif\n\nstatic inline unsigned long get_preempt_disable_ip(struct task_struct *p)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\treturn p->preempt_disable_ip;\n#else\n\treturn 0;\n#endif\n}\n\n/*\n * Print scheduling while atomic bug:\n */\nstatic noinline void __schedule_bug(struct task_struct *prev)\n{\n\t/* Save this before calling printk(), since that will clobber it */\n\tunsigned long preempt_disable_ip = get_preempt_disable_ip(current);\n\n\tif (oops_in_progress)\n\t\treturn;\n\n\tprintk(KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->comm, prev->pid, preempt_count());\n\n\tdebug_show_held_locks(prev);\n\tprint_modules();\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(prev);\n\tif (IS_ENABLED(CONFIG_DEBUG_PREEMPT)\n\t    && in_atomic_preempt_off()) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\tif (panic_on_warn)\n\t\tpanic(\"scheduling while atomic\\n\");\n\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}\n\n/*\n * Various schedule()-time debugging checks and statistics:\n */\nstatic inline void schedule_debug(struct task_struct *prev)\n{\n#ifdef CONFIG_SCHED_STACK_END_CHECK\n\tif (task_stack_end_corrupted(prev))\n\t\tpanic(\"corrupted stack end detected inside scheduler\\n\");\n#endif\n\n\tif (unlikely(in_atomic_preempt_off())) {\n\t\t__schedule_bug(prev);\n\t\tpreempt_count_set(PREEMPT_DISABLED);\n\t}\n\trcu_sleep_check();\n\n\tprofile_hit(SCHED_PROFILING, __builtin_return_address(0));\n\n\tschedstat_inc(this_rq()->sched_count);\n}\n\n/*\n * Pick up the highest-prio task:\n */\nstatic inline struct task_struct *\npick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tconst struct sched_class *class;\n\tstruct task_struct *p;\n\n\t/*\n\t * Optimization: we know that if all tasks are in the fair class we can\n\t * call that function directly, but only if the @prev task wasn't of a\n\t * higher scheduling class, because otherwise those loose the\n\t * opportunity to pull in more work from other CPUs.\n\t */\n\tif (likely((prev->sched_class == &idle_sched_class ||\n\t\t    prev->sched_class == &fair_sched_class) &&\n\t\t   rq->nr_running == rq->cfs.h_nr_running)) {\n\n\t\tp = fair_sched_class.pick_next_task(rq, prev, rf);\n\t\tif (unlikely(p == RETRY_TASK))\n\t\t\tgoto again;\n\n\t\t/* Assumes fair_sched_class->next == idle_sched_class */\n\t\tif (unlikely(!p))\n\t\t\tp = idle_sched_class.pick_next_task(rq, prev, rf);\n\n\t\treturn p;\n\t}\n\nagain:\n\tfor_each_class(class) {\n\t\tp = class->pick_next_task(rq, prev, rf);\n\t\tif (p) {\n\t\t\tif (unlikely(p == RETRY_TASK))\n\t\t\t\tgoto again;\n\t\t\treturn p;\n\t\t}\n\t}\n\n\t/* The idle class should always have a runnable task: */\n\tBUG();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == RETRY_TASK"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "class->pick_next_task",
          "args": [
            "rq",
            "prev",
            "rf"
          ],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_sched_class.pick_next_task",
          "args": [
            "rq",
            "prev",
            "rf"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == RETRY_TASK"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fair_sched_class.pick_next_task",
          "args": [
            "rq",
            "prev",
            "rf"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "(prev->sched_class == &idle_sched_class ||\n\t\t    prev->sched_class == &fair_sched_class) &&\n\t\t   rq->nr_running == rq->cfs.h_nr_running"
          ],
          "line": 3314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_inc",
          "args": [
            "this_rq()->sched_count"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_hit",
          "args": [
            "SCHED_PROFILING",
            "__builtin_return_address(0)"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_sleep_check",
          "args": [],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count_set",
          "args": [
            "PREEMPT_DISABLED"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedule_bug",
          "args": [
            "prev"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_atomic_preempt_off()"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic_preempt_off",
          "args": [],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"corrupted stack end detected inside scheduler\\n\""
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_panic_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "181-185",
          "snippet": "static int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_stack_end_corrupted",
          "args": [
            "prev"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_WARN",
            "LOCKDEP_STILL_OK"
          ],
          "line": 3275
        },
        "resolved": true,
        "details": {
          "function_name": "add_taint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "386-392",
          "snippet": "void add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\n\nvoid add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 3269
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_ip_sym",
          "args": [
            "preempt_disable_ip"
          ],
          "line": 3268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Preemption disabled at:\""
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic_preempt_off",
          "args": [],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DEBUG_PREEMPT"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "prev"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2606-2621",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_enable_event, (void *)curr->hardirq_enable_ip,\n\t\t(void *)curr->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->hardirq_disable_event, (void *)curr->hardirq_disable_ip,\n\t\t(void *)curr->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_enable_event, (void *)curr->softirq_enable_ip,\n\t\t(void *)curr->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\tcurr->softirq_disable_event, (void *)curr->softirq_disable_ip,\n\t\t(void *)curr->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_modules",
          "args": [],
          "line": 3262
        },
        "resolved": true,
        "details": {
          "function_name": "print_modules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4377-4394",
          "snippet": "void print_modules(void)\n{\n\tstruct module *mod;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\n\tprintk(KERN_DEFAULT \"Modules linked in:\");\n\t/* Most callers should already have preempt disabled, but make sure */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tpr_cont(\" %s%s\", mod->name, module_flags(mod, buf));\n\t}\n\tpreempt_enable();\n\tif (last_unloaded_module[0])\n\t\tpr_cont(\" [last unloaded: %s]\", last_unloaded_module);\n\tpr_cont(\"\\n\");\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define MODULE_FLAGS_BUF_SIZE (TAINT_FLAGS_COUNT + 4)"
          ],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static char last_unloaded_module[MODULE_NAME_LEN+1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\n#define MODULE_FLAGS_BUF_SIZE (TAINT_FLAGS_COUNT + 4)\n\nstatic LIST_HEAD(modules);\nstatic char last_unloaded_module[MODULE_NAME_LEN+1];\n\nvoid print_modules(void)\n{\n\tstruct module *mod;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\n\tprintk(KERN_DEFAULT \"Modules linked in:\");\n\t/* Most callers should already have preempt disabled, but make sure */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tpr_cont(\" %s%s\", mod->name, module_flags(mod, buf));\n\t}\n\tpreempt_enable();\n\tif (last_unloaded_module[0])\n\t\tpr_cont(\" [last unloaded: %s]\", last_unloaded_module);\n\tpr_cont(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_show_held_locks",
          "args": [
            "prev"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4403-4410",
          "snippet": "void debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\"",
            "prev->comm",
            "prev->pid",
            "preempt_count()"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_preempt_disable_ip",
          "args": [
            "current"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOKPROBE_SYMBOL",
          "args": [
            "preempt_count_sub"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "preempt_count_sub"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__preempt_count_sub",
          "args": [
            "val"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_latency_stop",
          "args": [
            "val"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "(val < PREEMPT_MASK) &&\n\t\t\t!(preempt_count() & PREEMPT_MASK)"
          ],
          "line": 3222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 3223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "val > preempt_count()"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_preempt_on",
          "args": [
            "CALLER_ADDR0",
            "get_lock_parent_ip()"
          ],
          "line": 3208
        },
        "resolved": true,
        "details": {
          "function_name": "trace_preempt_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_preemptirq.c",
          "lines": "76-81",
          "snippet": "void trace_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_enable_rcuidle(a0, a1);\n\ttracer_preempt_on(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_enable_rcuidle(a0, a1);\n\ttracer_preempt_on(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_parent_ip",
          "args": [],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOKPROBE_SYMBOL",
          "args": [
            "preempt_count_add"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "preempt_count_add"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_latency_start",
          "args": [
            "val"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "(preempt_count() & PREEMPT_MASK) >=\n\t\t\t\tPREEMPT_MASK - 10"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__preempt_count_add",
          "args": [
            "val"
          ],
          "line": 3188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUG_LOCKS_WARN_ON",
          "args": [
            "(preempt_count() < 0)"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_preempt_off",
          "args": [
            "CALLER_ADDR0",
            "ip"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "trace_preempt_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_preemptirq.c",
          "lines": "83-88",
          "snippet": "void trace_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_disable_rcuidle(a0, a1);\n\ttracer_preempt_off(a0, a1);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_disable_rcuidle(a0, a1);\n\ttracer_preempt_off(a0, a1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_lock_parent_ip",
          "args": [],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tick_work_cpu"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structtick_work"
          ],
          "line": 3151
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&twork->work"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_delayed_work_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3134-3137",
          "snippet": "bool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tick_work_cpu",
            "cpu"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tick_work_cpu"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpu",
          "args": [
            "cpu",
            "HK_FLAG_TICK"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "system_unbound_wq",
            "&twork->work",
            "HZ"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "903-920",
          "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&twork->work",
            "sched_tick_remote"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tick_work_cpu",
            "cpu"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tick_work_cpu"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpu",
          "args": [
            "cpu",
            "HK_FLAG_TICK"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_unlock_irq",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1146-1152",
          "snippet": "static inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "curr->sched_class->task_tick",
          "args": [
            "rq",
            "curr",
            "0"
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "delta > (u64)NSEC_PER_SEC * 3"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock_task",
          "args": [
            "rq"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1013-1019",
          "snippet": "static inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "curr"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_lock_irq",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "rq_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1114-1120",
          "snippet": "static inline void\nrq_lock_irq(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irq(&rq->lock);\n\trq_pin_lock(rq, rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_lock_irq(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irq(&rq->lock);\n\trq_pin_lock(rq, rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_tick_stopped_cpu",
          "args": [
            "cpu"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_tick_stopped_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "475-480",
          "snippet": "bool tick_nohz_tick_stopped_cpu(int cpu)\n{\n\tstruct tick_sched *ts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\treturn ts->tick_stopped;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_tick_stopped_cpu(int cpu)\n{\n\tstruct tick_sched *ts = per_cpu_ptr(&tick_cpu_sched, cpu);\n\n\treturn ts->tick_stopped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idle_cpu",
          "args": [
            "cpu"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "available_idle_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4012-4021",
          "snippet": "int available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dwork",
            "structtick_work",
            "work"
          ],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trigger_load_balance",
          "args": [
            "rq"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_task_tick",
          "args": [],
          "line": 3055
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_task_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "3732-3746",
          "snippet": "void perf_event_task_tick(void)\n{\n\tstruct list_head *head = this_cpu_ptr(&active_ctx_list);\n\tstruct perf_event_context *ctx, *tmp;\n\tint throttled;\n\n\tlockdep_assert_irqs_disabled();\n\n\t__this_cpu_inc(perf_throttled_seq);\n\tthrottled = __this_cpu_xchg(perf_throttled_count, 0);\n\ttick_dep_clear_cpu(smp_processor_id(), TICK_DEP_BIT_PERF_EVENTS);\n\n\tlist_for_each_entry_safe(ctx, tmp, head, active_ctx_list)\n\t\tperf_adjust_freq_unthr_context(ctx, throttled);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static DEFINE_PER_CPU(struct list_head, active_ctx_list);",
            "static __must_check struct",
            "static DEFINE_PER_CPU(int, perf_throttled_count);",
            "static DEFINE_PER_CPU(u64, perf_throttled_seq);",
            "static void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t       struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic DEFINE_PER_CPU(struct list_head, active_ctx_list);\nstatic __must_check struct;\nstatic DEFINE_PER_CPU(int, perf_throttled_count);\nstatic DEFINE_PER_CPU(u64, perf_throttled_seq);\nstatic void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t       struct list_head *head);\n\nvoid perf_event_task_tick(void)\n{\n\tstruct list_head *head = this_cpu_ptr(&active_ctx_list);\n\tstruct perf_event_context *ctx, *tmp;\n\tint throttled;\n\n\tlockdep_assert_irqs_disabled();\n\n\t__this_cpu_inc(perf_throttled_seq);\n\tthrottled = __this_cpu_xchg(perf_throttled_count, 0);\n\ttick_dep_clear_cpu(smp_processor_id(), TICK_DEP_BIT_PERF_EVENTS);\n\n\tlist_for_each_entry_safe(ctx, tmp, head, active_ctx_list)\n\t\tperf_adjust_freq_unthr_context(ctx, throttled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unlock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_task_tick",
          "args": [
            "rq"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "psi_task_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.h",
          "lines": "141-141",
          "snippet": "static inline void psi_task_tick(struct rq *rq) {}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void psi_task_tick(struct rq *rq) {}"
        }
      },
      {
        "call_info": {
          "callee": "calc_global_load_tick",
          "args": [
            "rq"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "calc_global_load_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/loadavg.c",
          "lines": "373-385",
          "snippet": "void calc_global_load_tick(struct rq *this_rq)\n{\n\tlong delta;\n\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\tdelta  = calc_load_fold_active(this_rq, 0);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tthis_rq->calc_load_update += LOAD_FREQ;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t calc_load_tasks;",
            "unsigned long calc_load_update;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\natomic_long_t calc_load_tasks;\nunsigned long calc_load_update;\n\nvoid calc_global_load_tick(struct rq *this_rq)\n{\n\tlong delta;\n\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\tdelta  = calc_load_fold_active(this_rq, 0);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tthis_rq->calc_load_update += LOAD_FREQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_load_update_active",
          "args": [
            "rq"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_load_update_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "100-100",
          "snippet": "static inline void cpu_load_update_active(struct rq *this_rq) { }",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void cpu_load_update_active(struct rq *this_rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "curr->sched_class->task_tick",
          "args": [
            "rq",
            "curr",
            "0"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_tick",
          "args": [],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_tick_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "405-420",
          "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->sched_class->update_curr",
          "args": [
            "rq"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "update_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "803-836",
          "snippet": "static void update_curr(struct cfs_rq *cfs_rq)\n{\n\tstruct sched_entity *curr = cfs_rq->curr;\n\tu64 now = rq_clock_task(rq_of(cfs_rq));\n\tu64 delta_exec;\n\n\tif (unlikely(!curr))\n\t\treturn;\n\n\tdelta_exec = now - curr->exec_start;\n\tif (unlikely((s64)delta_exec <= 0))\n\t\treturn;\n\n\tcurr->exec_start = now;\n\n\tschedstat_set(curr->statistics.exec_max,\n\t\t      max(delta_exec, curr->statistics.exec_max));\n\n\tcurr->sum_exec_runtime += delta_exec;\n\tschedstat_add(cfs_rq->exec_clock, delta_exec);\n\n\tcurr->vruntime += calc_delta_fair(delta_exec, curr);\n\tupdate_min_vruntime(cfs_rq);\n\n\tif (entity_is_task(curr)) {\n\t\tstruct task_struct *curtask = task_of(curr);\n\n\t\ttrace_sched_stat_runtime(curtask, delta_exec, curr->vruntime);\n\t\tcgroup_account_cputime(curtask, delta_exec);\n\t\taccount_group_exec_runtime(curtask, delta_exec);\n\t}\n\n\taccount_cfs_rq_runtime(cfs_rq, delta_exec);\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nvoid account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic __always_inline\nvoid account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic void update_curr(struct cfs_rq *cfs_rq)\n{\n\tstruct sched_entity *curr = cfs_rq->curr;\n\tu64 now = rq_clock_task(rq_of(cfs_rq));\n\tu64 delta_exec;\n\n\tif (unlikely(!curr))\n\t\treturn;\n\n\tdelta_exec = now - curr->exec_start;\n\tif (unlikely((s64)delta_exec <= 0))\n\t\treturn;\n\n\tcurr->exec_start = now;\n\n\tschedstat_set(curr->statistics.exec_max,\n\t\t      max(delta_exec, curr->statistics.exec_max));\n\n\tcurr->sum_exec_runtime += delta_exec;\n\tschedstat_add(cfs_rq->exec_clock, delta_exec);\n\n\tcurr->vruntime += calc_delta_fair(delta_exec, curr);\n\tupdate_min_vruntime(cfs_rq);\n\n\tif (entity_is_task(curr)) {\n\t\tstruct task_struct *curtask = task_of(curr);\n\n\t\ttrace_sched_stat_runtime(curtask, delta_exec, curr->vruntime);\n\t\tcgroup_account_cputime(curtask, delta_exec);\n\t\taccount_group_exec_runtime(curtask, delta_exec);\n\t}\n\n\taccount_cfs_rq_runtime(cfs_rq, delta_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefetch_curr_exec_start",
          "args": [
            "p"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1521-1524",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefetch",
          "args": [
            "&curr->exec_start"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prefetch",
          "args": [
            "curr"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_PER_CPU_SYMBOL",
          "args": [
            "kernel_cpustat"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_PER_CPU_SYMBOL",
          "args": [
            "kstat"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_one_cpu",
          "args": [
            "task_cpu(p)",
            "migration_cpu_stop",
            "&arg"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "stop_one_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "123-138",
          "snippet": "int stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done };\n\n\tcpu_stop_init_done(&done, 1);\n\tif (!cpu_stop_queue_work(cpu, &work))\n\t\treturn -ENOENT;\n\t/*\n\t * In case @cpu == smp_proccessor_id() we can avoid a sleep+wakeup\n\t * cycle by doing a preemption:\n\t */\n\tcond_resched();\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nint stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done };\n\n\tcpu_stop_init_done(&done, 1);\n\tif (!cpu_stop_queue_work(cpu, &work))\n\t\treturn -ENOENT;\n\t/*\n\t * In case @cpu == smp_proccessor_id() we can avoid a sleep+wakeup\n\t * cycle by doing a preemption:\n\t */\n\tcond_resched();\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "cpu_active(dest_cpu)"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_active",
          "args": [
            "dest_cpu"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->sched_class->select_task_rq",
          "args": [
            "p",
            "task_cpu(p)",
            "SD_BALANCE_EXEC",
            "0"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "select_task_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1530-1554",
          "snippet": "static inline\nint select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tcpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);\n\telse\n\t\tcpu = cpumask_any(&p->cpus_allowed);\n\n\t/*\n\t * In order not to call set_task_cpu() on a blocking task we need\n\t * to rely on ttwu() to place the task on a valid ->cpus_allowed\n\t * CPU.\n\t *\n\t * Since this is common to all placement strategies, this lives here.\n\t *\n\t * [ this allows ->select_task() to simply return task_cpu(p) and\n\t *   not worry about this generic constraint ]\n\t */\n\tif (unlikely(!is_cpu_allowed(p, cpu)))\n\t\tcpu = select_fallback_rq(task_cpu(p), p);\n\n\treturn cpu;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline\nint select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tcpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);\n\telse\n\t\tcpu = cpumask_any(&p->cpus_allowed);\n\n\t/*\n\t * In order not to call set_task_cpu() on a blocking task we need\n\t * to rely on ttwu() to place the task on a valid ->cpus_allowed\n\t * CPU.\n\t *\n\t * Since this is common to all placement strategies, this lives here.\n\t *\n\t * [ this allows ->select_task() to simply return task_cpu(p) and\n\t *   not worry about this generic constraint ]\n\t */\n\tif (unlikely(!is_cpu_allowed(p, cpu)))\n\t\tcpu = select_fallback_rq(task_cpu(p), p);\n\n\treturn cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cpu_rq(cpu)->nr_iowait"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nunsigned long long nr_context_switches(void)\n{\n\tint i;\n\tunsigned long long sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned long nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}\n\n/*\n * IO-wait accounting, and how its mostly bollocks (on SMP).\n *\n * The idea behind IO-wait account is to account the idle time that we could\n * have spend running if it were not for IO. That is, if we were to improve the\n * storage performance, we'd have a proportional reduction in IO-wait time.\n *\n * This all works nicely on UP, where, when a task blocks on IO, we account\n * idle time as IO-wait, because if the storage were faster, it could've been\n * running and we'd not be idle.\n *\n * This has been extended to SMP, by doing the same for each CPU. This however\n * is broken.\n *\n * Imagine for instance the case where two tasks block on one CPU, only the one\n * CPU will have IO-wait accounted, while the other has regular idle. Even\n * though, if the storage were faster, both could've ran at the same time,\n * utilising both CPUs.\n *\n * This means, that when looking globally, the current IO-wait accounting on\n * SMP is a lower bound, by reason of under accounting.\n *\n * Worse, since the numbers are provided per CPU, they are sometimes\n * interpreted per CPU, and that is nonsensical. A blocked task isn't strictly\n * associated with any one particular CPU, it can wake to another CPU than it\n * blocked on. This means the per CPU IO-wait number is meaningless.\n *\n * Task CPU affinities can make all that even more 'interesting'.\n */\n\nunsigned long nr_iowait(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += nr_iowait_cpu(i);\n\n\treturn sum;\n}\n\n#ifdef CONFIG_SMP\n\n/*\n * sched_exec - execve() is a valuable balancing opportunity, because at\n * this point the task has the smallest effective memory and cache footprint.\n */\nvoid sched_exec(void)\n{\n\tstruct task_struct *p = current;\n\tunsigned long flags;\n\tint dest_cpu;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0);\n\tif (dest_cpu == smp_processor_id())\n\t\tgoto unlock;\n\n\tif (likely(cpu_active(dest_cpu))) {\n\t\tstruct migration_arg arg = { p, dest_cpu };\n\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\t\tstop_one_cpu(task_cpu(p), migration_cpu_stop, &arg);\n\t\treturn;\n\t}\nunlock:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}\n\n#endif\n\nDEFINE_PER_CPU(struct kernel_stat, kstat);\nDEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);\n\nEXPORT_PER_CPU_SYMBOL(kstat);\nEXPORT_PER_CPU_SYMBOL(kernel_cpustat);\n\n/*\n * The function fair_sched_class.update_curr accesses the struct curr\n * and its field curr->exec_start; when called from task_sched_runtime(),\n * we observe a high rate of cache misses in practice.\n * Prefetching this data results in improved performance.\n */\nstatic inline void prefetch_curr_exec_start(struct task_struct *p)\n{\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tstruct sched_entity *curr = (&p->se)->cfs_rq->curr;\n#else\n\tstruct sched_entity *curr = (&task_rq(p)->cfs)->curr;\n#endif\n\tprefetch(curr);\n\tprefetch(&curr->exec_start);\n}\n\n/*\n * Return accounted runtime for the task.\n * In case the task is currently running, return the runtime plus current's\n * pending runtime that have not been accounted yet.\n */\nunsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}\n\n/*\n * This function gets called by the timer code, with HZ frequency.\n * We call it with interrupts disabled.\n */\nvoid scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq->curr;\n\tstruct rq_flags rf;\n\n\tsched_clock_tick();\n\n\trq_lock(rq, &rf);\n\n\tupdate_rq_clock(rq);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\tcpu_load_update_active(rq);\n\tcalc_global_load_tick(rq);\n\tpsi_task_tick(rq);\n\n\trq_unlock(rq, &rf);\n\n\tperf_event_task_tick();\n\n#ifdef CONFIG_SMP\n\trq->idle_balance = idle_cpu(cpu);\n\ttrigger_load_balance(rq);\n#endif\n}\n\n#ifdef CONFIG_NO_HZ_FULL\n\nstruct tick_work {\n\tint\t\t\tcpu;\n\tstruct delayed_work\twork;\n};\n\nstatic struct tick_work __percpu *tick_work_cpu;\n\nstatic void sched_tick_remote(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct tick_work *twork = container_of(dwork, struct tick_work, work);\n\tint cpu = twork->cpu;\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr;\n\tstruct rq_flags rf;\n\tu64 delta;\n\n\t/*\n\t * Handle the tick only if it appears the remote CPU is running in full\n\t * dynticks mode. The check is racy by nature, but missing a tick or\n\t * having one too much is no big deal because the scheduler tick updates\n\t * statistics and checks timeslices in a time-independent way, regardless\n\t * of when exactly it is running.\n\t */\n\tif (idle_cpu(cpu) || !tick_nohz_tick_stopped_cpu(cpu))\n\t\tgoto out_requeue;\n\n\trq_lock_irq(rq, &rf);\n\tcurr = rq->curr;\n\tif (is_idle_task(curr))\n\t\tgoto out_unlock;\n\n\tupdate_rq_clock(rq);\n\tdelta = rq_clock_task(rq) - curr->se.exec_start;\n\n\t/*\n\t * Make sure the next tick runs within a reasonable\n\t * amount of time.\n\t */\n\tWARN_ON_ONCE(delta > (u64)NSEC_PER_SEC * 3);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\nout_unlock:\n\trq_unlock_irq(rq, &rf);\n\nout_requeue:\n\t/*\n\t * Run the remote tick once per second (1Hz). This arbitrary\n\t * frequency is large enough to avoid overload but short enough\n\t * to keep scheduler internal stats reasonably up to date.\n\t */\n\tqueue_delayed_work(system_unbound_wq, dwork, HZ);\n}\n\nstatic void sched_tick_start(int cpu)\n{\n\tstruct tick_work *twork;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TICK))\n\t\treturn;\n\n\tWARN_ON_ONCE(!tick_work_cpu);\n\n\ttwork = per_cpu_ptr(tick_work_cpu, cpu);\n\ttwork->cpu = cpu;\n\tINIT_DELAYED_WORK(&twork->work, sched_tick_remote);\n\tqueue_delayed_work(system_unbound_wq, &twork->work, HZ);\n}\n\n#ifdef CONFIG_HOTPLUG_CPU\nstatic void sched_tick_stop(int cpu)\n{\n\tstruct tick_work *twork;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TICK))\n\t\treturn;\n\n\tWARN_ON_ONCE(!tick_work_cpu);\n\n\ttwork = per_cpu_ptr(tick_work_cpu, cpu);\n\tcancel_delayed_work_sync(&twork->work);\n}\n#endif /* CONFIG_HOTPLUG_CPU */\n\nint __init sched_tick_offload_init(void)\n{\n\ttick_work_cpu = alloc_percpu(struct tick_work);\n\tBUG_ON(!tick_work_cpu);\n\n\treturn 0;\n}\n\n#else /* !CONFIG_NO_HZ_FULL */\nstatic inline void sched_tick_start(int cpu) { }\nstatic inline void sched_tick_stop(int cpu) { }\n#endif\n\n#if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \\\n\t\t\t\tdefined(CONFIG_TRACE_PREEMPT_TOGGLE))\n/*\n * If the value passed in is equal to the current preempt count\n * then we just disabled preemption. Start timing the latency.\n */\nstatic inline void preempt_latency_start(int val)\n{\n\tif (preempt_count() == val) {\n\t\tunsigned long ip = get_lock_parent_ip();\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = ip;\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, ip);\n\t}\n}\n\nvoid preempt_count_add(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))\n\t\treturn;\n#endif\n\t__preempt_count_add(val);\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Spinlock count overflowing soon?\n\t */\n\tDEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >=\n\t\t\t\tPREEMPT_MASK - 10);\n#endif\n\tpreempt_latency_start(val);\n}\nEXPORT_SYMBOL(preempt_count_add);\nNOKPROBE_SYMBOL(preempt_count_add);\n\n/*\n * If the value passed in equals to the current preempt count\n * then we just enabled preemption. Stop timing the latency.\n */\nstatic inline void preempt_latency_stop(int val)\n{\n\tif (preempt_count() == val)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n}\n\nvoid preempt_count_sub(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(val > preempt_count()))\n\t\treturn;\n\t/*\n\t * Is the spinlock portion underflowing?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&\n\t\t\t!(preempt_count() & PREEMPT_MASK)))\n\t\treturn;\n#endif\n\n\tpreempt_latency_stop(val);\n\t__preempt_count_sub(val);\n}\nEXPORT_SYMBOL(preempt_count_sub);\nNOKPROBE_SYMBOL(preempt_count_sub);\n\n#else\nstatic inline void preempt_latency_start(int val) { }\nstatic inline void preempt_latency_stop(int val) { }\n#endif\n\nstatic inline unsigned long get_preempt_disable_ip(struct task_struct *p)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\treturn p->preempt_disable_ip;\n#else\n\treturn 0;\n#endif\n}\n\n/*\n * Print scheduling while atomic bug:\n */\nstatic noinline void __schedule_bug(struct task_struct *prev)\n{\n\t/* Save this before calling printk(), since that will clobber it */\n\tunsigned long preempt_disable_ip = get_preempt_disable_ip(current);\n\n\tif (oops_in_progress)\n\t\treturn;\n\n\tprintk(KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->comm, prev->pid, preempt_count());\n\n\tdebug_show_held_locks(prev);\n\tprint_modules();\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(prev);\n\tif (IS_ENABLED(CONFIG_DEBUG_PREEMPT)\n\t    && in_atomic_preempt_off()) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\tif (panic_on_warn)\n\t\tpanic(\"scheduling while atomic\\n\");\n\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}\n\n/*\n * Various schedule()-time debugging checks and statistics:\n */\nstatic inline void schedule_debug(struct task_struct *prev)\n{\n#ifdef CONFIG_SCHED_STACK_END_CHECK\n\tif (task_stack_end_corrupted(prev))\n\t\tpanic(\"corrupted stack end detected inside scheduler\\n\");\n#endif\n\n\tif (unlikely(in_atomic_preempt_off())) {\n\t\t__schedule_bug(prev);\n\t\tpreempt_count_set(PREEMPT_DISABLED);\n\t}\n\trcu_sleep_check();\n\n\tprofile_hit(SCHED_PROFILING, __builtin_return_address(0));\n\n\tschedstat_inc(this_rq()->sched_count);\n}\n\n/*\n * Pick up the highest-prio task:\n */\nstatic inline struct task_struct *\npick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tconst struct sched_class *class;\n\tstruct task_struct *p;\n\n\t/*\n\t * Optimization: we know that if all tasks are in the fair class we can\n\t * call that function directly, but only if the @prev task wasn't of a\n\t * higher scheduling class, because otherwise those loose the\n\t * opportunity to pull in more work from other CPUs.\n\t */\n\tif (likely((prev->sched_class == &idle_sched_class ||\n\t\t    prev->sched_class == &fair_sched_class) &&\n\t\t   rq->nr_running == rq->cfs.h_nr_running)) {\n\n\t\tp = fair_sched_class.pick_next_task(rq, prev, rf);\n\t\tif (unlikely(p == RETRY_TASK))\n\t\t\tgoto again;\n\n\t\t/* Assumes fair_sched_class->next == idle_sched_class */\n\t\tif (unlikely(!p))\n\t\t\tp = idle_sched_class.pick_next_task(rq, prev, rf);\n\n\t\treturn p;\n\t}\n\nagain:\n\tfor_each_class(class) {\n\t\tp = class->pick_next_task(rq, prev, rf);\n\t\tif (p) {\n\t\t\tif (unlikely(p == RETRY_TASK))\n\t\t\t\tgoto again;\n\t\t\treturn p;\n\t\t}\n\t}\n\n\t/* The idle class should always have a runnable task: */\n\tBUG();\n}"
  },
  {
    "function_name": "single_task_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2866-2869",
    "snippet": "bool single_task_running(void)\n{\n\treturn raw_rq()->nr_running == 1;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_rq",
          "args": [],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nbool single_task_running(void)\n{\n\treturn raw_rq()->nr_running == 1;\n}"
  },
  {
    "function_name": "nr_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2843-2851",
    "snippet": "unsigned long nr_running(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_online_cpu(i)\n\t\tsum += cpu_rq(i)->nr_running;\n\n\treturn sum;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nunsigned long nr_running(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_online_cpu(i)\n\t\tsum += cpu_rq(i)->nr_running;\n\n\treturn sum;\n}"
  },
  {
    "function_name": "context_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2790-2835",
    "snippet": "rq *\ncontext_switch(struct rq *rq, struct task_struct *prev,\n\t       struct task_struct *next, struct rq_flags *rf)\n{\n\tstruct mm_struct *mm, *oldmm;\n\n\tprepare_task_switch(rq, prev, next);\n\n\tmm = next->mm;\n\toldmm = prev->active_mm;\n\t/*\n\t * For paravirt, this is coupled with an exit in switch_to to\n\t * combine the page table reload and the switch backend into\n\t * one hypercall.\n\t */\n\tarch_start_context_switch(prev);\n\n\t/*\n\t * If mm is non-NULL, we pass through switch_mm(). If mm is\n\t * NULL, we will pass through mmdrop() in finish_task_switch().\n\t * Both of these contain the full memory barrier required by\n\t * membarrier after storing to rq->curr, before returning to\n\t * user-space.\n\t */\n\tif (!mm) {\n\t\tnext->active_mm = oldmm;\n\t\tmmgrab(oldmm);\n\t\tenter_lazy_tlb(oldmm, next);\n\t} else\n\t\tswitch_mm_irqs_off(oldmm, mm, next);\n\n\tif (!prev->mm) {\n\t\tprev->active_mm = NULL;\n\t\trq->prev_mm = oldmm;\n\t}\n\n\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\n\tprepare_lock_switch(rq, next, rf);\n\n\t/* Here we just switch the register state and the stack. */\n\tswitch_to(prev, next, prev);\n\tbarrier();\n\n\treturn finish_task_switch(prev);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_task_switch",
          "args": [
            "prev"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "finish_task_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2641-2720",
          "snippet": "static struct rq *finish_task_switch(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\n\t/*\n\t * The previous task will have left us with a preempt_count of 2\n\t * because it left us after:\n\t *\n\t *\tschedule()\n\t *\t  preempt_disable();\t\t\t// 1\n\t *\t  __schedule()\n\t *\t    raw_spin_lock_irq(&rq->lock)\t// 2\n\t *\n\t * Also, see FORK_PREEMPT_COUNT.\n\t */\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\n\trq->prev_mm = NULL;\n\n\t/*\n\t * A task struct has one reference for the use as \"current\".\n\t * If a task dies, then it sets TASK_DEAD in tsk->state and calls\n\t * schedule one last time. The schedule call will never return, and\n\t * the scheduled task must drop that reference.\n\t *\n\t * We must observe prev->state before clearing prev->on_cpu (in\n\t * finish_task), otherwise a concurrent wakeup can get prev\n\t * running on another CPU and we could rave with its RUNNING -> DEAD\n\t * transition, resulting in a double drop.\n\t */\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_task(prev);\n\tfinish_lock_switch(rq);\n\tfinish_arch_post_lock_switch();\n\tkcov_finish_switch(current);\n\n\tfire_sched_in_preempt_notifiers(current);\n\t/*\n\t * When switching through a kernel thread, the loop in\n\t * membarrier_{private,global}_expedited() may have observed that\n\t * kernel thread and not issued an IPI. It is therefore possible to\n\t * schedule between user->kernel->user threads without passing though\n\t * switch_mm(). Membarrier requires a barrier after storing to\n\t * rq->curr, before returning to userspace, so provide them here:\n\t *\n\t * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly\n\t *   provided by mmdrop(),\n\t * - a sync_core for SYNC_CORE.\n\t */\n\tif (mm) {\n\t\tmembarrier_mm_sync_core_before_usermode(mm);\n\t\tmmdrop(mm);\n\t}\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\n\t\t/*\n\t\t * Remove function-return probe instances associated with this\n\t\t * task and put them back on the free list.\n\t\t */\n\t\tkprobe_flush_task(prev);\n\n\t\t/* Task is done with its stack. */\n\t\tput_task_stack(prev);\n\n\t\tput_task_struct(prev);\n\t}\n\n\ttick_nohz_task_switch();\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct rq *finish_task_switch(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\n\t/*\n\t * The previous task will have left us with a preempt_count of 2\n\t * because it left us after:\n\t *\n\t *\tschedule()\n\t *\t  preempt_disable();\t\t\t// 1\n\t *\t  __schedule()\n\t *\t    raw_spin_lock_irq(&rq->lock)\t// 2\n\t *\n\t * Also, see FORK_PREEMPT_COUNT.\n\t */\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\n\trq->prev_mm = NULL;\n\n\t/*\n\t * A task struct has one reference for the use as \"current\".\n\t * If a task dies, then it sets TASK_DEAD in tsk->state and calls\n\t * schedule one last time. The schedule call will never return, and\n\t * the scheduled task must drop that reference.\n\t *\n\t * We must observe prev->state before clearing prev->on_cpu (in\n\t * finish_task), otherwise a concurrent wakeup can get prev\n\t * running on another CPU and we could rave with its RUNNING -> DEAD\n\t * transition, resulting in a double drop.\n\t */\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_task(prev);\n\tfinish_lock_switch(rq);\n\tfinish_arch_post_lock_switch();\n\tkcov_finish_switch(current);\n\n\tfire_sched_in_preempt_notifiers(current);\n\t/*\n\t * When switching through a kernel thread, the loop in\n\t * membarrier_{private,global}_expedited() may have observed that\n\t * kernel thread and not issued an IPI. It is therefore possible to\n\t * schedule between user->kernel->user threads without passing though\n\t * switch_mm(). Membarrier requires a barrier after storing to\n\t * rq->curr, before returning to userspace, so provide them here:\n\t *\n\t * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly\n\t *   provided by mmdrop(),\n\t * - a sync_core for SYNC_CORE.\n\t */\n\tif (mm) {\n\t\tmembarrier_mm_sync_core_before_usermode(mm);\n\t\tmmdrop(mm);\n\t}\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\n\t\t/*\n\t\t * Remove function-return probe instances associated with this\n\t\t * task and put them back on the free list.\n\t\t */\n\t\tkprobe_flush_task(prev);\n\n\t\t/* Task is done with its stack. */\n\t\tput_task_stack(prev);\n\n\t\tput_task_struct(prev);\n\t}\n\n\ttick_nohz_task_switch();\n\treturn rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "switch_to",
          "args": [
            "prev",
            "next",
            "prev"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_lock_switch",
          "args": [
            "rq",
            "next",
            "rf"
          ],
          "line": 2828
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_lock_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2556-2571",
          "snippet": "static inline void\nprepare_lock_switch(struct rq *rq, struct task_struct *next, struct rq_flags *rf)\n{\n\t/*\n\t * Since the runqueue lock will be released by the next\n\t * task (which is an invalid locking op but in the case\n\t * of the scheduler it's an obvious special-case), so we\n\t * do an early lockdep release here:\n\t */\n\trq_unpin_lock(rq, rf);\n\tspin_release(&rq->lock.dep_map, 1, _THIS_IP_);\n#ifdef CONFIG_DEBUG_SPINLOCK\n\t/* this is a valid case when another task releases the spinlock */\n\trq->lock.owner = next;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void\nprepare_lock_switch(struct rq *rq, struct task_struct *next, struct rq_flags *rf)\n{\n\t/*\n\t * Since the runqueue lock will be released by the next\n\t * task (which is an invalid locking op but in the case\n\t * of the scheduler it's an obvious special-case), so we\n\t * do an early lockdep release here:\n\t */\n\trq_unpin_lock(rq, rf);\n\tspin_release(&rq->lock.dep_map, 1, _THIS_IP_);\n#ifdef CONFIG_DEBUG_SPINLOCK\n\t/* this is a valid case when another task releases the spinlock */\n\trq->lock.owner = next;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "switch_mm_irqs_off",
          "args": [
            "oldmm",
            "mm",
            "next"
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_lazy_tlb",
          "args": [
            "oldmm",
            "next"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "oldmm"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_start_context_switch",
          "args": [
            "prev"
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_task_switch",
          "args": [
            "rq",
            "prev",
            "next"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_task_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2609-2620",
          "snippet": "static inline void\nprepare_task_switch(struct rq *rq, struct task_struct *prev,\n\t\t    struct task_struct *next)\n{\n\tkcov_prepare_switch(prev);\n\tsched_info_switch(rq, prev, next);\n\tperf_event_task_sched_out(prev, next);\n\trseq_preempt(prev);\n\tfire_sched_out_preempt_notifiers(prev, next);\n\tprepare_task(next);\n\tprepare_arch_switch(next);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void\nprepare_task_switch(struct rq *rq, struct task_struct *prev,\n\t\t    struct task_struct *next)\n{\n\tkcov_prepare_switch(prev);\n\tsched_info_switch(rq, prev, next);\n\tperf_event_task_sched_out(prev, next);\n\trseq_preempt(prev);\n\tfire_sched_out_preempt_notifiers(prev, next);\n\tprepare_task(next);\n\tprepare_arch_switch(next);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nrq *\ncontext_switch(struct rq *rq, struct task_struct *prev,\n\t       struct task_struct *next, struct rq_flags *rf)\n{\n\tstruct mm_struct *mm, *oldmm;\n\n\tprepare_task_switch(rq, prev, next);\n\n\tmm = next->mm;\n\toldmm = prev->active_mm;\n\t/*\n\t * For paravirt, this is coupled with an exit in switch_to to\n\t * combine the page table reload and the switch backend into\n\t * one hypercall.\n\t */\n\tarch_start_context_switch(prev);\n\n\t/*\n\t * If mm is non-NULL, we pass through switch_mm(). If mm is\n\t * NULL, we will pass through mmdrop() in finish_task_switch().\n\t * Both of these contain the full memory barrier required by\n\t * membarrier after storing to rq->curr, before returning to\n\t * user-space.\n\t */\n\tif (!mm) {\n\t\tnext->active_mm = oldmm;\n\t\tmmgrab(oldmm);\n\t\tenter_lazy_tlb(oldmm, next);\n\t} else\n\t\tswitch_mm_irqs_off(oldmm, mm, next);\n\n\tif (!prev->mm) {\n\t\tprev->active_mm = NULL;\n\t\trq->prev_mm = oldmm;\n\t}\n\n\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\n\tprepare_lock_switch(rq, next, rf);\n\n\t/* Here we just switch the register state and the stack. */\n\tswitch_to(prev, next, prev);\n\tbarrier();\n\n\treturn finish_task_switch(prev);\n}"
  },
  {
    "function_name": "schedule_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2763-2785",
    "snippet": "void schedule_tail(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq;\n\n\t/*\n\t * New tasks start with FORK_PREEMPT_COUNT, see there and\n\t * finish_task_switch() for details.\n\t *\n\t * finish_task_switch() will drop rq->lock() and lower preempt_count\n\t * and the preempt_enable() will end up enabling preemption (on\n\t * PREEMPT_COUNT kernels).\n\t */\n\n\trq = finish_task_switch(prev);\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\tif (current->set_child_tid)\n\t\tput_user(task_pid_vnr(current), current->set_child_tid);\n\n\tcalculate_sigpending();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_sigpending",
          "args": [],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_sigpending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "181-190",
          "snippet": "void calculate_sigpending(void)\n{\n\t/* Have any signals or users of TIF_SIGPENDING been delayed\n\t * until after fork?\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tset_tsk_thread_flag(current, TIF_SIGPENDING);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid calculate_sigpending(void)\n{\n\t/* Have any signals or users of TIF_SIGPENDING been delayed\n\t * until after fork?\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tset_tsk_thread_flag(current, TIF_SIGPENDING);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "task_pid_vnr(current)",
            "current->set_child_tid"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_callback",
          "args": [
            "rq"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "balance_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2753-2755",
          "snippet": "static inline void balance_callback(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void balance_callback(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_task_switch",
          "args": [
            "prev"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "finish_task_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2641-2720",
          "snippet": "static struct rq *finish_task_switch(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\n\t/*\n\t * The previous task will have left us with a preempt_count of 2\n\t * because it left us after:\n\t *\n\t *\tschedule()\n\t *\t  preempt_disable();\t\t\t// 1\n\t *\t  __schedule()\n\t *\t    raw_spin_lock_irq(&rq->lock)\t// 2\n\t *\n\t * Also, see FORK_PREEMPT_COUNT.\n\t */\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\n\trq->prev_mm = NULL;\n\n\t/*\n\t * A task struct has one reference for the use as \"current\".\n\t * If a task dies, then it sets TASK_DEAD in tsk->state and calls\n\t * schedule one last time. The schedule call will never return, and\n\t * the scheduled task must drop that reference.\n\t *\n\t * We must observe prev->state before clearing prev->on_cpu (in\n\t * finish_task), otherwise a concurrent wakeup can get prev\n\t * running on another CPU and we could rave with its RUNNING -> DEAD\n\t * transition, resulting in a double drop.\n\t */\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_task(prev);\n\tfinish_lock_switch(rq);\n\tfinish_arch_post_lock_switch();\n\tkcov_finish_switch(current);\n\n\tfire_sched_in_preempt_notifiers(current);\n\t/*\n\t * When switching through a kernel thread, the loop in\n\t * membarrier_{private,global}_expedited() may have observed that\n\t * kernel thread and not issued an IPI. It is therefore possible to\n\t * schedule between user->kernel->user threads without passing though\n\t * switch_mm(). Membarrier requires a barrier after storing to\n\t * rq->curr, before returning to userspace, so provide them here:\n\t *\n\t * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly\n\t *   provided by mmdrop(),\n\t * - a sync_core for SYNC_CORE.\n\t */\n\tif (mm) {\n\t\tmembarrier_mm_sync_core_before_usermode(mm);\n\t\tmmdrop(mm);\n\t}\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\n\t\t/*\n\t\t * Remove function-return probe instances associated with this\n\t\t * task and put them back on the free list.\n\t\t */\n\t\tkprobe_flush_task(prev);\n\n\t\t/* Task is done with its stack. */\n\t\tput_task_stack(prev);\n\n\t\tput_task_struct(prev);\n\t}\n\n\ttick_nohz_task_switch();\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct rq *finish_task_switch(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\n\t/*\n\t * The previous task will have left us with a preempt_count of 2\n\t * because it left us after:\n\t *\n\t *\tschedule()\n\t *\t  preempt_disable();\t\t\t// 1\n\t *\t  __schedule()\n\t *\t    raw_spin_lock_irq(&rq->lock)\t// 2\n\t *\n\t * Also, see FORK_PREEMPT_COUNT.\n\t */\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\n\trq->prev_mm = NULL;\n\n\t/*\n\t * A task struct has one reference for the use as \"current\".\n\t * If a task dies, then it sets TASK_DEAD in tsk->state and calls\n\t * schedule one last time. The schedule call will never return, and\n\t * the scheduled task must drop that reference.\n\t *\n\t * We must observe prev->state before clearing prev->on_cpu (in\n\t * finish_task), otherwise a concurrent wakeup can get prev\n\t * running on another CPU and we could rave with its RUNNING -> DEAD\n\t * transition, resulting in a double drop.\n\t */\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_task(prev);\n\tfinish_lock_switch(rq);\n\tfinish_arch_post_lock_switch();\n\tkcov_finish_switch(current);\n\n\tfire_sched_in_preempt_notifiers(current);\n\t/*\n\t * When switching through a kernel thread, the loop in\n\t * membarrier_{private,global}_expedited() may have observed that\n\t * kernel thread and not issued an IPI. It is therefore possible to\n\t * schedule between user->kernel->user threads without passing though\n\t * switch_mm(). Membarrier requires a barrier after storing to\n\t * rq->curr, before returning to userspace, so provide them here:\n\t *\n\t * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly\n\t *   provided by mmdrop(),\n\t * - a sync_core for SYNC_CORE.\n\t */\n\tif (mm) {\n\t\tmembarrier_mm_sync_core_before_usermode(mm);\n\t\tmmdrop(mm);\n\t}\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\n\t\t/*\n\t\t * Remove function-return probe instances associated with this\n\t\t * task and put them back on the free list.\n\t\t */\n\t\tkprobe_flush_task(prev);\n\n\t\t/* Task is done with its stack. */\n\t\tput_task_stack(prev);\n\n\t\tput_task_struct(prev);\n\t}\n\n\ttick_nohz_task_switch();\n\treturn rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rq->lock"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid schedule_tail(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq;\n\n\t/*\n\t * New tasks start with FORK_PREEMPT_COUNT, see there and\n\t * finish_task_switch() for details.\n\t *\n\t * finish_task_switch() will drop rq->lock() and lower preempt_count\n\t * and the preempt_enable() will end up enabling preemption (on\n\t * PREEMPT_COUNT kernels).\n\t */\n\n\trq = finish_task_switch(prev);\n\tbalance_callback(rq);\n\tpreempt_enable();\n\n\tif (current->set_child_tid)\n\t\tput_user(task_pid_vnr(current), current->set_child_tid);\n\n\tcalculate_sigpending();\n}"
  },
  {
    "function_name": "balance_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2753-2755",
    "snippet": "static inline void balance_callback(struct rq *rq)\n{\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void balance_callback(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "balance_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2745-2749",
    "snippet": "static inline void balance_callback(struct rq *rq)\n{\n\tif (unlikely(rq->balance_callback))\n\t\t__balance_callback(rq);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__balance_callback",
          "args": [
            "rq"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "__balance_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2725-2743",
          "snippet": "static void __balance_callback(struct rq *rq)\n{\n\tstruct callback_head *head, *next;\n\tvoid (*func)(struct rq *rq);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\thead = rq->balance_callback;\n\trq->balance_callback = NULL;\n\twhile (head) {\n\t\tfunc = (void (*)(struct rq *))head->func;\n\t\tnext = head->next;\n\t\thead->next = NULL;\n\t\thead = next;\n\n\t\tfunc(rq);\n\t}\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __balance_callback(struct rq *rq)\n{\n\tstruct callback_head *head, *next;\n\tvoid (*func)(struct rq *rq);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\thead = rq->balance_callback;\n\trq->balance_callback = NULL;\n\twhile (head) {\n\t\tfunc = (void (*)(struct rq *))head->func;\n\t\tnext = head->next;\n\t\thead->next = NULL;\n\t\thead = next;\n\n\t\tfunc(rq);\n\t}\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rq->balance_callback"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void balance_callback(struct rq *rq)\n{\n\tif (unlikely(rq->balance_callback))\n\t\t__balance_callback(rq);\n}"
  },
  {
    "function_name": "__balance_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2725-2743",
    "snippet": "static void __balance_callback(struct rq *rq)\n{\n\tstruct callback_head *head, *next;\n\tvoid (*func)(struct rq *rq);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\thead = rq->balance_callback;\n\trq->balance_callback = NULL;\n\twhile (head) {\n\t\tfunc = (void (*)(struct rq *))head->func;\n\t\tnext = head->next;\n\t\thead->next = NULL;\n\t\thead = next;\n\n\t\tfunc(rq);\n\t}\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rq->lock",
            "flags"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "rq"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "in_sched_functions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5885-5890",
          "snippet": "int in_sched_functions(unsigned long addr)\n{\n\treturn in_lock_functions(addr) ||\n\t\t(addr >= (unsigned long)__sched_text_start\n\t\t&& addr < (unsigned long)__sched_text_end);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint in_sched_functions(unsigned long addr)\n{\n\treturn in_lock_functions(addr) ||\n\t\t(addr >= (unsigned long)__sched_text_start\n\t\t&& addr < (unsigned long)__sched_text_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rq->lock",
            "flags"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __balance_callback(struct rq *rq)\n{\n\tstruct callback_head *head, *next;\n\tvoid (*func)(struct rq *rq);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\thead = rq->balance_callback;\n\trq->balance_callback = NULL;\n\twhile (head) {\n\t\tfunc = (void (*)(struct rq *))head->func;\n\t\tnext = head->next;\n\t\thead->next = NULL;\n\t\thead = next;\n\n\t\tfunc(rq);\n\t}\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n}"
  },
  {
    "function_name": "finish_task_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2641-2720",
    "snippet": "static struct rq *finish_task_switch(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\n\t/*\n\t * The previous task will have left us with a preempt_count of 2\n\t * because it left us after:\n\t *\n\t *\tschedule()\n\t *\t  preempt_disable();\t\t\t// 1\n\t *\t  __schedule()\n\t *\t    raw_spin_lock_irq(&rq->lock)\t// 2\n\t *\n\t * Also, see FORK_PREEMPT_COUNT.\n\t */\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\n\trq->prev_mm = NULL;\n\n\t/*\n\t * A task struct has one reference for the use as \"current\".\n\t * If a task dies, then it sets TASK_DEAD in tsk->state and calls\n\t * schedule one last time. The schedule call will never return, and\n\t * the scheduled task must drop that reference.\n\t *\n\t * We must observe prev->state before clearing prev->on_cpu (in\n\t * finish_task), otherwise a concurrent wakeup can get prev\n\t * running on another CPU and we could rave with its RUNNING -> DEAD\n\t * transition, resulting in a double drop.\n\t */\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_task(prev);\n\tfinish_lock_switch(rq);\n\tfinish_arch_post_lock_switch();\n\tkcov_finish_switch(current);\n\n\tfire_sched_in_preempt_notifiers(current);\n\t/*\n\t * When switching through a kernel thread, the loop in\n\t * membarrier_{private,global}_expedited() may have observed that\n\t * kernel thread and not issued an IPI. It is therefore possible to\n\t * schedule between user->kernel->user threads without passing though\n\t * switch_mm(). Membarrier requires a barrier after storing to\n\t * rq->curr, before returning to userspace, so provide them here:\n\t *\n\t * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly\n\t *   provided by mmdrop(),\n\t * - a sync_core for SYNC_CORE.\n\t */\n\tif (mm) {\n\t\tmembarrier_mm_sync_core_before_usermode(mm);\n\t\tmmdrop(mm);\n\t}\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\n\t\t/*\n\t\t * Remove function-return probe instances associated with this\n\t\t * task and put them back on the free list.\n\t\t */\n\t\tkprobe_flush_task(prev);\n\n\t\t/* Task is done with its stack. */\n\t\tput_task_stack(prev);\n\n\t\tput_task_struct(prev);\n\t}\n\n\ttick_nohz_task_switch();\n\treturn rq;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_task_switch",
          "args": [],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "__tick_nohz_task_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "369-388",
          "snippet": "void __tick_nohz_task_switch(void)\n{\n\tunsigned long flags;\n\tstruct tick_sched *ts;\n\n\tlocal_irq_save(flags);\n\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\tgoto out;\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped) {\n\t\tif (atomic_read(&current->tick_dep_mask) ||\n\t\t    atomic_read(&current->signal->tick_dep_mask))\n\t\t\ttick_nohz_full_kick();\n\t}\nout:\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid __tick_nohz_task_switch(void)\n{\n\tunsigned long flags;\n\tstruct tick_sched *ts;\n\n\tlocal_irq_save(flags);\n\n\tif (!tick_nohz_full_cpu(smp_processor_id()))\n\t\tgoto out;\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped) {\n\t\tif (atomic_read(&current->tick_dep_mask) ||\n\t\t    atomic_read(&current->signal->tick_dep_mask))\n\t\t\ttick_nohz_full_kick();\n\t}\nout:\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "prev"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_stack",
          "args": [
            "prev"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "put_task_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "429-433",
          "snippet": "void put_task_stack(struct task_struct *tsk)\n{\n\tif (atomic_dec_and_test(&tsk->stack_refcount))\n\t\trelease_task_stack(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid put_task_stack(struct task_struct *tsk)\n{\n\tif (atomic_dec_and_test(&tsk->stack_refcount))\n\t\trelease_task_stack(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_flush_task",
          "args": [
            "prev"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_flush_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1215-1239",
          "snippet": "void kprobe_flush_task(struct task_struct *tk)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_head *head, empty_rp;\n\tstruct hlist_node *tmp;\n\tunsigned long hash, flags = 0;\n\n\tif (unlikely(!kprobes_initialized))\n\t\t/* Early boot.  kretprobe_table_locks not yet initialized. */\n\t\treturn;\n\n\tINIT_HLIST_HEAD(&empty_rp);\n\thash = hash_ptr(tk, KPROBE_HASH_BITS);\n\thead = &kretprobe_inst_table[hash];\n\tkretprobe_table_lock(hash, &flags);\n\thlist_for_each_entry_safe(ri, tmp, head, hlist) {\n\t\tif (ri->task == tk)\n\t\t\trecycle_rp_inst(ri, &empty_rp);\n\t}\n\tkretprobe_table_unlock(hash, &flags);\n\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_HASH_BITS 6"
          ],
          "globals_used": [
            "static int kprobes_initialized;",
            "static struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];",
            "static struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic int kprobes_initialized;\nstatic struct hlist_head kretprobe_inst_table[KPROBE_TABLE_SIZE];\nstatic struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[KPROBE_TABLE_SIZE];\n\nvoid kprobe_flush_task(struct task_struct *tk)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct hlist_head *head, empty_rp;\n\tstruct hlist_node *tmp;\n\tunsigned long hash, flags = 0;\n\n\tif (unlikely(!kprobes_initialized))\n\t\t/* Early boot.  kretprobe_table_locks not yet initialized. */\n\t\treturn;\n\n\tINIT_HLIST_HEAD(&empty_rp);\n\thash = hash_ptr(tk, KPROBE_HASH_BITS);\n\thead = &kretprobe_inst_table[hash];\n\tkretprobe_table_lock(hash, &flags);\n\thlist_for_each_entry_safe(ri, tmp, head, hlist) {\n\t\tif (ri->task == tk)\n\t\t\trecycle_rp_inst(ri, &empty_rp);\n\t}\n\tkretprobe_table_unlock(hash, &flags);\n\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prev->sched_class->task_dead",
          "args": [
            "prev"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "prev_state == TASK_DEAD"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "mmdrop_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "689-695",
          "snippet": "static void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "membarrier_mm_sync_core_before_usermode",
          "args": [
            "mm"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fire_sched_in_preempt_notifiers",
          "args": [
            "current"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "fire_sched_in_preempt_notifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2516-2518",
          "snippet": "static inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_finish_switch",
          "args": [
            "current"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_arch_post_lock_switch",
          "args": [],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_lock_switch",
          "args": [
            "rq"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "finish_lock_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2573-2582",
          "snippet": "static inline void finish_lock_switch(struct rq *rq)\n{\n\t/*\n\t * If we are tracking spinlock dependencies then we have to\n\t * fix up the runqueue lock - which gets 'carried over' from\n\t * prev into current:\n\t */\n\tspin_acquire(&rq->lock.dep_map, 0, 0, _THIS_IP_);\n\traw_spin_unlock_irq(&rq->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void finish_lock_switch(struct rq *rq)\n{\n\t/*\n\t * If we are tracking spinlock dependencies then we have to\n\t * fix up the runqueue lock - which gets 'carried over' from\n\t * prev into current:\n\t */\n\tspin_acquire(&rq->lock.dep_map, 0, 0, _THIS_IP_);\n\traw_spin_unlock_irq(&rq->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_task",
          "args": [
            "prev"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "finish_task_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2641-2720",
          "snippet": "static struct rq *finish_task_switch(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\n\t/*\n\t * The previous task will have left us with a preempt_count of 2\n\t * because it left us after:\n\t *\n\t *\tschedule()\n\t *\t  preempt_disable();\t\t\t// 1\n\t *\t  __schedule()\n\t *\t    raw_spin_lock_irq(&rq->lock)\t// 2\n\t *\n\t * Also, see FORK_PREEMPT_COUNT.\n\t */\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\n\trq->prev_mm = NULL;\n\n\t/*\n\t * A task struct has one reference for the use as \"current\".\n\t * If a task dies, then it sets TASK_DEAD in tsk->state and calls\n\t * schedule one last time. The schedule call will never return, and\n\t * the scheduled task must drop that reference.\n\t *\n\t * We must observe prev->state before clearing prev->on_cpu (in\n\t * finish_task), otherwise a concurrent wakeup can get prev\n\t * running on another CPU and we could rave with its RUNNING -> DEAD\n\t * transition, resulting in a double drop.\n\t */\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_task(prev);\n\tfinish_lock_switch(rq);\n\tfinish_arch_post_lock_switch();\n\tkcov_finish_switch(current);\n\n\tfire_sched_in_preempt_notifiers(current);\n\t/*\n\t * When switching through a kernel thread, the loop in\n\t * membarrier_{private,global}_expedited() may have observed that\n\t * kernel thread and not issued an IPI. It is therefore possible to\n\t * schedule between user->kernel->user threads without passing though\n\t * switch_mm(). Membarrier requires a barrier after storing to\n\t * rq->curr, before returning to userspace, so provide them here:\n\t *\n\t * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly\n\t *   provided by mmdrop(),\n\t * - a sync_core for SYNC_CORE.\n\t */\n\tif (mm) {\n\t\tmembarrier_mm_sync_core_before_usermode(mm);\n\t\tmmdrop(mm);\n\t}\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\n\t\t/*\n\t\t * Remove function-return probe instances associated with this\n\t\t * task and put them back on the free list.\n\t\t */\n\t\tkprobe_flush_task(prev);\n\n\t\t/* Task is done with its stack. */\n\t\tput_task_stack(prev);\n\n\t\tput_task_struct(prev);\n\t}\n\n\ttick_nohz_task_switch();\n\treturn rq;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_task_sched_in",
          "args": [
            "prev",
            "current"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "__perf_event_task_sched_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "3446-3475",
          "snippet": "void __perf_event_task_sched_in(struct task_struct *prev,\n\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\t/*\n\t * If cgroup events exist on this CPU, then we need to check if we have\n\t * to switch in PMU state; cgroup event are system-wide mode only.\n\t *\n\t * Since cgroup events are CPU events, we must schedule these in before\n\t * we schedule in the task events.\n\t */\n\tif (atomic_read(this_cpu_ptr(&perf_cgroup_events)))\n\t\tperf_cgroup_sched_in(prev, task);\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = task->perf_event_ctxp[ctxn];\n\t\tif (likely(!ctx))\n\t\t\tcontinue;\n\n\t\tperf_event_context_sched_in(ctx, task);\n\t}\n\n\tif (atomic_read(&nr_switch_events))\n\t\tperf_event_switch(task, prev, true);\n\n\tif (__this_cpu_read(perf_sched_cb_usages))\n\t\tperf_pmu_sched_task(prev, task, true);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(atomic_t, perf_cgroup_events);",
            "static DEFINE_PER_CPU(int, perf_sched_cb_usages);",
            "static atomic_t nr_switch_events",
            "static void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic DEFINE_PER_CPU(atomic_t, perf_cgroup_events);\nstatic DEFINE_PER_CPU(int, perf_sched_cb_usages);\nstatic atomic_t nr_switch_events;\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid __perf_event_task_sched_in(struct task_struct *prev,\n\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\t/*\n\t * If cgroup events exist on this CPU, then we need to check if we have\n\t * to switch in PMU state; cgroup event are system-wide mode only.\n\t *\n\t * Since cgroup events are CPU events, we must schedule these in before\n\t * we schedule in the task events.\n\t */\n\tif (atomic_read(this_cpu_ptr(&perf_cgroup_events)))\n\t\tperf_cgroup_sched_in(prev, task);\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = task->perf_event_ctxp[ctxn];\n\t\tif (likely(!ctx))\n\t\t\tcontinue;\n\n\t\tperf_event_context_sched_in(ctx, task);\n\t}\n\n\tif (atomic_read(&nr_switch_events))\n\t\tperf_event_switch(task, prev, true);\n\n\tif (__this_cpu_read(perf_sched_cb_usages))\n\t\tperf_pmu_sched_task(prev, task, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_task_switch",
          "args": [
            "prev"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "arch_vtime_task_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "806-820",
          "snippet": "void arch_vtime_task_switch(struct task_struct *prev)\n{\n\tstruct vtime *vtime = &prev->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_INACTIVE;\n\twrite_seqcount_end(&vtime->seqcount);\n\n\tvtime = &current->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\twrite_seqcount_end(&vtime->seqcount);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid arch_vtime_task_switch(struct task_struct *prev)\n{\n\tstruct vtime *vtime = &prev->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_INACTIVE;\n\twrite_seqcount_end(&vtime->seqcount);\n\n\tvtime = &current->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\twrite_seqcount_end(&vtime->seqcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count_set",
          "args": [
            "FORK_PREEMPT_COUNT"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "preempt_count() != 2*PREEMPT_DISABLE_OFFSET",
            "\"corrupted preempt_count: %s/%d/0x%x\\n\"",
            "current->comm",
            "current->pid",
            "preempt_count()"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rq->lock"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct rq *finish_task_switch(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\n\t/*\n\t * The previous task will have left us with a preempt_count of 2\n\t * because it left us after:\n\t *\n\t *\tschedule()\n\t *\t  preempt_disable();\t\t\t// 1\n\t *\t  __schedule()\n\t *\t    raw_spin_lock_irq(&rq->lock)\t// 2\n\t *\n\t * Also, see FORK_PREEMPT_COUNT.\n\t */\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\n\trq->prev_mm = NULL;\n\n\t/*\n\t * A task struct has one reference for the use as \"current\".\n\t * If a task dies, then it sets TASK_DEAD in tsk->state and calls\n\t * schedule one last time. The schedule call will never return, and\n\t * the scheduled task must drop that reference.\n\t *\n\t * We must observe prev->state before clearing prev->on_cpu (in\n\t * finish_task), otherwise a concurrent wakeup can get prev\n\t * running on another CPU and we could rave with its RUNNING -> DEAD\n\t * transition, resulting in a double drop.\n\t */\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_task(prev);\n\tfinish_lock_switch(rq);\n\tfinish_arch_post_lock_switch();\n\tkcov_finish_switch(current);\n\n\tfire_sched_in_preempt_notifiers(current);\n\t/*\n\t * When switching through a kernel thread, the loop in\n\t * membarrier_{private,global}_expedited() may have observed that\n\t * kernel thread and not issued an IPI. It is therefore possible to\n\t * schedule between user->kernel->user threads without passing though\n\t * switch_mm(). Membarrier requires a barrier after storing to\n\t * rq->curr, before returning to userspace, so provide them here:\n\t *\n\t * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly\n\t *   provided by mmdrop(),\n\t * - a sync_core for SYNC_CORE.\n\t */\n\tif (mm) {\n\t\tmembarrier_mm_sync_core_before_usermode(mm);\n\t\tmmdrop(mm);\n\t}\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\n\t\t/*\n\t\t * Remove function-return probe instances associated with this\n\t\t * task and put them back on the free list.\n\t\t */\n\t\tkprobe_flush_task(prev);\n\n\t\t/* Task is done with its stack. */\n\t\tput_task_stack(prev);\n\n\t\tput_task_struct(prev);\n\t}\n\n\ttick_nohz_task_switch();\n\treturn rq;\n}"
  },
  {
    "function_name": "prepare_task_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2609-2620",
    "snippet": "static inline void\nprepare_task_switch(struct rq *rq, struct task_struct *prev,\n\t\t    struct task_struct *next)\n{\n\tkcov_prepare_switch(prev);\n\tsched_info_switch(rq, prev, next);\n\tperf_event_task_sched_out(prev, next);\n\trseq_preempt(prev);\n\tfire_sched_out_preempt_notifiers(prev, next);\n\tprepare_task(next);\n\tprepare_arch_switch(next);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prepare_arch_switch",
          "args": [
            "next"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_task",
          "args": [
            "next"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2528-2537",
          "snippet": "static inline void prepare_task(struct task_struct *next)\n{\n#ifdef CONFIG_SMP\n\t/*\n\t * Claim the task as running, we do this before switching to it\n\t * such that any running task will have this set.\n\t */\n\tnext->on_cpu = 1;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void prepare_task(struct task_struct *next)\n{\n#ifdef CONFIG_SMP\n\t/*\n\t * Claim the task as running, we do this before switching to it\n\t * such that any running task will have this set.\n\t */\n\tnext->on_cpu = 1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fire_sched_out_preempt_notifiers",
          "args": [
            "prev",
            "next"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "fire_sched_out_preempt_notifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2520-2524",
          "snippet": "static inline void\nfire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void\nfire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rseq_preempt",
          "args": [
            "prev"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_task_sched_out",
          "args": [
            "prev",
            "next"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "__perf_event_task_sched_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "3204-3225",
          "snippet": "void __perf_event_task_sched_out(struct task_struct *task,\n\t\t\t\t struct task_struct *next)\n{\n\tint ctxn;\n\n\tif (__this_cpu_read(perf_sched_cb_usages))\n\t\tperf_pmu_sched_task(task, next, false);\n\n\tif (atomic_read(&nr_switch_events))\n\t\tperf_event_switch(task, next, false);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_context_sched_out(task, ctxn, next);\n\n\t/*\n\t * if cgroup events exist on this CPU, then we need\n\t * to check if we have to switch out PMU state.\n\t * cgroup event are system-wide mode only\n\t */\n\tif (atomic_read(this_cpu_ptr(&perf_cgroup_events)))\n\t\tperf_cgroup_sched_out(task, next);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(atomic_t, perf_cgroup_events);",
            "static DEFINE_PER_CPU(int, perf_sched_cb_usages);",
            "static atomic_t nr_switch_events",
            "static void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic DEFINE_PER_CPU(atomic_t, perf_cgroup_events);\nstatic DEFINE_PER_CPU(int, perf_sched_cb_usages);\nstatic atomic_t nr_switch_events;\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid __perf_event_task_sched_out(struct task_struct *task,\n\t\t\t\t struct task_struct *next)\n{\n\tint ctxn;\n\n\tif (__this_cpu_read(perf_sched_cb_usages))\n\t\tperf_pmu_sched_task(task, next, false);\n\n\tif (atomic_read(&nr_switch_events))\n\t\tperf_event_switch(task, next, false);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_context_sched_out(task, ctxn, next);\n\n\t/*\n\t * if cgroup events exist on this CPU, then we need\n\t * to check if we have to switch out PMU state.\n\t * cgroup event are system-wide mode only\n\t */\n\tif (atomic_read(this_cpu_ptr(&perf_cgroup_events)))\n\t\tperf_cgroup_sched_out(task, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_info_switch",
          "args": [
            "rq",
            "prev",
            "next"
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "sched_info_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.h",
          "lines": "239-244",
          "snippet": "static inline void\nsched_info_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next)\n{\n\tif (unlikely(sched_info_on()))\n\t\t__sched_info_switch(rq, prev, next);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nsched_info_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next)\n{\n\tif (unlikely(sched_info_on()))\n\t\t__sched_info_switch(rq, prev, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_prepare_switch",
          "args": [
            "prev"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void\nprepare_task_switch(struct rq *rq, struct task_struct *prev,\n\t\t    struct task_struct *next)\n{\n\tkcov_prepare_switch(prev);\n\tsched_info_switch(rq, prev, next);\n\tperf_event_task_sched_out(prev, next);\n\trseq_preempt(prev);\n\tfire_sched_out_preempt_notifiers(prev, next);\n\tprepare_task(next);\n\tprepare_arch_switch(next);\n}"
  },
  {
    "function_name": "finish_lock_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2573-2582",
    "snippet": "static inline void finish_lock_switch(struct rq *rq)\n{\n\t/*\n\t * If we are tracking spinlock dependencies then we have to\n\t * fix up the runqueue lock - which gets 'carried over' from\n\t * prev into current:\n\t */\n\tspin_acquire(&rq->lock.dep_map, 0, 0, _THIS_IP_);\n\traw_spin_unlock_irq(&rq->lock);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&rq->lock"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_acquire",
          "args": [
            "&rq->lock.dep_map",
            "0",
            "0",
            "_THIS_IP_"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void finish_lock_switch(struct rq *rq)\n{\n\t/*\n\t * If we are tracking spinlock dependencies then we have to\n\t * fix up the runqueue lock - which gets 'carried over' from\n\t * prev into current:\n\t */\n\tspin_acquire(&rq->lock.dep_map, 0, 0, _THIS_IP_);\n\traw_spin_unlock_irq(&rq->lock);\n}"
  },
  {
    "function_name": "prepare_lock_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2556-2571",
    "snippet": "static inline void\nprepare_lock_switch(struct rq *rq, struct task_struct *next, struct rq_flags *rf)\n{\n\t/*\n\t * Since the runqueue lock will be released by the next\n\t * task (which is an invalid locking op but in the case\n\t * of the scheduler it's an obvious special-case), so we\n\t * do an early lockdep release here:\n\t */\n\trq_unpin_lock(rq, rf);\n\tspin_release(&rq->lock.dep_map, 1, _THIS_IP_);\n#ifdef CONFIG_DEBUG_SPINLOCK\n\t/* this is a valid case when another task releases the spinlock */\n\trq->lock.owner = next;\n#endif\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_release",
          "args": [
            "&rq->lock.dep_map",
            "1",
            "_THIS_IP_"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_unpin_lock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unpin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1060-1068",
          "snippet": "static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_UPDATED\t\t0x04",
            "#define RQCF_ACT_SKIP\t\t0x02"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_UPDATED\t\t0x04\n#define RQCF_ACT_SKIP\t\t0x02\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void\nprepare_lock_switch(struct rq *rq, struct task_struct *next, struct rq_flags *rf)\n{\n\t/*\n\t * Since the runqueue lock will be released by the next\n\t * task (which is an invalid locking op but in the case\n\t * of the scheduler it's an obvious special-case), so we\n\t * do an early lockdep release here:\n\t */\n\trq_unpin_lock(rq, rf);\n\tspin_release(&rq->lock.dep_map, 1, _THIS_IP_);\n#ifdef CONFIG_DEBUG_SPINLOCK\n\t/* this is a valid case when another task releases the spinlock */\n\trq->lock.owner = next;\n#endif\n}"
  },
  {
    "function_name": "finish_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2539-2554",
    "snippet": "static inline void finish_task(struct task_struct *prev)\n{\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->on_cpu is cleared, the task can be moved to a different CPU.\n\t * We must ensure this doesn't happen until the switch is completely\n\t * finished.\n\t *\n\t * In particular, the load of prev->state in finish_task_switch() must\n\t * happen before this.\n\t *\n\t * Pairs with the smp_cond_load_acquire() in try_to_wake_up().\n\t */\n\tsmp_store_release(&prev->on_cpu, 0);\n#endif\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&prev->on_cpu",
            "0"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void finish_task(struct task_struct *prev)\n{\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->on_cpu is cleared, the task can be moved to a different CPU.\n\t * We must ensure this doesn't happen until the switch is completely\n\t * finished.\n\t *\n\t * In particular, the load of prev->state in finish_task_switch() must\n\t * happen before this.\n\t *\n\t * Pairs with the smp_cond_load_acquire() in try_to_wake_up().\n\t */\n\tsmp_store_release(&prev->on_cpu, 0);\n#endif\n}"
  },
  {
    "function_name": "prepare_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2528-2537",
    "snippet": "static inline void prepare_task(struct task_struct *next)\n{\n#ifdef CONFIG_SMP\n\t/*\n\t * Claim the task as running, we do this before switching to it\n\t * such that any running task will have this set.\n\t */\n\tnext->on_cpu = 1;\n#endif\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void prepare_task(struct task_struct *next)\n{\n#ifdef CONFIG_SMP\n\t/*\n\t * Claim the task as running, we do this before switching to it\n\t * such that any running task will have this set.\n\t */\n\tnext->on_cpu = 1;\n#endif\n}"
  },
  {
    "function_name": "fire_sched_out_preempt_notifiers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2520-2524",
    "snippet": "static inline void\nfire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void\nfire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n}"
  },
  {
    "function_name": "fire_sched_in_preempt_notifiers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2516-2518",
    "snippet": "static inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n}"
  },
  {
    "function_name": "fire_sched_out_preempt_notifiers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2506-2512",
    "snippet": "static __always_inline void\nfire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n\tif (static_branch_unlikely(&preempt_notifier_key))\n\t\t__fire_sched_out_preempt_notifiers(curr, next);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fire_sched_out_preempt_notifiers",
          "args": [
            "curr",
            "next"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "__fire_sched_out_preempt_notifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2496-2504",
          "snippet": "static void\n__fire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t   struct task_struct *next)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_out(notifier, next);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void\n__fire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t   struct task_struct *next)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_out(notifier, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&preempt_notifier_key"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic __always_inline void\nfire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n\tif (static_branch_unlikely(&preempt_notifier_key))\n\t\t__fire_sched_out_preempt_notifiers(curr, next);\n}"
  },
  {
    "function_name": "__fire_sched_out_preempt_notifiers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2496-2504",
    "snippet": "static void\n__fire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t   struct task_struct *next)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_out(notifier, next);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "notifier",
            "next"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "notifier",
            "&curr->preempt_notifiers",
            "link"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void\n__fire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t   struct task_struct *next)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_out(notifier, next);\n}"
  },
  {
    "function_name": "fire_sched_in_preempt_notifiers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2490-2494",
    "snippet": "static __always_inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n\tif (static_branch_unlikely(&preempt_notifier_key))\n\t\t__fire_sched_in_preempt_notifiers(curr);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fire_sched_in_preempt_notifiers",
          "args": [
            "curr"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "__fire_sched_in_preempt_notifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2482-2488",
          "snippet": "static void __fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_in(notifier, raw_smp_processor_id());\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_in(notifier, raw_smp_processor_id());\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&preempt_notifier_key"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic __always_inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n\tif (static_branch_unlikely(&preempt_notifier_key))\n\t\t__fire_sched_in_preempt_notifiers(curr);\n}"
  },
  {
    "function_name": "__fire_sched_in_preempt_notifiers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2482-2488",
    "snippet": "static void __fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_in(notifier, raw_smp_processor_id());\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "notifier",
            "raw_smp_processor_id()"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "notifier",
            "&curr->preempt_notifiers",
            "link"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_in(notifier, raw_smp_processor_id());\n}"
  },
  {
    "function_name": "preempt_notifier_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2476-2479",
    "snippet": "void preempt_notifier_unregister(struct preempt_notifier *notifier)\n{\n\thlist_del(&notifier->link);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&notifier->link"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid preempt_notifier_unregister(struct preempt_notifier *notifier)\n{\n\thlist_del(&notifier->link);\n}"
  },
  {
    "function_name": "preempt_notifier_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2461-2467",
    "snippet": "void preempt_notifier_register(struct preempt_notifier *notifier)\n{\n\tif (!static_branch_unlikely(&preempt_notifier_key))\n\t\tWARN(1, \"registering preempt_notifier while notifiers disabled\\n\");\n\n\thlist_add_head(&notifier->link, &current->preempt_notifiers);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&notifier->link",
            "&current->preempt_notifiers"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"registering preempt_notifier while notifiers disabled\\n\""
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&preempt_notifier_key"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid preempt_notifier_register(struct preempt_notifier *notifier)\n{\n\tif (!static_branch_unlikely(&preempt_notifier_key))\n\t\tWARN(1, \"registering preempt_notifier while notifiers disabled\\n\");\n\n\thlist_add_head(&notifier->link, &current->preempt_notifiers);\n}"
  },
  {
    "function_name": "preempt_notifier_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2451-2454",
    "snippet": "void preempt_notifier_dec(void)\n{\n\tstatic_branch_dec(&preempt_notifier_key);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_dec",
          "args": [
            "&preempt_notifier_key"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid preempt_notifier_dec(void)\n{\n\tstatic_branch_dec(&preempt_notifier_key);\n}"
  },
  {
    "function_name": "preempt_notifier_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2445-2448",
    "snippet": "void preempt_notifier_inc(void)\n{\n\tstatic_branch_inc(&preempt_notifier_key);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&preempt_notifier_key"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid preempt_notifier_inc(void)\n{\n\tstatic_branch_inc(&preempt_notifier_key);\n}"
  },
  {
    "function_name": "wake_up_new_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2400-2439",
    "snippet": "void wake_up_new_task(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\tp->state = TASK_RUNNING;\n#ifdef CONFIG_SMP\n\t/*\n\t * Fork balancing, do it here and not earlier because:\n\t *  - cpus_allowed can change in the fork path\n\t *  - any previously selected CPU might disappear through hotplug\n\t *\n\t * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,\n\t * as we're not fully set-up yet.\n\t */\n\tp->recent_used_cpu = task_cpu(p);\n\t__set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0));\n#endif\n\trq = __task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\tpost_init_entity_util_avg(&p->se);\n\n\tactivate_task(rq, p, ENQUEUE_NOCLOCK);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\ttrace_sched_wakeup_new(p);\n\tcheck_preempt_curr(rq, p, WF_FORK);\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Nothing relies on rq->lock after this, so its fine to\n\t\t * drop it.\n\t\t */\n\t\trq_unpin_lock(rq, &rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, &rf);\n\t}\n#endif\n\ttask_rq_unlock(rq, p, &rf);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_repin_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "rq_repin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1070-1080",
          "snippet": "static inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(&rq->lock, rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(&rq->lock, rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->sched_class->task_woken",
          "args": [
            "rq",
            "p"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_unpin_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unpin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1060-1068",
          "snippet": "static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_UPDATED\t\t0x04",
            "#define RQCF_ACT_SKIP\t\t0x02"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_UPDATED\t\t0x04\n#define RQCF_ACT_SKIP\t\t0x02\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_preempt_curr",
          "args": [
            "rq",
            "p",
            "WF_FORK"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "841-864",
          "snippet": "void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_wakeup_new",
          "args": [
            "p"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "activate_task",
          "args": [
            "rq",
            "p",
            "ENQUEUE_NOCLOCK"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "754-760",
          "snippet": "void deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "post_init_entity_util_avg",
          "args": [
            "&p->se"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "post_init_entity_util_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "792-794",
          "snippet": "void post_init_entity_util_avg(struct sched_entity *se)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nwakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se);",
            "static void set_next_buddy(struct sched_entity *se);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic int\nwakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se);\nstatic void set_next_buddy(struct sched_entity *se);\n\nvoid post_init_entity_util_avg(struct sched_entity *se)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "__task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "66-85",
          "snippet": "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_task_cpu",
          "args": [
            "p",
            "select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "__set_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1428-1445",
          "snippet": "static inline void __set_task_cpu(struct task_struct *p, unsigned int cpu)\n{\n\tset_task_rq(p, cpu);\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->cpu is set up to a new value, task_rq_lock(p, ...) can be\n\t * successfuly executed on another CPU. We must ensure that updates of\n\t * per-task data have been completed by this moment.\n\t */\n\tsmp_wmb();\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tp->cpu = cpu;\n#else\n\ttask_thread_info(p)->cpu = cpu;\n#endif\n\tp->wake_cpu = cpu;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline void __set_task_cpu(struct task_struct *p, unsigned int cpu)\n{\n\tset_task_rq(p, cpu);\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->cpu is set up to a new value, task_rq_lock(p, ...) can be\n\t * successfuly executed on another CPU. We must ensure that updates of\n\t * per-task data have been completed by this moment.\n\t */\n\tsmp_wmb();\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tp->cpu = cpu;\n#else\n\ttask_thread_info(p)->cpu = cpu;\n#endif\n\tp->wake_cpu = cpu;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_task_rq",
          "args": [
            "p",
            "task_cpu(p)",
            "SD_BALANCE_FORK",
            "0"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "select_task_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1530-1554",
          "snippet": "static inline\nint select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tcpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);\n\telse\n\t\tcpu = cpumask_any(&p->cpus_allowed);\n\n\t/*\n\t * In order not to call set_task_cpu() on a blocking task we need\n\t * to rely on ttwu() to place the task on a valid ->cpus_allowed\n\t * CPU.\n\t *\n\t * Since this is common to all placement strategies, this lives here.\n\t *\n\t * [ this allows ->select_task() to simply return task_cpu(p) and\n\t *   not worry about this generic constraint ]\n\t */\n\tif (unlikely(!is_cpu_allowed(p, cpu)))\n\t\tcpu = select_fallback_rq(task_cpu(p), p);\n\n\treturn cpu;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline\nint select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tcpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);\n\telse\n\t\tcpu = cpumask_any(&p->cpus_allowed);\n\n\t/*\n\t * In order not to call set_task_cpu() on a blocking task we need\n\t * to rely on ttwu() to place the task on a valid ->cpus_allowed\n\t * CPU.\n\t *\n\t * Since this is common to all placement strategies, this lives here.\n\t *\n\t * [ this allows ->select_task() to simply return task_cpu(p) and\n\t *   not worry about this generic constraint ]\n\t */\n\tif (unlikely(!is_cpu_allowed(p, cpu)))\n\t\tcpu = select_fallback_rq(task_cpu(p), p);\n\n\treturn cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&p->pi_lock",
            "rf.flags"
          ],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid wake_up_new_task(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\tp->state = TASK_RUNNING;\n#ifdef CONFIG_SMP\n\t/*\n\t * Fork balancing, do it here and not earlier because:\n\t *  - cpus_allowed can change in the fork path\n\t *  - any previously selected CPU might disappear through hotplug\n\t *\n\t * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,\n\t * as we're not fully set-up yet.\n\t */\n\tp->recent_used_cpu = task_cpu(p);\n\t__set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0));\n#endif\n\trq = __task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\tpost_init_entity_util_avg(&p->se);\n\n\tactivate_task(rq, p, ENQUEUE_NOCLOCK);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\ttrace_sched_wakeup_new(p);\n\tcheck_preempt_curr(rq, p, WF_FORK);\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Nothing relies on rq->lock after this, so its fine to\n\t\t * drop it.\n\t\t */\n\t\trq_unpin_lock(rq, &rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, &rf);\n\t}\n#endif\n\ttask_rq_unlock(rq, p, &rf);\n}"
  },
  {
    "function_name": "to_ratio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2377-2391",
    "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "runtime << BW_SHIFT",
            "period"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
  },
  {
    "function_name": "sched_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2298-2375",
    "snippet": "int sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t__sched_fork(clone_flags, p);\n\t/*\n\t * We mark the process as NEW here. This guarantees that\n\t * nobody will actually run it, and a signal or other external\n\t * event cannot wake it up and insert it on the runqueue either.\n\t */\n\tp->state = TASK_NEW;\n\n\t/*\n\t * Make sure we do not leak PI boosting priority to the child.\n\t */\n\tp->prio = current->normal_prio;\n\n\t/*\n\t * Revert to default priority/policy on fork if requested.\n\t */\n\tif (unlikely(p->sched_reset_on_fork)) {\n\t\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\t\tp->policy = SCHED_NORMAL;\n\t\t\tp->static_prio = NICE_TO_PRIO(0);\n\t\t\tp->rt_priority = 0;\n\t\t} else if (PRIO_TO_NICE(p->static_prio) < 0)\n\t\t\tp->static_prio = NICE_TO_PRIO(0);\n\n\t\tp->prio = p->normal_prio = __normal_prio(p);\n\t\tset_load_weight(p, false);\n\n\t\t/*\n\t\t * We don't need the reset flag anymore after the fork. It has\n\t\t * fulfilled its duty:\n\t\t */\n\t\tp->sched_reset_on_fork = 0;\n\t}\n\n\tif (dl_prio(p->prio))\n\t\treturn -EAGAIN;\n\telse if (rt_prio(p->prio))\n\t\tp->sched_class = &rt_sched_class;\n\telse\n\t\tp->sched_class = &fair_sched_class;\n\n\tinit_entity_runnable_average(&p->se);\n\n\t/*\n\t * The child is not yet in the pid-hash so no cgroup attach races,\n\t * and the cgroup is pinned to this child due to cgroup_fork()\n\t * is ran before sched_fork().\n\t *\n\t * Silence PROVE_RCU.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\t/*\n\t * We're setting the CPU for the first time, we don't migrate,\n\t * so use __set_task_cpu().\n\t */\n\t__set_task_cpu(p, smp_processor_id());\n\tif (p->sched_class->task_fork)\n\t\tp->sched_class->task_fork(p);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n#ifdef CONFIG_SCHED_INFO\n\tif (likely(sched_info_on()))\n\t\tmemset(&p->sched_info, 0, sizeof(p->sched_info));\n#endif\n#if defined(CONFIG_SMP)\n\tp->on_cpu = 0;\n#endif\n\tinit_task_preempt_count(p);\n#ifdef CONFIG_SMP\n\tplist_node_init(&p->pushable_tasks, MAX_PRIO);\n\tRB_CLEAR_NODE(&p->pushable_dl_tasks);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&p->pushable_dl_tasks"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_node_init",
          "args": [
            "&p->pushable_tasks",
            "MAX_PRIO"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_task_preempt_count",
          "args": [
            "p"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&p->sched_info",
            "0",
            "sizeof(p->sched_info)"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sched_info_on()"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_info_on",
          "args": [],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->sched_class->task_fork",
          "args": [
            "p"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_task_cpu",
          "args": [
            "p",
            "smp_processor_id()"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "__set_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1428-1445",
          "snippet": "static inline void __set_task_cpu(struct task_struct *p, unsigned int cpu)\n{\n\tset_task_rq(p, cpu);\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->cpu is set up to a new value, task_rq_lock(p, ...) can be\n\t * successfuly executed on another CPU. We must ensure that updates of\n\t * per-task data have been completed by this moment.\n\t */\n\tsmp_wmb();\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tp->cpu = cpu;\n#else\n\ttask_thread_info(p)->cpu = cpu;\n#endif\n\tp->wake_cpu = cpu;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline void __set_task_cpu(struct task_struct *p, unsigned int cpu)\n{\n\tset_task_rq(p, cpu);\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->cpu is set up to a new value, task_rq_lock(p, ...) can be\n\t * successfuly executed on another CPU. We must ensure that updates of\n\t * per-task data have been completed by this moment.\n\t */\n\tsmp_wmb();\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tp->cpu = cpu;\n#else\n\ttask_thread_info(p)->cpu = cpu;\n#endif\n\tp->wake_cpu = cpu;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_entity_runnable_average",
          "args": [
            "&p->se"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "init_entity_runnable_average",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "789-791",
          "snippet": "void init_entity_runnable_average(struct sched_entity *se)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nwakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se);",
            "static void set_next_buddy(struct sched_entity *se);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic int\nwakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se);\nstatic void set_next_buddy(struct sched_entity *se);\n\nvoid init_entity_runnable_average(struct sched_entity *se)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_prio",
          "args": [
            "p->prio"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "convert_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
          "lines": "32-46",
          "snippet": "static int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "p->prio"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_load_weight",
          "args": [
            "p",
            "false"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "set_load_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "692-718",
          "snippet": "static void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (idle_policy(p->policy)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\tp->se.runnable_weight = load->weight;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t\tp->se.runnable_weight = load->weight;\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "const int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};",
            "const u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nconst int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};\nconst u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};\n\nstatic void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (idle_policy(p->policy)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\tp->se.runnable_weight = load->weight;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t\tp->se.runnable_weight = load->weight;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__normal_prio",
          "args": [
            "p"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "__normal_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "765-768",
          "snippet": "static inline int __normal_prio(struct task_struct *p)\n{\n\treturn p->static_prio;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int __normal_prio(struct task_struct *p)\n{\n\treturn p->static_prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NICE_TO_PRIO",
          "args": [
            "0"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRIO_TO_NICE",
          "args": [
            "p->static_prio"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NICE_TO_PRIO",
          "args": [
            "0"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_has_rt_policy",
          "args": [
            "p"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_rt_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "179-182",
          "snippet": "static inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_has_dl_policy",
          "args": [
            "p"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_dl_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "184-187",
          "snippet": "static inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->sched_reset_on_fork"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sched_fork",
          "args": [
            "clone_flags",
            "p"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2144-2181",
          "snippet": "static void __sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tp->on_rq\t\t\t= 0;\n\n\tp->se.on_rq\t\t\t= 0;\n\tp->se.exec_start\t\t= 0;\n\tp->se.sum_exec_runtime\t\t= 0;\n\tp->se.prev_sum_exec_runtime\t= 0;\n\tp->se.nr_migrations\t\t= 0;\n\tp->se.vruntime\t\t\t= 0;\n\tINIT_LIST_HEAD(&p->se.group_node);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tp->se.cfs_rq\t\t\t= NULL;\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n\t/* Even if schedstat is disabled, there should not be garbage */\n\tmemset(&p->se.statistics, 0, sizeof(p->se.statistics));\n#endif\n\n\tRB_CLEAR_NODE(&p->dl.rb_node);\n\tinit_dl_task_timer(&p->dl);\n\tinit_dl_inactive_task_timer(&p->dl);\n\t__dl_clear_params(p);\n\n\tINIT_LIST_HEAD(&p->rt.run_list);\n\tp->rt.timeout\t\t= 0;\n\tp->rt.time_slice\t= sched_rr_timeslice;\n\tp->rt.on_rq\t\t= 0;\n\tp->rt.on_list\t\t= 0;\n\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n\tINIT_HLIST_HEAD(&p->preempt_notifiers);\n#endif\n\n\tinit_numa_balancing(clone_flags, p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tp->on_rq\t\t\t= 0;\n\n\tp->se.on_rq\t\t\t= 0;\n\tp->se.exec_start\t\t= 0;\n\tp->se.sum_exec_runtime\t\t= 0;\n\tp->se.prev_sum_exec_runtime\t= 0;\n\tp->se.nr_migrations\t\t= 0;\n\tp->se.vruntime\t\t\t= 0;\n\tINIT_LIST_HEAD(&p->se.group_node);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tp->se.cfs_rq\t\t\t= NULL;\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n\t/* Even if schedstat is disabled, there should not be garbage */\n\tmemset(&p->se.statistics, 0, sizeof(p->se.statistics));\n#endif\n\n\tRB_CLEAR_NODE(&p->dl.rb_node);\n\tinit_dl_task_timer(&p->dl);\n\tinit_dl_inactive_task_timer(&p->dl);\n\t__dl_clear_params(p);\n\n\tINIT_LIST_HEAD(&p->rt.run_list);\n\tp->rt.timeout\t\t= 0;\n\tp->rt.time_slice\t= sched_rr_timeslice;\n\tp->rt.on_rq\t\t= 0;\n\tp->rt.on_list\t\t= 0;\n\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n\tINIT_HLIST_HEAD(&p->preempt_notifiers);\n#endif\n\n\tinit_numa_balancing(clone_flags, p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t__sched_fork(clone_flags, p);\n\t/*\n\t * We mark the process as NEW here. This guarantees that\n\t * nobody will actually run it, and a signal or other external\n\t * event cannot wake it up and insert it on the runqueue either.\n\t */\n\tp->state = TASK_NEW;\n\n\t/*\n\t * Make sure we do not leak PI boosting priority to the child.\n\t */\n\tp->prio = current->normal_prio;\n\n\t/*\n\t * Revert to default priority/policy on fork if requested.\n\t */\n\tif (unlikely(p->sched_reset_on_fork)) {\n\t\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\t\tp->policy = SCHED_NORMAL;\n\t\t\tp->static_prio = NICE_TO_PRIO(0);\n\t\t\tp->rt_priority = 0;\n\t\t} else if (PRIO_TO_NICE(p->static_prio) < 0)\n\t\t\tp->static_prio = NICE_TO_PRIO(0);\n\n\t\tp->prio = p->normal_prio = __normal_prio(p);\n\t\tset_load_weight(p, false);\n\n\t\t/*\n\t\t * We don't need the reset flag anymore after the fork. It has\n\t\t * fulfilled its duty:\n\t\t */\n\t\tp->sched_reset_on_fork = 0;\n\t}\n\n\tif (dl_prio(p->prio))\n\t\treturn -EAGAIN;\n\telse if (rt_prio(p->prio))\n\t\tp->sched_class = &rt_sched_class;\n\telse\n\t\tp->sched_class = &fair_sched_class;\n\n\tinit_entity_runnable_average(&p->se);\n\n\t/*\n\t * The child is not yet in the pid-hash so no cgroup attach races,\n\t * and the cgroup is pinned to this child due to cgroup_fork()\n\t * is ran before sched_fork().\n\t *\n\t * Silence PROVE_RCU.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\t/*\n\t * We're setting the CPU for the first time, we don't migrate,\n\t * so use __set_task_cpu().\n\t */\n\t__set_task_cpu(p, smp_processor_id());\n\tif (p->sched_class->task_fork)\n\t\tp->sched_class->task_fork(p);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n#ifdef CONFIG_SCHED_INFO\n\tif (likely(sched_info_on()))\n\t\tmemset(&p->sched_info, 0, sizeof(p->sched_info));\n#endif\n#if defined(CONFIG_SMP)\n\tp->on_cpu = 0;\n#endif\n\tinit_task_preempt_count(p);\n#ifdef CONFIG_SMP\n\tplist_node_init(&p->pushable_tasks, MAX_PRIO);\n\tRB_CLEAR_NODE(&p->pushable_dl_tasks);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "init_schedstats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2292-2292",
    "snippet": "static inline void init_schedstats(void) {}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic inline void init_schedstats(void) {}"
  },
  {
    "function_name": "sysctl_schedstats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2271-2289",
    "snippet": "int sysctl_schedstats(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_schedstats);\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_schedstats(state);\n\treturn err;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_schedstats",
          "args": [
            "state"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "set_schedstats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2223-2229",
          "snippet": "static void set_schedstats(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_schedstats);\n\telse\n\t\tstatic_branch_disable(&sched_schedstats);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void set_schedstats(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_schedstats);\n\telse\n\t\tstatic_branch_disable(&sched_schedstats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "&t",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3200-3204",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&sched_schedstats"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sysctl_schedstats(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_schedstats);\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_schedstats(state);\n\treturn err;\n}"
  },
  {
    "function_name": "init_schedstats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2265-2268",
    "snippet": "static void __init init_schedstats(void)\n{\n\tset_schedstats(__sched_schedstats);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_schedstats",
          "args": [
            "__sched_schedstats"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "set_schedstats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2223-2229",
          "snippet": "static void set_schedstats(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_schedstats);\n\telse\n\t\tstatic_branch_disable(&sched_schedstats);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void set_schedstats(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_schedstats);\n\telse\n\t\tstatic_branch_disable(&sched_schedstats);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __init init_schedstats(void)\n{\n\tset_schedstats(__sched_schedstats);\n}"
  },
  {
    "function_name": "setup_schedstats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2239-2262",
    "snippet": "static int __init setup_schedstats(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\n\t/*\n\t * This code is called before jump labels have been set up, so we can't\n\t * change the static branch directly just yet.  Instead set a temporary\n\t * variable so init_schedstats() can do it later.\n\t */\n\tif (!strcmp(str, \"enable\")) {\n\t\t__sched_schedstats = true;\n\t\tret = 1;\n\t} else if (!strcmp(str, \"disable\")) {\n\t\t__sched_schedstats = false;\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"Unable to parse schedstats=\\n\");\n\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unable to parse schedstats=\\n\""
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"disable\""
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"enable\""
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic int __init setup_schedstats(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\n\t/*\n\t * This code is called before jump labels have been set up, so we can't\n\t * change the static branch directly just yet.  Instead set a temporary\n\t * variable so init_schedstats() can do it later.\n\t */\n\tif (!strcmp(str, \"enable\")) {\n\t\t__sched_schedstats = true;\n\t\tret = 1;\n\t} else if (!strcmp(str, \"disable\")) {\n\t\t__sched_schedstats = false;\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"Unable to parse schedstats=\\n\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "force_schedstat_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2231-2237",
    "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&sched_schedstats"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\""
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2231-2237",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
  },
  {
    "function_name": "set_schedstats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2223-2229",
    "snippet": "static void set_schedstats(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_schedstats);\n\telse\n\t\tstatic_branch_disable(&sched_schedstats);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&sched_schedstats"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&sched_schedstats"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void set_schedstats(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_schedstats);\n\telse\n\t\tstatic_branch_disable(&sched_schedstats);\n}"
  },
  {
    "function_name": "sysctl_numa_balancing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2196-2214",
    "snippet": "int sysctl_numa_balancing(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_numa_balancing);\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_numabalancing_state(state);\n\treturn err;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_numabalancing_state",
          "args": [
            "state"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "set_numabalancing_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2187-2193",
          "snippet": "void set_numabalancing_state(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_numa_balancing);\n\telse\n\t\tstatic_branch_disable(&sched_numa_balancing);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid set_numabalancing_state(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_numa_balancing);\n\telse\n\t\tstatic_branch_disable(&sched_numa_balancing);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "&t",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3200-3204",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&sched_numa_balancing"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sysctl_numa_balancing(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_numa_balancing);\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_numabalancing_state(state);\n\treturn err;\n}"
  },
  {
    "function_name": "set_numabalancing_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2187-2193",
    "snippet": "void set_numabalancing_state(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_numa_balancing);\n\telse\n\t\tstatic_branch_disable(&sched_numa_balancing);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&sched_numa_balancing"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&sched_numa_balancing"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid set_numabalancing_state(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_numa_balancing);\n\telse\n\t\tstatic_branch_disable(&sched_numa_balancing);\n}"
  },
  {
    "function_name": "__sched_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2144-2181",
    "snippet": "static void __sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tp->on_rq\t\t\t= 0;\n\n\tp->se.on_rq\t\t\t= 0;\n\tp->se.exec_start\t\t= 0;\n\tp->se.sum_exec_runtime\t\t= 0;\n\tp->se.prev_sum_exec_runtime\t= 0;\n\tp->se.nr_migrations\t\t= 0;\n\tp->se.vruntime\t\t\t= 0;\n\tINIT_LIST_HEAD(&p->se.group_node);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tp->se.cfs_rq\t\t\t= NULL;\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n\t/* Even if schedstat is disabled, there should not be garbage */\n\tmemset(&p->se.statistics, 0, sizeof(p->se.statistics));\n#endif\n\n\tRB_CLEAR_NODE(&p->dl.rb_node);\n\tinit_dl_task_timer(&p->dl);\n\tinit_dl_inactive_task_timer(&p->dl);\n\t__dl_clear_params(p);\n\n\tINIT_LIST_HEAD(&p->rt.run_list);\n\tp->rt.timeout\t\t= 0;\n\tp->rt.time_slice\t= sched_rr_timeslice;\n\tp->rt.on_rq\t\t= 0;\n\tp->rt.on_list\t\t= 0;\n\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n\tINIT_HLIST_HEAD(&p->preempt_notifiers);\n#endif\n\n\tinit_numa_balancing(clone_flags, p);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_numa_balancing",
          "args": [
            "clone_flags",
            "p"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "init_numa_balancing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1209-1212",
          "snippet": "static inline void\ninit_numa_balancing(unsigned long clone_flags, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline void\ninit_numa_balancing(unsigned long clone_flags, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&p->preempt_notifiers"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&p->rt.run_list"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dl_clear_params",
          "args": [
            "p"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_clear_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2648-2663",
          "snippet": "void __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dl_inactive_task_timer",
          "args": [
            "&p->dl"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_inactive_task_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1292-1298",
          "snippet": "void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\ttimer->function = inactive_task_timer;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_inactive_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\ttimer->function = inactive_task_timer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dl_task_timer",
          "args": [
            "&p->dl"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_task_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1053-1059",
          "snippet": "void init_dl_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\ttimer->function = dl_task_timer;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\ttimer->function = dl_task_timer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&p->dl.rb_node"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&p->se.statistics",
            "0",
            "sizeof(p->se.statistics)"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&p->se.group_node"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tp->on_rq\t\t\t= 0;\n\n\tp->se.on_rq\t\t\t= 0;\n\tp->se.exec_start\t\t= 0;\n\tp->se.sum_exec_runtime\t\t= 0;\n\tp->se.prev_sum_exec_runtime\t= 0;\n\tp->se.nr_migrations\t\t= 0;\n\tp->se.vruntime\t\t\t= 0;\n\tINIT_LIST_HEAD(&p->se.group_node);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tp->se.cfs_rq\t\t\t= NULL;\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n\t/* Even if schedstat is disabled, there should not be garbage */\n\tmemset(&p->se.statistics, 0, sizeof(p->se.statistics));\n#endif\n\n\tRB_CLEAR_NODE(&p->dl.rb_node);\n\tinit_dl_task_timer(&p->dl);\n\tinit_dl_inactive_task_timer(&p->dl);\n\t__dl_clear_params(p);\n\n\tINIT_LIST_HEAD(&p->rt.run_list);\n\tp->rt.timeout\t\t= 0;\n\tp->rt.time_slice\t= sched_rr_timeslice;\n\tp->rt.on_rq\t\t= 0;\n\tp->rt.on_list\t\t= 0;\n\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n\tINIT_HLIST_HEAD(&p->preempt_notifiers);\n#endif\n\n\tinit_numa_balancing(clone_flags, p);\n}"
  },
  {
    "function_name": "wake_up_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2133-2136",
    "snippet": "int wake_up_state(struct task_struct *p, unsigned int state)\n{\n\treturn try_to_wake_up(p, state, 0);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_wake_up",
          "args": [
            "p",
            "state",
            "0"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_wake_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1953-2064",
          "snippet": "static int\ntry_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with mb() in\n\t * set_current_state() the waiting thread does.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tsmp_mb__after_spinlock();\n\tif (!(p->state & state))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\t/* We're going to change ->state: */\n\tsuccess = 1;\n\tcpu = task_cpu(p);\n\n\t/*\n\t * Ensure we load p->on_rq _after_ p->state, otherwise it would\n\t * be possible to, falsely, observe p->on_rq == 0 and get stuck\n\t * in smp_cond_load_acquire() below.\n\t *\n\t * sched_ttwu_pending()\t\t\ttry_to_wake_up()\n\t *   STORE p->on_rq = 1\t\t\t  LOAD p->state\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   UNLOCK rq->lock\n\t *\n\t * [task p]\n\t *   STORE p->state = UNINTERRUPTIBLE\t  LOAD p->on_rq\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\tif (p->on_rq && ttwu_remote(p, wake_flags))\n\t\tgoto stat;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Ensure we load p->on_cpu _after_ p->on_rq, otherwise it would be\n\t * possible to, falsely, observe p->on_cpu == 0.\n\t *\n\t * One must be running (->on_cpu == 1) in order to remove oneself\n\t * from the runqueue.\n\t *\n\t * __schedule() (switch to task 'p')\ttry_to_wake_up()\n\t *   STORE p->on_cpu = 1\t\t  LOAD p->on_rq\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (put 'p' to sleep)\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   STORE p->on_rq = 0\t\t\t  LOAD p->on_cpu\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the owning (remote) CPU is still in the middle of schedule() with\n\t * this task as prev, wait until its done referencing the task.\n\t *\n\t * Pairs with the smp_store_release() in finish_task().\n\t *\n\t * This ensures that tasks getting woken will be fully ordered against\n\t * their previous state and preserve Program Order.\n\t */\n\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\tp->sched_contributes_to_load = !!task_contributes_to_load(p);\n\tp->state = TASK_WAKING;\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n\tcpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);\n\tif (task_cpu(p) != cpu) {\n\t\twake_flags |= WF_MIGRATED;\n\t\tpsi_ttwu_dequeue(p);\n\t\tset_task_cpu(p, cpu);\n\t}\n\n#else /* CONFIG_SMP */\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu, wake_flags);\nstat:\n\tttwu_stat(p, cpu, wake_flags);\nout:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn success;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int\ntry_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with mb() in\n\t * set_current_state() the waiting thread does.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tsmp_mb__after_spinlock();\n\tif (!(p->state & state))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\t/* We're going to change ->state: */\n\tsuccess = 1;\n\tcpu = task_cpu(p);\n\n\t/*\n\t * Ensure we load p->on_rq _after_ p->state, otherwise it would\n\t * be possible to, falsely, observe p->on_rq == 0 and get stuck\n\t * in smp_cond_load_acquire() below.\n\t *\n\t * sched_ttwu_pending()\t\t\ttry_to_wake_up()\n\t *   STORE p->on_rq = 1\t\t\t  LOAD p->state\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   UNLOCK rq->lock\n\t *\n\t * [task p]\n\t *   STORE p->state = UNINTERRUPTIBLE\t  LOAD p->on_rq\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\tif (p->on_rq && ttwu_remote(p, wake_flags))\n\t\tgoto stat;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Ensure we load p->on_cpu _after_ p->on_rq, otherwise it would be\n\t * possible to, falsely, observe p->on_cpu == 0.\n\t *\n\t * One must be running (->on_cpu == 1) in order to remove oneself\n\t * from the runqueue.\n\t *\n\t * __schedule() (switch to task 'p')\ttry_to_wake_up()\n\t *   STORE p->on_cpu = 1\t\t  LOAD p->on_rq\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (put 'p' to sleep)\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   STORE p->on_rq = 0\t\t\t  LOAD p->on_cpu\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the owning (remote) CPU is still in the middle of schedule() with\n\t * this task as prev, wait until its done referencing the task.\n\t *\n\t * Pairs with the smp_store_release() in finish_task().\n\t *\n\t * This ensures that tasks getting woken will be fully ordered against\n\t * their previous state and preserve Program Order.\n\t */\n\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\tp->sched_contributes_to_load = !!task_contributes_to_load(p);\n\tp->state = TASK_WAKING;\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n\tcpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);\n\tif (task_cpu(p) != cpu) {\n\t\twake_flags |= WF_MIGRATED;\n\t\tpsi_ttwu_dequeue(p);\n\t\tset_task_cpu(p, cpu);\n\t}\n\n#else /* CONFIG_SMP */\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu, wake_flags);\nstat:\n\tttwu_stat(p, cpu, wake_flags);\nout:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn success;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_state(struct task_struct *p, unsigned int state)\n{\n\treturn try_to_wake_up(p, state, 0);\n}"
  },
  {
    "function_name": "wake_up_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2127-2130",
    "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_wake_up",
          "args": [
            "p",
            "TASK_NORMAL",
            "0"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_wake_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1953-2064",
          "snippet": "static int\ntry_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with mb() in\n\t * set_current_state() the waiting thread does.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tsmp_mb__after_spinlock();\n\tif (!(p->state & state))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\t/* We're going to change ->state: */\n\tsuccess = 1;\n\tcpu = task_cpu(p);\n\n\t/*\n\t * Ensure we load p->on_rq _after_ p->state, otherwise it would\n\t * be possible to, falsely, observe p->on_rq == 0 and get stuck\n\t * in smp_cond_load_acquire() below.\n\t *\n\t * sched_ttwu_pending()\t\t\ttry_to_wake_up()\n\t *   STORE p->on_rq = 1\t\t\t  LOAD p->state\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   UNLOCK rq->lock\n\t *\n\t * [task p]\n\t *   STORE p->state = UNINTERRUPTIBLE\t  LOAD p->on_rq\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\tif (p->on_rq && ttwu_remote(p, wake_flags))\n\t\tgoto stat;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Ensure we load p->on_cpu _after_ p->on_rq, otherwise it would be\n\t * possible to, falsely, observe p->on_cpu == 0.\n\t *\n\t * One must be running (->on_cpu == 1) in order to remove oneself\n\t * from the runqueue.\n\t *\n\t * __schedule() (switch to task 'p')\ttry_to_wake_up()\n\t *   STORE p->on_cpu = 1\t\t  LOAD p->on_rq\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (put 'p' to sleep)\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   STORE p->on_rq = 0\t\t\t  LOAD p->on_cpu\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the owning (remote) CPU is still in the middle of schedule() with\n\t * this task as prev, wait until its done referencing the task.\n\t *\n\t * Pairs with the smp_store_release() in finish_task().\n\t *\n\t * This ensures that tasks getting woken will be fully ordered against\n\t * their previous state and preserve Program Order.\n\t */\n\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\tp->sched_contributes_to_load = !!task_contributes_to_load(p);\n\tp->state = TASK_WAKING;\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n\tcpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);\n\tif (task_cpu(p) != cpu) {\n\t\twake_flags |= WF_MIGRATED;\n\t\tpsi_ttwu_dequeue(p);\n\t\tset_task_cpu(p, cpu);\n\t}\n\n#else /* CONFIG_SMP */\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu, wake_flags);\nstat:\n\tttwu_stat(p, cpu, wake_flags);\nout:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn success;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int\ntry_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with mb() in\n\t * set_current_state() the waiting thread does.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tsmp_mb__after_spinlock();\n\tif (!(p->state & state))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\t/* We're going to change ->state: */\n\tsuccess = 1;\n\tcpu = task_cpu(p);\n\n\t/*\n\t * Ensure we load p->on_rq _after_ p->state, otherwise it would\n\t * be possible to, falsely, observe p->on_rq == 0 and get stuck\n\t * in smp_cond_load_acquire() below.\n\t *\n\t * sched_ttwu_pending()\t\t\ttry_to_wake_up()\n\t *   STORE p->on_rq = 1\t\t\t  LOAD p->state\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   UNLOCK rq->lock\n\t *\n\t * [task p]\n\t *   STORE p->state = UNINTERRUPTIBLE\t  LOAD p->on_rq\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\tif (p->on_rq && ttwu_remote(p, wake_flags))\n\t\tgoto stat;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Ensure we load p->on_cpu _after_ p->on_rq, otherwise it would be\n\t * possible to, falsely, observe p->on_cpu == 0.\n\t *\n\t * One must be running (->on_cpu == 1) in order to remove oneself\n\t * from the runqueue.\n\t *\n\t * __schedule() (switch to task 'p')\ttry_to_wake_up()\n\t *   STORE p->on_cpu = 1\t\t  LOAD p->on_rq\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (put 'p' to sleep)\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   STORE p->on_rq = 0\t\t\t  LOAD p->on_cpu\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the owning (remote) CPU is still in the middle of schedule() with\n\t * this task as prev, wait until its done referencing the task.\n\t *\n\t * Pairs with the smp_store_release() in finish_task().\n\t *\n\t * This ensures that tasks getting woken will be fully ordered against\n\t * their previous state and preserve Program Order.\n\t */\n\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\tp->sched_contributes_to_load = !!task_contributes_to_load(p);\n\tp->state = TASK_WAKING;\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n\tcpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);\n\tif (task_cpu(p) != cpu) {\n\t\twake_flags |= WF_MIGRATED;\n\t\tpsi_ttwu_dequeue(p);\n\t\tset_task_cpu(p, cpu);\n\t}\n\n#else /* CONFIG_SMP */\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu, wake_flags);\nstat:\n\tttwu_stat(p, cpu, wake_flags);\nout:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn success;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
  },
  {
    "function_name": "try_to_wake_up_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "2075-2114",
    "snippet": "static void try_to_wake_up_local(struct task_struct *p, struct rq_flags *rf)\n{\n\tstruct rq *rq = task_rq(p);\n\n\tif (WARN_ON_ONCE(rq != this_rq()) ||\n\t    WARN_ON_ONCE(p == current))\n\t\treturn;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (!raw_spin_trylock(&p->pi_lock)) {\n\t\t/*\n\t\t * This is OK, because current is on_cpu, which avoids it being\n\t\t * picked for load-balance and preemption/IRQs are still\n\t\t * disabled avoiding further scheduler activity on it and we've\n\t\t * not yet picked a replacement task.\n\t\t */\n\t\trq_unlock(rq, rf);\n\t\traw_spin_lock(&p->pi_lock);\n\t\trq_relock(rq, rf);\n\t}\n\n\tif (!(p->state & TASK_NORMAL))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\tif (!task_on_rq_queued(p)) {\n\t\tif (p->in_iowait) {\n\t\t\tdelayacct_blkio_end(p);\n\t\t\tatomic_dec(&rq->nr_iowait);\n\t\t}\n\t\tttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK);\n\t}\n\n\tttwu_do_wakeup(rq, p, 0, rf);\n\tttwu_stat(p, smp_processor_id(), 0);\nout:\n\traw_spin_unlock(&p->pi_lock);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&p->pi_lock"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttwu_stat",
          "args": [
            "p",
            "smp_processor_id()",
            "0"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1602-1639",
          "snippet": "static void\nttwu_stat(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\trq = this_rq();\n\n#ifdef CONFIG_SMP\n\tif (cpu == rq->cpu) {\n\t\t__schedstat_inc(rq->ttwu_local);\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_local);\n\t} else {\n\t\tstruct sched_domain *sd;\n\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_remote);\n\t\trcu_read_lock();\n\t\tfor_each_domain(rq->cpu, sd) {\n\t\t\tif (cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\t\t\t__schedstat_inc(sd->ttwu_wake_remote);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (wake_flags & WF_MIGRATED)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_migrate);\n#endif /* CONFIG_SMP */\n\n\t__schedstat_inc(rq->ttwu_count);\n\t__schedstat_inc(p->se.statistics.nr_wakeups);\n\n\tif (wake_flags & WF_SYNC)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_sync);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void\nttwu_stat(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\trq = this_rq();\n\n#ifdef CONFIG_SMP\n\tif (cpu == rq->cpu) {\n\t\t__schedstat_inc(rq->ttwu_local);\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_local);\n\t} else {\n\t\tstruct sched_domain *sd;\n\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_remote);\n\t\trcu_read_lock();\n\t\tfor_each_domain(rq->cpu, sd) {\n\t\t\tif (cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\t\t\t__schedstat_inc(sd->ttwu_wake_remote);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (wake_flags & WF_MIGRATED)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_migrate);\n#endif /* CONFIG_SMP */\n\n\t__schedstat_inc(rq->ttwu_count);\n\t__schedstat_inc(p->se.statistics.nr_wakeups);\n\n\tif (wake_flags & WF_SYNC)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_sync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttwu_do_wakeup",
          "args": [
            "rq",
            "p",
            "0",
            "rf"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_do_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1654-1684",
          "snippet": "static void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t\t   struct rq_flags *rf)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Our task @p is fully woken up and running; so its safe to\n\t\t * drop the rq->lock, hereafter rq is only used for statistics.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\n\t\tupdate_avg(&rq->avg_idle, delta);\n\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t\t   struct rq_flags *rf)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Our task @p is fully woken up and running; so its safe to\n\t\t * drop the rq->lock, hereafter rq is only used for statistics.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\n\t\tupdate_avg(&rq->avg_idle, delta);\n\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttwu_activate",
          "args": [
            "rq",
            "p",
            "ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1641-1649",
          "snippet": "static inline void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags)\n{\n\tactivate_task(rq, p, en_flags);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\n\t/* If a worker is waking up, notify the workqueue: */\n\tif (p->flags & PF_WQ_WORKER)\n\t\twq_worker_waking_up(p, cpu_of(rq));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags)\n{\n\tactivate_task(rq, p, en_flags);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\n\t/* If a worker is waking up, notify the workqueue: */\n\tif (p->flags & PF_WQ_WORKER)\n\t\twq_worker_waking_up(p, cpu_of(rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&rq->nr_iowait"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayacct_blkio_end",
          "args": [
            "p"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "__delayacct_blkio_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/delayacct.c",
          "lines": "77-92",
          "snippet": "void __delayacct_blkio_end(struct task_struct *p)\n{\n\tstruct task_delay_info *delays = p->delays;\n\tu64 *total;\n\tu32 *count;\n\n\tif (p->delays->flags & DELAYACCT_PF_SWAPIN) {\n\t\ttotal = &delays->swapin_delay;\n\t\tcount = &delays->swapin_count;\n\t} else {\n\t\ttotal = &delays->blkio_delay;\n\t\tcount = &delays->blkio_count;\n\t}\n\n\tdelayacct_end(&delays->lock, &delays->blkio_start, total, count);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/time.h>",
            "#include <linux/taskstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/delayacct.h>\n#include <linux/sysctl.h>\n#include <linux/time.h>\n#include <linux/taskstats.h>\n#include <linux/slab.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n\nvoid __delayacct_blkio_end(struct task_struct *p)\n{\n\tstruct task_delay_info *delays = p->delays;\n\tu64 *total;\n\tu32 *count;\n\n\tif (p->delays->flags & DELAYACCT_PF_SWAPIN) {\n\t\ttotal = &delays->swapin_delay;\n\t\tcount = &delays->swapin_count;\n\t} else {\n\t\ttotal = &delays->blkio_delay;\n\t\tcount = &delays->blkio_count;\n\t}\n\n\tdelayacct_end(&delays->lock, &delays->blkio_start, total, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_waking",
          "args": [
            "p"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_relock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "rq_relock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1130-1136",
          "snippet": "static inline void\nrq_relock(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock(&rq->lock);\n\trq_repin_lock(rq, rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nrq_relock(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock(&rq->lock);\n\trq_repin_lock(rq, rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&p->pi_lock"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unlock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&p->pi_lock"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "134-137",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rq->lock"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "p == current"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rq != this_rq()"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void try_to_wake_up_local(struct task_struct *p, struct rq_flags *rf)\n{\n\tstruct rq *rq = task_rq(p);\n\n\tif (WARN_ON_ONCE(rq != this_rq()) ||\n\t    WARN_ON_ONCE(p == current))\n\t\treturn;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (!raw_spin_trylock(&p->pi_lock)) {\n\t\t/*\n\t\t * This is OK, because current is on_cpu, which avoids it being\n\t\t * picked for load-balance and preemption/IRQs are still\n\t\t * disabled avoiding further scheduler activity on it and we've\n\t\t * not yet picked a replacement task.\n\t\t */\n\t\trq_unlock(rq, rf);\n\t\traw_spin_lock(&p->pi_lock);\n\t\trq_relock(rq, rf);\n\t}\n\n\tif (!(p->state & TASK_NORMAL))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\tif (!task_on_rq_queued(p)) {\n\t\tif (p->in_iowait) {\n\t\t\tdelayacct_blkio_end(p);\n\t\t\tatomic_dec(&rq->nr_iowait);\n\t\t}\n\t\tttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK);\n\t}\n\n\tttwu_do_wakeup(rq, p, 0, rf);\n\tttwu_stat(p, smp_processor_id(), 0);\nout:\n\traw_spin_unlock(&p->pi_lock);\n}"
  },
  {
    "function_name": "try_to_wake_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1953-2064",
    "snippet": "static int\ntry_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with mb() in\n\t * set_current_state() the waiting thread does.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tsmp_mb__after_spinlock();\n\tif (!(p->state & state))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\t/* We're going to change ->state: */\n\tsuccess = 1;\n\tcpu = task_cpu(p);\n\n\t/*\n\t * Ensure we load p->on_rq _after_ p->state, otherwise it would\n\t * be possible to, falsely, observe p->on_rq == 0 and get stuck\n\t * in smp_cond_load_acquire() below.\n\t *\n\t * sched_ttwu_pending()\t\t\ttry_to_wake_up()\n\t *   STORE p->on_rq = 1\t\t\t  LOAD p->state\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   UNLOCK rq->lock\n\t *\n\t * [task p]\n\t *   STORE p->state = UNINTERRUPTIBLE\t  LOAD p->on_rq\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\tif (p->on_rq && ttwu_remote(p, wake_flags))\n\t\tgoto stat;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Ensure we load p->on_cpu _after_ p->on_rq, otherwise it would be\n\t * possible to, falsely, observe p->on_cpu == 0.\n\t *\n\t * One must be running (->on_cpu == 1) in order to remove oneself\n\t * from the runqueue.\n\t *\n\t * __schedule() (switch to task 'p')\ttry_to_wake_up()\n\t *   STORE p->on_cpu = 1\t\t  LOAD p->on_rq\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (put 'p' to sleep)\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   STORE p->on_rq = 0\t\t\t  LOAD p->on_cpu\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the owning (remote) CPU is still in the middle of schedule() with\n\t * this task as prev, wait until its done referencing the task.\n\t *\n\t * Pairs with the smp_store_release() in finish_task().\n\t *\n\t * This ensures that tasks getting woken will be fully ordered against\n\t * their previous state and preserve Program Order.\n\t */\n\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\tp->sched_contributes_to_load = !!task_contributes_to_load(p);\n\tp->state = TASK_WAKING;\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n\tcpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);\n\tif (task_cpu(p) != cpu) {\n\t\twake_flags |= WF_MIGRATED;\n\t\tpsi_ttwu_dequeue(p);\n\t\tset_task_cpu(p, cpu);\n\t}\n\n#else /* CONFIG_SMP */\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu, wake_flags);\nstat:\n\tttwu_stat(p, cpu, wake_flags);\nout:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn success;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttwu_stat",
          "args": [
            "p",
            "cpu",
            "wake_flags"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1602-1639",
          "snippet": "static void\nttwu_stat(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\trq = this_rq();\n\n#ifdef CONFIG_SMP\n\tif (cpu == rq->cpu) {\n\t\t__schedstat_inc(rq->ttwu_local);\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_local);\n\t} else {\n\t\tstruct sched_domain *sd;\n\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_remote);\n\t\trcu_read_lock();\n\t\tfor_each_domain(rq->cpu, sd) {\n\t\t\tif (cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\t\t\t__schedstat_inc(sd->ttwu_wake_remote);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (wake_flags & WF_MIGRATED)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_migrate);\n#endif /* CONFIG_SMP */\n\n\t__schedstat_inc(rq->ttwu_count);\n\t__schedstat_inc(p->se.statistics.nr_wakeups);\n\n\tif (wake_flags & WF_SYNC)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_sync);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void\nttwu_stat(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\trq = this_rq();\n\n#ifdef CONFIG_SMP\n\tif (cpu == rq->cpu) {\n\t\t__schedstat_inc(rq->ttwu_local);\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_local);\n\t} else {\n\t\tstruct sched_domain *sd;\n\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_remote);\n\t\trcu_read_lock();\n\t\tfor_each_domain(rq->cpu, sd) {\n\t\t\tif (cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\t\t\t__schedstat_inc(sd->ttwu_wake_remote);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (wake_flags & WF_MIGRATED)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_migrate);\n#endif /* CONFIG_SMP */\n\n\t__schedstat_inc(rq->ttwu_count);\n\t__schedstat_inc(p->se.statistics.nr_wakeups);\n\n\tif (wake_flags & WF_SYNC)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_sync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttwu_queue",
          "args": [
            "p",
            "cpu",
            "wake_flags"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1832-1849",
          "snippet": "static void ttwu_queue(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n#if defined(CONFIG_SMP)\n\tif (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {\n\t\tsched_clock_cpu(cpu); /* Sync clocks across CPUs */\n\t\tttwu_queue_remote(p, cpu, wake_flags);\n\t\treturn;\n\t}\n#endif\n\n\trq_lock(rq, &rf);\n\tupdate_rq_clock(rq);\n\tttwu_do_activate(rq, p, wake_flags, &rf);\n\trq_unlock(rq, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void ttwu_queue(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n#if defined(CONFIG_SMP)\n\tif (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {\n\t\tsched_clock_cpu(cpu); /* Sync clocks across CPUs */\n\t\tttwu_queue_remote(p, cpu, wake_flags);\n\t\treturn;\n\t}\n#endif\n\n\trq_lock(rq, &rf);\n\tupdate_rq_clock(rq);\n\tttwu_do_activate(rq, p, wake_flags, &rf);\n\trq_unlock(rq, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&task_rq(p)->nr_iowait"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayacct_blkio_end",
          "args": [
            "p"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "__delayacct_blkio_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/delayacct.c",
          "lines": "77-92",
          "snippet": "void __delayacct_blkio_end(struct task_struct *p)\n{\n\tstruct task_delay_info *delays = p->delays;\n\tu64 *total;\n\tu32 *count;\n\n\tif (p->delays->flags & DELAYACCT_PF_SWAPIN) {\n\t\ttotal = &delays->swapin_delay;\n\t\tcount = &delays->swapin_count;\n\t} else {\n\t\ttotal = &delays->blkio_delay;\n\t\tcount = &delays->blkio_count;\n\t}\n\n\tdelayacct_end(&delays->lock, &delays->blkio_start, total, count);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/time.h>",
            "#include <linux/taskstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/delayacct.h>\n#include <linux/sysctl.h>\n#include <linux/time.h>\n#include <linux/taskstats.h>\n#include <linux/slab.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n\nvoid __delayacct_blkio_end(struct task_struct *p)\n{\n\tstruct task_delay_info *delays = p->delays;\n\tu64 *total;\n\tu32 *count;\n\n\tif (p->delays->flags & DELAYACCT_PF_SWAPIN) {\n\t\ttotal = &delays->swapin_delay;\n\t\tcount = &delays->swapin_count;\n\t} else {\n\t\ttotal = &delays->blkio_delay;\n\t\tcount = &delays->blkio_count;\n\t}\n\n\tdelayacct_end(&delays->lock, &delays->blkio_start, total, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_cpu",
          "args": [
            "p",
            "cpu"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "set_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1132-1182",
          "snippet": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_ttwu_dequeue",
          "args": [
            "p"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "psi_ttwu_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.h",
          "lines": "140-140",
          "snippet": "static inline void psi_ttwu_dequeue(struct task_struct *p) {}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void psi_ttwu_dequeue(struct task_struct *p) {}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_task_rq",
          "args": [
            "p",
            "p->wake_cpu",
            "SD_BALANCE_WAKE",
            "wake_flags"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "select_task_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1530-1554",
          "snippet": "static inline\nint select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tcpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);\n\telse\n\t\tcpu = cpumask_any(&p->cpus_allowed);\n\n\t/*\n\t * In order not to call set_task_cpu() on a blocking task we need\n\t * to rely on ttwu() to place the task on a valid ->cpus_allowed\n\t * CPU.\n\t *\n\t * Since this is common to all placement strategies, this lives here.\n\t *\n\t * [ this allows ->select_task() to simply return task_cpu(p) and\n\t *   not worry about this generic constraint ]\n\t */\n\tif (unlikely(!is_cpu_allowed(p, cpu)))\n\t\tcpu = select_fallback_rq(task_cpu(p), p);\n\n\treturn cpu;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline\nint select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tcpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);\n\telse\n\t\tcpu = cpumask_any(&p->cpus_allowed);\n\n\t/*\n\t * In order not to call set_task_cpu() on a blocking task we need\n\t * to rely on ttwu() to place the task on a valid ->cpus_allowed\n\t * CPU.\n\t *\n\t * Since this is common to all placement strategies, this lives here.\n\t *\n\t * [ this allows ->select_task() to simply return task_cpu(p) and\n\t *   not worry about this generic constraint ]\n\t */\n\tif (unlikely(!is_cpu_allowed(p, cpu)))\n\t\tcpu = select_fallback_rq(task_cpu(p), p);\n\n\treturn cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&task_rq(p)->nr_iowait"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_contributes_to_load",
          "args": [
            "p"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_cond_load_acquire",
          "args": [
            "&p->on_cpu",
            "!VAL"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttwu_remote",
          "args": [
            "p",
            "wake_flags"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1712-1728",
          "snippet": "static int ttwu_remote(struct task_struct *p, int wake_flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint ret = 0;\n\n\trq = __task_rq_lock(p, &rf);\n\tif (task_on_rq_queued(p)) {\n\t\t/* check_preempt_curr() may use rq clock */\n\t\tupdate_rq_clock(rq);\n\t\tttwu_do_wakeup(rq, p, wake_flags, &rf);\n\t\tret = 1;\n\t}\n\t__task_rq_unlock(rq, &rf);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int ttwu_remote(struct task_struct *p, int wake_flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint ret = 0;\n\n\trq = __task_rq_lock(p, &rf);\n\tif (task_on_rq_queued(p)) {\n\t\t/* check_preempt_curr() may use rq clock */\n\t\tupdate_rq_clock(rq);\n\t\tttwu_do_wakeup(rq, p, wake_flags, &rf);\n\t\tret = 1;\n\t}\n\t__task_rq_unlock(rq, &rf);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_waking",
          "args": [
            "p"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&p->pi_lock",
            "flags"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int\ntry_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with mb() in\n\t * set_current_state() the waiting thread does.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tsmp_mb__after_spinlock();\n\tif (!(p->state & state))\n\t\tgoto out;\n\n\ttrace_sched_waking(p);\n\n\t/* We're going to change ->state: */\n\tsuccess = 1;\n\tcpu = task_cpu(p);\n\n\t/*\n\t * Ensure we load p->on_rq _after_ p->state, otherwise it would\n\t * be possible to, falsely, observe p->on_rq == 0 and get stuck\n\t * in smp_cond_load_acquire() below.\n\t *\n\t * sched_ttwu_pending()\t\t\ttry_to_wake_up()\n\t *   STORE p->on_rq = 1\t\t\t  LOAD p->state\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   UNLOCK rq->lock\n\t *\n\t * [task p]\n\t *   STORE p->state = UNINTERRUPTIBLE\t  LOAD p->on_rq\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\tif (p->on_rq && ttwu_remote(p, wake_flags))\n\t\tgoto stat;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Ensure we load p->on_cpu _after_ p->on_rq, otherwise it would be\n\t * possible to, falsely, observe p->on_cpu == 0.\n\t *\n\t * One must be running (->on_cpu == 1) in order to remove oneself\n\t * from the runqueue.\n\t *\n\t * __schedule() (switch to task 'p')\ttry_to_wake_up()\n\t *   STORE p->on_cpu = 1\t\t  LOAD p->on_rq\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (put 'p' to sleep)\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   STORE p->on_rq = 0\t\t\t  LOAD p->on_cpu\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * If the owning (remote) CPU is still in the middle of schedule() with\n\t * this task as prev, wait until its done referencing the task.\n\t *\n\t * Pairs with the smp_store_release() in finish_task().\n\t *\n\t * This ensures that tasks getting woken will be fully ordered against\n\t * their previous state and preserve Program Order.\n\t */\n\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\tp->sched_contributes_to_load = !!task_contributes_to_load(p);\n\tp->state = TASK_WAKING;\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n\tcpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);\n\tif (task_cpu(p) != cpu) {\n\t\twake_flags |= WF_MIGRATED;\n\t\tpsi_ttwu_dequeue(p);\n\t\tset_task_cpu(p, cpu);\n\t}\n\n#else /* CONFIG_SMP */\n\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu, wake_flags);\nstat:\n\tttwu_stat(p, cpu, wake_flags);\nout:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn success;\n}"
  },
  {
    "function_name": "ttwu_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1832-1849",
    "snippet": "static void ttwu_queue(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n#if defined(CONFIG_SMP)\n\tif (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {\n\t\tsched_clock_cpu(cpu); /* Sync clocks across CPUs */\n\t\tttwu_queue_remote(p, cpu, wake_flags);\n\t\treturn;\n\t}\n#endif\n\n\trq_lock(rq, &rf);\n\tupdate_rq_clock(rq);\n\tttwu_do_activate(rq, p, wake_flags, &rf);\n\trq_unlock(rq, &rf);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_unlock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttwu_do_activate",
          "args": [
            "rq",
            "p",
            "wake_flags",
            "&rf"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_do_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1686-1704",
          "snippet": "static void\nttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t struct rq_flags *rf)\n{\n\tint en_flags = ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK;\n\n\tlockdep_assert_held(&rq->lock);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_contributes_to_load)\n\t\trq->nr_uninterruptible--;\n\n\tif (wake_flags & WF_MIGRATED)\n\t\ten_flags |= ENQUEUE_MIGRATED;\n#endif\n\n\tttwu_activate(rq, p, en_flags);\n\tttwu_do_wakeup(rq, p, wake_flags, rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void\nttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t struct rq_flags *rf)\n{\n\tint en_flags = ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK;\n\n\tlockdep_assert_held(&rq->lock);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_contributes_to_load)\n\t\trq->nr_uninterruptible--;\n\n\tif (wake_flags & WF_MIGRATED)\n\t\ten_flags |= ENQUEUE_MIGRATED;\n#endif\n\n\tttwu_activate(rq, p, en_flags);\n\tttwu_do_wakeup(rq, p, wake_flags, rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttwu_queue_remote",
          "args": [
            "p",
            "cpu",
            "wake_flags"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_queue_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1788-1800",
          "snippet": "static void ttwu_queue_remote(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tp->sched_remote_wakeup = !!(wake_flags & WF_MIGRATED);\n\n\tif (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) {\n\t\tif (!set_nr_if_polling(rq->idle))\n\t\t\tsmp_send_reschedule(cpu);\n\t\telse\n\t\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void ttwu_queue_remote(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tp->sched_remote_wakeup = !!(wake_flags & WF_MIGRATED);\n\n\tif (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) {\n\t\tif (!set_nr_if_polling(rq->idle))\n\t\t\tsmp_send_reschedule(cpu);\n\t\telse\n\t\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_cpu",
          "args": [
            "cpu"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "460-466",
          "snippet": "u64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nu64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_share_cache",
          "args": [
            "smp_processor_id()",
            "cpu"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_share_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1826-1829",
          "snippet": "bool cpus_share_cache(int this_cpu, int that_cpu)\n{\n\treturn per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nbool cpus_share_cache(int this_cpu, int that_cpu)\n{\n\treturn per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_feat",
          "args": [
            "TTWU_QUEUE"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "sched_feat_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "104-127",
          "snippet": "static int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const sched_feat_names[] = {\n#include \"features.h\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic const char * const sched_feat_names[] = {\n#include \"features.h\"\n};\n\nstatic int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void ttwu_queue(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n#if defined(CONFIG_SMP)\n\tif (sched_feat(TTWU_QUEUE) && !cpus_share_cache(smp_processor_id(), cpu)) {\n\t\tsched_clock_cpu(cpu); /* Sync clocks across CPUs */\n\t\tttwu_queue_remote(p, cpu, wake_flags);\n\t\treturn;\n\t}\n#endif\n\n\trq_lock(rq, &rf);\n\tupdate_rq_clock(rq);\n\tttwu_do_activate(rq, p, wake_flags, &rf);\n\trq_unlock(rq, &rf);\n}"
  },
  {
    "function_name": "cpus_share_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1826-1829",
    "snippet": "bool cpus_share_cache(int this_cpu, int that_cpu)\n{\n\treturn per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "sd_llc_id",
            "that_cpu"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nbool cpus_share_cache(int this_cpu, int that_cpu)\n{\n\treturn per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu);\n}"
  },
  {
    "function_name": "wake_up_if_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1802-1824",
    "snippet": "void wake_up_if_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trcu_read_lock();\n\n\tif (!is_idle_task(rcu_dereference(rq->curr)))\n\t\tgoto out;\n\n\tif (set_nr_if_polling(rq->idle)) {\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t} else {\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (is_idle_task(rq->curr))\n\t\t\tsmp_send_reschedule(cpu);\n\t\t/* Else CPU is not idle, do nothing here: */\n\t\trq_unlock_irqrestore(rq, &rf);\n\t}\n\nout:\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unlock_irqrestore",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1138-1144",
          "snippet": "static inline void\nrq_unlock_irqrestore(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irqrestore(&rq->lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nrq_unlock_irqrestore(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irqrestore(&rq->lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_send_reschedule",
          "args": [
            "cpu"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "rq->curr"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_lock_irqsave",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "rq_lock_irqsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1106-1112",
          "snippet": "static inline void\nrq_lock_irqsave(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irqsave(&rq->lock, rf->flags);\n\trq_pin_lock(rq, rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nrq_lock_irqsave(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irqsave(&rq->lock, rf->flags);\n\trq_pin_lock(rq, rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_wake_idle_without_ipi",
          "args": [
            "cpu"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nr_if_polling",
          "args": [
            "rq->idle"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "set_nr_if_polling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "392-395",
          "snippet": "static bool set_nr_if_polling(struct task_struct *p)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool set_nr_if_polling(struct task_struct *p)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "rcu_dereference(rq->curr)"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "rq->curr"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid wake_up_if_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trcu_read_lock();\n\n\tif (!is_idle_task(rcu_dereference(rq->curr)))\n\t\tgoto out;\n\n\tif (set_nr_if_polling(rq->idle)) {\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t} else {\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (is_idle_task(rq->curr))\n\t\t\tsmp_send_reschedule(cpu);\n\t\t/* Else CPU is not idle, do nothing here: */\n\t\trq_unlock_irqrestore(rq, &rf);\n\t}\n\nout:\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "ttwu_queue_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1788-1800",
    "snippet": "static void ttwu_queue_remote(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tp->sched_remote_wakeup = !!(wake_flags & WF_MIGRATED);\n\n\tif (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) {\n\t\tif (!set_nr_if_polling(rq->idle))\n\t\t\tsmp_send_reschedule(cpu);\n\t\telse\n\t\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_sched_wake_idle_without_ipi",
          "args": [
            "cpu"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_send_reschedule",
          "args": [
            "cpu"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nr_if_polling",
          "args": [
            "rq->idle"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "set_nr_if_polling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "392-395",
          "snippet": "static bool set_nr_if_polling(struct task_struct *p)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool set_nr_if_polling(struct task_struct *p)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&p->wake_entry",
            "&cpu_rq(cpu)->wake_list"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void ttwu_queue_remote(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tp->sched_remote_wakeup = !!(wake_flags & WF_MIGRATED);\n\n\tif (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) {\n\t\tif (!set_nr_if_polling(rq->idle))\n\t\t\tsmp_send_reschedule(cpu);\n\t\telse\n\t\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t}\n}"
  },
  {
    "function_name": "scheduler_ipi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1750-1786",
    "snippet": "void scheduler_ipi(void)\n{\n\t/*\n\t * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting\n\t * TIF_NEED_RESCHED remotely (for the first time) will also send\n\t * this IPI.\n\t */\n\tpreempt_fold_need_resched();\n\n\tif (llist_empty(&this_rq()->wake_list) && !got_nohz_idle_kick())\n\t\treturn;\n\n\t/*\n\t * Not all reschedule IPI handlers call irq_enter/irq_exit, since\n\t * traditionally all their work was done from the interrupt return\n\t * path. Now that we actually do some work, we need to make sure\n\t * we do call them.\n\t *\n\t * Some archs already do call them, luckily irq_enter/exit nest\n\t * properly.\n\t *\n\t * Arguably we should visit all archs and update all handlers,\n\t * however a fair share of IPIs are still resched only so this would\n\t * somewhat pessimize the simple resched case.\n\t */\n\tirq_enter();\n\tsched_ttwu_pending();\n\n\t/*\n\t * Check if someone kicked us for doing the nohz idle load balance.\n\t */\n\tif (unlikely(got_nohz_idle_kick())) {\n\t\tthis_rq()->idle_balance = 1;\n\t\traise_softirq_irqoff(SCHED_SOFTIRQ);\n\t}\n\tirq_exit();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_exit",
          "args": [],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "irq_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "403-418",
          "snippet": "void irq_exit(void)\n{\n#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED\n\tlocal_irq_disable();\n#else\n\tlockdep_assert_irqs_disabled();\n#endif\n\taccount_irq_exit_time(current);\n\tpreempt_count_sub(HARDIRQ_OFFSET);\n\tif (!in_interrupt() && local_softirq_pending())\n\t\tinvoke_softirq();\n\n\ttick_irq_exit();\n\trcu_irq_exit();\n\ttrace_hardirq_exit(); /* must be last! */\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid irq_exit(void)\n{\n#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED\n\tlocal_irq_disable();\n#else\n\tlockdep_assert_irqs_disabled();\n#endif\n\taccount_irq_exit_time(current);\n\tpreempt_count_sub(HARDIRQ_OFFSET);\n\tif (!in_interrupt() && local_softirq_pending())\n\t\tinvoke_softirq();\n\n\ttick_irq_exit();\n\trcu_irq_exit();\n\ttrace_hardirq_exit(); /* must be last! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "raise_softirq_irqoff",
          "args": [
            "SCHED_SOFTIRQ"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "449-453",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "got_nohz_idle_kick()"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "got_nohz_idle_kick",
          "args": [],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "got_nohz_idle_kick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "599-602",
          "snippet": "static inline bool got_nohz_idle_kick(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic inline bool got_nohz_idle_kick(void)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_ttwu_pending",
          "args": [],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "sched_ttwu_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1731-1748",
          "snippet": "void sched_ttwu_pending(void)\n{\n\tstruct rq *rq = this_rq();\n\tstruct llist_node *llist = llist_del_all(&rq->wake_list);\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry)\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\n\trq_unlock_irqrestore(rq, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_ttwu_pending(void)\n{\n\tstruct rq *rq = this_rq();\n\tstruct llist_node *llist = llist_del_all(&rq->wake_list);\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry)\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\n\trq_unlock_irqrestore(rq, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_enter",
          "args": [],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "irq_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "345-359",
          "snippet": "void irq_enter(void)\n{\n\trcu_irq_enter();\n\tif (is_idle_task(current) && !in_interrupt()) {\n\t\t/*\n\t\t * Prevent raise_softirq from needlessly waking up ksoftirqd\n\t\t * here, as softirq will be serviced on return from interrupt.\n\t\t */\n\t\tlocal_bh_disable();\n\t\ttick_irq_enter();\n\t\t_local_bh_enable();\n\t}\n\n\t__irq_enter();\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid irq_enter(void)\n{\n\trcu_irq_enter();\n\tif (is_idle_task(current) && !in_interrupt()) {\n\t\t/*\n\t\t * Prevent raise_softirq from needlessly waking up ksoftirqd\n\t\t * here, as softirq will be serviced on return from interrupt.\n\t\t */\n\t\tlocal_bh_disable();\n\t\ttick_irq_enter();\n\t\t_local_bh_enable();\n\t}\n\n\t__irq_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "&this_rq()->wake_list"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_fold_need_resched",
          "args": [],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid scheduler_ipi(void)\n{\n\t/*\n\t * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting\n\t * TIF_NEED_RESCHED remotely (for the first time) will also send\n\t * this IPI.\n\t */\n\tpreempt_fold_need_resched();\n\n\tif (llist_empty(&this_rq()->wake_list) && !got_nohz_idle_kick())\n\t\treturn;\n\n\t/*\n\t * Not all reschedule IPI handlers call irq_enter/irq_exit, since\n\t * traditionally all their work was done from the interrupt return\n\t * path. Now that we actually do some work, we need to make sure\n\t * we do call them.\n\t *\n\t * Some archs already do call them, luckily irq_enter/exit nest\n\t * properly.\n\t *\n\t * Arguably we should visit all archs and update all handlers,\n\t * however a fair share of IPIs are still resched only so this would\n\t * somewhat pessimize the simple resched case.\n\t */\n\tirq_enter();\n\tsched_ttwu_pending();\n\n\t/*\n\t * Check if someone kicked us for doing the nohz idle load balance.\n\t */\n\tif (unlikely(got_nohz_idle_kick())) {\n\t\tthis_rq()->idle_balance = 1;\n\t\traise_softirq_irqoff(SCHED_SOFTIRQ);\n\t}\n\tirq_exit();\n}"
  },
  {
    "function_name": "sched_ttwu_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1731-1748",
    "snippet": "void sched_ttwu_pending(void)\n{\n\tstruct rq *rq = this_rq();\n\tstruct llist_node *llist = llist_del_all(&rq->wake_list);\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry)\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\n\trq_unlock_irqrestore(rq, &rf);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_unlock_irqrestore",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1138-1144",
          "snippet": "static inline void\nrq_unlock_irqrestore(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irqrestore(&rq->lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nrq_unlock_irqrestore(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irqrestore(&rq->lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttwu_do_activate",
          "args": [
            "rq",
            "p",
            "p->sched_remote_wakeup ? WF_MIGRATED : 0",
            "&rf"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_do_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1686-1704",
          "snippet": "static void\nttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t struct rq_flags *rf)\n{\n\tint en_flags = ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK;\n\n\tlockdep_assert_held(&rq->lock);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_contributes_to_load)\n\t\trq->nr_uninterruptible--;\n\n\tif (wake_flags & WF_MIGRATED)\n\t\ten_flags |= ENQUEUE_MIGRATED;\n#endif\n\n\tttwu_activate(rq, p, en_flags);\n\tttwu_do_wakeup(rq, p, wake_flags, rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void\nttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t struct rq_flags *rf)\n{\n\tint en_flags = ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK;\n\n\tlockdep_assert_held(&rq->lock);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_contributes_to_load)\n\t\trq->nr_uninterruptible--;\n\n\tif (wake_flags & WF_MIGRATED)\n\t\ten_flags |= ENQUEUE_MIGRATED;\n#endif\n\n\tttwu_activate(rq, p, en_flags);\n\tttwu_do_wakeup(rq, p, wake_flags, rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry_safe",
          "args": [
            "p",
            "t",
            "llist",
            "wake_entry"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_lock_irqsave",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "rq_lock_irqsave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1106-1112",
          "snippet": "static inline void\nrq_lock_irqsave(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irqsave(&rq->lock, rf->flags);\n\trq_pin_lock(rq, rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nrq_lock_irqsave(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irqsave(&rq->lock, rf->flags);\n\trq_pin_lock(rq, rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "&rq->wake_list"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_ttwu_pending(void)\n{\n\tstruct rq *rq = this_rq();\n\tstruct llist_node *llist = llist_del_all(&rq->wake_list);\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry)\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\n\trq_unlock_irqrestore(rq, &rf);\n}"
  },
  {
    "function_name": "ttwu_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1712-1728",
    "snippet": "static int ttwu_remote(struct task_struct *p, int wake_flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint ret = 0;\n\n\trq = __task_rq_lock(p, &rf);\n\tif (task_on_rq_queued(p)) {\n\t\t/* check_preempt_curr() may use rq clock */\n\t\tupdate_rq_clock(rq);\n\t\tttwu_do_wakeup(rq, p, wake_flags, &rf);\n\t\tret = 1;\n\t}\n\t__task_rq_unlock(rq, &rf);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__task_rq_unlock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "__task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1089-1094",
          "snippet": "static inline void __task_rq_unlock(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void __task_rq_unlock(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttwu_do_wakeup",
          "args": [
            "rq",
            "p",
            "wake_flags",
            "&rf"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_do_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1654-1684",
          "snippet": "static void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t\t   struct rq_flags *rf)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Our task @p is fully woken up and running; so its safe to\n\t\t * drop the rq->lock, hereafter rq is only used for statistics.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\n\t\tupdate_avg(&rq->avg_idle, delta);\n\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t\t   struct rq_flags *rf)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Our task @p is fully woken up and running; so its safe to\n\t\t * drop the rq->lock, hereafter rq is only used for statistics.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\n\t\tupdate_avg(&rq->avg_idle, delta);\n\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "__task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "66-85",
          "snippet": "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int ttwu_remote(struct task_struct *p, int wake_flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint ret = 0;\n\n\trq = __task_rq_lock(p, &rf);\n\tif (task_on_rq_queued(p)) {\n\t\t/* check_preempt_curr() may use rq clock */\n\t\tupdate_rq_clock(rq);\n\t\tttwu_do_wakeup(rq, p, wake_flags, &rf);\n\t\tret = 1;\n\t}\n\t__task_rq_unlock(rq, &rf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ttwu_do_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1686-1704",
    "snippet": "static void\nttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t struct rq_flags *rf)\n{\n\tint en_flags = ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK;\n\n\tlockdep_assert_held(&rq->lock);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_contributes_to_load)\n\t\trq->nr_uninterruptible--;\n\n\tif (wake_flags & WF_MIGRATED)\n\t\ten_flags |= ENQUEUE_MIGRATED;\n#endif\n\n\tttwu_activate(rq, p, en_flags);\n\tttwu_do_wakeup(rq, p, wake_flags, rf);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ttwu_do_wakeup",
          "args": [
            "rq",
            "p",
            "wake_flags",
            "rf"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_do_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1654-1684",
          "snippet": "static void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t\t   struct rq_flags *rf)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Our task @p is fully woken up and running; so its safe to\n\t\t * drop the rq->lock, hereafter rq is only used for statistics.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\n\t\tupdate_avg(&rq->avg_idle, delta);\n\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t\t   struct rq_flags *rf)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Our task @p is fully woken up and running; so its safe to\n\t\t * drop the rq->lock, hereafter rq is only used for statistics.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\n\t\tupdate_avg(&rq->avg_idle, delta);\n\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttwu_activate",
          "args": [
            "rq",
            "p",
            "en_flags"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "ttwu_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1641-1649",
          "snippet": "static inline void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags)\n{\n\tactivate_task(rq, p, en_flags);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\n\t/* If a worker is waking up, notify the workqueue: */\n\tif (p->flags & PF_WQ_WORKER)\n\t\twq_worker_waking_up(p, cpu_of(rq));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags)\n{\n\tactivate_task(rq, p, en_flags);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\n\t/* If a worker is waking up, notify the workqueue: */\n\tif (p->flags & PF_WQ_WORKER)\n\t\twq_worker_waking_up(p, cpu_of(rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rq->lock"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void\nttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t struct rq_flags *rf)\n{\n\tint en_flags = ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK;\n\n\tlockdep_assert_held(&rq->lock);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_contributes_to_load)\n\t\trq->nr_uninterruptible--;\n\n\tif (wake_flags & WF_MIGRATED)\n\t\ten_flags |= ENQUEUE_MIGRATED;\n#endif\n\n\tttwu_activate(rq, p, en_flags);\n\tttwu_do_wakeup(rq, p, wake_flags, rf);\n}"
  },
  {
    "function_name": "ttwu_do_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1654-1684",
    "snippet": "static void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t\t   struct rq_flags *rf)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Our task @p is fully woken up and running; so its safe to\n\t\t * drop the rq->lock, hereafter rq is only used for statistics.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\n\t\tupdate_avg(&rq->avg_idle, delta);\n\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_avg",
          "args": [
            "&rq->avg_idle",
            "delta"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "update_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1556-1560",
          "snippet": "static void update_avg(u64 *avg, u64 sample)\n{\n\ts64 diff = sample - *avg;\n\t*avg += diff >> 3;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void update_avg(u64 *avg, u64 sample)\n{\n\ts64 diff = sample - *avg;\n\t*avg += diff >> 3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_repin_lock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "rq_repin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1070-1080",
          "snippet": "static inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(&rq->lock, rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(&rq->lock, rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->sched_class->task_woken",
          "args": [
            "rq",
            "p"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_unpin_lock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unpin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1060-1068",
          "snippet": "static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_UPDATED\t\t0x04",
            "#define RQCF_ACT_SKIP\t\t0x02"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_UPDATED\t\t0x04\n#define RQCF_ACT_SKIP\t\t0x02\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_wakeup",
          "args": [
            "p"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_preempt_curr",
          "args": [
            "rq",
            "p",
            "wake_flags"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "841-864",
          "snippet": "void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t\t   struct rq_flags *rf)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Our task @p is fully woken up and running; so its safe to\n\t\t * drop the rq->lock, hereafter rq is only used for statistics.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\n\t\tupdate_avg(&rq->avg_idle, delta);\n\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}"
  },
  {
    "function_name": "ttwu_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1641-1649",
    "snippet": "static inline void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags)\n{\n\tactivate_task(rq, p, en_flags);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\n\t/* If a worker is waking up, notify the workqueue: */\n\tif (p->flags & PF_WQ_WORKER)\n\t\twq_worker_waking_up(p, cpu_of(rq));\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_worker_waking_up",
          "args": [
            "p",
            "cpu_of(rq)"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "wq_worker_waking_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "852-860",
          "snippet": "void wq_worker_waking_up(struct task_struct *task, int cpu)\n{\n\tstruct worker *worker = kthread_data(task);\n\n\tif (!(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tWARN_ON_ONCE(worker->pool->cpu != cpu);\n\t\tatomic_inc(&worker->pool->nr_running);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid wq_worker_waking_up(struct task_struct *task, int cpu)\n{\n\tstruct worker *worker = kthread_data(task);\n\n\tif (!(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tWARN_ON_ONCE(worker->pool->cpu != cpu);\n\t\tatomic_inc(&worker->pool->nr_running);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "928-935",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "activate_task",
          "args": [
            "rq",
            "p",
            "en_flags"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "754-760",
          "snippet": "void deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void ttwu_activate(struct rq *rq, struct task_struct *p, int en_flags)\n{\n\tactivate_task(rq, p, en_flags);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\n\t/* If a worker is waking up, notify the workqueue: */\n\tif (p->flags & PF_WQ_WORKER)\n\t\twq_worker_waking_up(p, cpu_of(rq));\n}"
  },
  {
    "function_name": "ttwu_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1602-1639",
    "snippet": "static void\nttwu_stat(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\trq = this_rq();\n\n#ifdef CONFIG_SMP\n\tif (cpu == rq->cpu) {\n\t\t__schedstat_inc(rq->ttwu_local);\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_local);\n\t} else {\n\t\tstruct sched_domain *sd;\n\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_remote);\n\t\trcu_read_lock();\n\t\tfor_each_domain(rq->cpu, sd) {\n\t\t\tif (cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\t\t\t__schedstat_inc(sd->ttwu_wake_remote);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (wake_flags & WF_MIGRATED)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_migrate);\n#endif /* CONFIG_SMP */\n\n\t__schedstat_inc(rq->ttwu_count);\n\t__schedstat_inc(p->se.statistics.nr_wakeups);\n\n\tif (wake_flags & WF_SYNC)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_sync);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__schedstat_inc",
          "args": [
            "p->se.statistics.nr_wakeups_sync"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_inc",
          "args": [
            "p->se.statistics.nr_wakeups"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_inc",
          "args": [
            "rq->ttwu_count"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_inc",
          "args": [
            "p->se.statistics.nr_wakeups_migrate"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__schedstat_inc",
          "args": [
            "sd->ttwu_wake_remote"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "sched_domain_span(sd)"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_domain",
          "args": [
            "rq->cpu",
            "sd"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__schedstat_inc",
          "args": [
            "p->se.statistics.nr_wakeups_remote"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_inc",
          "args": [
            "p->se.statistics.nr_wakeups_local"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_inc",
          "args": [
            "rq->ttwu_local"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2231-2237",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void\nttwu_stat(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\trq = this_rq();\n\n#ifdef CONFIG_SMP\n\tif (cpu == rq->cpu) {\n\t\t__schedstat_inc(rq->ttwu_local);\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_local);\n\t} else {\n\t\tstruct sched_domain *sd;\n\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_remote);\n\t\trcu_read_lock();\n\t\tfor_each_domain(rq->cpu, sd) {\n\t\t\tif (cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\t\t\t__schedstat_inc(sd->ttwu_wake_remote);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (wake_flags & WF_MIGRATED)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_migrate);\n#endif /* CONFIG_SMP */\n\n\t__schedstat_inc(rq->ttwu_count);\n\t__schedstat_inc(p->se.statistics.nr_wakeups);\n\n\tif (wake_flags & WF_SYNC)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_sync);\n}"
  },
  {
    "function_name": "__set_cpus_allowed_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1594-1598",
    "snippet": "static inline int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t\t const struct cpumask *new_mask, bool check)\n{\n\treturn set_cpus_allowed_ptr(p, new_mask);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "p",
            "new_mask"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1126-1129",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t\t const struct cpumask *new_mask, bool check)\n{\n\treturn set_cpus_allowed_ptr(p, new_mask);\n}"
  },
  {
    "function_name": "sched_set_stop_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1562-1590",
    "snippet": "void sched_set_stop_task(int cpu, struct task_struct *stop)\n{\n\tstruct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };\n\tstruct task_struct *old_stop = cpu_rq(cpu)->stop;\n\n\tif (stop) {\n\t\t/*\n\t\t * Make it appear like a SCHED_FIFO task, its something\n\t\t * userspace knows about and won't get confused about.\n\t\t *\n\t\t * Also, it will make PI more or less work without too\n\t\t * much confusion -- but then, stop work should not\n\t\t * rely on PI working anyway.\n\t\t */\n\t\tsched_setscheduler_nocheck(stop, SCHED_FIFO, &param);\n\n\t\tstop->sched_class = &stop_sched_class;\n\t}\n\n\tcpu_rq(cpu)->stop = stop;\n\n\tif (old_stop) {\n\t\t/*\n\t\t * Reset it back to a normal scheduling class so that\n\t\t * it can die in pieces.\n\t\t */\n\t\told_stop->sched_class = &rt_sched_class;\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_setscheduler_nocheck",
          "args": [
            "stop",
            "SCHED_FIFO",
            "&param"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setscheduler_nocheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4416-4420",
          "snippet": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_set_stop_task(int cpu, struct task_struct *stop)\n{\n\tstruct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };\n\tstruct task_struct *old_stop = cpu_rq(cpu)->stop;\n\n\tif (stop) {\n\t\t/*\n\t\t * Make it appear like a SCHED_FIFO task, its something\n\t\t * userspace knows about and won't get confused about.\n\t\t *\n\t\t * Also, it will make PI more or less work without too\n\t\t * much confusion -- but then, stop work should not\n\t\t * rely on PI working anyway.\n\t\t */\n\t\tsched_setscheduler_nocheck(stop, SCHED_FIFO, &param);\n\n\t\tstop->sched_class = &stop_sched_class;\n\t}\n\n\tcpu_rq(cpu)->stop = stop;\n\n\tif (old_stop) {\n\t\t/*\n\t\t * Reset it back to a normal scheduling class so that\n\t\t * it can die in pieces.\n\t\t */\n\t\told_stop->sched_class = &rt_sched_class;\n\t}\n}"
  },
  {
    "function_name": "update_avg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1556-1560",
    "snippet": "static void update_avg(u64 *avg, u64 sample)\n{\n\ts64 diff = sample - *avg;\n\t*avg += diff >> 3;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void update_avg(u64 *avg, u64 sample)\n{\n\ts64 diff = sample - *avg;\n\t*avg += diff >> 3;\n}"
  },
  {
    "function_name": "select_task_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1530-1554",
    "snippet": "static inline\nint select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tcpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);\n\telse\n\t\tcpu = cpumask_any(&p->cpus_allowed);\n\n\t/*\n\t * In order not to call set_task_cpu() on a blocking task we need\n\t * to rely on ttwu() to place the task on a valid ->cpus_allowed\n\t * CPU.\n\t *\n\t * Since this is common to all placement strategies, this lives here.\n\t *\n\t * [ this allows ->select_task() to simply return task_cpu(p) and\n\t *   not worry about this generic constraint ]\n\t */\n\tif (unlikely(!is_cpu_allowed(p, cpu)))\n\t\tcpu = select_fallback_rq(task_cpu(p), p);\n\n\treturn cpu;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "select_fallback_rq",
          "args": [
            "task_cpu(p)",
            "p"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "select_fallback_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1458-1525",
          "snippet": "static int select_fallback_rq(int cpu, struct task_struct *p)\n{\n\tint nid = cpu_to_node(cpu);\n\tconst struct cpumask *nodemask = NULL;\n\tenum { cpuset, possible, fail } state = cpuset;\n\tint dest_cpu;\n\n\t/*\n\t * If the node that the CPU is on has been offlined, cpu_to_node()\n\t * will return -1. There is no CPU on the node, and we should\n\t * select the CPU on the other node.\n\t */\n\tif (nid != -1) {\n\t\tnodemask = cpumask_of_node(nid);\n\n\t\t/* Look for allowed, online CPU in same node. */\n\t\tfor_each_cpu(dest_cpu, nodemask) {\n\t\t\tif (!cpu_active(dest_cpu))\n\t\t\t\tcontinue;\n\t\t\tif (cpumask_test_cpu(dest_cpu, &p->cpus_allowed))\n\t\t\t\treturn dest_cpu;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t/* Any allowed, online CPU? */\n\t\tfor_each_cpu(dest_cpu, &p->cpus_allowed) {\n\t\t\tif (!is_cpu_allowed(p, dest_cpu))\n\t\t\t\tcontinue;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* No more Mr. Nice Guy. */\n\t\tswitch (state) {\n\t\tcase cpuset:\n\t\t\tif (IS_ENABLED(CONFIG_CPUSETS)) {\n\t\t\t\tcpuset_cpus_allowed_fallback(p);\n\t\t\t\tstate = possible;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall-through */\n\t\tcase possible:\n\t\t\tdo_set_cpus_allowed(p, cpu_possible_mask);\n\t\t\tstate = fail;\n\t\t\tbreak;\n\n\t\tcase fail:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (state != cpuset) {\n\t\t/*\n\t\t * Don't tell them about moving exiting tasks or\n\t\t * kernel threads (both mm NULL), since they never\n\t\t * leave kernel.\n\t\t */\n\t\tif (p->mm && printk_ratelimit()) {\n\t\t\tprintk_deferred(\"process %d (%s) no longer affine to cpu%d\\n\",\n\t\t\t\t\ttask_pid_nr(p), p->comm, cpu);\n\t\t}\n\t}\n\n\treturn dest_cpu;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int select_fallback_rq(int cpu, struct task_struct *p)\n{\n\tint nid = cpu_to_node(cpu);\n\tconst struct cpumask *nodemask = NULL;\n\tenum { cpuset, possible, fail } state = cpuset;\n\tint dest_cpu;\n\n\t/*\n\t * If the node that the CPU is on has been offlined, cpu_to_node()\n\t * will return -1. There is no CPU on the node, and we should\n\t * select the CPU on the other node.\n\t */\n\tif (nid != -1) {\n\t\tnodemask = cpumask_of_node(nid);\n\n\t\t/* Look for allowed, online CPU in same node. */\n\t\tfor_each_cpu(dest_cpu, nodemask) {\n\t\t\tif (!cpu_active(dest_cpu))\n\t\t\t\tcontinue;\n\t\t\tif (cpumask_test_cpu(dest_cpu, &p->cpus_allowed))\n\t\t\t\treturn dest_cpu;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t/* Any allowed, online CPU? */\n\t\tfor_each_cpu(dest_cpu, &p->cpus_allowed) {\n\t\t\tif (!is_cpu_allowed(p, dest_cpu))\n\t\t\t\tcontinue;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* No more Mr. Nice Guy. */\n\t\tswitch (state) {\n\t\tcase cpuset:\n\t\t\tif (IS_ENABLED(CONFIG_CPUSETS)) {\n\t\t\t\tcpuset_cpus_allowed_fallback(p);\n\t\t\t\tstate = possible;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall-through */\n\t\tcase possible:\n\t\t\tdo_set_cpus_allowed(p, cpu_possible_mask);\n\t\t\tstate = fail;\n\t\t\tbreak;\n\n\t\tcase fail:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (state != cpuset) {\n\t\t/*\n\t\t * Don't tell them about moving exiting tasks or\n\t\t * kernel threads (both mm NULL), since they never\n\t\t * leave kernel.\n\t\t */\n\t\tif (p->mm && printk_ratelimit()) {\n\t\t\tprintk_deferred(\"process %d (%s) no longer affine to cpu%d\\n\",\n\t\t\t\t\ttask_pid_nr(p), p->comm, cpu);\n\t\t}\n\t}\n\n\treturn dest_cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!is_cpu_allowed(p, cpu)"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cpu_allowed",
          "args": [
            "p",
            "cpu"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpu_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "883-892",
          "snippet": "static inline bool is_cpu_allowed(struct task_struct *p, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn false;\n\n\tif (is_per_cpu_kthread(p))\n\t\treturn cpu_online(cpu);\n\n\treturn cpu_active(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline bool is_cpu_allowed(struct task_struct *p, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn false;\n\n\tif (is_per_cpu_kthread(p))\n\t\treturn cpu_online(cpu);\n\n\treturn cpu_active(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any",
          "args": [
            "&p->cpus_allowed"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->sched_class->select_task_rq",
          "args": [
            "p",
            "cpu",
            "sd_flags",
            "wake_flags"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "select_task_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1530-1554",
          "snippet": "static inline\nint select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tcpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);\n\telse\n\t\tcpu = cpumask_any(&p->cpus_allowed);\n\n\t/*\n\t * In order not to call set_task_cpu() on a blocking task we need\n\t * to rely on ttwu() to place the task on a valid ->cpus_allowed\n\t * CPU.\n\t *\n\t * Since this is common to all placement strategies, this lives here.\n\t *\n\t * [ this allows ->select_task() to simply return task_cpu(p) and\n\t *   not worry about this generic constraint ]\n\t */\n\tif (unlikely(!is_cpu_allowed(p, cpu)))\n\t\tcpu = select_fallback_rq(task_cpu(p), p);\n\n\treturn cpu;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&p->pi_lock"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline\nint select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tcpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);\n\telse\n\t\tcpu = cpumask_any(&p->cpus_allowed);\n\n\t/*\n\t * In order not to call set_task_cpu() on a blocking task we need\n\t * to rely on ttwu() to place the task on a valid ->cpus_allowed\n\t * CPU.\n\t *\n\t * Since this is common to all placement strategies, this lives here.\n\t *\n\t * [ this allows ->select_task() to simply return task_cpu(p) and\n\t *   not worry about this generic constraint ]\n\t */\n\tif (unlikely(!is_cpu_allowed(p, cpu)))\n\t\tcpu = select_fallback_rq(task_cpu(p), p);\n\n\treturn cpu;\n}"
  },
  {
    "function_name": "select_fallback_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1458-1525",
    "snippet": "static int select_fallback_rq(int cpu, struct task_struct *p)\n{\n\tint nid = cpu_to_node(cpu);\n\tconst struct cpumask *nodemask = NULL;\n\tenum { cpuset, possible, fail } state = cpuset;\n\tint dest_cpu;\n\n\t/*\n\t * If the node that the CPU is on has been offlined, cpu_to_node()\n\t * will return -1. There is no CPU on the node, and we should\n\t * select the CPU on the other node.\n\t */\n\tif (nid != -1) {\n\t\tnodemask = cpumask_of_node(nid);\n\n\t\t/* Look for allowed, online CPU in same node. */\n\t\tfor_each_cpu(dest_cpu, nodemask) {\n\t\t\tif (!cpu_active(dest_cpu))\n\t\t\t\tcontinue;\n\t\t\tif (cpumask_test_cpu(dest_cpu, &p->cpus_allowed))\n\t\t\t\treturn dest_cpu;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t/* Any allowed, online CPU? */\n\t\tfor_each_cpu(dest_cpu, &p->cpus_allowed) {\n\t\t\tif (!is_cpu_allowed(p, dest_cpu))\n\t\t\t\tcontinue;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* No more Mr. Nice Guy. */\n\t\tswitch (state) {\n\t\tcase cpuset:\n\t\t\tif (IS_ENABLED(CONFIG_CPUSETS)) {\n\t\t\t\tcpuset_cpus_allowed_fallback(p);\n\t\t\t\tstate = possible;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall-through */\n\t\tcase possible:\n\t\t\tdo_set_cpus_allowed(p, cpu_possible_mask);\n\t\t\tstate = fail;\n\t\t\tbreak;\n\n\t\tcase fail:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (state != cpuset) {\n\t\t/*\n\t\t * Don't tell them about moving exiting tasks or\n\t\t * kernel threads (both mm NULL), since they never\n\t\t * leave kernel.\n\t\t */\n\t\tif (p->mm && printk_ratelimit()) {\n\t\t\tprintk_deferred(\"process %d (%s) no longer affine to cpu%d\\n\",\n\t\t\t\t\ttask_pid_nr(p), p->comm, cpu);\n\t\t}\n\t}\n\n\treturn dest_cpu;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "\"process %d (%s) no longer affine to cpu%d\\n\"",
            "task_pid_nr(p)",
            "p->comm",
            "cpu"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "p"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_set_cpus_allowed",
          "args": [
            "p",
            "cpu_possible_mask"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "do_set_cpus_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1015-1042",
          "snippet": "void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tstruct rq *rq = task_rq(p);\n\tbool queued, running;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued) {\n\t\t/*\n\t\t * Because __kthread_bind() calls this on blocked tasks without\n\t\t * holding rq->lock.\n\t\t */\n\t\tlockdep_assert_held(&rq->lock);\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\t}\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->sched_class->set_cpus_allowed(p, new_mask);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_curr_task(rq, p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tstruct rq *rq = task_rq(p);\n\tbool queued, running;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued) {\n\t\t/*\n\t\t * Because __kthread_bind() calls this on blocked tasks without\n\t\t * holding rq->lock.\n\t\t */\n\t\tlockdep_assert_held(&rq->lock);\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\t}\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->sched_class->set_cpus_allowed(p, new_mask);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_curr_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_cpus_allowed_fallback",
          "args": [
            "p"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_cpus_allowed_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cpuset.c",
          "lines": "2435-2458",
          "snippet": "void cpuset_cpus_allowed_fallback(struct task_struct *tsk)\n{\n\trcu_read_lock();\n\tdo_set_cpus_allowed(tsk, task_cs(tsk)->effective_cpus);\n\trcu_read_unlock();\n\n\t/*\n\t * We own tsk->cpus_allowed, nobody can change it under us.\n\t *\n\t * But we used cs && cs->cpus_allowed lockless and thus can\n\t * race with cgroup_attach_task() or update_cpumask() and get\n\t * the wrong tsk->cpus_allowed. However, both cases imply the\n\t * subsequent cpuset_change_cpumask()->set_cpus_allowed_ptr()\n\t * which takes task_rq_lock().\n\t *\n\t * If we are called after it dropped the lock we must see all\n\t * changes in tsk_cs()->cpus_allowed. Otherwise we can temporary\n\t * set any mask even if it is not right from task_cs() pov,\n\t * the pending set_cpus_allowed_ptr() will fix things.\n\t *\n\t * select_fallback_rq() will fix things ups and set cpu_possible_mask\n\t * if required.\n\t */\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid cpuset_cpus_allowed_fallback(struct task_struct *tsk)\n{\n\trcu_read_lock();\n\tdo_set_cpus_allowed(tsk, task_cs(tsk)->effective_cpus);\n\trcu_read_unlock();\n\n\t/*\n\t * We own tsk->cpus_allowed, nobody can change it under us.\n\t *\n\t * But we used cs && cs->cpus_allowed lockless and thus can\n\t * race with cgroup_attach_task() or update_cpumask() and get\n\t * the wrong tsk->cpus_allowed. However, both cases imply the\n\t * subsequent cpuset_change_cpumask()->set_cpus_allowed_ptr()\n\t * which takes task_rq_lock().\n\t *\n\t * If we are called after it dropped the lock we must see all\n\t * changes in tsk_cs()->cpus_allowed. Otherwise we can temporary\n\t * set any mask even if it is not right from task_cs() pov,\n\t * the pending set_cpus_allowed_ptr() will fix things.\n\t *\n\t * select_fallback_rq() will fix things ups and set cpu_possible_mask\n\t * if required.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CPUSETS"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cpu_allowed",
          "args": [
            "p",
            "dest_cpu"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpu_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "883-892",
          "snippet": "static inline bool is_cpu_allowed(struct task_struct *p, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn false;\n\n\tif (is_per_cpu_kthread(p))\n\t\treturn cpu_online(cpu);\n\n\treturn cpu_active(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline bool is_cpu_allowed(struct task_struct *p, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn false;\n\n\tif (is_per_cpu_kthread(p))\n\t\treturn cpu_online(cpu);\n\n\treturn cpu_active(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "dest_cpu",
            "&p->cpus_allowed"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "dest_cpu",
            "&p->cpus_allowed"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_active",
          "args": [
            "dest_cpu"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "dest_cpu",
            "nodemask"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "nid"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int select_fallback_rq(int cpu, struct task_struct *p)\n{\n\tint nid = cpu_to_node(cpu);\n\tconst struct cpumask *nodemask = NULL;\n\tenum { cpuset, possible, fail } state = cpuset;\n\tint dest_cpu;\n\n\t/*\n\t * If the node that the CPU is on has been offlined, cpu_to_node()\n\t * will return -1. There is no CPU on the node, and we should\n\t * select the CPU on the other node.\n\t */\n\tif (nid != -1) {\n\t\tnodemask = cpumask_of_node(nid);\n\n\t\t/* Look for allowed, online CPU in same node. */\n\t\tfor_each_cpu(dest_cpu, nodemask) {\n\t\t\tif (!cpu_active(dest_cpu))\n\t\t\t\tcontinue;\n\t\t\tif (cpumask_test_cpu(dest_cpu, &p->cpus_allowed))\n\t\t\t\treturn dest_cpu;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t/* Any allowed, online CPU? */\n\t\tfor_each_cpu(dest_cpu, &p->cpus_allowed) {\n\t\t\tif (!is_cpu_allowed(p, dest_cpu))\n\t\t\t\tcontinue;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* No more Mr. Nice Guy. */\n\t\tswitch (state) {\n\t\tcase cpuset:\n\t\t\tif (IS_ENABLED(CONFIG_CPUSETS)) {\n\t\t\t\tcpuset_cpus_allowed_fallback(p);\n\t\t\t\tstate = possible;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall-through */\n\t\tcase possible:\n\t\t\tdo_set_cpus_allowed(p, cpu_possible_mask);\n\t\t\tstate = fail;\n\t\t\tbreak;\n\n\t\tcase fail:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (state != cpuset) {\n\t\t/*\n\t\t * Don't tell them about moving exiting tasks or\n\t\t * kernel threads (both mm NULL), since they never\n\t\t * leave kernel.\n\t\t */\n\t\tif (p->mm && printk_ratelimit()) {\n\t\t\tprintk_deferred(\"process %d (%s) no longer affine to cpu%d\\n\",\n\t\t\t\t\ttask_pid_nr(p), p->comm, cpu);\n\t\t}\n\t}\n\n\treturn dest_cpu;\n}"
  },
  {
    "function_name": "kick_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1424-1433",
    "snippet": "void kick_process(struct task_struct *p)\n{\n\tint cpu;\n\n\tpreempt_disable();\n\tcpu = task_cpu(p);\n\tif ((cpu != smp_processor_id()) && task_curr(p))\n\t\tsmp_send_reschedule(cpu);\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_send_reschedule",
          "args": [
            "cpu"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_curr",
          "args": [
            "p"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "task_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "816-819",
          "snippet": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid kick_process(struct task_struct *p)\n{\n\tint cpu;\n\n\tpreempt_disable();\n\tcpu = task_cpu(p);\n\tif ((cpu != smp_processor_id()) && task_curr(p))\n\t\tsmp_send_reschedule(cpu);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "wait_task_inactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1319-1409",
    "snippet": "unsigned long wait_task_inactive(struct task_struct *p, long match_state)\n{\n\tint running, queued;\n\tstruct rq_flags rf;\n\tunsigned long ncsw;\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\t/*\n\t\t * We do the initial early heuristics without holding\n\t\t * any task-queue locks at all. We'll only try to get\n\t\t * the runqueue lock when things look like they will\n\t\t * work out!\n\t\t */\n\t\trq = task_rq(p);\n\n\t\t/*\n\t\t * If the task is actively running on another CPU\n\t\t * still, just relax and busy-wait without holding\n\t\t * any locks.\n\t\t *\n\t\t * NOTE! Since we don't hold any locks, it's not\n\t\t * even sure that \"rq\" stays as the right runqueue!\n\t\t * But we don't care, since \"task_running()\" will\n\t\t * return false if the runqueue has changed and p\n\t\t * is actually now running somewhere else!\n\t\t */\n\t\twhile (task_running(rq, p)) {\n\t\t\tif (match_state && unlikely(p->state != match_state))\n\t\t\t\treturn 0;\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t/*\n\t\t * Ok, time to look more closely! We need the rq\n\t\t * lock now, to be *sure*. If we're wrong, we'll\n\t\t * just go back and repeat.\n\t\t */\n\t\trq = task_rq_lock(p, &rf);\n\t\ttrace_sched_wait_task(p);\n\t\trunning = task_running(rq, p);\n\t\tqueued = task_on_rq_queued(p);\n\t\tncsw = 0;\n\t\tif (!match_state || p->state == match_state)\n\t\t\tncsw = p->nvcsw | LONG_MIN; /* sets MSB */\n\t\ttask_rq_unlock(rq, p, &rf);\n\n\t\t/*\n\t\t * If it changed from the expected state, bail out now.\n\t\t */\n\t\tif (unlikely(!ncsw))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Was it really running after all now that we\n\t\t * checked with the proper locks actually held?\n\t\t *\n\t\t * Oops. Go back and try again..\n\t\t */\n\t\tif (unlikely(running)) {\n\t\t\tcpu_relax();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * It's not enough that it's not actively running,\n\t\t * it must be off the runqueue _entirely_, and not\n\t\t * preempted!\n\t\t *\n\t\t * So if it was still runnable (but just not actively\n\t\t * running right now), it's preempted, and we should\n\t\t * yield - it could be a while.\n\t\t */\n\t\tif (unlikely(queued)) {\n\t\t\tktime_t to = NSEC_PER_SEC / HZ;\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&to, HRTIMER_MODE_REL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Ahh, all good. It wasn't running, and it wasn't\n\t\t * runnable, which means that it will never become\n\t\t * running in the future either. We're all done!\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn ncsw;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_hrtimeout",
          "args": [
            "&to",
            "HRTIMER_MODE_REL"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_hrtimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "2023-2027",
          "snippet": "int __sched schedule_hrtimeout(ktime_t *expires,\n\t\t\t       const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range(expires, 0, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched schedule_hrtimeout(ktime_t *expires,\n\t\t\t       const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range(expires, 0, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "queued"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "running"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ncsw"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "p"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1526-1533",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_wait_task",
          "args": [
            "p"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->state != match_state"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nunsigned long wait_task_inactive(struct task_struct *p, long match_state)\n{\n\tint running, queued;\n\tstruct rq_flags rf;\n\tunsigned long ncsw;\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\t/*\n\t\t * We do the initial early heuristics without holding\n\t\t * any task-queue locks at all. We'll only try to get\n\t\t * the runqueue lock when things look like they will\n\t\t * work out!\n\t\t */\n\t\trq = task_rq(p);\n\n\t\t/*\n\t\t * If the task is actively running on another CPU\n\t\t * still, just relax and busy-wait without holding\n\t\t * any locks.\n\t\t *\n\t\t * NOTE! Since we don't hold any locks, it's not\n\t\t * even sure that \"rq\" stays as the right runqueue!\n\t\t * But we don't care, since \"task_running()\" will\n\t\t * return false if the runqueue has changed and p\n\t\t * is actually now running somewhere else!\n\t\t */\n\t\twhile (task_running(rq, p)) {\n\t\t\tif (match_state && unlikely(p->state != match_state))\n\t\t\t\treturn 0;\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t/*\n\t\t * Ok, time to look more closely! We need the rq\n\t\t * lock now, to be *sure*. If we're wrong, we'll\n\t\t * just go back and repeat.\n\t\t */\n\t\trq = task_rq_lock(p, &rf);\n\t\ttrace_sched_wait_task(p);\n\t\trunning = task_running(rq, p);\n\t\tqueued = task_on_rq_queued(p);\n\t\tncsw = 0;\n\t\tif (!match_state || p->state == match_state)\n\t\t\tncsw = p->nvcsw | LONG_MIN; /* sets MSB */\n\t\ttask_rq_unlock(rq, p, &rf);\n\n\t\t/*\n\t\t * If it changed from the expected state, bail out now.\n\t\t */\n\t\tif (unlikely(!ncsw))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Was it really running after all now that we\n\t\t * checked with the proper locks actually held?\n\t\t *\n\t\t * Oops. Go back and try again..\n\t\t */\n\t\tif (unlikely(running)) {\n\t\t\tcpu_relax();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * It's not enough that it's not actively running,\n\t\t * it must be off the runqueue _entirely_, and not\n\t\t * preempted!\n\t\t *\n\t\t * So if it was still runnable (but just not actively\n\t\t * running right now), it's preempted, and we should\n\t\t * yield - it could be a while.\n\t\t */\n\t\tif (unlikely(queued)) {\n\t\t\tktime_t to = NSEC_PER_SEC / HZ;\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&to, HRTIMER_MODE_REL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Ahh, all good. It wasn't running, and it wasn't\n\t\t * runnable, which means that it will never become\n\t\t * running in the future either. We're all done!\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn ncsw;\n}"
  },
  {
    "function_name": "migrate_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1266-1300",
    "snippet": "int migrate_swap(struct task_struct *cur, struct task_struct *p,\n\t\tint target_cpu, int curr_cpu)\n{\n\tstruct migration_swap_arg arg;\n\tint ret = -EINVAL;\n\n\targ = (struct migration_swap_arg){\n\t\t.src_task = cur,\n\t\t.src_cpu = curr_cpu,\n\t\t.dst_task = p,\n\t\t.dst_cpu = target_cpu,\n\t};\n\n\tif (arg.src_cpu == arg.dst_cpu)\n\t\tgoto out;\n\n\t/*\n\t * These three tests are all lockless; this is OK since all of them\n\t * will be re-checked with proper locks held further down the line.\n\t */\n\tif (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu))\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(arg.dst_cpu, &arg.src_task->cpus_allowed))\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(arg.src_cpu, &arg.dst_task->cpus_allowed))\n\t\tgoto out;\n\n\ttrace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu);\n\tret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_two_cpus",
          "args": [
            "arg.dst_cpu",
            "arg.src_cpu",
            "migrate_swap_stop",
            "&arg"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "stop_two_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "307-336",
          "snippet": "int stop_two_cpus(unsigned int cpu1, unsigned int cpu2, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work1, work2;\n\tstruct multi_stop_data msdata;\n\n\tmsdata = (struct multi_stop_data){\n\t\t.fn = fn,\n\t\t.data = arg,\n\t\t.num_threads = 2,\n\t\t.active_cpus = cpumask_of(cpu1),\n\t};\n\n\twork1 = work2 = (struct cpu_stop_work){\n\t\t.fn = multi_cpu_stop,\n\t\t.arg = &msdata,\n\t\t.done = &done\n\t};\n\n\tcpu_stop_init_done(&done, 2);\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\n\tif (cpu1 > cpu2)\n\t\tswap(cpu1, cpu2);\n\tif (cpu_stop_queue_two_works(cpu1, &work1, cpu2, &work2))\n\t\treturn -ENOENT;\n\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nint stop_two_cpus(unsigned int cpu1, unsigned int cpu2, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work1, work2;\n\tstruct multi_stop_data msdata;\n\n\tmsdata = (struct multi_stop_data){\n\t\t.fn = fn,\n\t\t.data = arg,\n\t\t.num_threads = 2,\n\t\t.active_cpus = cpumask_of(cpu1),\n\t};\n\n\twork1 = work2 = (struct cpu_stop_work){\n\t\t.fn = multi_cpu_stop,\n\t\t.arg = &msdata,\n\t\t.done = &done\n\t};\n\n\tcpu_stop_init_done(&done, 2);\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\n\tif (cpu1 > cpu2)\n\t\tswap(cpu1, cpu2);\n\tif (cpu_stop_queue_two_works(cpu1, &work1, cpu2, &work2))\n\t\treturn -ENOENT;\n\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_swap_numa",
          "args": [
            "cur",
            "arg.src_cpu",
            "p",
            "arg.dst_cpu"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "arg.src_cpu",
            "&arg.dst_task->cpus_allowed"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "arg.dst_cpu",
            "&arg.src_task->cpus_allowed"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_active",
          "args": [
            "arg.dst_cpu"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_active",
          "args": [
            "arg.src_cpu"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint migrate_swap(struct task_struct *cur, struct task_struct *p,\n\t\tint target_cpu, int curr_cpu)\n{\n\tstruct migration_swap_arg arg;\n\tint ret = -EINVAL;\n\n\targ = (struct migration_swap_arg){\n\t\t.src_task = cur,\n\t\t.src_cpu = curr_cpu,\n\t\t.dst_task = p,\n\t\t.dst_cpu = target_cpu,\n\t};\n\n\tif (arg.src_cpu == arg.dst_cpu)\n\t\tgoto out;\n\n\t/*\n\t * These three tests are all lockless; this is OK since all of them\n\t * will be re-checked with proper locks held further down the line.\n\t */\n\tif (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu))\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(arg.dst_cpu, &arg.src_task->cpus_allowed))\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(arg.src_cpu, &arg.dst_task->cpus_allowed))\n\t\tgoto out;\n\n\ttrace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu);\n\tret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "migrate_swap_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1222-1261",
    "snippet": "static int migrate_swap_stop(void *data)\n{\n\tstruct migration_swap_arg *arg = data;\n\tstruct rq *src_rq, *dst_rq;\n\tint ret = -EAGAIN;\n\n\tif (!cpu_active(arg->src_cpu) || !cpu_active(arg->dst_cpu))\n\t\treturn -EAGAIN;\n\n\tsrc_rq = cpu_rq(arg->src_cpu);\n\tdst_rq = cpu_rq(arg->dst_cpu);\n\n\tdouble_raw_lock(&arg->src_task->pi_lock,\n\t\t\t&arg->dst_task->pi_lock);\n\tdouble_rq_lock(src_rq, dst_rq);\n\n\tif (task_cpu(arg->dst_task) != arg->dst_cpu)\n\t\tgoto unlock;\n\n\tif (task_cpu(arg->src_task) != arg->src_cpu)\n\t\tgoto unlock;\n\n\tif (!cpumask_test_cpu(arg->dst_cpu, &arg->src_task->cpus_allowed))\n\t\tgoto unlock;\n\n\tif (!cpumask_test_cpu(arg->src_cpu, &arg->dst_task->cpus_allowed))\n\t\tgoto unlock;\n\n\t__migrate_swap_task(arg->src_task, arg->dst_cpu);\n\t__migrate_swap_task(arg->dst_task, arg->src_cpu);\n\n\tret = 0;\n\nunlock:\n\tdouble_rq_unlock(src_rq, dst_rq);\n\traw_spin_unlock(&arg->dst_task->pi_lock);\n\traw_spin_unlock(&arg->src_task->pi_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&arg->src_task->pi_lock"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_rq_unlock",
          "args": [
            "src_rq",
            "dst_rq"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__migrate_swap_task",
          "args": [
            "arg->dst_task",
            "arg->src_cpu"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "__migrate_swap_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1185-1215",
          "snippet": "static void __migrate_swap_task(struct task_struct *p, int cpu)\n{\n\tif (task_on_rq_queued(p)) {\n\t\tstruct rq *src_rq, *dst_rq;\n\t\tstruct rq_flags srf, drf;\n\n\t\tsrc_rq = task_rq(p);\n\t\tdst_rq = cpu_rq(cpu);\n\n\t\trq_pin_lock(src_rq, &srf);\n\t\trq_pin_lock(dst_rq, &drf);\n\n\t\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\t\tdeactivate_task(src_rq, p, 0);\n\t\tset_task_cpu(p, cpu);\n\t\tactivate_task(dst_rq, p, 0);\n\t\tp->on_rq = TASK_ON_RQ_QUEUED;\n\t\tcheck_preempt_curr(dst_rq, p, 0);\n\n\t\trq_unpin_lock(dst_rq, &drf);\n\t\trq_unpin_lock(src_rq, &srf);\n\n\t} else {\n\t\t/*\n\t\t * Task isn't running anymore; make it appear like we migrated\n\t\t * it before it went to sleep. This means on wakeup we make the\n\t\t * previous CPU our target instead of where it really is.\n\t\t */\n\t\tp->wake_cpu = cpu;\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __migrate_swap_task(struct task_struct *p, int cpu)\n{\n\tif (task_on_rq_queued(p)) {\n\t\tstruct rq *src_rq, *dst_rq;\n\t\tstruct rq_flags srf, drf;\n\n\t\tsrc_rq = task_rq(p);\n\t\tdst_rq = cpu_rq(cpu);\n\n\t\trq_pin_lock(src_rq, &srf);\n\t\trq_pin_lock(dst_rq, &drf);\n\n\t\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\t\tdeactivate_task(src_rq, p, 0);\n\t\tset_task_cpu(p, cpu);\n\t\tactivate_task(dst_rq, p, 0);\n\t\tp->on_rq = TASK_ON_RQ_QUEUED;\n\t\tcheck_preempt_curr(dst_rq, p, 0);\n\n\t\trq_unpin_lock(dst_rq, &drf);\n\t\trq_unpin_lock(src_rq, &srf);\n\n\t} else {\n\t\t/*\n\t\t * Task isn't running anymore; make it appear like we migrated\n\t\t * it before it went to sleep. This means on wakeup we make the\n\t\t * previous CPU our target instead of where it really is.\n\t\t */\n\t\tp->wake_cpu = cpu;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "arg->src_cpu",
            "&arg->dst_task->cpus_allowed"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "arg->dst_cpu",
            "&arg->src_task->cpus_allowed"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "arg->src_task"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_rq_lock",
          "args": [
            "src_rq",
            "dst_rq"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2037-2045",
          "snippet": "static inline void double_rq_lock(struct rq *rq1, struct rq *rq2)\n\t__acquires(rq1->lock)\n\t__acquires(rq2->lock)\n{\n\tBUG_ON(!irqs_disabled());\n\tBUG_ON(rq1 != rq2);\n\traw_spin_lock(&rq1->lock);\n\t__acquire(rq2->lock);\t/* Fake it out ;) */\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_lock(struct rq *rq1, struct rq *rq2)\n\t__acquires(rq1->lock)\n\t__acquires(rq2->lock)\n{\n\tBUG_ON(!irqs_disabled());\n\tBUG_ON(rq1 != rq2);\n\traw_spin_lock(&rq1->lock);\n\t__acquire(rq2->lock);\t/* Fake it out ;) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_raw_lock",
          "args": [
            "&arg->src_task->pi_lock",
            "&arg->dst_task->pi_lock"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "double_raw_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1974-1981",
          "snippet": "static inline void double_raw_lock(raw_spinlock_t *l1, raw_spinlock_t *l2)\n{\n\tif (l1 > l2)\n\t\tswap(l1, l2);\n\n\traw_spin_lock(l1);\n\traw_spin_lock_nested(l2, SINGLE_DEPTH_NESTING);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void double_raw_lock(raw_spinlock_t *l1, raw_spinlock_t *l2)\n{\n\tif (l1 > l2)\n\t\tswap(l1, l2);\n\n\traw_spin_lock(l1);\n\traw_spin_lock_nested(l2, SINGLE_DEPTH_NESTING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "arg->dst_cpu"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "arg->src_cpu"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_active",
          "args": [
            "arg->dst_cpu"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_active",
          "args": [
            "arg->src_cpu"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int migrate_swap_stop(void *data)\n{\n\tstruct migration_swap_arg *arg = data;\n\tstruct rq *src_rq, *dst_rq;\n\tint ret = -EAGAIN;\n\n\tif (!cpu_active(arg->src_cpu) || !cpu_active(arg->dst_cpu))\n\t\treturn -EAGAIN;\n\n\tsrc_rq = cpu_rq(arg->src_cpu);\n\tdst_rq = cpu_rq(arg->dst_cpu);\n\n\tdouble_raw_lock(&arg->src_task->pi_lock,\n\t\t\t&arg->dst_task->pi_lock);\n\tdouble_rq_lock(src_rq, dst_rq);\n\n\tif (task_cpu(arg->dst_task) != arg->dst_cpu)\n\t\tgoto unlock;\n\n\tif (task_cpu(arg->src_task) != arg->src_cpu)\n\t\tgoto unlock;\n\n\tif (!cpumask_test_cpu(arg->dst_cpu, &arg->src_task->cpus_allowed))\n\t\tgoto unlock;\n\n\tif (!cpumask_test_cpu(arg->src_cpu, &arg->dst_task->cpus_allowed))\n\t\tgoto unlock;\n\n\t__migrate_swap_task(arg->src_task, arg->dst_cpu);\n\t__migrate_swap_task(arg->dst_task, arg->src_cpu);\n\n\tret = 0;\n\nunlock:\n\tdouble_rq_unlock(src_rq, dst_rq);\n\traw_spin_unlock(&arg->dst_task->pi_lock);\n\traw_spin_unlock(&arg->src_task->pi_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__migrate_swap_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1185-1215",
    "snippet": "static void __migrate_swap_task(struct task_struct *p, int cpu)\n{\n\tif (task_on_rq_queued(p)) {\n\t\tstruct rq *src_rq, *dst_rq;\n\t\tstruct rq_flags srf, drf;\n\n\t\tsrc_rq = task_rq(p);\n\t\tdst_rq = cpu_rq(cpu);\n\n\t\trq_pin_lock(src_rq, &srf);\n\t\trq_pin_lock(dst_rq, &drf);\n\n\t\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\t\tdeactivate_task(src_rq, p, 0);\n\t\tset_task_cpu(p, cpu);\n\t\tactivate_task(dst_rq, p, 0);\n\t\tp->on_rq = TASK_ON_RQ_QUEUED;\n\t\tcheck_preempt_curr(dst_rq, p, 0);\n\n\t\trq_unpin_lock(dst_rq, &drf);\n\t\trq_unpin_lock(src_rq, &srf);\n\n\t} else {\n\t\t/*\n\t\t * Task isn't running anymore; make it appear like we migrated\n\t\t * it before it went to sleep. This means on wakeup we make the\n\t\t * previous CPU our target instead of where it really is.\n\t\t */\n\t\tp->wake_cpu = cpu;\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_unpin_lock",
          "args": [
            "src_rq",
            "&srf"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unpin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1060-1068",
          "snippet": "static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_UPDATED\t\t0x04",
            "#define RQCF_ACT_SKIP\t\t0x02"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_UPDATED\t\t0x04\n#define RQCF_ACT_SKIP\t\t0x02\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_preempt_curr",
          "args": [
            "dst_rq",
            "p",
            "0"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "841-864",
          "snippet": "void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "activate_task",
          "args": [
            "dst_rq",
            "p",
            "0"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "754-760",
          "snippet": "void deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_cpu",
          "args": [
            "p",
            "cpu"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "set_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1132-1182",
          "snippet": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_pin_lock",
          "args": [
            "dst_rq",
            "&drf"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "rq_pin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1050-1058",
          "snippet": "static inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\trf->cookie = lockdep_pin_lock(&rq->lock);\n\n#ifdef CONFIG_SCHED_DEBUG\n\trq->clock_update_flags &= (RQCF_REQ_SKIP|RQCF_ACT_SKIP);\n\trf->clock_update_flags = 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_ACT_SKIP\t\t0x02",
            "#define RQCF_REQ_SKIP\t\t0x01"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_ACT_SKIP\t\t0x02\n#define RQCF_REQ_SKIP\t\t0x01\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\trf->cookie = lockdep_pin_lock(&rq->lock);\n\n#ifdef CONFIG_SCHED_DEBUG\n\trq->clock_update_flags &= (RQCF_REQ_SKIP|RQCF_ACT_SKIP);\n\trf->clock_update_flags = 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __migrate_swap_task(struct task_struct *p, int cpu)\n{\n\tif (task_on_rq_queued(p)) {\n\t\tstruct rq *src_rq, *dst_rq;\n\t\tstruct rq_flags srf, drf;\n\n\t\tsrc_rq = task_rq(p);\n\t\tdst_rq = cpu_rq(cpu);\n\n\t\trq_pin_lock(src_rq, &srf);\n\t\trq_pin_lock(dst_rq, &drf);\n\n\t\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\t\tdeactivate_task(src_rq, p, 0);\n\t\tset_task_cpu(p, cpu);\n\t\tactivate_task(dst_rq, p, 0);\n\t\tp->on_rq = TASK_ON_RQ_QUEUED;\n\t\tcheck_preempt_curr(dst_rq, p, 0);\n\n\t\trq_unpin_lock(dst_rq, &drf);\n\t\trq_unpin_lock(src_rq, &srf);\n\n\t} else {\n\t\t/*\n\t\t * Task isn't running anymore; make it appear like we migrated\n\t\t * it before it went to sleep. This means on wakeup we make the\n\t\t * previous CPU our target instead of where it really is.\n\t\t */\n\t\tp->wake_cpu = cpu;\n\t}\n}"
  },
  {
    "function_name": "set_task_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1132-1182",
    "snippet": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_task_cpu",
          "args": [
            "p",
            "new_cpu"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "__set_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1428-1445",
          "snippet": "static inline void __set_task_cpu(struct task_struct *p, unsigned int cpu)\n{\n\tset_task_rq(p, cpu);\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->cpu is set up to a new value, task_rq_lock(p, ...) can be\n\t * successfuly executed on another CPU. We must ensure that updates of\n\t * per-task data have been completed by this moment.\n\t */\n\tsmp_wmb();\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tp->cpu = cpu;\n#else\n\ttask_thread_info(p)->cpu = cpu;\n#endif\n\tp->wake_cpu = cpu;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline void __set_task_cpu(struct task_struct *p, unsigned int cpu)\n{\n\tset_task_rq(p, cpu);\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->cpu is set up to a new value, task_rq_lock(p, ...) can be\n\t * successfuly executed on another CPU. We must ensure that updates of\n\t * per-task data have been completed by this moment.\n\t */\n\tsmp_wmb();\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tp->cpu = cpu;\n#else\n\ttask_thread_info(p)->cpu = cpu;\n#endif\n\tp->wake_cpu = cpu;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_task_migrate",
          "args": [
            "p"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rseq_migrate",
          "args": [
            "p"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->sched_class->migrate_task_rq",
          "args": [
            "p",
            "new_cpu"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_migrate_task",
          "args": [
            "p",
            "new_cpu"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cpu_online(new_cpu)"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "new_cpu"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock))"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&task_rq(p)->lock"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&p->pi_lock"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p))"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_migrating",
          "args": [
            "p"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_migrating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1540-1543",
          "snippet": "static inline int task_on_rq_migrating(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_MIGRATING;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_MIGRATING\t2"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_MIGRATING\t2\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_migrating(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_MIGRATING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}"
  },
  {
    "function_name": "set_cpus_allowed_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1126-1129",
    "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_cpus_allowed_ptr",
          "args": [
            "p",
            "new_mask",
            "false"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "__set_cpus_allowed_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1594-1598",
          "snippet": "static inline int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t\t const struct cpumask *new_mask, bool check)\n{\n\treturn set_cpus_allowed_ptr(p, new_mask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t\t const struct cpumask *new_mask, bool check)\n{\n\treturn set_cpus_allowed_ptr(p, new_mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}"
  },
  {
    "function_name": "__set_cpus_allowed_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1053-1124",
    "snippet": "static int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t  const struct cpumask *new_mask, bool check)\n{\n\tconst struct cpumask *cpu_valid_mask = cpu_active_mask;\n\tunsigned int dest_cpu;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint ret = 0;\n\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\tif (p->flags & PF_KTHREAD) {\n\t\t/*\n\t\t * Kernel threads are allowed on online && !active CPUs\n\t\t */\n\t\tcpu_valid_mask = cpu_online_mask;\n\t}\n\n\t/*\n\t * Must re-check here, to close a race against __kthread_bind(),\n\t * sched_setaffinity() is not guaranteed to observe the flag.\n\t */\n\tif (check && (p->flags & PF_NO_SETAFFINITY)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (cpumask_equal(&p->cpus_allowed, new_mask))\n\t\tgoto out;\n\n\tif (!cpumask_intersects(new_mask, cpu_valid_mask)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdo_set_cpus_allowed(p, new_mask);\n\n\tif (p->flags & PF_KTHREAD) {\n\t\t/*\n\t\t * For kernel threads that do indeed end up on online &&\n\t\t * !active we want to ensure they are strict per-CPU threads.\n\t\t */\n\t\tWARN_ON(cpumask_intersects(new_mask, cpu_online_mask) &&\n\t\t\t!cpumask_intersects(new_mask, cpu_active_mask) &&\n\t\t\tp->nr_cpus_allowed != 1);\n\t}\n\n\t/* Can the task run on the task's current CPU? If so, we're done */\n\tif (cpumask_test_cpu(task_cpu(p), new_mask))\n\t\tgoto out;\n\n\tdest_cpu = cpumask_any_and(cpu_valid_mask, new_mask);\n\tif (task_running(rq, p) || p->state == TASK_WAKING) {\n\t\tstruct migration_arg arg = { p, dest_cpu };\n\t\t/* Need help from migration thread: drop lock and wait. */\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tstop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg);\n\t\ttlb_migrate_finish(p->mm);\n\t\treturn 0;\n\t} else if (task_on_rq_queued(p)) {\n\t\t/*\n\t\t * OK, since we're going to drop the lock immediately\n\t\t * afterwards anyway.\n\t\t */\n\t\trq = move_queued_task(rq, &rf, p, dest_cpu);\n\t}\nout:\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_queued_task",
          "args": [
            "rq",
            "&rf",
            "p",
            "dest_cpu"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "move_queued_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "913-932",
          "snippet": "static struct rq *move_queued_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t   struct task_struct *p, int new_cpu)\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\tdequeue_task(rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, new_cpu);\n\trq_unlock(rq, rf);\n\n\trq = cpu_rq(new_cpu);\n\n\trq_lock(rq, rf);\n\tBUG_ON(task_cpu(p) != new_cpu);\n\tenqueue_task(rq, p, 0);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\tcheck_preempt_curr(rq, p, 0);\n\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct rq *move_queued_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t   struct task_struct *p, int new_cpu)\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\tdequeue_task(rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, new_cpu);\n\trq_unlock(rq, rf);\n\n\trq = cpu_rq(new_cpu);\n\n\trq_lock(rq, rf);\n\tBUG_ON(task_cpu(p) != new_cpu);\n\tenqueue_task(rq, p, 0);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\tcheck_preempt_curr(rq, p, 0);\n\n\treturn rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_migrate_finish",
          "args": [
            "p->mm"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_one_cpu",
          "args": [
            "cpu_of(rq)",
            "migration_cpu_stop",
            "&arg"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "stop_one_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "123-138",
          "snippet": "int stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done };\n\n\tcpu_stop_init_done(&done, 1);\n\tif (!cpu_stop_queue_work(cpu, &work))\n\t\treturn -ENOENT;\n\t/*\n\t * In case @cpu == smp_proccessor_id() we can avoid a sleep+wakeup\n\t * cycle by doing a preemption:\n\t */\n\tcond_resched();\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nint stop_one_cpu(unsigned int cpu, cpu_stop_fn_t fn, void *arg)\n{\n\tstruct cpu_stop_done done;\n\tstruct cpu_stop_work work = { .fn = fn, .arg = arg, .done = &done };\n\n\tcpu_stop_init_done(&done, 1);\n\tif (!cpu_stop_queue_work(cpu, &work))\n\t\treturn -ENOENT;\n\t/*\n\t * In case @cpu == smp_proccessor_id() we can avoid a sleep+wakeup\n\t * cycle by doing a preemption:\n\t */\n\tcond_resched();\n\twait_for_completion(&done.completion);\n\treturn done.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "928-935",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "p"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1526-1533",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "cpu_valid_mask",
            "new_mask"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "task_cpu(p)",
            "new_mask"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cpumask_intersects(new_mask, cpu_online_mask) &&\n\t\t\t!cpumask_intersects(new_mask, cpu_active_mask) &&\n\t\t\tp->nr_cpus_allowed != 1"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "new_mask",
            "cpu_active_mask"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "new_mask",
            "cpu_online_mask"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_set_cpus_allowed",
          "args": [
            "p",
            "new_mask"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "do_set_cpus_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1015-1042",
          "snippet": "void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tstruct rq *rq = task_rq(p);\n\tbool queued, running;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued) {\n\t\t/*\n\t\t * Because __kthread_bind() calls this on blocked tasks without\n\t\t * holding rq->lock.\n\t\t */\n\t\tlockdep_assert_held(&rq->lock);\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\t}\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->sched_class->set_cpus_allowed(p, new_mask);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_curr_task(rq, p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tstruct rq *rq = task_rq(p);\n\tbool queued, running;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued) {\n\t\t/*\n\t\t * Because __kthread_bind() calls this on blocked tasks without\n\t\t * holding rq->lock.\n\t\t */\n\t\tlockdep_assert_held(&rq->lock);\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\t}\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->sched_class->set_cpus_allowed(p, new_mask);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_curr_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "new_mask",
            "cpu_valid_mask"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "&p->cpus_allowed",
            "new_mask"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t  const struct cpumask *new_mask, bool check)\n{\n\tconst struct cpumask *cpu_valid_mask = cpu_active_mask;\n\tunsigned int dest_cpu;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint ret = 0;\n\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\tif (p->flags & PF_KTHREAD) {\n\t\t/*\n\t\t * Kernel threads are allowed on online && !active CPUs\n\t\t */\n\t\tcpu_valid_mask = cpu_online_mask;\n\t}\n\n\t/*\n\t * Must re-check here, to close a race against __kthread_bind(),\n\t * sched_setaffinity() is not guaranteed to observe the flag.\n\t */\n\tif (check && (p->flags & PF_NO_SETAFFINITY)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (cpumask_equal(&p->cpus_allowed, new_mask))\n\t\tgoto out;\n\n\tif (!cpumask_intersects(new_mask, cpu_valid_mask)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdo_set_cpus_allowed(p, new_mask);\n\n\tif (p->flags & PF_KTHREAD) {\n\t\t/*\n\t\t * For kernel threads that do indeed end up on online &&\n\t\t * !active we want to ensure they are strict per-CPU threads.\n\t\t */\n\t\tWARN_ON(cpumask_intersects(new_mask, cpu_online_mask) &&\n\t\t\t!cpumask_intersects(new_mask, cpu_active_mask) &&\n\t\t\tp->nr_cpus_allowed != 1);\n\t}\n\n\t/* Can the task run on the task's current CPU? If so, we're done */\n\tif (cpumask_test_cpu(task_cpu(p), new_mask))\n\t\tgoto out;\n\n\tdest_cpu = cpumask_any_and(cpu_valid_mask, new_mask);\n\tif (task_running(rq, p) || p->state == TASK_WAKING) {\n\t\tstruct migration_arg arg = { p, dest_cpu };\n\t\t/* Need help from migration thread: drop lock and wait. */\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tstop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg);\n\t\ttlb_migrate_finish(p->mm);\n\t\treturn 0;\n\t} else if (task_on_rq_queued(p)) {\n\t\t/*\n\t\t * OK, since we're going to drop the lock immediately\n\t\t * afterwards anyway.\n\t\t */\n\t\trq = move_queued_task(rq, &rf, p, dest_cpu);\n\t}\nout:\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_set_cpus_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1015-1042",
    "snippet": "void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tstruct rq *rq = task_rq(p);\n\tbool queued, running;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued) {\n\t\t/*\n\t\t * Because __kthread_bind() calls this on blocked tasks without\n\t\t * holding rq->lock.\n\t\t */\n\t\tlockdep_assert_held(&rq->lock);\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\t}\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->sched_class->set_cpus_allowed(p, new_mask);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_curr_task(rq, p);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_curr_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "ia64_set_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "6228-6231",
          "snippet": "void ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task",
          "args": [
            "rq",
            "p",
            "ENQUEUE_RESTORE | ENQUEUE_NOCLOCK"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "720-731",
          "snippet": "static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->sched_class->set_cpus_allowed",
          "args": [
            "p",
            "new_mask"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_prev_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "put_prev_task_fake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5553-5555",
          "snippet": "static void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void put_prev_task_fake(struct rq *rq, struct task_struct *prev)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_task",
          "args": [
            "rq",
            "p",
            "DEQUEUE_SAVE | DEQUEUE_NOCLOCK"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "733-744",
          "snippet": "static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rq->lock"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1521-1524",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&p->pi_lock"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tstruct rq *rq = task_rq(p);\n\tbool queued, running;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued) {\n\t\t/*\n\t\t * Because __kthread_bind() calls this on blocked tasks without\n\t\t * holding rq->lock.\n\t\t */\n\t\tlockdep_assert_held(&rq->lock);\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\t}\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->sched_class->set_cpus_allowed(p, new_mask);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_curr_task(rq, p);\n}"
  },
  {
    "function_name": "set_cpus_allowed_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "1009-1013",
    "snippet": "void set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tcpumask_copy(&p->cpus_allowed, new_mask);\n\tp->nr_cpus_allowed = cpumask_weight(new_mask);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "new_mask"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&p->cpus_allowed",
            "new_mask"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tcpumask_copy(&p->cpus_allowed, new_mask);\n\tp->nr_cpus_allowed = cpumask_weight(new_mask);\n}"
  },
  {
    "function_name": "migration_cpu_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "966-1003",
    "snippet": "static int migration_cpu_stop(void *data)\n{\n\tstruct migration_arg *arg = data;\n\tstruct task_struct *p = arg->task;\n\tstruct rq *rq = this_rq();\n\tstruct rq_flags rf;\n\n\t/*\n\t * The original target CPU might have gone down and we might\n\t * be on another CPU but it doesn't matter.\n\t */\n\tlocal_irq_disable();\n\t/*\n\t * We need to explicitly wake pending tasks before running\n\t * __migrate_task() such that we will not miss enforcing cpus_allowed\n\t * during wakeups, see set_cpus_allowed_ptr()'s TASK_WAKING test.\n\t */\n\tsched_ttwu_pending();\n\n\traw_spin_lock(&p->pi_lock);\n\trq_lock(rq, &rf);\n\t/*\n\t * If task_rq(p) != rq, it cannot be migrated here, because we're\n\t * holding rq->lock, if p->on_rq == 0 it cannot get enqueued because\n\t * we're holding p->pi_lock.\n\t */\n\tif (task_rq(p) == rq) {\n\t\tif (task_on_rq_queued(p))\n\t\t\trq = __migrate_task(rq, &rf, p, arg->dest_cpu);\n\t\telse\n\t\t\tp->wake_cpu = arg->dest_cpu;\n\t}\n\trq_unlock(rq, &rf);\n\traw_spin_unlock(&p->pi_lock);\n\n\tlocal_irq_enable();\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&p->pi_lock"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unlock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__migrate_task",
          "args": [
            "rq",
            "&rf",
            "p",
            "arg->dest_cpu"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "__migrate_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "948-959",
          "snippet": "static struct rq *__migrate_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t struct task_struct *p, int dest_cpu)\n{\n\t/* Affinity changed (again). */\n\tif (!is_cpu_allowed(p, dest_cpu))\n\t\treturn rq;\n\n\tupdate_rq_clock(rq);\n\trq = move_queued_task(rq, rf, p, dest_cpu);\n\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct rq *__migrate_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t struct task_struct *p, int dest_cpu)\n{\n\t/* Affinity changed (again). */\n\tif (!is_cpu_allowed(p, dest_cpu))\n\t\treturn rq;\n\n\tupdate_rq_clock(rq);\n\trq = move_queued_task(rq, rf, p, dest_cpu);\n\n\treturn rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&p->pi_lock"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_ttwu_pending",
          "args": [],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "sched_ttwu_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1731-1748",
          "snippet": "void sched_ttwu_pending(void)\n{\n\tstruct rq *rq = this_rq();\n\tstruct llist_node *llist = llist_del_all(&rq->wake_list);\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry)\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\n\trq_unlock_irqrestore(rq, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_ttwu_pending(void)\n{\n\tstruct rq *rq = this_rq();\n\tstruct llist_node *llist = llist_del_all(&rq->wake_list);\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry)\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\n\trq_unlock_irqrestore(rq, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int migration_cpu_stop(void *data)\n{\n\tstruct migration_arg *arg = data;\n\tstruct task_struct *p = arg->task;\n\tstruct rq *rq = this_rq();\n\tstruct rq_flags rf;\n\n\t/*\n\t * The original target CPU might have gone down and we might\n\t * be on another CPU but it doesn't matter.\n\t */\n\tlocal_irq_disable();\n\t/*\n\t * We need to explicitly wake pending tasks before running\n\t * __migrate_task() such that we will not miss enforcing cpus_allowed\n\t * during wakeups, see set_cpus_allowed_ptr()'s TASK_WAKING test.\n\t */\n\tsched_ttwu_pending();\n\n\traw_spin_lock(&p->pi_lock);\n\trq_lock(rq, &rf);\n\t/*\n\t * If task_rq(p) != rq, it cannot be migrated here, because we're\n\t * holding rq->lock, if p->on_rq == 0 it cannot get enqueued because\n\t * we're holding p->pi_lock.\n\t */\n\tif (task_rq(p) == rq) {\n\t\tif (task_on_rq_queued(p))\n\t\t\trq = __migrate_task(rq, &rf, p, arg->dest_cpu);\n\t\telse\n\t\t\tp->wake_cpu = arg->dest_cpu;\n\t}\n\trq_unlock(rq, &rf);\n\traw_spin_unlock(&p->pi_lock);\n\n\tlocal_irq_enable();\n\treturn 0;\n}"
  },
  {
    "function_name": "__migrate_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "948-959",
    "snippet": "static struct rq *__migrate_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t struct task_struct *p, int dest_cpu)\n{\n\t/* Affinity changed (again). */\n\tif (!is_cpu_allowed(p, dest_cpu))\n\t\treturn rq;\n\n\tupdate_rq_clock(rq);\n\trq = move_queued_task(rq, rf, p, dest_cpu);\n\n\treturn rq;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_queued_task",
          "args": [
            "rq",
            "rf",
            "p",
            "dest_cpu"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "move_queued_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "913-932",
          "snippet": "static struct rq *move_queued_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t   struct task_struct *p, int new_cpu)\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\tdequeue_task(rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, new_cpu);\n\trq_unlock(rq, rf);\n\n\trq = cpu_rq(new_cpu);\n\n\trq_lock(rq, rf);\n\tBUG_ON(task_cpu(p) != new_cpu);\n\tenqueue_task(rq, p, 0);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\tcheck_preempt_curr(rq, p, 0);\n\n\treturn rq;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct rq *move_queued_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t   struct task_struct *p, int new_cpu)\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\tdequeue_task(rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, new_cpu);\n\trq_unlock(rq, rf);\n\n\trq = cpu_rq(new_cpu);\n\n\trq_lock(rq, rf);\n\tBUG_ON(task_cpu(p) != new_cpu);\n\tenqueue_task(rq, p, 0);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\tcheck_preempt_curr(rq, p, 0);\n\n\treturn rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpu_allowed",
          "args": [
            "p",
            "dest_cpu"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpu_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "883-892",
          "snippet": "static inline bool is_cpu_allowed(struct task_struct *p, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn false;\n\n\tif (is_per_cpu_kthread(p))\n\t\treturn cpu_online(cpu);\n\n\treturn cpu_active(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline bool is_cpu_allowed(struct task_struct *p, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn false;\n\n\tif (is_per_cpu_kthread(p))\n\t\treturn cpu_online(cpu);\n\n\treturn cpu_active(cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct rq *__migrate_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t struct task_struct *p, int dest_cpu)\n{\n\t/* Affinity changed (again). */\n\tif (!is_cpu_allowed(p, dest_cpu))\n\t\treturn rq;\n\n\tupdate_rq_clock(rq);\n\trq = move_queued_task(rq, rf, p, dest_cpu);\n\n\treturn rq;\n}"
  },
  {
    "function_name": "move_queued_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "913-932",
    "snippet": "static struct rq *move_queued_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t   struct task_struct *p, int new_cpu)\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\tdequeue_task(rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, new_cpu);\n\trq_unlock(rq, rf);\n\n\trq = cpu_rq(new_cpu);\n\n\trq_lock(rq, rf);\n\tBUG_ON(task_cpu(p) != new_cpu);\n\tenqueue_task(rq, p, 0);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\tcheck_preempt_curr(rq, p, 0);\n\n\treturn rq;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_preempt_curr",
          "args": [
            "rq",
            "p",
            "0"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "841-864",
          "snippet": "void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task",
          "args": [
            "rq",
            "p",
            "0"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "720-731",
          "snippet": "static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "task_cpu(p) != new_cpu"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_lock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "new_cpu"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_unlock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_cpu",
          "args": [
            "p",
            "new_cpu"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "set_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1132-1182",
          "snippet": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_task",
          "args": [
            "rq",
            "p",
            "DEQUEUE_NOCLOCK"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "733-744",
          "snippet": "static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rq->lock"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic struct rq *move_queued_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t   struct task_struct *p, int new_cpu)\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\tdequeue_task(rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, new_cpu);\n\trq_unlock(rq, rf);\n\n\trq = cpu_rq(new_cpu);\n\n\trq_lock(rq, rf);\n\tBUG_ON(task_cpu(p) != new_cpu);\n\tenqueue_task(rq, p, 0);\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n\tcheck_preempt_curr(rq, p, 0);\n\n\treturn rq;\n}"
  },
  {
    "function_name": "is_cpu_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "883-892",
    "snippet": "static inline bool is_cpu_allowed(struct task_struct *p, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn false;\n\n\tif (is_per_cpu_kthread(p))\n\t\treturn cpu_online(cpu);\n\n\treturn cpu_active(cpu);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_active",
          "args": [
            "cpu"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_per_cpu_kthread",
          "args": [
            "p"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "is_per_cpu_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "868-877",
          "snippet": "static inline bool is_per_cpu_kthread(struct task_struct *p)\n{\n\tif (!(p->flags & PF_KTHREAD))\n\t\treturn false;\n\n\tif (p->nr_cpus_allowed != 1)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline bool is_per_cpu_kthread(struct task_struct *p)\n{\n\tif (!(p->flags & PF_KTHREAD))\n\t\treturn false;\n\n\tif (p->nr_cpus_allowed != 1)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&p->cpus_allowed"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline bool is_cpu_allowed(struct task_struct *p, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn false;\n\n\tif (is_per_cpu_kthread(p))\n\t\treturn cpu_online(cpu);\n\n\treturn cpu_active(cpu);\n}"
  },
  {
    "function_name": "is_per_cpu_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "868-877",
    "snippet": "static inline bool is_per_cpu_kthread(struct task_struct *p)\n{\n\tif (!(p->flags & PF_KTHREAD))\n\t\treturn false;\n\n\tif (p->nr_cpus_allowed != 1)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline bool is_per_cpu_kthread(struct task_struct *p)\n{\n\tif (!(p->flags & PF_KTHREAD))\n\t\treturn false;\n\n\tif (p->nr_cpus_allowed != 1)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "check_preempt_curr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "841-864",
    "snippet": "void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_clock_skip_update",
          "args": [
            "rq"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_skip_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1021-1025",
          "snippet": "static inline void rq_clock_skip_update(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\trq->clock_update_flags |= RQCF_REQ_SKIP;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_REQ_SKIP\t\t0x01"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_REQ_SKIP\t\t0x01\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_clock_skip_update(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\trq->clock_update_flags |= RQCF_REQ_SKIP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_tsk_need_resched",
          "args": [
            "rq->curr"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "rq->curr"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq->curr->sched_class->check_preempt_curr",
          "args": [
            "rq",
            "p",
            "flags"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "841-864",
          "snippet": "void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_curr(rq);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}"
  },
  {
    "function_name": "check_class_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "828-839",
    "snippet": "static inline void check_class_changed(struct rq *rq, struct task_struct *p,\n\t\t\t\t       const struct sched_class *prev_class,\n\t\t\t\t       int oldprio)\n{\n\tif (prev_class != p->sched_class) {\n\t\tif (prev_class->switched_from)\n\t\t\tprev_class->switched_from(rq, p);\n\n\t\tp->sched_class->switched_to(rq, p);\n\t} else if (oldprio != p->prio || dl_task(p))\n\t\tp->sched_class->prio_changed(rq, p, oldprio);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "p->sched_class->prio_changed",
          "args": [
            "rq",
            "p",
            "oldprio"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->sched_class->switched_to",
          "args": [
            "rq",
            "p"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prev_class->switched_from",
          "args": [
            "rq",
            "p"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void check_class_changed(struct rq *rq, struct task_struct *p,\n\t\t\t\t       const struct sched_class *prev_class,\n\t\t\t\t       int oldprio)\n{\n\tif (prev_class != p->sched_class) {\n\t\tif (prev_class->switched_from)\n\t\t\tprev_class->switched_from(rq, p);\n\n\t\tp->sched_class->switched_to(rq, p);\n\t} else if (oldprio != p->prio || dl_task(p))\n\t\tp->sched_class->prio_changed(rq, p, oldprio);\n}"
  },
  {
    "function_name": "task_curr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "816-819",
    "snippet": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_curr",
          "args": [
            "task_cpu(p)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}"
  },
  {
    "function_name": "effective_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "797-808",
    "snippet": "static int effective_prio(struct task_struct *p)\n{\n\tp->normal_prio = normal_prio(p);\n\t/*\n\t * If we are RT tasks or we were boosted to RT priority,\n\t * keep the priority unchanged. Otherwise, update priority\n\t * to the normal priority:\n\t */\n\tif (!rt_prio(p->prio))\n\t\treturn p->normal_prio;\n\treturn p->prio;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rt_prio",
          "args": [
            "p->prio"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "convert_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
          "lines": "32-46",
          "snippet": "static int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == CPUPRI_INVALID)\n\t\tcpupri = CPUPRI_INVALID;\n\telse if (prio == MAX_PRIO)\n\t\tcpupri = CPUPRI_IDLE;\n\telse if (prio >= MAX_RT_PRIO)\n\t\tcpupri = CPUPRI_NORMAL;\n\telse\n\t\tcpupri = MAX_RT_PRIO - prio + 1;\n\n\treturn cpupri;\n}"
        }
      },
      {
        "call_info": {
          "callee": "normal_prio",
          "args": [
            "p"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "normal_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "777-788",
          "snippet": "static inline int normal_prio(struct task_struct *p)\n{\n\tint prio;\n\n\tif (task_has_dl_policy(p))\n\t\tprio = MAX_DL_PRIO-1;\n\telse if (task_has_rt_policy(p))\n\t\tprio = MAX_RT_PRIO-1 - p->rt_priority;\n\telse\n\t\tprio = __normal_prio(p);\n\treturn prio;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int normal_prio(struct task_struct *p)\n{\n\tint prio;\n\n\tif (task_has_dl_policy(p))\n\t\tprio = MAX_DL_PRIO-1;\n\telse if (task_has_rt_policy(p))\n\t\tprio = MAX_RT_PRIO-1 - p->rt_priority;\n\telse\n\t\tprio = __normal_prio(p);\n\treturn prio;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int effective_prio(struct task_struct *p)\n{\n\tp->normal_prio = normal_prio(p);\n\t/*\n\t * If we are RT tasks or we were boosted to RT priority,\n\t * keep the priority unchanged. Otherwise, update priority\n\t * to the normal priority:\n\t */\n\tif (!rt_prio(p->prio))\n\t\treturn p->normal_prio;\n\treturn p->prio;\n}"
  },
  {
    "function_name": "normal_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "777-788",
    "snippet": "static inline int normal_prio(struct task_struct *p)\n{\n\tint prio;\n\n\tif (task_has_dl_policy(p))\n\t\tprio = MAX_DL_PRIO-1;\n\telse if (task_has_rt_policy(p))\n\t\tprio = MAX_RT_PRIO-1 - p->rt_priority;\n\telse\n\t\tprio = __normal_prio(p);\n\treturn prio;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__normal_prio",
          "args": [
            "p"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "__normal_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "765-768",
          "snippet": "static inline int __normal_prio(struct task_struct *p)\n{\n\treturn p->static_prio;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int __normal_prio(struct task_struct *p)\n{\n\treturn p->static_prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_has_rt_policy",
          "args": [
            "p"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_rt_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "179-182",
          "snippet": "static inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_has_dl_policy",
          "args": [
            "p"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_dl_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "184-187",
          "snippet": "static inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int normal_prio(struct task_struct *p)\n{\n\tint prio;\n\n\tif (task_has_dl_policy(p))\n\t\tprio = MAX_DL_PRIO-1;\n\telse if (task_has_rt_policy(p))\n\t\tprio = MAX_RT_PRIO-1 - p->rt_priority;\n\telse\n\t\tprio = __normal_prio(p);\n\treturn prio;\n}"
  },
  {
    "function_name": "__normal_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "765-768",
    "snippet": "static inline int __normal_prio(struct task_struct *p)\n{\n\treturn p->static_prio;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline int __normal_prio(struct task_struct *p)\n{\n\treturn p->static_prio;\n}"
  },
  {
    "function_name": "deactivate_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "754-760",
    "snippet": "void deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dequeue_task",
          "args": [
            "rq",
            "p",
            "flags"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "733-744",
          "snippet": "static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_contributes_to_load",
          "args": [
            "p"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}"
  },
  {
    "function_name": "activate_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "746-752",
    "snippet": "void activate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible--;\n\n\tenqueue_task(rq, p, flags);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enqueue_task",
          "args": [
            "rq",
            "p",
            "flags"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "720-731",
          "snippet": "static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_contributes_to_load",
          "args": [
            "p"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid activate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible--;\n\n\tenqueue_task(rq, p, flags);\n}"
  },
  {
    "function_name": "dequeue_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "733-744",
    "snippet": "static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "p->sched_class->dequeue_task",
          "args": [
            "rq",
            "p",
            "flags"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "733-744",
          "snippet": "static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "psi_dequeue",
          "args": [
            "p",
            "flags & DEQUEUE_SLEEP"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "psi_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.h",
          "lines": "139-139",
          "snippet": "static inline void psi_dequeue(struct task_struct *p, bool sleep) {}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void psi_dequeue(struct task_struct *p, bool sleep) {}"
        }
      },
      {
        "call_info": {
          "callee": "sched_info_dequeued",
          "args": [
            "rq",
            "p"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "sched_info_dequeued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.h",
          "lines": "156-167",
          "snippet": "static inline void sched_info_dequeued(struct rq *rq, struct task_struct *t)\n{\n\tunsigned long long now = rq_clock(rq), delta = 0;\n\n\tif (unlikely(sched_info_on()))\n\t\tif (t->sched_info.last_queued)\n\t\t\tdelta = now - t->sched_info.last_queued;\n\tsched_info_reset_dequeued(t);\n\tt->sched_info.run_delay += delta;\n\n\trq_sched_info_dequeued(rq, delta);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void sched_info_dequeued(struct rq *rq, struct task_struct *t)\n{\n\tunsigned long long now = rq_clock(rq), delta = 0;\n\n\tif (unlikely(sched_info_on()))\n\t\tif (t->sched_info.last_queued)\n\t\t\tdelta = now - t->sched_info.last_queued;\n\tsched_info_reset_dequeued(t);\n\tt->sched_info.run_delay += delta;\n\n\trq_sched_info_dequeued(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tp->sched_class->dequeue_task(rq, p, flags);\n}"
  },
  {
    "function_name": "enqueue_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "720-731",
    "snippet": "static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "p->sched_class->enqueue_task",
          "args": [
            "rq",
            "p",
            "flags"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "720-731",
          "snippet": "static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "psi_enqueue",
          "args": [
            "p",
            "flags & ENQUEUE_WAKEUP"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "psi_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.h",
          "lines": "138-138",
          "snippet": "static inline void psi_enqueue(struct task_struct *p, bool wakeup) {}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void psi_enqueue(struct task_struct *p, bool wakeup) {}"
        }
      },
      {
        "call_info": {
          "callee": "sched_info_queued",
          "args": [
            "rq",
            "p"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "sched_info_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/stats.h",
          "lines": "193-199",
          "snippet": "static inline void sched_info_queued(struct rq *rq, struct task_struct *t)\n{\n\tif (unlikely(sched_info_on())) {\n\t\tif (!t->sched_info.last_queued)\n\t\t\tt->sched_info.last_queued = rq_clock(rq);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void sched_info_queued(struct rq *rq, struct task_struct *t)\n{\n\tif (unlikely(sched_info_on())) {\n\t\tif (!t->sched_info.last_queued)\n\t\t\tt->sched_info.last_queued = rq_clock(rq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tp->sched_class->enqueue_task(rq, p, flags);\n}"
  },
  {
    "function_name": "set_load_weight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "692-718",
    "snippet": "static void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (idle_policy(p->policy)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\tp->se.runnable_weight = load->weight;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t\tp->se.runnable_weight = load->weight;\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct",
      "const int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};",
      "const u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scale_load",
          "args": [
            "sched_prio_to_weight[prio]"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reweight_task",
          "args": [
            "p",
            "prio"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "reweight_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "2813-2822",
          "snippet": "void reweight_task(struct task_struct *p, int prio)\n{\n\tstruct sched_entity *se = &p->se;\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\tstruct load_weight *load = &se->load;\n\tunsigned long weight = scale_load(sched_prio_to_weight[prio]);\n\n\treweight_entity(cfs_rq, se, weight, weight);\n\tload->inv_weight = sched_prio_to_wmult[prio];\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static int\nwakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static void set_next_buddy(struct sched_entity *se);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic int\nwakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic void set_next_buddy(struct sched_entity *se);\n\nvoid reweight_task(struct task_struct *p, int prio)\n{\n\tstruct sched_entity *se = &p->se;\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\tstruct load_weight *load = &se->load;\n\tunsigned long weight = scale_load(sched_prio_to_weight[prio]);\n\n\treweight_entity(cfs_rq, se, weight, weight);\n\tload->inv_weight = sched_prio_to_wmult[prio];\n}"
        }
      },
      {
        "call_info": {
          "callee": "scale_load",
          "args": [
            "WEIGHT_IDLEPRIO"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_policy",
          "args": [
            "p->policy"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "idle_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "155-158",
          "snippet": "static inline int idle_policy(int policy)\n{\n\treturn policy == SCHED_IDLE;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int idle_policy(int policy)\n{\n\treturn policy == SCHED_IDLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\nconst int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};\nconst u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};\n\nstatic void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (idle_policy(p->policy)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\tp->se.runnable_weight = load->weight;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t\tp->se.runnable_weight = load->weight;\n\t}\n}"
  },
  {
    "function_name": "tg_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "686-689",
    "snippet": "int tg_nop(struct task_group *tg, void *data)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint tg_nop(struct task_group *tg, void *data)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "walk_tg_tree_from",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "655-684",
    "snippet": "int walk_tg_tree_from(struct task_group *from,\n\t\t\t     tg_visitor down, tg_visitor up, void *data)\n{\n\tstruct task_group *parent, *child;\n\tint ret;\n\n\tparent = from;\n\ndown:\n\tret = (*down)(parent, data);\n\tif (ret)\n\t\tgoto out;\n\tlist_for_each_entry_rcu(child, &parent->children, siblings) {\n\t\tparent = child;\n\t\tgoto down;\n\nup:\n\t\tcontinue;\n\t}\n\tret = (*up)(parent, data);\n\tif (ret || parent == from)\n\t\tgoto out;\n\n\tchild = parent;\n\tparent = parent->parent;\n\tif (parent)\n\t\tgoto up;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "data"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "child",
            "&parent->children",
            "siblings"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "data"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint walk_tg_tree_from(struct task_group *from,\n\t\t\t     tg_visitor down, tg_visitor up, void *data)\n{\n\tstruct task_group *parent, *child;\n\tint ret;\n\n\tparent = from;\n\ndown:\n\tret = (*down)(parent, data);\n\tif (ret)\n\t\tgoto out;\n\tlist_for_each_entry_rcu(child, &parent->children, siblings) {\n\t\tparent = child;\n\t\tgoto down;\n\nup:\n\t\tcontinue;\n\t}\n\tret = (*up)(parent, data);\n\tif (ret || parent == from)\n\t\tgoto out;\n\n\tchild = parent;\n\tparent = parent->parent;\n\tif (parent)\n\t\tgoto up;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "sched_can_stop_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "607-643",
    "snippet": "bool sched_can_stop_tick(struct rq *rq)\n{\n\tint fifo_nr_running;\n\n\t/* Deadline tasks, even if single, need the tick */\n\tif (rq->dl.dl_nr_running)\n\t\treturn false;\n\n\t/*\n\t * If there are more than one RR tasks, we need the tick to effect the\n\t * actual RR behaviour.\n\t */\n\tif (rq->rt.rr_nr_running) {\n\t\tif (rq->rt.rr_nr_running == 1)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * If there's no RR tasks, but FIFO tasks, we can skip the tick, no\n\t * forced preemption between FIFO tasks.\n\t */\n\tfifo_nr_running = rq->rt.rt_nr_running - rq->rt.rr_nr_running;\n\tif (fifo_nr_running)\n\t\treturn true;\n\n\t/*\n\t * If there are no DL,RR/FIFO tasks, there must only be CFS tasks left;\n\t * if there's more than one we need the tick for involuntary\n\t * preemption.\n\t */\n\tif (rq->nr_running > 1)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nbool sched_can_stop_tick(struct rq *rq)\n{\n\tint fifo_nr_running;\n\n\t/* Deadline tasks, even if single, need the tick */\n\tif (rq->dl.dl_nr_running)\n\t\treturn false;\n\n\t/*\n\t * If there are more than one RR tasks, we need the tick to effect the\n\t * actual RR behaviour.\n\t */\n\tif (rq->rt.rr_nr_running) {\n\t\tif (rq->rt.rr_nr_running == 1)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * If there's no RR tasks, but FIFO tasks, we can skip the tick, no\n\t * forced preemption between FIFO tasks.\n\t */\n\tfifo_nr_running = rq->rt.rt_nr_running - rq->rt.rr_nr_running;\n\tif (fifo_nr_running)\n\t\treturn true;\n\n\t/*\n\t * If there are no DL,RR/FIFO tasks, there must only be CFS tasks left;\n\t * if there's more than one we need the tick for involuntary\n\t * preemption.\n\t */\n\tif (rq->nr_running > 1)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "got_nohz_idle_kick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "599-602",
    "snippet": "static inline bool got_nohz_idle_kick(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic inline bool got_nohz_idle_kick(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "got_nohz_idle_kick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "579-595",
    "snippet": "static inline bool got_nohz_idle_kick(void)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!(atomic_read(nohz_flags(cpu)) & NOHZ_KICK_MASK))\n\t\treturn false;\n\n\tif (idle_cpu(cpu) && !need_resched())\n\t\treturn true;\n\n\t/*\n\t * We can't run Idle Load Balance on this CPU for this time so we\n\t * cancel it and clear NOHZ_BALANCE_KICK\n\t */\n\tatomic_andnot(NOHZ_KICK_MASK, nohz_flags(cpu));\n\treturn false;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_andnot",
          "args": [
            "NOHZ_KICK_MASK",
            "nohz_flags(cpu)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nohz_flags",
          "args": [
            "cpu"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_cpu",
          "args": [
            "cpu"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "available_idle_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4012-4021",
          "snippet": "int available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "nohz_flags(cpu)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nohz_flags",
          "args": [
            "cpu"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic inline bool got_nohz_idle_kick(void)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!(atomic_read(nohz_flags(cpu)) & NOHZ_KICK_MASK))\n\t\treturn false;\n\n\tif (idle_cpu(cpu) && !need_resched())\n\t\treturn true;\n\n\t/*\n\t * We can't run Idle Load Balance on this CPU for this time so we\n\t * cancel it and clear NOHZ_BALANCE_KICK\n\t */\n\tatomic_andnot(NOHZ_KICK_MASK, nohz_flags(cpu));\n\treturn false;\n}"
  },
  {
    "function_name": "wake_up_nohz_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "573-577",
    "snippet": "void wake_up_nohz_cpu(int cpu)\n{\n\tif (!wake_up_full_nohz_cpu(cpu))\n\t\twake_up_idle_cpu(cpu);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_idle_cpu",
          "args": [
            "cpu"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_idle_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "535-546",
          "snippet": "static void wake_up_idle_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (cpu == smp_processor_id())\n\t\treturn;\n\n\tif (set_nr_and_not_polling(rq->idle))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void wake_up_idle_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (cpu == smp_processor_id())\n\t\treturn;\n\n\tif (set_nr_and_not_polling(rq->idle))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_full_nohz_cpu",
          "args": [
            "cpu"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_full_nohz_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "548-566",
          "snippet": "static bool wake_up_full_nohz_cpu(int cpu)\n{\n\t/*\n\t * We just need the target to call irq_exit() and re-evaluate\n\t * the next tick. The nohz full kick at least implies that.\n\t * If needed we can still optimize that later with an\n\t * empty IRQ.\n\t */\n\tif (cpu_is_offline(cpu))\n\t\treturn true;  /* Don't try to wake offline CPUs. */\n\tif (tick_nohz_full_cpu(cpu)) {\n\t\tif (cpu != smp_processor_id() ||\n\t\t    tick_nohz_tick_stopped())\n\t\t\ttick_nohz_full_kick_cpu(cpu);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic bool wake_up_full_nohz_cpu(int cpu)\n{\n\t/*\n\t * We just need the target to call irq_exit() and re-evaluate\n\t * the next tick. The nohz full kick at least implies that.\n\t * If needed we can still optimize that later with an\n\t * empty IRQ.\n\t */\n\tif (cpu_is_offline(cpu))\n\t\treturn true;  /* Don't try to wake offline CPUs. */\n\tif (tick_nohz_full_cpu(cpu)) {\n\t\tif (cpu != smp_processor_id() ||\n\t\t    tick_nohz_tick_stopped())\n\t\t\ttick_nohz_full_kick_cpu(cpu);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid wake_up_nohz_cpu(int cpu)\n{\n\tif (!wake_up_full_nohz_cpu(cpu))\n\t\twake_up_idle_cpu(cpu);\n}"
  },
  {
    "function_name": "wake_up_full_nohz_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "548-566",
    "snippet": "static bool wake_up_full_nohz_cpu(int cpu)\n{\n\t/*\n\t * We just need the target to call irq_exit() and re-evaluate\n\t * the next tick. The nohz full kick at least implies that.\n\t * If needed we can still optimize that later with an\n\t * empty IRQ.\n\t */\n\tif (cpu_is_offline(cpu))\n\t\treturn true;  /* Don't try to wake offline CPUs. */\n\tif (tick_nohz_full_cpu(cpu)) {\n\t\tif (cpu != smp_processor_id() ||\n\t\t    tick_nohz_tick_stopped())\n\t\t\ttick_nohz_full_kick_cpu(cpu);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_full_kick_cpu",
          "args": [
            "cpu"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_full_kick_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "250-256",
          "snippet": "void tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_nohz_full_kick_cpu(int cpu)\n{\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tirq_work_queue_on(&per_cpu(nohz_full_kick_work, cpu), cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_tick_stopped",
          "args": [],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_tick_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "468-473",
          "snippet": "bool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "cpu"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "cpu"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic bool wake_up_full_nohz_cpu(int cpu)\n{\n\t/*\n\t * We just need the target to call irq_exit() and re-evaluate\n\t * the next tick. The nohz full kick at least implies that.\n\t * If needed we can still optimize that later with an\n\t * empty IRQ.\n\t */\n\tif (cpu_is_offline(cpu))\n\t\treturn true;  /* Don't try to wake offline CPUs. */\n\tif (tick_nohz_full_cpu(cpu)) {\n\t\tif (cpu != smp_processor_id() ||\n\t\t    tick_nohz_tick_stopped())\n\t\t\ttick_nohz_full_kick_cpu(cpu);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "wake_up_idle_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "535-546",
    "snippet": "static void wake_up_idle_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (cpu == smp_processor_id())\n\t\treturn;\n\n\tif (set_nr_and_not_polling(rq->idle))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_sched_wake_idle_without_ipi",
          "args": [
            "cpu"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_send_reschedule",
          "args": [
            "cpu"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nr_and_not_polling",
          "args": [
            "rq->idle"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "set_nr_and_not_polling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "385-389",
          "snippet": "static bool set_nr_and_not_polling(struct task_struct *p)\n{\n\tset_tsk_need_resched(p);\n\treturn true;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool set_nr_and_not_polling(struct task_struct *p)\n{\n\tset_tsk_need_resched(p);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void wake_up_idle_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (cpu == smp_processor_id())\n\t\treturn;\n\n\tif (set_nr_and_not_polling(rq->idle))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
  },
  {
    "function_name": "get_nohz_timer_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "497-523",
    "snippet": "int get_nohz_timer_target(void)\n{\n\tint i, cpu = smp_processor_id();\n\tstruct sched_domain *sd;\n\n\tif (!idle_cpu(cpu) && housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\treturn cpu;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tfor_each_cpu(i, sched_domain_span(sd)) {\n\t\t\tif (cpu == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (!idle_cpu(i) && housekeeping_cpu(i, HK_FLAG_TIMER)) {\n\t\t\t\tcpu = i;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\tcpu = housekeeping_any_cpu(HK_FLAG_TIMER);\nunlock:\n\trcu_read_unlock();\n\treturn cpu;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "housekeeping_any_cpu",
          "args": [
            "HK_FLAG_TIMER"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_any_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/isolation.c",
          "lines": "16-22",
          "snippet": "int housekeeping_any_cpu(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn cpumask_any_and(housekeeping_mask, cpu_online_mask);\n\treturn smp_processor_id();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nint housekeeping_any_cpu(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn cpumask_any_and(housekeeping_mask, cpu_online_mask);\n\treturn smp_processor_id();\n}"
        }
      },
      {
        "call_info": {
          "callee": "housekeeping_cpu",
          "args": [
            "cpu",
            "HK_FLAG_TIMER"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpu",
          "args": [
            "i",
            "HK_FLAG_TIMER"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_cpu",
          "args": [
            "i"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "available_idle_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4012-4021",
          "snippet": "int available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nint available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "sched_domain_span(sd)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_domain",
          "args": [
            "cpu",
            "sd"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "housekeeping_cpu",
          "args": [
            "cpu",
            "HK_FLAG_TIMER"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint get_nohz_timer_target(void)\n{\n\tint i, cpu = smp_processor_id();\n\tstruct sched_domain *sd;\n\n\tif (!idle_cpu(cpu) && housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\treturn cpu;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tfor_each_cpu(i, sched_domain_span(sd)) {\n\t\t\tif (cpu == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (!idle_cpu(i) && housekeeping_cpu(i, HK_FLAG_TIMER)) {\n\t\t\t\tcpu = i;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\tcpu = housekeeping_any_cpu(HK_FLAG_TIMER);\nunlock:\n\trcu_read_unlock();\n\treturn cpu;\n}"
  },
  {
    "function_name": "resched_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "476-485",
    "snippet": "void resched_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\tif (cpu_online(cpu) || cpu == smp_processor_id())\n\t\tresched_curr(rq);\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rq->lock",
            "flags"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rq->lock",
            "flags"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\tif (cpu_online(cpu) || cpu == smp_processor_id())\n\t\tresched_curr(rq);\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n}"
  },
  {
    "function_name": "resched_curr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "452-474",
    "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_sched_wake_idle_without_ipi",
          "args": [
            "cpu"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_send_reschedule",
          "args": [
            "cpu"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nr_and_not_polling",
          "args": [
            "curr"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "set_nr_and_not_polling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "385-389",
          "snippet": "static bool set_nr_and_not_polling(struct task_struct *p)\n{\n\tset_tsk_need_resched(p);\n\treturn true;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool set_nr_and_not_polling(struct task_struct *p)\n{\n\tset_tsk_need_resched(p);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "curr"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "928-935",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_tsk_need_resched",
          "args": [
            "curr"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rq->lock"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
  },
  {
    "function_name": "wake_up_q",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "423-443",
    "snippet": "void wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\tBUG_ON(!task);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!task"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structtask_struct",
            "wake_q"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\tBUG_ON(!task);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}"
  },
  {
    "function_name": "wake_q_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "399-421",
    "snippet": "void wake_q_add(struct wake_q_head *head, struct task_struct *task)\n{\n\tstruct wake_q_node *node = &task->wake_q;\n\n\t/*\n\t * Atomically grab the task, if ->wake_q is !nil already it means\n\t * its already queued (either by us or someone else) and will get the\n\t * wakeup due to that.\n\t *\n\t * This cmpxchg() executes a full barrier, which pairs with the full\n\t * barrier executed by the wakeup in wake_up_q().\n\t */\n\tif (cmpxchg(&node->next, NULL, WAKE_Q_TAIL))\n\t\treturn;\n\n\tget_task_struct(task);\n\n\t/*\n\t * The head is context local, there can be no concurrency.\n\t */\n\t*head->lastp = node;\n\thead->lastp = &node->next;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "task"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&node->next",
            "NULL",
            "WAKE_Q_TAIL"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid wake_q_add(struct wake_q_head *head, struct task_struct *task)\n{\n\tstruct wake_q_node *node = &task->wake_q;\n\n\t/*\n\t * Atomically grab the task, if ->wake_q is !nil already it means\n\t * its already queued (either by us or someone else) and will get the\n\t * wakeup due to that.\n\t *\n\t * This cmpxchg() executes a full barrier, which pairs with the full\n\t * barrier executed by the wakeup in wake_up_q().\n\t */\n\tif (cmpxchg(&node->next, NULL, WAKE_Q_TAIL))\n\t\treturn;\n\n\tget_task_struct(task);\n\n\t/*\n\t * The head is context local, there can be no concurrency.\n\t */\n\t*head->lastp = node;\n\thead->lastp = &node->next;\n}"
  },
  {
    "function_name": "set_nr_if_polling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "392-395",
    "snippet": "static bool set_nr_if_polling(struct task_struct *p)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool set_nr_if_polling(struct task_struct *p)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "set_nr_and_not_polling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "385-389",
    "snippet": "static bool set_nr_and_not_polling(struct task_struct *p)\n{\n\tset_tsk_need_resched(p);\n\treturn true;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "p"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool set_nr_and_not_polling(struct task_struct *p)\n{\n\tset_tsk_need_resched(p);\n\treturn true;\n}"
  },
  {
    "function_name": "set_nr_if_polling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "366-382",
    "snippet": "static bool set_nr_if_polling(struct task_struct *p)\n{\n\tstruct thread_info *ti = task_thread_info(p);\n\ttypeof(ti->flags) old, val = READ_ONCE(ti->flags);\n\n\tfor (;;) {\n\t\tif (!(val & _TIF_POLLING_NRFLAG))\n\t\t\treturn false;\n\t\tif (val & _TIF_NEED_RESCHED)\n\t\t\treturn true;\n\t\told = cmpxchg(&ti->flags, val, val | _TIF_NEED_RESCHED);\n\t\tif (old == val)\n\t\t\tbreak;\n\t\tval = old;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&ti->flags",
            "val",
            "val | _TIF_NEED_RESCHED"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ti->flags"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "ti->flags"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_thread_info",
          "args": [
            "p"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool set_nr_if_polling(struct task_struct *p)\n{\n\tstruct thread_info *ti = task_thread_info(p);\n\ttypeof(ti->flags) old, val = READ_ONCE(ti->flags);\n\n\tfor (;;) {\n\t\tif (!(val & _TIF_POLLING_NRFLAG))\n\t\t\treturn false;\n\t\tif (val & _TIF_NEED_RESCHED)\n\t\t\treturn true;\n\t\told = cmpxchg(&ti->flags, val, val | _TIF_NEED_RESCHED);\n\t\tif (old == val)\n\t\t\tbreak;\n\t\tval = old;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "set_nr_and_not_polling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "354-358",
    "snippet": "static bool set_nr_and_not_polling(struct task_struct *p)\n{\n\tstruct thread_info *ti = task_thread_info(p);\n\treturn !(fetch_or(&ti->flags, _TIF_NEED_RESCHED) & _TIF_POLLING_NRFLAG);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fetch_or",
          "args": [
            "&ti->flags",
            "_TIF_NEED_RESCHED"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_thread_info",
          "args": [
            "p"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic bool set_nr_and_not_polling(struct task_struct *p)\n{\n\tstruct thread_info *ti = task_thread_info(p);\n\treturn !(fetch_or(&ti->flags, _TIF_NEED_RESCHED) & _TIF_POLLING_NRFLAG);\n}"
  },
  {
    "function_name": "hrtick_rq_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "325-327",
    "snippet": "static inline void hrtick_rq_init(struct rq *rq)\n{\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void hrtick_rq_init(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "hrtick_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "321-323",
    "snippet": "static inline void hrtick_clear(struct rq *rq)\n{\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic inline void hrtick_clear(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "hrtick_rq_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "307-319",
    "snippet": "static void hrtick_rq_init(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\trq->hrtick_csd_pending = 0;\n\n\trq->hrtick_csd.flags = 0;\n\trq->hrtick_csd.func = __hrtick_start;\n\trq->hrtick_csd.info = rq;\n#endif\n\n\thrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\trq->hrtick_timer.function = hrtick;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&rq->hrtick_timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void hrtick_rq_init(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\trq->hrtick_csd_pending = 0;\n\n\trq->hrtick_csd.flags = 0;\n\trq->hrtick_csd.func = __hrtick_start;\n\trq->hrtick_csd.info = rq;\n#endif\n\n\thrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\trq->hrtick_timer.function = hrtick;\n}"
  },
  {
    "function_name": "hrtick_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "295-304",
    "snippet": "void hrtick_start(struct rq *rq, u64 delay)\n{\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense. Rely on vruntime for fairness.\n\t */\n\tdelay = max_t(u64, delay, 10000LL);\n\thrtimer_start(&rq->hrtick_timer, ns_to_ktime(delay),\n\t\t      HRTIMER_MODE_REL_PINNED);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&rq->hrtick_timer",
            "ns_to_ktime(delay)",
            "HRTIMER_MODE_REL_PINNED"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "delay"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "delay",
            "10000LL"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1397-1431",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid hrtick_start(struct rq *rq, u64 delay)\n{\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense. Rely on vruntime for fairness.\n\t */\n\tdelay = max_t(u64, delay, 10000LL);\n\thrtimer_start(&rq->hrtick_timer, ns_to_ktime(delay),\n\t\t      HRTIMER_MODE_REL_PINNED);\n}"
  },
  {
    "function_name": "hrtick_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "266-287",
    "snippet": "void hrtick_start(struct rq *rq, u64 delay)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\tktime_t time;\n\ts64 delta;\n\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense and can cause timer DoS.\n\t */\n\tdelta = max_t(s64, delay, 10000LL);\n\ttime = ktime_add_ns(timer->base->get_time(), delta);\n\n\thrtimer_set_expires(timer, time);\n\n\tif (rq == this_rq()) {\n\t\t__hrtick_restart(rq);\n\t} else if (!rq->hrtick_csd_pending) {\n\t\tsmp_call_function_single_async(cpu_of(rq), &rq->hrtick_csd);\n\t\trq->hrtick_csd_pending = 1;\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single_async",
          "args": [
            "cpu_of(rq)",
            "&rq->hrtick_csd"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "26-34",
          "snippet": "int smp_call_function_single_async(int cpu, call_single_data_t *csd)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tcsd->func(csd->info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single_async(int cpu, call_single_data_t *csd)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tcsd->func(csd->info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "928-935",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtick_restart",
          "args": [
            "rq"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtick_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "240-245",
          "snippet": "static void __hrtick_restart(struct rq *rq)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\n\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __hrtick_restart(struct rq *rq)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\n\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "timer",
            "time"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "timer->base->get_time()",
            "delta"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer->base->get_time",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "s64",
            "delay",
            "10000LL"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1397-1431",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid hrtick_start(struct rq *rq, u64 delay)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\tktime_t time;\n\ts64 delta;\n\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense and can cause timer DoS.\n\t */\n\tdelta = max_t(s64, delay, 10000LL);\n\ttime = ktime_add_ns(timer->base->get_time(), delta);\n\n\thrtimer_set_expires(timer, time);\n\n\tif (rq == this_rq()) {\n\t\t__hrtick_restart(rq);\n\t} else if (!rq->hrtick_csd_pending) {\n\t\tsmp_call_function_single_async(cpu_of(rq), &rq->hrtick_csd);\n\t\trq->hrtick_csd_pending = 1;\n\t}\n}"
  },
  {
    "function_name": "__hrtick_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "250-259",
    "snippet": "static void __hrtick_start(void *arg)\n{\n\tstruct rq *rq = arg;\n\tstruct rq_flags rf;\n\n\trq_lock(rq, &rf);\n\t__hrtick_restart(rq);\n\trq->hrtick_csd_pending = 0;\n\trq_unlock(rq, &rf);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_unlock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtick_restart",
          "args": [
            "rq"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtick_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "240-245",
          "snippet": "static void __hrtick_restart(struct rq *rq)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\n\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __hrtick_restart(struct rq *rq)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\n\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __hrtick_start(void *arg)\n{\n\tstruct rq *rq = arg;\n\tstruct rq_flags rf;\n\n\trq_lock(rq, &rf);\n\t__hrtick_restart(rq);\n\trq->hrtick_csd_pending = 0;\n\trq_unlock(rq, &rf);\n}"
  },
  {
    "function_name": "__hrtick_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "240-245",
    "snippet": "static void __hrtick_restart(struct rq *rq)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\n\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "timer",
            "HRTIMER_MODE_ABS_PINNED"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __hrtick_restart(struct rq *rq)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\n\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n}"
  },
  {
    "function_name": "hrtick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "223-236",
    "snippet": "static enum hrtimer_restart hrtick(struct hrtimer *timer)\n{\n\tstruct rq *rq = container_of(timer, struct rq, hrtick_timer);\n\tstruct rq_flags rf;\n\n\tWARN_ON_ONCE(cpu_of(rq) != smp_processor_id());\n\n\trq_lock(rq, &rf);\n\tupdate_rq_clock(rq);\n\trq->curr->sched_class->task_tick(rq, rq->curr, 1);\n\trq_unlock(rq, &rf);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_unlock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "double_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2053-2060",
          "snippet": "static inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq->curr->sched_class->task_tick",
          "args": [
            "rq",
            "rq->curr",
            "1"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu_of(rq) != smp_processor_id()"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "928-935",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structrq",
            "hrtick_timer"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic enum hrtimer_restart hrtick(struct hrtimer *timer)\n{\n\tstruct rq *rq = container_of(timer, struct rq, hrtick_timer);\n\tstruct rq_flags rf;\n\n\tWARN_ON_ONCE(cpu_of(rq) != smp_processor_id());\n\n\trq_lock(rq, &rf);\n\tupdate_rq_clock(rq);\n\trq->curr->sched_class->task_tick(rq, rq->curr, 1);\n\trq_unlock(rq, &rf);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "hrtick_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "213-217",
    "snippet": "static void hrtick_clear(struct rq *rq)\n{\n\tif (hrtimer_active(&rq->hrtick_timer))\n\t\thrtimer_cancel(&rq->hrtick_timer);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&rq->hrtick_timer"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "&rq->hrtick_timer"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1320-1337",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void hrtick_clear(struct rq *rq)\n{\n\tif (hrtimer_active(&rq->hrtick_timer))\n\t\thrtimer_cancel(&rq->hrtick_timer);\n}"
  },
  {
    "function_name": "update_rq_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "185-205",
    "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_rq_clock_task",
          "args": [
            "rq",
            "delta"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "132-183",
          "snippet": "static void update_rq_clock_task(struct rq *rq, s64 delta)\n{\n/*\n * In theory, the compile should just see 0 here, and optimize out the call\n * to sched_rt_avg_update. But I don't trust it...\n */\n\ts64 __maybe_unused steal = 0, irq_delta = 0;\n\n#ifdef CONFIG_IRQ_TIME_ACCOUNTING\n\tirq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time;\n\n\t/*\n\t * Since irq_time is only updated on {soft,}irq_exit, we might run into\n\t * this case when a previous update_rq_clock() happened inside a\n\t * {soft,}irq region.\n\t *\n\t * When this happens, we stop ->clock_task and only update the\n\t * prev_irq_time stamp to account for the part that fit, so that a next\n\t * update will consume the rest. This ensures ->clock_task is\n\t * monotonic.\n\t *\n\t * It does however cause some slight miss-attribution of {soft,}irq\n\t * time, a more accurate solution would be to update the irq_time using\n\t * the current rq->clock timestamp, except that would require using\n\t * atomic ops.\n\t */\n\tif (irq_delta > delta)\n\t\tirq_delta = delta;\n\n\trq->prev_irq_time += irq_delta;\n\tdelta -= irq_delta;\n#endif\n#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING\n\tif (static_key_false((&paravirt_steal_rq_enabled))) {\n\t\tsteal = paravirt_steal_clock(cpu_of(rq));\n\t\tsteal -= rq->prev_steal_time_rq;\n\n\t\tif (unlikely(steal > delta))\n\t\t\tsteal = delta;\n\n\t\trq->prev_steal_time_rq += steal;\n\t\tdelta -= steal;\n\t}\n#endif\n\n\trq->clock_task += delta;\n\n#ifdef CONFIG_HAVE_SCHED_AVG_IRQ\n\tif ((irq_delta + steal) && sched_feat(NONTASK_CAPACITY))\n\t\tupdate_irq_load_avg(rq, irq_delta + steal);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void update_rq_clock_task(struct rq *rq, s64 delta)\n{\n/*\n * In theory, the compile should just see 0 here, and optimize out the call\n * to sched_rt_avg_update. But I don't trust it...\n */\n\ts64 __maybe_unused steal = 0, irq_delta = 0;\n\n#ifdef CONFIG_IRQ_TIME_ACCOUNTING\n\tirq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time;\n\n\t/*\n\t * Since irq_time is only updated on {soft,}irq_exit, we might run into\n\t * this case when a previous update_rq_clock() happened inside a\n\t * {soft,}irq region.\n\t *\n\t * When this happens, we stop ->clock_task and only update the\n\t * prev_irq_time stamp to account for the part that fit, so that a next\n\t * update will consume the rest. This ensures ->clock_task is\n\t * monotonic.\n\t *\n\t * It does however cause some slight miss-attribution of {soft,}irq\n\t * time, a more accurate solution would be to update the irq_time using\n\t * the current rq->clock timestamp, except that would require using\n\t * atomic ops.\n\t */\n\tif (irq_delta > delta)\n\t\tirq_delta = delta;\n\n\trq->prev_irq_time += irq_delta;\n\tdelta -= irq_delta;\n#endif\n#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING\n\tif (static_key_false((&paravirt_steal_rq_enabled))) {\n\t\tsteal = paravirt_steal_clock(cpu_of(rq));\n\t\tsteal -= rq->prev_steal_time_rq;\n\n\t\tif (unlikely(steal > delta))\n\t\t\tsteal = delta;\n\n\t\trq->prev_steal_time_rq += steal;\n\t\tdelta -= steal;\n\t}\n#endif\n\n\trq->clock_task += delta;\n\n#ifdef CONFIG_HAVE_SCHED_AVG_IRQ\n\tif ((irq_delta + steal) && sched_feat(NONTASK_CAPACITY))\n\t\tupdate_irq_load_avg(rq, irq_delta + steal);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_cpu",
          "args": [
            "cpu_of(rq)"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "460-466",
          "snippet": "u64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nu64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "928-935",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "rq->clock_update_flags & RQCF_UPDATED"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_feat",
          "args": [
            "WARN_DOUBLE_CLOCK"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "sched_feat_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "104-127",
          "snippet": "static int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const sched_feat_names[] = {\n#include \"features.h\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic const char * const sched_feat_names[] = {\n#include \"features.h\"\n};\n\nstatic int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rq->lock"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
  },
  {
    "function_name": "update_rq_clock_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "132-183",
    "snippet": "static void update_rq_clock_task(struct rq *rq, s64 delta)\n{\n/*\n * In theory, the compile should just see 0 here, and optimize out the call\n * to sched_rt_avg_update. But I don't trust it...\n */\n\ts64 __maybe_unused steal = 0, irq_delta = 0;\n\n#ifdef CONFIG_IRQ_TIME_ACCOUNTING\n\tirq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time;\n\n\t/*\n\t * Since irq_time is only updated on {soft,}irq_exit, we might run into\n\t * this case when a previous update_rq_clock() happened inside a\n\t * {soft,}irq region.\n\t *\n\t * When this happens, we stop ->clock_task and only update the\n\t * prev_irq_time stamp to account for the part that fit, so that a next\n\t * update will consume the rest. This ensures ->clock_task is\n\t * monotonic.\n\t *\n\t * It does however cause some slight miss-attribution of {soft,}irq\n\t * time, a more accurate solution would be to update the irq_time using\n\t * the current rq->clock timestamp, except that would require using\n\t * atomic ops.\n\t */\n\tif (irq_delta > delta)\n\t\tirq_delta = delta;\n\n\trq->prev_irq_time += irq_delta;\n\tdelta -= irq_delta;\n#endif\n#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING\n\tif (static_key_false((&paravirt_steal_rq_enabled))) {\n\t\tsteal = paravirt_steal_clock(cpu_of(rq));\n\t\tsteal -= rq->prev_steal_time_rq;\n\n\t\tif (unlikely(steal > delta))\n\t\t\tsteal = delta;\n\n\t\trq->prev_steal_time_rq += steal;\n\t\tdelta -= steal;\n\t}\n#endif\n\n\trq->clock_task += delta;\n\n#ifdef CONFIG_HAVE_SCHED_AVG_IRQ\n\tif ((irq_delta + steal) && sched_feat(NONTASK_CAPACITY))\n\t\tupdate_irq_load_avg(rq, irq_delta + steal);\n#endif\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_irq_load_avg",
          "args": [
            "rq",
            "irq_delta + steal"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "update_irq_load_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.h",
          "lines": "65-69",
          "snippet": "static inline int\nupdate_irq_load_avg(struct rq *rq, u64 running)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nupdate_irq_load_avg(struct rq *rq, u64 running)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_feat",
          "args": [
            "NONTASK_CAPACITY"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "sched_feat_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "104-127",
          "snippet": "static int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const sched_feat_names[] = {\n#include \"features.h\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic const char * const sched_feat_names[] = {\n#include \"features.h\"\n};\n\nstatic int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"NO_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\ti = match_string(sched_feat_names, __SCHED_FEAT_NR, cmp);\n\tif (i < 0)\n\t\treturn i;\n\n\tif (neg) {\n\t\tsysctl_sched_features &= ~(1UL << i);\n\t\tsched_feat_disable(i);\n\t} else {\n\t\tsysctl_sched_features |= (1UL << i);\n\t\tsched_feat_enable(i);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "steal > delta"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paravirt_steal_clock",
          "args": [
            "cpu_of(rq)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "928-935",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_false",
          "args": [
            "(&paravirt_steal_rq_enabled)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_time_read",
          "args": [
            "cpu_of(rq)"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "irq_time_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2150-2162",
          "snippet": "static inline u64 irq_time_read(int cpu)\n{\n\tstruct irqtime *irqtime = &per_cpu(cpu_irqtime, cpu);\n\tunsigned int seq;\n\tu64 total;\n\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&irqtime->sync);\n\t\ttotal = irqtime->total;\n\t} while (__u64_stats_fetch_retry(&irqtime->sync, seq));\n\n\treturn total;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline u64 irq_time_read(int cpu)\n{\n\tstruct irqtime *irqtime = &per_cpu(cpu_irqtime, cpu);\n\tunsigned int seq;\n\tu64 total;\n\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&irqtime->sync);\n\t\ttotal = irqtime->total;\n\t} while (__u64_stats_fetch_retry(&irqtime->sync, seq));\n\n\treturn total;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void update_rq_clock_task(struct rq *rq, s64 delta)\n{\n/*\n * In theory, the compile should just see 0 here, and optimize out the call\n * to sched_rt_avg_update. But I don't trust it...\n */\n\ts64 __maybe_unused steal = 0, irq_delta = 0;\n\n#ifdef CONFIG_IRQ_TIME_ACCOUNTING\n\tirq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time;\n\n\t/*\n\t * Since irq_time is only updated on {soft,}irq_exit, we might run into\n\t * this case when a previous update_rq_clock() happened inside a\n\t * {soft,}irq region.\n\t *\n\t * When this happens, we stop ->clock_task and only update the\n\t * prev_irq_time stamp to account for the part that fit, so that a next\n\t * update will consume the rest. This ensures ->clock_task is\n\t * monotonic.\n\t *\n\t * It does however cause some slight miss-attribution of {soft,}irq\n\t * time, a more accurate solution would be to update the irq_time using\n\t * the current rq->clock timestamp, except that would require using\n\t * atomic ops.\n\t */\n\tif (irq_delta > delta)\n\t\tirq_delta = delta;\n\n\trq->prev_irq_time += irq_delta;\n\tdelta -= irq_delta;\n#endif\n#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING\n\tif (static_key_false((&paravirt_steal_rq_enabled))) {\n\t\tsteal = paravirt_steal_clock(cpu_of(rq));\n\t\tsteal -= rq->prev_steal_time_rq;\n\n\t\tif (unlikely(steal > delta))\n\t\t\tsteal = delta;\n\n\t\trq->prev_steal_time_rq += steal;\n\t\tdelta -= steal;\n\t}\n#endif\n\n\trq->clock_task += delta;\n\n#ifdef CONFIG_HAVE_SCHED_AVG_IRQ\n\tif ((irq_delta + steal) && sched_feat(NONTASK_CAPACITY))\n\t\tupdate_irq_load_avg(rq, irq_delta + steal);\n#endif\n}"
  },
  {
    "function_name": "task_rq_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "90-126",
    "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task_on_rq_migrating(p)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_migrating",
          "args": [
            "p"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_migrating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1540-1543",
          "snippet": "static inline int task_on_rq_migrating(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_MIGRATING;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_MIGRATING\t2"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_MIGRATING\t2\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_migrating(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_MIGRATING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&p->pi_lock",
            "rf->flags"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rq->lock"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_pin_lock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "rq_pin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1050-1058",
          "snippet": "static inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\trf->cookie = lockdep_pin_lock(&rq->lock);\n\n#ifdef CONFIG_SCHED_DEBUG\n\trq->clock_update_flags &= (RQCF_REQ_SKIP|RQCF_ACT_SKIP);\n\trf->clock_update_flags = 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_ACT_SKIP\t\t0x02",
            "#define RQCF_REQ_SKIP\t\t0x01"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_ACT_SKIP\t\t0x02\n#define RQCF_REQ_SKIP\t\t0x01\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\trf->cookie = lockdep_pin_lock(&rq->lock);\n\n#ifdef CONFIG_SCHED_DEBUG\n\trq->clock_update_flags &= (RQCF_REQ_SKIP|RQCF_ACT_SKIP);\n\trf->clock_update_flags = 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rq == task_rq(p) && !task_on_rq_migrating(p)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rq->lock"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&p->pi_lock",
            "rf->flags"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "rq->lock"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "p->pi_lock"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "__task_rq_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "66-85",
    "snippet": "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task_on_rq_migrating(p)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_migrating",
          "args": [
            "p"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_migrating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1540-1543",
          "snippet": "static inline int task_on_rq_migrating(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_MIGRATING;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_MIGRATING\t2"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_MIGRATING\t2\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_migrating(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_MIGRATING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rq->lock"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_pin_lock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "rq_pin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1050-1058",
          "snippet": "static inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\trf->cookie = lockdep_pin_lock(&rq->lock);\n\n#ifdef CONFIG_SCHED_DEBUG\n\trq->clock_update_flags &= (RQCF_REQ_SKIP|RQCF_ACT_SKIP);\n\trf->clock_update_flags = 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_ACT_SKIP\t\t0x02",
            "#define RQCF_REQ_SKIP\t\t0x01"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_ACT_SKIP\t\t0x02\n#define RQCF_REQ_SKIP\t\t0x01\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\trf->cookie = lockdep_pin_lock(&rq->lock);\n\n#ifdef CONFIG_SCHED_DEBUG\n\trq->clock_update_flags &= (RQCF_REQ_SKIP|RQCF_ACT_SKIP);\n\trf->clock_update_flags = 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rq == task_rq(p) && !task_on_rq_migrating(p)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rq->lock"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&p->pi_lock"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "rq->lock"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "nice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "3943-3965",
    "snippet": "SYSCALL_DEFINE1(nice, int, increment)\n{\n\tlong nice, retval;\n\n\t/*\n\t * Setpriority might change our priority at the same moment.\n\t * We don't have to worry. Conceptually one call occurs first\n\t * and we have a single winner.\n\t */\n\tincrement = clamp(increment, -NICE_WIDTH, NICE_WIDTH);\n\tnice = task_nice(current) + increment;\n\n\tnice = clamp_val(nice, MIN_NICE, MAX_NICE);\n\tif (increment < 0 && !can_nice(current, nice))\n\t\treturn -EPERM;\n\n\tretval = security_task_setnice(current, nice);\n\tif (retval)\n\t\treturn retval;\n\n\tset_user_nice(current, nice);\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nSYSCALL_DEFINE1(nice, int, increment)\n{\n\tlong nice, retval;\n\n\t/*\n\t * Setpriority might change our priority at the same moment.\n\t * We don't have to worry. Conceptually one call occurs first\n\t * and we have a single winner.\n\t */\n\tincrement = clamp(increment, -NICE_WIDTH, NICE_WIDTH);\n\tnice = task_nice(current) + increment;\n\n\tnice = clamp_val(nice, MIN_NICE, MAX_NICE);\n\tif (increment < 0 && !can_nice(current, nice))\n\t\treturn -EPERM;\n\n\tretval = security_task_setnice(current, nice);\n\tif (retval)\n\t\treturn retval;\n\n\tset_user_nice(current, nice);\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_setscheduler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4523-4529",
    "snippet": "SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, struct sched_param __user *, param)\n{\n\tif (policy < 0)\n\t\treturn -EINVAL;\n\n\treturn do_sched_setscheduler(pid, policy, param);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nSYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, struct sched_param __user *, param)\n{\n\tif (policy < 0)\n\t\treturn -EINVAL;\n\n\treturn do_sched_setscheduler(pid, policy, param);\n}"
  },
  {
    "function_name": "sched_setparam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4538-4541",
    "snippet": "SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param)\n{\n\treturn do_sched_setscheduler(pid, SETPARAM_POLICY, param);\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define SETPARAM_POLICY\t-1"
    ],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\n#define SETPARAM_POLICY\t-1\n\nstatic __always_inline struct;\n\nSYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param)\n{\n\treturn do_sched_setscheduler(pid, SETPARAM_POLICY, param);\n}"
  },
  {
    "function_name": "sched_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4549-4574",
    "snippet": "SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\t\t       unsigned int, flags)\n{\n\tstruct sched_attr attr;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!uattr || pid < 0 || flags)\n\t\treturn -EINVAL;\n\n\tretval = sched_copy_attr(uattr, &attr);\n\tif (retval)\n\t\treturn retval;\n\n\tif ((int)attr.sched_policy < 0)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setattr(p, &attr);\n\trcu_read_unlock();\n\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nSYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\t\t       unsigned int, flags)\n{\n\tstruct sched_attr attr;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!uattr || pid < 0 || flags)\n\t\treturn -EINVAL;\n\n\tretval = sched_copy_attr(uattr, &attr);\n\tif (retval)\n\t\treturn retval;\n\n\tif ((int)attr.sched_policy < 0)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setattr(p, &attr);\n\trcu_read_unlock();\n\n\treturn retval;\n}"
  },
  {
    "function_name": "sched_getscheduler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4583-4602",
    "snippet": "SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid)\n{\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tretval = -ESRCH;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (p) {\n\t\tretval = security_task_getscheduler(p);\n\t\tif (!retval)\n\t\t\tretval = p->policy\n\t\t\t\t| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0);\n\t}\n\trcu_read_unlock();\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nSYSCALL_DEFINE1(sched_getscheduler, pid_t, pid)\n{\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tretval = -ESRCH;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (p) {\n\t\tretval = security_task_getscheduler(p);\n\t\tif (!retval)\n\t\t\tretval = p->policy\n\t\t\t\t| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0);\n\t}\n\trcu_read_unlock();\n\treturn retval;\n}"
  },
  {
    "function_name": "sched_getparam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4612-4645",
    "snippet": "SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param)\n{\n\tstruct sched_param lp = { .sched_priority = 0 };\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -ESRCH;\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tif (task_has_rt_policy(p))\n\t\tlp.sched_priority = p->rt_priority;\n\trcu_read_unlock();\n\n\t/*\n\t * This one might sleep, we cannot do it with a spinlock held ...\n\t */\n\tretval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0;\n\n\treturn retval;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nSYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param)\n{\n\tstruct sched_param lp = { .sched_priority = 0 };\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -ESRCH;\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tif (task_has_rt_policy(p))\n\t\tlp.sched_priority = p->rt_priority;\n\trcu_read_unlock();\n\n\t/*\n\t * This one might sleep, we cannot do it with a spinlock held ...\n\t */\n\tretval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0;\n\n\treturn retval;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}"
  },
  {
    "function_name": "sched_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4690-4731",
    "snippet": "SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\tunsigned int, size, unsigned int, flags)\n{\n\tstruct sched_attr attr = {\n\t\t.size = sizeof(struct sched_attr),\n\t};\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!uattr || pid < 0 || size > PAGE_SIZE ||\n\t    size < SCHED_ATTR_SIZE_VER0 || flags)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -ESRCH;\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tattr.sched_policy = p->policy;\n\tif (p->sched_reset_on_fork)\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\tif (task_has_dl_policy(p))\n\t\t__getparam_dl(p, &attr);\n\telse if (task_has_rt_policy(p))\n\t\tattr.sched_priority = p->rt_priority;\n\telse\n\t\tattr.sched_nice = task_nice(p);\n\n\trcu_read_unlock();\n\n\tretval = sched_read_attr(uattr, &attr, size);\n\treturn retval;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nSYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\tunsigned int, size, unsigned int, flags)\n{\n\tstruct sched_attr attr = {\n\t\t.size = sizeof(struct sched_attr),\n\t};\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!uattr || pid < 0 || size > PAGE_SIZE ||\n\t    size < SCHED_ATTR_SIZE_VER0 || flags)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -ESRCH;\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tattr.sched_policy = p->policy;\n\tif (p->sched_reset_on_fork)\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\tif (task_has_dl_policy(p))\n\t\t__getparam_dl(p, &attr);\n\telse if (task_has_rt_policy(p))\n\t\tattr.sched_priority = p->rt_priority;\n\telse\n\t\tattr.sched_nice = task_nice(p);\n\n\trcu_read_unlock();\n\n\tretval = sched_read_attr(uattr, &attr, size);\n\treturn retval;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}"
  },
  {
    "function_name": "sched_setaffinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4841-4855",
    "snippet": "SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len,\n\t\tunsigned long __user *, user_mask_ptr)\n{\n\tcpumask_var_t new_mask;\n\tint retval;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tretval = get_user_cpu_mask(user_mask_ptr, len, new_mask);\n\tif (retval == 0)\n\t\tretval = sched_setaffinity(pid, new_mask);\n\tfree_cpumask_var(new_mask);\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nSYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len,\n\t\tunsigned long __user *, user_mask_ptr)\n{\n\tcpumask_var_t new_mask;\n\tint retval;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tretval = get_user_cpu_mask(user_mask_ptr, len, new_mask);\n\tif (retval == 0)\n\t\tretval = sched_setaffinity(pid, new_mask);\n\tfree_cpumask_var(new_mask);\n\treturn retval;\n}"
  },
  {
    "function_name": "sched_getaffinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4893-4919",
    "snippet": "SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len,\n\t\tunsigned long __user *, user_mask_ptr)\n{\n\tint ret;\n\tcpumask_var_t mask;\n\n\tif ((len * BITS_PER_BYTE) < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (len & (sizeof(unsigned long)-1))\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tunsigned int retlen = min(len, cpumask_size());\n\n\t\tif (copy_to_user(user_mask_ptr, mask, retlen))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nSYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len,\n\t\tunsigned long __user *, user_mask_ptr)\n{\n\tint ret;\n\tcpumask_var_t mask;\n\n\tif ((len * BITS_PER_BYTE) < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (len & (sizeof(unsigned long)-1))\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tunsigned int retlen = min(len, cpumask_size());\n\n\t\tif (copy_to_user(user_mask_ptr, mask, retlen))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sched_yield",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "4950-4954",
    "snippet": "SYSCALL_DEFINE0(sched_yield)\n{\n\tdo_sched_yield();\n\treturn 0;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nSYSCALL_DEFINE0(sched_yield)\n{\n\tdo_sched_yield();\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_get_priority_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5150-5167",
    "snippet": "SYSCALL_DEFINE1(sched_get_priority_max, int, policy)\n{\n\tint ret = -EINVAL;\n\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = MAX_USER_RT_PRIO-1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nSYSCALL_DEFINE1(sched_get_priority_max, int, policy)\n{\n\tint ret = -EINVAL;\n\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = MAX_USER_RT_PRIO-1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sched_get_priority_min",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5177-5193",
    "snippet": "SYSCALL_DEFINE1(sched_get_priority_min, int, policy)\n{\n\tint ret = -EINVAL;\n\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = 1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nSYSCALL_DEFINE1(sched_get_priority_min, int, policy)\n{\n\tint ret = -EINVAL;\n\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = 1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sched_rr_get_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5242-5252",
    "snippet": "SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid,\n\t\tstruct __kernel_timespec __user *, interval)\n{\n\tstruct timespec64 t;\n\tint retval = sched_rr_get_interval(pid, &t);\n\n\tif (retval == 0)\n\t\tretval = put_timespec64(&t, interval);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nSYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid,\n\t\tstruct __kernel_timespec __user *, interval)\n{\n\tstruct timespec64 t;\n\tint retval = sched_rr_get_interval(pid, &t);\n\n\tif (retval == 0)\n\t\tretval = put_timespec64(&t, interval);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "sched_rr_get_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
    "lines": "5255-5265",
    "snippet": "SYSCALL_DEFINE2(sched_rr_get_interval,\n\t\t       compat_pid_t, pid,\n\t\t       struct old_timespec32 __user *, interval)\n{\n\tstruct timespec64 t;\n\tint retval = sched_rr_get_interval(pid, &t);\n\n\tif (retval == 0)\n\t\tretval = put_old_timespec32(&t, interval);\n\treturn retval;\n}",
    "includes": [
      "#include \"features.h\"",
      "#include <trace/events/sched.h>",
      "#include \"pelt.h\"",
      "#include \"../smpboot.h\"",
      "#include \"../workqueue_internal.h\"",
      "#include <asm/tlb.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/kcov.h>",
      "#include <linux/nospec.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nSYSCALL_DEFINE2(sched_rr_get_interval,\n\t\t       compat_pid_t, pid,\n\t\t       struct old_timespec32 __user *, interval)\n{\n\tstruct timespec64 t;\n\tint retval = sched_rr_get_interval(pid, &t);\n\n\tif (retval == 0)\n\t\tretval = put_old_timespec32(&t, interval);\n\treturn retval;\n}"
  }
]