[
  {
    "function_name": "init_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "674-708",
    "snippet": "int __init init_hw_breakpoint(void)\n{\n\tint cpu, err_cpu;\n\tint i;\n\n\tfor (i = 0; i < TYPE_MAX; i++)\n\t\tnr_slots[i] = hw_breakpoint_slots(i);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < TYPE_MAX; i++) {\n\t\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, i);\n\n\t\t\tinfo->tsk_pinned = kcalloc(nr_slots[i], sizeof(int),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!info->tsk_pinned)\n\t\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\tconstraints_initialized = 1;\n\n\tperf_pmu_register(&perf_breakpoint, \"breakpoint\", PERF_TYPE_BREAKPOINT);\n\n\treturn register_die_notifier(&hw_breakpoint_exceptions_nb);\n\n err_alloc:\n\tfor_each_possible_cpu(err_cpu) {\n\t\tfor (i = 0; i < TYPE_MAX; i++)\n\t\t\tkfree(get_bp_info(err_cpu, i)->tsk_pinned);\n\t\tif (err_cpu == cpu)\n\t\t\tbreak;\n\t}\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);",
      "static int nr_slots[TYPE_MAX];",
      "static int constraints_initialized;",
      "static struct notifier_block hw_breakpoint_exceptions_nb = {\n\t.notifier_call = hw_breakpoint_exceptions_notify,\n\t/* we need to be notified first */\n\t.priority = 0x7fffffff\n};",
      "static struct pmu perf_breakpoint = {\n\t.task_ctx_nr\t= perf_sw_context, /* could eventually get its own */\n\n\t.event_init\t= hw_breakpoint_event_init,\n\t.add\t\t= hw_breakpoint_add,\n\t.del\t\t= hw_breakpoint_del,\n\t.start\t\t= hw_breakpoint_start,\n\t.stop\t\t= hw_breakpoint_stop,\n\t.read\t\t= hw_breakpoint_pmu_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "get_bp_info(err_cpu, i)->tsk_pinned"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bp_info",
          "args": [
            "err_cpu",
            "i"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "get_bp_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "65-68",
          "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_die_notifier",
          "args": [
            "&hw_breakpoint_exceptions_nb"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_die_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "560-563",
          "snippet": "int unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ATOMIC_NOTIFIER_HEAD(die_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(die_chain);\n\nint unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_pmu_register",
          "args": [
            "&perf_breakpoint",
            "\"breakpoint\"",
            "PERF_TYPE_BREAKPOINT"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "perf_pmu_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "9603-9716",
          "snippet": "int perf_pmu_register(struct pmu *pmu, const char *name, int type)\n{\n\tint cpu, ret;\n\n\tmutex_lock(&pmus_lock);\n\tret = -ENOMEM;\n\tpmu->pmu_disable_count = alloc_percpu(int);\n\tif (!pmu->pmu_disable_count)\n\t\tgoto unlock;\n\n\tpmu->type = -1;\n\tif (!name)\n\t\tgoto skip_type;\n\tpmu->name = name;\n\n\tif (type < 0) {\n\t\ttype = idr_alloc(&pmu_idr, pmu, PERF_TYPE_MAX, 0, GFP_KERNEL);\n\t\tif (type < 0) {\n\t\t\tret = type;\n\t\t\tgoto free_pdc;\n\t\t}\n\t}\n\tpmu->type = type;\n\n\tif (pmu_bus_running) {\n\t\tret = pmu_dev_alloc(pmu);\n\t\tif (ret)\n\t\t\tgoto free_idr;\n\t}\n\nskip_type:\n\tif (pmu->task_ctx_nr == perf_hw_context) {\n\t\tstatic int hw_context_taken = 0;\n\n\t\t/*\n\t\t * Other than systems with heterogeneous CPUs, it never makes\n\t\t * sense for two PMUs to share perf_hw_context. PMUs which are\n\t\t * uncore must use perf_invalid_context.\n\t\t */\n\t\tif (WARN_ON_ONCE(hw_context_taken &&\n\t\t    !(pmu->capabilities & PERF_PMU_CAP_HETEROGENEOUS_CPUS)))\n\t\t\tpmu->task_ctx_nr = perf_invalid_context;\n\n\t\thw_context_taken = 1;\n\t}\n\n\tpmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);\n\tif (pmu->pmu_cpu_context)\n\t\tgoto got_cpu_context;\n\n\tret = -ENOMEM;\n\tpmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);\n\tif (!pmu->pmu_cpu_context)\n\t\tgoto free_dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\t__perf_event_init_context(&cpuctx->ctx);\n\t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);\n\t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);\n\t\tcpuctx->ctx.pmu = pmu;\n\t\tcpuctx->online = cpumask_test_cpu(cpu, perf_online_mask);\n\n\t\t__perf_mux_hrtimer_init(cpuctx, cpu);\n\t}\n\ngot_cpu_context:\n\tif (!pmu->start_txn) {\n\t\tif (pmu->pmu_enable) {\n\t\t\t/*\n\t\t\t * If we have pmu_enable/pmu_disable calls, install\n\t\t\t * transaction stubs that use that to try and batch\n\t\t\t * hardware accesses.\n\t\t\t */\n\t\t\tpmu->start_txn  = perf_pmu_start_txn;\n\t\t\tpmu->commit_txn = perf_pmu_commit_txn;\n\t\t\tpmu->cancel_txn = perf_pmu_cancel_txn;\n\t\t} else {\n\t\t\tpmu->start_txn  = perf_pmu_nop_txn;\n\t\t\tpmu->commit_txn = perf_pmu_nop_int;\n\t\t\tpmu->cancel_txn = perf_pmu_nop_void;\n\t\t}\n\t}\n\n\tif (!pmu->pmu_enable) {\n\t\tpmu->pmu_enable  = perf_pmu_nop_void;\n\t\tpmu->pmu_disable = perf_pmu_nop_void;\n\t}\n\n\tif (!pmu->event_idx)\n\t\tpmu->event_idx = perf_event_idx_default;\n\n\tlist_add_rcu(&pmu->entry, &pmus);\n\tatomic_set(&pmu->exclusive_cnt, 0);\n\tret = 0;\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n\nfree_dev:\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\nfree_idr:\n\tif (pmu->type >= PERF_TYPE_MAX)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\nfree_pdc:\n\tfree_percpu(pmu->pmu_disable_count);\n\tgoto unlock;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(pmus);",
            "static DEFINE_MUTEX(pmus_lock);",
            "static cpumask_var_t perf_online_mask;",
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static __must_check struct",
            "static struct idr pmu_idr;",
            "static DEVICE_ATTR_RO(type);",
            "static int pmu_bus_running;",
            "static struct lock_class_key cpuctx_mutex;",
            "static struct lock_class_key cpuctx_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic LIST_HEAD(pmus);\nstatic DEFINE_MUTEX(pmus_lock);\nstatic cpumask_var_t perf_online_mask;\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic __must_check struct;\nstatic struct idr pmu_idr;\nstatic DEVICE_ATTR_RO(type);\nstatic int pmu_bus_running;\nstatic struct lock_class_key cpuctx_mutex;\nstatic struct lock_class_key cpuctx_lock;\n\nint perf_pmu_register(struct pmu *pmu, const char *name, int type)\n{\n\tint cpu, ret;\n\n\tmutex_lock(&pmus_lock);\n\tret = -ENOMEM;\n\tpmu->pmu_disable_count = alloc_percpu(int);\n\tif (!pmu->pmu_disable_count)\n\t\tgoto unlock;\n\n\tpmu->type = -1;\n\tif (!name)\n\t\tgoto skip_type;\n\tpmu->name = name;\n\n\tif (type < 0) {\n\t\ttype = idr_alloc(&pmu_idr, pmu, PERF_TYPE_MAX, 0, GFP_KERNEL);\n\t\tif (type < 0) {\n\t\t\tret = type;\n\t\t\tgoto free_pdc;\n\t\t}\n\t}\n\tpmu->type = type;\n\n\tif (pmu_bus_running) {\n\t\tret = pmu_dev_alloc(pmu);\n\t\tif (ret)\n\t\t\tgoto free_idr;\n\t}\n\nskip_type:\n\tif (pmu->task_ctx_nr == perf_hw_context) {\n\t\tstatic int hw_context_taken = 0;\n\n\t\t/*\n\t\t * Other than systems with heterogeneous CPUs, it never makes\n\t\t * sense for two PMUs to share perf_hw_context. PMUs which are\n\t\t * uncore must use perf_invalid_context.\n\t\t */\n\t\tif (WARN_ON_ONCE(hw_context_taken &&\n\t\t    !(pmu->capabilities & PERF_PMU_CAP_HETEROGENEOUS_CPUS)))\n\t\t\tpmu->task_ctx_nr = perf_invalid_context;\n\n\t\thw_context_taken = 1;\n\t}\n\n\tpmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);\n\tif (pmu->pmu_cpu_context)\n\t\tgoto got_cpu_context;\n\n\tret = -ENOMEM;\n\tpmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);\n\tif (!pmu->pmu_cpu_context)\n\t\tgoto free_dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\t__perf_event_init_context(&cpuctx->ctx);\n\t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);\n\t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);\n\t\tcpuctx->ctx.pmu = pmu;\n\t\tcpuctx->online = cpumask_test_cpu(cpu, perf_online_mask);\n\n\t\t__perf_mux_hrtimer_init(cpuctx, cpu);\n\t}\n\ngot_cpu_context:\n\tif (!pmu->start_txn) {\n\t\tif (pmu->pmu_enable) {\n\t\t\t/*\n\t\t\t * If we have pmu_enable/pmu_disable calls, install\n\t\t\t * transaction stubs that use that to try and batch\n\t\t\t * hardware accesses.\n\t\t\t */\n\t\t\tpmu->start_txn  = perf_pmu_start_txn;\n\t\t\tpmu->commit_txn = perf_pmu_commit_txn;\n\t\t\tpmu->cancel_txn = perf_pmu_cancel_txn;\n\t\t} else {\n\t\t\tpmu->start_txn  = perf_pmu_nop_txn;\n\t\t\tpmu->commit_txn = perf_pmu_nop_int;\n\t\t\tpmu->cancel_txn = perf_pmu_nop_void;\n\t\t}\n\t}\n\n\tif (!pmu->pmu_enable) {\n\t\tpmu->pmu_enable  = perf_pmu_nop_void;\n\t\tpmu->pmu_disable = perf_pmu_nop_void;\n\t}\n\n\tif (!pmu->event_idx)\n\t\tpmu->event_idx = perf_event_idx_default;\n\n\tlist_add_rcu(&pmu->entry, &pmus);\n\tatomic_set(&pmu->exclusive_cnt, 0);\n\tret = 0;\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n\nfree_dev:\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\nfree_idr:\n\tif (pmu->type >= PERF_TYPE_MAX)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\nfree_pdc:\n\tfree_percpu(pmu->pmu_disable_count);\n\tgoto unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_slots[i]",
            "sizeof(int)",
            "GFP_KERNEL"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_slots",
          "args": [
            "i"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\nstatic int nr_slots[TYPE_MAX];\nstatic int constraints_initialized;\nstatic struct notifier_block hw_breakpoint_exceptions_nb = {\n\t.notifier_call = hw_breakpoint_exceptions_notify,\n\t/* we need to be notified first */\n\t.priority = 0x7fffffff\n};\nstatic struct pmu perf_breakpoint = {\n\t.task_ctx_nr\t= perf_sw_context, /* could eventually get its own */\n\n\t.event_init\t= hw_breakpoint_event_init,\n\t.add\t\t= hw_breakpoint_add,\n\t.del\t\t= hw_breakpoint_del,\n\t.start\t\t= hw_breakpoint_start,\n\t.stop\t\t= hw_breakpoint_stop,\n\t.read\t\t= hw_breakpoint_pmu_read,\n};\n\nint __init init_hw_breakpoint(void)\n{\n\tint cpu, err_cpu;\n\tint i;\n\n\tfor (i = 0; i < TYPE_MAX; i++)\n\t\tnr_slots[i] = hw_breakpoint_slots(i);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < TYPE_MAX; i++) {\n\t\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, i);\n\n\t\t\tinfo->tsk_pinned = kcalloc(nr_slots[i], sizeof(int),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!info->tsk_pinned)\n\t\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\tconstraints_initialized = 1;\n\n\tperf_pmu_register(&perf_breakpoint, \"breakpoint\", PERF_TYPE_BREAKPOINT);\n\n\treturn register_die_notifier(&hw_breakpoint_exceptions_nb);\n\n err_alloc:\n\tfor_each_possible_cpu(err_cpu) {\n\t\tfor (i = 0; i < TYPE_MAX; i++)\n\t\t\tkfree(get_bp_info(err_cpu, i)->tsk_pinned);\n\t\tif (err_cpu == cpu)\n\t\t\tbreak;\n\t}\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "hw_breakpoint_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "658-661",
    "snippet": "static void hw_breakpoint_stop(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = PERF_HES_STOPPED;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void hw_breakpoint_stop(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = PERF_HES_STOPPED;\n}"
  },
  {
    "function_name": "hw_breakpoint_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "653-656",
    "snippet": "static void hw_breakpoint_start(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void hw_breakpoint_start(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = 0;\n}"
  },
  {
    "function_name": "hw_breakpoint_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "648-651",
    "snippet": "static void hw_breakpoint_del(struct perf_event *bp, int flags)\n{\n\tarch_uninstall_hw_breakpoint(bp);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_uninstall_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void hw_breakpoint_del(struct perf_event *bp, int flags)\n{\n\tarch_uninstall_hw_breakpoint(bp);\n}"
  },
  {
    "function_name": "hw_breakpoint_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "635-646",
    "snippet": "static int hw_breakpoint_add(struct perf_event *bp, int flags)\n{\n\tif (!(flags & PERF_EF_START))\n\t\tbp->hw.state = PERF_HES_STOPPED;\n\n\tif (is_sampling_event(bp)) {\n\t\tbp->hw.last_period = bp->hw.sample_period;\n\t\tperf_swevent_set_period(bp);\n\t}\n\n\treturn arch_install_hw_breakpoint(bp);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_install_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_swevent_set_period",
          "args": [
            "bp"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "perf_swevent_set_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "7807-7828",
          "snippet": "u64 perf_swevent_set_period(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 period = hwc->last_period;\n\tu64 nr, offset;\n\ts64 old, val;\n\n\thwc->last_period = hwc->sample_period;\n\nagain:\n\told = val = local64_read(&hwc->period_left);\n\tif (val < 0)\n\t\treturn 0;\n\n\tnr = div64_u64(period + val, period);\n\toffset = nr * period;\n\tval -= offset;\n\tif (local64_cmpxchg(&hwc->period_left, old, val) != old)\n\t\tgoto again;\n\n\treturn nr;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nu64 perf_swevent_set_period(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 period = hwc->last_period;\n\tu64 nr, offset;\n\ts64 old, val;\n\n\thwc->last_period = hwc->sample_period;\n\nagain:\n\told = val = local64_read(&hwc->period_left);\n\tif (val < 0)\n\t\treturn 0;\n\n\tnr = div64_u64(period + val, period);\n\toffset = nr * period;\n\tval -= offset;\n\tif (local64_cmpxchg(&hwc->period_left, old, val) != old)\n\t\tgoto again;\n\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sampling_event",
          "args": [
            "bp"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int hw_breakpoint_add(struct perf_event *bp, int flags)\n{\n\tif (!(flags & PERF_EF_START))\n\t\tbp->hw.state = PERF_HES_STOPPED;\n\n\tif (is_sampling_event(bp)) {\n\t\tbp->hw.last_period = bp->hw.sample_period;\n\t\tperf_swevent_set_period(bp);\n\t}\n\n\treturn arch_install_hw_breakpoint(bp);\n}"
  },
  {
    "function_name": "hw_breakpoint_event_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "613-633",
    "snippet": "static int hw_breakpoint_event_init(struct perf_event *bp)\n{\n\tint err;\n\n\tif (bp->attr.type != PERF_TYPE_BREAKPOINT)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for breakpoint events\n\t */\n\tif (has_branch_stack(bp))\n\t\treturn -EOPNOTSUPP;\n\n\terr = register_perf_hw_breakpoint(bp);\n\tif (err)\n\t\treturn err;\n\n\tbp->destroy = bp_perf_event_destroy;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_perf_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "register_perf_hw_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "427-445",
          "snippet": "int register_perf_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint hw;\n\tint err;\n\n\terr = reserve_bp_slot(bp);\n\tif (err)\n\t\treturn err;\n\n\terr = hw_breakpoint_parse(bp, &bp->attr, &hw);\n\tif (err) {\n\t\trelease_bp_slot(bp);\n\t\treturn err;\n\t}\n\n\tbp->hw.info = hw;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nint register_perf_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint hw;\n\tint err;\n\n\terr = reserve_bp_slot(bp);\n\tif (err)\n\t\treturn err;\n\n\terr = hw_breakpoint_parse(bp, &bp->attr, &hw);\n\tif (err) {\n\t\trelease_bp_slot(bp);\n\t\treturn err;\n\t}\n\n\tbp->hw.info = hw;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_branch_stack",
          "args": [
            "bp"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int hw_breakpoint_event_init(struct perf_event *bp)\n{\n\tint err;\n\n\tif (bp->attr.type != PERF_TYPE_BREAKPOINT)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for breakpoint events\n\t */\n\tif (has_branch_stack(bp))\n\t\treturn -EOPNOTSUPP;\n\n\terr = register_perf_hw_breakpoint(bp);\n\tif (err)\n\t\treturn err;\n\n\tbp->destroy = bp_perf_event_destroy;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bp_perf_event_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "608-611",
    "snippet": "static void bp_perf_event_destroy(struct perf_event *event)\n{\n\trelease_bp_slot(event);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_bp_slot",
          "args": [
            "event"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_release_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "393-401",
          "snippet": "int dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nr_bp_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void bp_perf_event_destroy(struct perf_event *event)\n{\n\trelease_bp_slot(event);\n}"
  },
  {
    "function_name": "unregister_wide_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "591-599",
    "snippet": "void unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tunregister_hw_breakpoint(per_cpu(*cpu_events, cpu));\n\n\tfree_percpu(cpu_events);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "cpu_events"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nvoid unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tunregister_hw_breakpoint(per_cpu(*cpu_events, cpu));\n\n\tfree_percpu(cpu_events);\n}"
  },
  {
    "function_name": "register_wide_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "553-584",
    "snippet": "struct perf_event * __percpu *\nregister_wide_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context)\n{\n\tstruct perf_event * __percpu *cpu_events, *bp;\n\tlong err = 0;\n\tint cpu;\n\n\tcpu_events = alloc_percpu(typeof(*cpu_events));\n\tif (!cpu_events)\n\t\treturn (void __percpu __force *)ERR_PTR(-ENOMEM);\n\n\tget_online_cpus();\n\tfor_each_online_cpu(cpu) {\n\t\tbp = perf_event_create_kernel_counter(attr, cpu, NULL,\n\t\t\t\t\t\t      triggered, context);\n\t\tif (IS_ERR(bp)) {\n\t\t\terr = PTR_ERR(bp);\n\t\t\tbreak;\n\t\t}\n\n\t\tper_cpu(*cpu_events, cpu) = bp;\n\t}\n\tput_online_cpus();\n\n\tif (likely(!err))\n\t\treturn cpu_events;\n\n\tunregister_wide_hw_breakpoint(cpu_events);\n\treturn (void __percpu __force *)ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_wide_hw_breakpoint",
          "args": [
            "cpu_events"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_wide_hw_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "591-599",
          "snippet": "void unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tunregister_hw_breakpoint(per_cpu(*cpu_events, cpu));\n\n\tfree_percpu(cpu_events);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nvoid unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tunregister_hw_breakpoint(per_cpu(*cpu_events, cpu));\n\n\tfree_percpu(cpu_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "*cpu_events",
            "cpu"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bp"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bp"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_create_kernel_counter",
          "args": [
            "attr",
            "cpu",
            "NULL",
            "triggered",
            "context"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_create_kernel_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "10853-10924",
          "snippet": "struct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\n\tevent = perf_event_alloc(attr, cpu, task, NULL, NULL,\n\t\t\t\t overflow_handler, context, -1);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err;\n\t}\n\n\t/* Mark owner so we could distinguish it from user events. */\n\tevent->owner = TASK_TOMBSTONE;\n\n\tctx = find_get_context(event->pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_free;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_unlock;\n\t}\n\n\tif (!task) {\n\t\t/*\n\t\t * Check if the @cpu we're creating an event for is online.\n\t\t *\n\t\t * We use the perf_cpu_context::ctx::mutex to serialize against\n\t\t * the hotplug notifiers. See perf_event_{init,exit}_cpu().\n\t\t */\n\t\tstruct perf_cpu_context *cpuctx =\n\t\t\tcontainer_of(ctx, struct perf_cpu_context, ctx);\n\t\tif (!cpuctx->online) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tperf_install_in_context(ctx, event, cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_unlock:\n\tmutex_unlock(&ctx->mutex);\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_free:\n\tfree_event(event);\nerr:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TASK_TOMBSTONE ((void *)-1L)"
          ],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define TASK_TOMBSTONE ((void *)-1L)\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstruct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\n\tevent = perf_event_alloc(attr, cpu, task, NULL, NULL,\n\t\t\t\t overflow_handler, context, -1);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err;\n\t}\n\n\t/* Mark owner so we could distinguish it from user events. */\n\tevent->owner = TASK_TOMBSTONE;\n\n\tctx = find_get_context(event->pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_free;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_unlock;\n\t}\n\n\tif (!task) {\n\t\t/*\n\t\t * Check if the @cpu we're creating an event for is online.\n\t\t *\n\t\t * We use the perf_cpu_context::ctx::mutex to serialize against\n\t\t * the hotplug notifiers. See perf_event_{init,exit}_cpu().\n\t\t */\n\t\tstruct perf_cpu_context *cpuctx =\n\t\t\tcontainer_of(ctx, struct perf_cpu_context, ctx);\n\t\tif (!cpuctx->online) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tperf_install_in_context(ctx, event, cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_unlock:\n\tmutex_unlock(&ctx->mutex);\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_free:\n\tfree_event(event);\nerr:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "typeof(*cpu_events)"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*cpu_events"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstruct perf_event * __percpu *\nregister_wide_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context)\n{\n\tstruct perf_event * __percpu *cpu_events, *bp;\n\tlong err = 0;\n\tint cpu;\n\n\tcpu_events = alloc_percpu(typeof(*cpu_events));\n\tif (!cpu_events)\n\t\treturn (void __percpu __force *)ERR_PTR(-ENOMEM);\n\n\tget_online_cpus();\n\tfor_each_online_cpu(cpu) {\n\t\tbp = perf_event_create_kernel_counter(attr, cpu, NULL,\n\t\t\t\t\t\t      triggered, context);\n\t\tif (IS_ERR(bp)) {\n\t\t\terr = PTR_ERR(bp);\n\t\t\tbreak;\n\t\t}\n\n\t\tper_cpu(*cpu_events, cpu) = bp;\n\t}\n\tput_online_cpus();\n\n\tif (likely(!err))\n\t\treturn cpu_events;\n\n\tunregister_wide_hw_breakpoint(cpu_events);\n\treturn (void __percpu __force *)ERR_PTR(err);\n}"
  },
  {
    "function_name": "unregister_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "538-543",
    "snippet": "void unregister_hw_breakpoint(struct perf_event *bp)\n{\n\tif (!bp)\n\t\treturn;\n\tperf_event_release_kernel(bp);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_release_kernel",
          "args": [
            "bp"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_release_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "4540-4640",
          "snippet": "int perf_event_release_kernel(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *child, *tmp;\n\tLIST_HEAD(free_list);\n\n\t/*\n\t * If we got here through err_file: fput(event_file); we will not have\n\t * attached to a context yet.\n\t */\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(event->attach_state &\n\t\t\t\t(PERF_ATTACH_CONTEXT|PERF_ATTACH_GROUP));\n\t\tgoto no_ctx;\n\t}\n\n\tif (!is_kernel_event(event))\n\t\tperf_remove_from_owner(event);\n\n\tctx = perf_event_ctx_lock(event);\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tperf_remove_from_context(event, DETACH_GROUP);\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * Mark this event as STATE_DEAD, there is no external reference to it\n\t * anymore.\n\t *\n\t * Anybody acquiring event->child_mutex after the below loop _must_\n\t * also see this, most importantly inherit_event() which will avoid\n\t * placing more children on the list.\n\t *\n\t * Thus this guarantees that we will in fact observe and kill _ALL_\n\t * child events.\n\t */\n\tevent->state = PERF_EVENT_STATE_DEAD;\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tperf_event_ctx_unlock(event, ctx);\n\nagain:\n\tmutex_lock(&event->child_mutex);\n\tlist_for_each_entry(child, &event->child_list, child_list) {\n\n\t\t/*\n\t\t * Cannot change, child events are not migrated, see the\n\t\t * comment with perf_event_ctx_lock_nested().\n\t\t */\n\t\tctx = READ_ONCE(child->ctx);\n\t\t/*\n\t\t * Since child_mutex nests inside ctx::mutex, we must jump\n\t\t * through hoops. We start by grabbing a reference on the ctx.\n\t\t *\n\t\t * Since the event cannot get freed while we hold the\n\t\t * child_mutex, the context must also exist and have a !0\n\t\t * reference count.\n\t\t */\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that we have a ctx ref, we can drop child_mutex, and\n\t\t * acquire ctx::mutex without fear of it going away. Then we\n\t\t * can re-acquire child_mutex.\n\t\t */\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_lock(&ctx->mutex);\n\t\tmutex_lock(&event->child_mutex);\n\n\t\t/*\n\t\t * Now that we hold ctx::mutex and child_mutex, revalidate our\n\t\t * state, if child is still the first entry, it didn't get freed\n\t\t * and we can continue doing so.\n\t\t */\n\t\ttmp = list_first_entry_or_null(&event->child_list,\n\t\t\t\t\t       struct perf_event, child_list);\n\t\tif (tmp == child) {\n\t\t\tperf_remove_from_context(child, DETACH_GROUP);\n\t\t\tlist_move(&child->child_list, &free_list);\n\t\t\t/*\n\t\t\t * This matches the refcount bump in inherit_event();\n\t\t\t * this can't be the last reference.\n\t\t\t */\n\t\t\tput_event(event);\n\t\t}\n\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\tmutex_unlock(&event->child_mutex);\n\n\tlist_for_each_entry_safe(child, tmp, &free_list, child_list) {\n\t\tlist_del(&child->child_list);\n\t\tfree_event(child);\n\t}\n\nno_ctx:\n\tput_event(event); /* Must be the 'last' reference */\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define DETACH_GROUP\t0x01UL"
          ],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define DETACH_GROUP\t0x01UL\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nint perf_event_release_kernel(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *child, *tmp;\n\tLIST_HEAD(free_list);\n\n\t/*\n\t * If we got here through err_file: fput(event_file); we will not have\n\t * attached to a context yet.\n\t */\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(event->attach_state &\n\t\t\t\t(PERF_ATTACH_CONTEXT|PERF_ATTACH_GROUP));\n\t\tgoto no_ctx;\n\t}\n\n\tif (!is_kernel_event(event))\n\t\tperf_remove_from_owner(event);\n\n\tctx = perf_event_ctx_lock(event);\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tperf_remove_from_context(event, DETACH_GROUP);\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * Mark this event as STATE_DEAD, there is no external reference to it\n\t * anymore.\n\t *\n\t * Anybody acquiring event->child_mutex after the below loop _must_\n\t * also see this, most importantly inherit_event() which will avoid\n\t * placing more children on the list.\n\t *\n\t * Thus this guarantees that we will in fact observe and kill _ALL_\n\t * child events.\n\t */\n\tevent->state = PERF_EVENT_STATE_DEAD;\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tperf_event_ctx_unlock(event, ctx);\n\nagain:\n\tmutex_lock(&event->child_mutex);\n\tlist_for_each_entry(child, &event->child_list, child_list) {\n\n\t\t/*\n\t\t * Cannot change, child events are not migrated, see the\n\t\t * comment with perf_event_ctx_lock_nested().\n\t\t */\n\t\tctx = READ_ONCE(child->ctx);\n\t\t/*\n\t\t * Since child_mutex nests inside ctx::mutex, we must jump\n\t\t * through hoops. We start by grabbing a reference on the ctx.\n\t\t *\n\t\t * Since the event cannot get freed while we hold the\n\t\t * child_mutex, the context must also exist and have a !0\n\t\t * reference count.\n\t\t */\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that we have a ctx ref, we can drop child_mutex, and\n\t\t * acquire ctx::mutex without fear of it going away. Then we\n\t\t * can re-acquire child_mutex.\n\t\t */\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_lock(&ctx->mutex);\n\t\tmutex_lock(&event->child_mutex);\n\n\t\t/*\n\t\t * Now that we hold ctx::mutex and child_mutex, revalidate our\n\t\t * state, if child is still the first entry, it didn't get freed\n\t\t * and we can continue doing so.\n\t\t */\n\t\ttmp = list_first_entry_or_null(&event->child_list,\n\t\t\t\t\t       struct perf_event, child_list);\n\t\tif (tmp == child) {\n\t\t\tperf_remove_from_context(child, DETACH_GROUP);\n\t\t\tlist_move(&child->child_list, &free_list);\n\t\t\t/*\n\t\t\t * This matches the refcount bump in inherit_event();\n\t\t\t * this can't be the last reference.\n\t\t\t */\n\t\t\tput_event(event);\n\t\t}\n\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\tmutex_unlock(&event->child_mutex);\n\n\tlist_for_each_entry_safe(child, tmp, &free_list, child_list) {\n\t\tlist_del(&child->child_list);\n\t\tfree_event(child);\n\t}\n\nno_ctx:\n\tput_event(event); /* Must be the 'last' reference */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nvoid unregister_hw_breakpoint(struct perf_event *bp)\n{\n\tif (!bp)\n\t\treturn;\n\tperf_event_release_kernel(bp);\n}"
  },
  {
    "function_name": "modify_user_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "510-531",
    "snippet": "int modify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr)\n{\n\tint err;\n\n\t/*\n\t * modify_user_hw_breakpoint can be invoked with IRQs disabled and hence it\n\t * will not be possible to raise IPIs that invoke __perf_event_disable.\n\t * So call the function directly after making sure we are targeting the\n\t * current task.\n\t */\n\tif (irqs_disabled() && bp->ctx && bp->ctx->task == current)\n\t\tperf_event_disable_local(bp);\n\telse\n\t\tperf_event_disable(bp);\n\n\terr = modify_user_hw_breakpoint_check(bp, attr, false);\n\n\tif (!bp->attr.disabled)\n\t\tperf_event_enable(bp);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_enable",
          "args": [
            "bp"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_enable_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "3767-3805",
          "snippet": "static void perf_event_enable_on_exec(int ctxn)\n{\n\tstruct perf_event_context *ctx, *clone_ctx = NULL;\n\tenum event_type_t event_type = 0;\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event *event;\n\tunsigned long flags;\n\tint enabled = 0;\n\n\tlocal_irq_save(flags);\n\tctx = current->perf_event_ctxp[ctxn];\n\tif (!ctx || !ctx->nr_events)\n\t\tgoto out;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tperf_ctx_lock(cpuctx, ctx);\n\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry) {\n\t\tenabled |= event_enable_on_exec(event, ctx);\n\t\tevent_type |= get_event_type(event);\n\t}\n\n\t/*\n\t * Unclone and reschedule this context if we enabled any event.\n\t */\n\tif (enabled) {\n\t\tclone_ctx = unclone_ctx(ctx);\n\t\tctx_resched(cpuctx, ctx, event_type);\n\t} else {\n\t\tctx_sched_in(ctx, cpuctx, EVENT_TIME, current);\n\t}\n\tperf_ctx_unlock(cpuctx, ctx);\n\nout:\n\tlocal_irq_restore(flags);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void cpu_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t      enum event_type_t event_type);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __always_inline enum",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void ctx_sched_out(struct perf_event_context *ctx,\n\t\t\t  struct perf_cpu_context *cpuctx,\n\t\t\t  enum event_type_t event_type);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void cpu_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t      enum event_type_t event_type);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __always_inline enum;\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void ctx_sched_out(struct perf_event_context *ctx,\n\t\t\t  struct perf_cpu_context *cpuctx,\n\t\t\t  enum event_type_t event_type);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void perf_event_enable_on_exec(int ctxn)\n{\n\tstruct perf_event_context *ctx, *clone_ctx = NULL;\n\tenum event_type_t event_type = 0;\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event *event;\n\tunsigned long flags;\n\tint enabled = 0;\n\n\tlocal_irq_save(flags);\n\tctx = current->perf_event_ctxp[ctxn];\n\tif (!ctx || !ctx->nr_events)\n\t\tgoto out;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tperf_ctx_lock(cpuctx, ctx);\n\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry) {\n\t\tenabled |= event_enable_on_exec(event, ctx);\n\t\tevent_type |= get_event_type(event);\n\t}\n\n\t/*\n\t * Unclone and reschedule this context if we enabled any event.\n\t */\n\tif (enabled) {\n\t\tclone_ctx = unclone_ctx(ctx);\n\t\tctx_resched(cpuctx, ctx, event_type);\n\t} else {\n\t\tctx_sched_in(ctx, cpuctx, EVENT_TIME, current);\n\t}\n\tperf_ctx_unlock(cpuctx, ctx);\n\nout:\n\tlocal_irq_restore(flags);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_user_hw_breakpoint_check",
          "args": [
            "bp",
            "attr",
            "false"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "modify_user_hw_breakpoint_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "473-503",
          "snippet": "int\nmodify_user_hw_breakpoint_check(struct perf_event *bp, struct perf_event_attr *attr,\n\t\t\t        bool check)\n{\n\tstruct arch_hw_breakpoint hw;\n\tint err;\n\n\terr = hw_breakpoint_parse(bp, attr, &hw);\n\tif (err)\n\t\treturn err;\n\n\tif (check) {\n\t\tstruct perf_event_attr old_attr;\n\n\t\told_attr = bp->attr;\n\t\thw_breakpoint_copy_attr(&old_attr, attr);\n\t\tif (memcmp(&old_attr, attr, sizeof(*attr)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (bp->attr.bp_type != attr->bp_type) {\n\t\terr = modify_bp_slot(bp, bp->attr.bp_type, attr->bp_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thw_breakpoint_copy_attr(&bp->attr, attr);\n\tbp->hw.info = hw;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nint\nmodify_user_hw_breakpoint_check(struct perf_event *bp, struct perf_event_attr *attr,\n\t\t\t        bool check)\n{\n\tstruct arch_hw_breakpoint hw;\n\tint err;\n\n\terr = hw_breakpoint_parse(bp, attr, &hw);\n\tif (err)\n\t\treturn err;\n\n\tif (check) {\n\t\tstruct perf_event_attr old_attr;\n\n\t\told_attr = bp->attr;\n\t\thw_breakpoint_copy_attr(&old_attr, attr);\n\t\tif (memcmp(&old_attr, attr, sizeof(*attr)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (bp->attr.bp_type != attr->bp_type) {\n\t\terr = modify_bp_slot(bp, bp->attr.bp_type, attr->bp_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thw_breakpoint_copy_attr(&bp->attr, attr);\n\tbp->hw.info = hw;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_disable",
          "args": [
            "bp"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_disable_inatomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "2197-2201",
          "snippet": "void perf_event_disable_inatomic(struct perf_event *event)\n{\n\tevent->pending_disable = 1;\n\tirq_work_queue(&event->pending);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event_disable_inatomic(struct perf_event *event)\n{\n\tevent->pending_disable = 1;\n\tirq_work_queue(&event->pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_disable_local",
          "args": [
            "bp"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_disable_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "2178-2181",
          "snippet": "void perf_event_disable_local(struct perf_event *event)\n{\n\tevent_function_local(event, __perf_event_disable, NULL);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event_disable_local(struct perf_event *event)\n{\n\tevent_function_local(event, __perf_event_disable, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nint modify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr)\n{\n\tint err;\n\n\t/*\n\t * modify_user_hw_breakpoint can be invoked with IRQs disabled and hence it\n\t * will not be possible to raise IPIs that invoke __perf_event_disable.\n\t * So call the function directly after making sure we are targeting the\n\t * current task.\n\t */\n\tif (irqs_disabled() && bp->ctx && bp->ctx->task == current)\n\t\tperf_event_disable_local(bp);\n\telse\n\t\tperf_event_disable(bp);\n\n\terr = modify_user_hw_breakpoint_check(bp, attr, false);\n\n\tif (!bp->attr.disabled)\n\t\tperf_event_enable(bp);\n\n\treturn err;\n}"
  },
  {
    "function_name": "modify_user_hw_breakpoint_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "473-503",
    "snippet": "int\nmodify_user_hw_breakpoint_check(struct perf_event *bp, struct perf_event_attr *attr,\n\t\t\t        bool check)\n{\n\tstruct arch_hw_breakpoint hw;\n\tint err;\n\n\terr = hw_breakpoint_parse(bp, attr, &hw);\n\tif (err)\n\t\treturn err;\n\n\tif (check) {\n\t\tstruct perf_event_attr old_attr;\n\n\t\told_attr = bp->attr;\n\t\thw_breakpoint_copy_attr(&old_attr, attr);\n\t\tif (memcmp(&old_attr, attr, sizeof(*attr)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (bp->attr.bp_type != attr->bp_type) {\n\t\terr = modify_bp_slot(bp, bp->attr.bp_type, attr->bp_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thw_breakpoint_copy_attr(&bp->attr, attr);\n\tbp->hw.info = hw;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hw_breakpoint_copy_attr",
          "args": [
            "&bp->attr",
            "attr"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_copy_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "464-471",
          "snippet": "static void hw_breakpoint_copy_attr(struct perf_event_attr *to,\n\t\t\t\t    struct perf_event_attr *from)\n{\n\tto->bp_addr = from->bp_addr;\n\tto->bp_type = from->bp_type;\n\tto->bp_len  = from->bp_len;\n\tto->disabled = from->disabled;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void hw_breakpoint_copy_attr(struct perf_event_attr *to,\n\t\t\t\t    struct perf_event_attr *from)\n{\n\tto->bp_addr = from->bp_addr;\n\tto->bp_type = from->bp_type;\n\tto->bp_len  = from->bp_len;\n\tto->disabled = from->disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_bp_slot",
          "args": [
            "bp",
            "bp->attr.bp_type",
            "attr->bp_type"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "modify_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "370-378",
          "snippet": "static int modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\tret = __modify_bp_slot(bp, old_type, new_type);\n\tmutex_unlock(&nr_bp_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nr_bp_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nstatic int modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\tret = __modify_bp_slot(bp, old_type, new_type);\n\tmutex_unlock(&nr_bp_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&old_attr",
            "attr",
            "sizeof(*attr)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_parse",
          "args": [
            "bp",
            "attr",
            "&hw"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "403-425",
          "snippet": "static int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nint\nmodify_user_hw_breakpoint_check(struct perf_event *bp, struct perf_event_attr *attr,\n\t\t\t        bool check)\n{\n\tstruct arch_hw_breakpoint hw;\n\tint err;\n\n\terr = hw_breakpoint_parse(bp, attr, &hw);\n\tif (err)\n\t\treturn err;\n\n\tif (check) {\n\t\tstruct perf_event_attr old_attr;\n\n\t\told_attr = bp->attr;\n\t\thw_breakpoint_copy_attr(&old_attr, attr);\n\t\tif (memcmp(&old_attr, attr, sizeof(*attr)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (bp->attr.bp_type != attr->bp_type) {\n\t\terr = modify_bp_slot(bp, bp->attr.bp_type, attr->bp_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thw_breakpoint_copy_attr(&bp->attr, attr);\n\tbp->hw.info = hw;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hw_breakpoint_copy_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "464-471",
    "snippet": "static void hw_breakpoint_copy_attr(struct perf_event_attr *to,\n\t\t\t\t    struct perf_event_attr *from)\n{\n\tto->bp_addr = from->bp_addr;\n\tto->bp_type = from->bp_type;\n\tto->bp_len  = from->bp_len;\n\tto->disabled = from->disabled;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void hw_breakpoint_copy_attr(struct perf_event_attr *to,\n\t\t\t\t    struct perf_event_attr *from)\n{\n\tto->bp_addr = from->bp_addr;\n\tto->bp_type = from->bp_type;\n\tto->bp_len  = from->bp_len;\n\tto->disabled = from->disabled;\n}"
  },
  {
    "function_name": "register_user_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "453-461",
    "snippet": "struct perf_event *\nregister_user_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context,\n\t\t\t    struct task_struct *tsk)\n{\n\treturn perf_event_create_kernel_counter(attr, -1, tsk, triggered,\n\t\t\t\t\t\tcontext);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_create_kernel_counter",
          "args": [
            "attr",
            "-1",
            "tsk",
            "triggered",
            "context"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_create_kernel_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "10853-10924",
          "snippet": "struct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\n\tevent = perf_event_alloc(attr, cpu, task, NULL, NULL,\n\t\t\t\t overflow_handler, context, -1);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err;\n\t}\n\n\t/* Mark owner so we could distinguish it from user events. */\n\tevent->owner = TASK_TOMBSTONE;\n\n\tctx = find_get_context(event->pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_free;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_unlock;\n\t}\n\n\tif (!task) {\n\t\t/*\n\t\t * Check if the @cpu we're creating an event for is online.\n\t\t *\n\t\t * We use the perf_cpu_context::ctx::mutex to serialize against\n\t\t * the hotplug notifiers. See perf_event_{init,exit}_cpu().\n\t\t */\n\t\tstruct perf_cpu_context *cpuctx =\n\t\t\tcontainer_of(ctx, struct perf_cpu_context, ctx);\n\t\tif (!cpuctx->online) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tperf_install_in_context(ctx, event, cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_unlock:\n\tmutex_unlock(&ctx->mutex);\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_free:\n\tfree_event(event);\nerr:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TASK_TOMBSTONE ((void *)-1L)"
          ],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define TASK_TOMBSTONE ((void *)-1L)\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstruct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t/*\n\t * Get the target context (task or percpu):\n\t */\n\n\tevent = perf_event_alloc(attr, cpu, task, NULL, NULL,\n\t\t\t\t overflow_handler, context, -1);\n\tif (IS_ERR(event)) {\n\t\terr = PTR_ERR(event);\n\t\tgoto err;\n\t}\n\n\t/* Mark owner so we could distinguish it from user events. */\n\tevent->owner = TASK_TOMBSTONE;\n\n\tctx = find_get_context(event->pmu, task, event);\n\tif (IS_ERR(ctx)) {\n\t\terr = PTR_ERR(ctx);\n\t\tgoto err_free;\n\t}\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->task == TASK_TOMBSTONE) {\n\t\terr = -ESRCH;\n\t\tgoto err_unlock;\n\t}\n\n\tif (!task) {\n\t\t/*\n\t\t * Check if the @cpu we're creating an event for is online.\n\t\t *\n\t\t * We use the perf_cpu_context::ctx::mutex to serialize against\n\t\t * the hotplug notifiers. See perf_event_{init,exit}_cpu().\n\t\t */\n\t\tstruct perf_cpu_context *cpuctx =\n\t\t\tcontainer_of(ctx, struct perf_cpu_context, ctx);\n\t\tif (!cpuctx->online) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tperf_install_in_context(ctx, event, cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_unlock:\n\tmutex_unlock(&ctx->mutex);\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_free:\n\tfree_event(event);\nerr:\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstruct perf_event *\nregister_user_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context,\n\t\t\t    struct task_struct *tsk)\n{\n\treturn perf_event_create_kernel_counter(attr, -1, tsk, triggered,\n\t\t\t\t\t\tcontext);\n}"
  },
  {
    "function_name": "register_perf_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "427-445",
    "snippet": "int register_perf_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint hw;\n\tint err;\n\n\terr = reserve_bp_slot(bp);\n\tif (err)\n\t\treturn err;\n\n\terr = hw_breakpoint_parse(bp, &bp->attr, &hw);\n\tif (err) {\n\t\trelease_bp_slot(bp);\n\t\treturn err;\n\t}\n\n\tbp->hw.info = hw;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_bp_slot",
          "args": [
            "bp"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_release_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "393-401",
          "snippet": "int dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nr_bp_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_parse",
          "args": [
            "bp",
            "&bp->attr",
            "&hw"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "403-425",
          "snippet": "static int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_bp_slot",
          "args": [
            "bp"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_reserve_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "385-391",
          "snippet": "int dbg_reserve_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\treturn __reserve_bp_slot(bp, bp->attr.bp_type);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(nr_bp_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint dbg_reserve_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\treturn __reserve_bp_slot(bp, bp->attr.bp_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nint register_perf_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint hw;\n\tint err;\n\n\terr = reserve_bp_slot(bp);\n\tif (err)\n\t\treturn err;\n\n\terr = hw_breakpoint_parse(bp, &bp->attr, &hw);\n\tif (err) {\n\t\trelease_bp_slot(bp);\n\t\treturn err;\n\t}\n\n\tbp->hw.info = hw;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hw_breakpoint_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "403-425",
    "snippet": "static int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_check_bp_in_kernelspace",
          "args": [
            "hw"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_arch_parse",
          "args": [
            "bp",
            "attr",
            "hw"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int hw_breakpoint_parse(struct perf_event *bp,\n\t\t\t       const struct perf_event_attr *attr,\n\t\t\t       struct arch_hw_breakpoint *hw)\n{\n\tint err;\n\n\terr = hw_breakpoint_arch_parse(bp, attr, hw);\n\tif (err)\n\t\treturn err;\n\n\tif (arch_check_bp_in_kernelspace(hw)) {\n\t\tif (attr->exclude_kernel)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Don't let unprivileged users set a breakpoint in the trap\n\t\t * path to avoid trap recursion attacks.\n\t\t */\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_release_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "393-401",
    "snippet": "int dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nr_bp_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release_bp_slot",
          "args": [
            "bp",
            "bp->attr.bp_type"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "__release_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "328-336",
          "snippet": "static void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dbg_reserve_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "385-391",
    "snippet": "int dbg_reserve_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\treturn __reserve_bp_slot(bp, bp->attr.bp_type);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nr_bp_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reserve_bp_slot",
          "args": [
            "bp",
            "bp->attr.bp_type"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "__reserve_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "281-313",
          "snippet": "static int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nr_slots[TYPE_MAX];",
            "static int constraints_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\nstatic int constraints_initialized;\n\nstatic int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint dbg_reserve_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\treturn __reserve_bp_slot(bp, bp->attr.bp_type);\n}"
  },
  {
    "function_name": "modify_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "370-378",
    "snippet": "static int modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\tret = __modify_bp_slot(bp, old_type, new_type);\n\tmutex_unlock(&nr_bp_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nr_bp_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__modify_bp_slot",
          "args": [
            "bp",
            "old_type",
            "new_type"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "__modify_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "348-368",
          "snippet": "static int __modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint err;\n\n\t__release_bp_slot(bp, old_type);\n\n\terr = __reserve_bp_slot(bp, new_type);\n\tif (err) {\n\t\t/*\n\t\t * Reserve the old_type slot back in case\n\t\t * there's no space for the new type.\n\t\t *\n\t\t * This must succeed, because we just released\n\t\t * the old_type slot in the __release_bp_slot\n\t\t * call above. If not, something is broken.\n\t\t */\n\t\tWARN_ON(__reserve_bp_slot(bp, old_type));\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int __modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint err;\n\n\t__release_bp_slot(bp, old_type);\n\n\terr = __reserve_bp_slot(bp, new_type);\n\tif (err) {\n\t\t/*\n\t\t * Reserve the old_type slot back in case\n\t\t * there's no space for the new type.\n\t\t *\n\t\t * This must succeed, because we just released\n\t\t * the old_type slot in the __release_bp_slot\n\t\t * call above. If not, something is broken.\n\t\t */\n\t\tWARN_ON(__reserve_bp_slot(bp, old_type));\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nstatic int modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\tret = __modify_bp_slot(bp, old_type, new_type);\n\tmutex_unlock(&nr_bp_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__modify_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "348-368",
    "snippet": "static int __modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint err;\n\n\t__release_bp_slot(bp, old_type);\n\n\terr = __reserve_bp_slot(bp, new_type);\n\tif (err) {\n\t\t/*\n\t\t * Reserve the old_type slot back in case\n\t\t * there's no space for the new type.\n\t\t *\n\t\t * This must succeed, because we just released\n\t\t * the old_type slot in the __release_bp_slot\n\t\t * call above. If not, something is broken.\n\t\t */\n\t\tWARN_ON(__reserve_bp_slot(bp, old_type));\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "__reserve_bp_slot(bp, old_type)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__reserve_bp_slot",
          "args": [
            "bp",
            "old_type"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "__reserve_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "281-313",
          "snippet": "static int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nr_slots[TYPE_MAX];",
            "static int constraints_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\nstatic int constraints_initialized;\n\nstatic int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_bp_slot",
          "args": [
            "bp",
            "old_type"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "__release_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "328-336",
          "snippet": "static void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int __modify_bp_slot(struct perf_event *bp, u64 old_type, u64 new_type)\n{\n\tint err;\n\n\t__release_bp_slot(bp, old_type);\n\n\terr = __reserve_bp_slot(bp, new_type);\n\tif (err) {\n\t\t/*\n\t\t * Reserve the old_type slot back in case\n\t\t * there's no space for the new type.\n\t\t *\n\t\t * This must succeed, because we just released\n\t\t * the old_type slot in the __release_bp_slot\n\t\t * call above. If not, something is broken.\n\t\t */\n\t\tWARN_ON(__reserve_bp_slot(bp, old_type));\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "release_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "338-346",
    "snippet": "void release_bp_slot(struct perf_event *bp)\n{\n\tmutex_lock(&nr_bp_mutex);\n\n\tarch_unregister_hw_breakpoint(bp);\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\tmutex_unlock(&nr_bp_mutex);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nr_bp_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__release_bp_slot",
          "args": [
            "bp",
            "bp->attr.bp_type"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "__release_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "328-336",
          "snippet": "static void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_unregister_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "arch_unregister_hw_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "232-238",
          "snippet": "__weak void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * A weak stub function here for those archs that don't define\n\t * it inside arch/.../kernel/hw_breakpoint.c\n\t */\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * A weak stub function here for those archs that don't define\n\t * it inside arch/.../kernel/hw_breakpoint.c\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nvoid release_bp_slot(struct perf_event *bp)\n{\n\tmutex_lock(&nr_bp_mutex);\n\n\tarch_unregister_hw_breakpoint(bp);\n\t__release_bp_slot(bp, bp->attr.bp_type);\n\n\tmutex_unlock(&nr_bp_mutex);\n}"
  },
  {
    "function_name": "__release_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "328-336",
    "snippet": "static void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "toggle_bp_slot",
          "args": [
            "bp",
            "false",
            "type",
            "weight"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "toggle_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "203-227",
          "snippet": "static void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(bp_task_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_weight",
          "args": [
            "bp"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "84-87",
          "snippet": "__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_slot_idx",
          "args": [
            "bp_type"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "find_slot_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "89-95",
          "snippet": "static inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void __release_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}"
  },
  {
    "function_name": "reserve_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "315-326",
    "snippet": "int reserve_bp_slot(struct perf_event *bp)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\n\tret = __reserve_bp_slot(bp, bp->attr.bp_type);\n\n\tmutex_unlock(&nr_bp_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(nr_bp_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reserve_bp_slot",
          "args": [
            "bp",
            "bp->attr.bp_type"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__reserve_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "281-313",
          "snippet": "static int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nr_slots[TYPE_MAX];",
            "static int constraints_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\nstatic int constraints_initialized;\n\nstatic int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nr_bp_mutex"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_MUTEX(nr_bp_mutex);\n\nint reserve_bp_slot(struct perf_event *bp)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\n\tret = __reserve_bp_slot(bp, bp->attr.bp_type);\n\n\tmutex_unlock(&nr_bp_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__reserve_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "281-313",
    "snippet": "static int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nr_slots[TYPE_MAX];",
      "static int constraints_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "toggle_bp_slot",
          "args": [
            "bp",
            "true",
            "type",
            "weight"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "toggle_bp_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "203-227",
          "snippet": "static void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(bp_task_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_this_slot",
          "args": [
            "&slots",
            "weight"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_this_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "176-180",
          "snippet": "static void\nfetch_this_slot(struct bp_busy_slots *slots, int weight)\n{\n\tslots->pinned += weight;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void\nfetch_this_slot(struct bp_busy_slots *slots, int weight)\n{\n\tslots->pinned += weight;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_bp_busy_slots",
          "args": [
            "&slots",
            "bp",
            "type"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_bp_busy_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "145-169",
          "snippet": "static void\nfetch_bp_busy_slots(struct bp_busy_slots *slots, struct perf_event *bp,\n\t\t    enum bp_type_idx type)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, type);\n\t\tint nr;\n\n\t\tnr = info->cpu_pinned;\n\t\tif (!bp->hw.target)\n\t\t\tnr += max_task_bp_pinned(cpu, type);\n\t\telse\n\t\t\tnr += task_bp_pinned(cpu, bp, type);\n\n\t\tif (nr > slots->pinned)\n\t\t\tslots->pinned = nr;\n\n\t\tnr = info->flexible;\n\t\tif (nr > slots->flexible)\n\t\t\tslots->flexible = nr;\n\t}\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic void\nfetch_bp_busy_slots(struct bp_busy_slots *slots, struct perf_event *bp,\n\t\t    enum bp_type_idx type)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, type);\n\t\tint nr;\n\n\t\tnr = info->cpu_pinned;\n\t\tif (!bp->hw.target)\n\t\t\tnr += max_task_bp_pinned(cpu, type);\n\t\telse\n\t\t\tnr += task_bp_pinned(cpu, bp, type);\n\n\t\tif (nr > slots->pinned)\n\t\t\tslots->pinned = nr;\n\n\t\tnr = info->flexible;\n\t\tif (nr > slots->flexible)\n\t\t\tslots->flexible = nr;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_weight",
          "args": [
            "bp"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "84-87",
          "snippet": "__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_slot_idx",
          "args": [
            "bp_type"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "find_slot_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "89-95",
          "snippet": "static inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\nstatic int constraints_initialized;\n\nstatic int __reserve_bp_slot(struct perf_event *bp, u64 bp_type)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\n\t/* We couldn't initialize breakpoint constraints on boot */\n\tif (!constraints_initialized)\n\t\treturn -ENOMEM;\n\n\t/* Basic checks */\n\tif (bp_type == HW_BREAKPOINT_EMPTY ||\n\t    bp_type == HW_BREAKPOINT_INVALID)\n\t\treturn -EINVAL;\n\n\ttype = find_slot_idx(bp_type);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t/*\n\t * Simulate the addition of this breakpoint to the constraints\n\t * and see the result.\n\t */\n\tfetch_this_slot(&slots, weight);\n\n\t/* Flexible counters need to keep at least one slot */\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -ENOSPC;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_unregister_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "232-238",
    "snippet": "__weak void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * A weak stub function here for those archs that don't define\n\t * it inside arch/.../kernel/hw_breakpoint.c\n\t */\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * A weak stub function here for those archs that don't define\n\t * it inside arch/.../kernel/hw_breakpoint.c\n\t */\n}"
  },
  {
    "function_name": "toggle_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "203-227",
    "snippet": "static void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(bp_task_head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&bp->hw.bp_list"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bp->hw.bp_list",
            "&bp_task_head"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toggle_bp_task_slot",
          "args": [
            "bp",
            "cpu",
            "type",
            "weight"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "toggle_bp_task_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "185-198",
          "snippet": "static void toggle_bp_task_slot(struct perf_event *bp, int cpu,\n\t\t\t\tenum bp_type_idx type, int weight)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint old_idx, new_idx;\n\n\told_idx = task_bp_pinned(cpu, bp, type) - 1;\n\tnew_idx = old_idx + weight;\n\n\tif (old_idx >= 0)\n\t\ttsk_pinned[old_idx]--;\n\tif (new_idx >= 0)\n\t\ttsk_pinned[new_idx]++;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void toggle_bp_task_slot(struct perf_event *bp, int cpu,\n\t\t\t\tenum bp_type_idx type, int weight)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint old_idx, new_idx;\n\n\told_idx = task_bp_pinned(cpu, bp, type) - 1;\n\tnew_idx = old_idx + weight;\n\n\tif (old_idx >= 0)\n\t\ttsk_pinned[old_idx]--;\n\tif (new_idx >= 0)\n\t\ttsk_pinned[new_idx]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cpumask"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bp_info",
          "args": [
            "bp->cpu",
            "type"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "get_bp_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "65-68",
          "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of_bp",
          "args": [
            "bp"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t/* Pinned counter cpu profiling */\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t/* Pinned counter task profiling */\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}"
  },
  {
    "function_name": "toggle_bp_task_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "185-198",
    "snippet": "static void toggle_bp_task_slot(struct perf_event *bp, int cpu,\n\t\t\t\tenum bp_type_idx type, int weight)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint old_idx, new_idx;\n\n\told_idx = task_bp_pinned(cpu, bp, type) - 1;\n\tnew_idx = old_idx + weight;\n\n\tif (old_idx >= 0)\n\t\ttsk_pinned[old_idx]--;\n\tif (new_idx >= 0)\n\t\ttsk_pinned[new_idx]++;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_bp_pinned",
          "args": [
            "cpu",
            "bp",
            "type"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "task_bp_pinned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "118-132",
          "snippet": "static int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(bp_task_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bp_info",
          "args": [
            "cpu",
            "type"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "get_bp_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "65-68",
          "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void toggle_bp_task_slot(struct perf_event *bp, int cpu,\n\t\t\t\tenum bp_type_idx type, int weight)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint old_idx, new_idx;\n\n\told_idx = task_bp_pinned(cpu, bp, type) - 1;\n\tnew_idx = old_idx + weight;\n\n\tif (old_idx >= 0)\n\t\ttsk_pinned[old_idx]--;\n\tif (new_idx >= 0)\n\t\ttsk_pinned[new_idx]++;\n}"
  },
  {
    "function_name": "fetch_this_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "176-180",
    "snippet": "static void\nfetch_this_slot(struct bp_busy_slots *slots, int weight)\n{\n\tslots->pinned += weight;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic void\nfetch_this_slot(struct bp_busy_slots *slots, int weight)\n{\n\tslots->pinned += weight;\n}"
  },
  {
    "function_name": "fetch_bp_busy_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "145-169",
    "snippet": "static void\nfetch_bp_busy_slots(struct bp_busy_slots *slots, struct perf_event *bp,\n\t\t    enum bp_type_idx type)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, type);\n\t\tint nr;\n\n\t\tnr = info->cpu_pinned;\n\t\tif (!bp->hw.target)\n\t\t\tnr += max_task_bp_pinned(cpu, type);\n\t\telse\n\t\t\tnr += task_bp_pinned(cpu, bp, type);\n\n\t\tif (nr > slots->pinned)\n\t\t\tslots->pinned = nr;\n\n\t\tnr = info->flexible;\n\t\tif (nr > slots->flexible)\n\t\t\tslots->flexible = nr;\n\t}\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_bp_pinned",
          "args": [
            "cpu",
            "bp",
            "type"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "task_bp_pinned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "118-132",
          "snippet": "static int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(bp_task_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_task_bp_pinned",
          "args": [
            "cpu",
            "type"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "max_task_bp_pinned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "101-112",
          "snippet": "static unsigned int max_task_bp_pinned(int cpu, enum bp_type_idx type)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint i;\n\n\tfor (i = nr_slots[type] - 1; i >= 0; i--) {\n\t\tif (tsk_pinned[i] > 0)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nr_slots[TYPE_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\n\nstatic unsigned int max_task_bp_pinned(int cpu, enum bp_type_idx type)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint i;\n\n\tfor (i = nr_slots[type] - 1; i >= 0; i--) {\n\t\tif (tsk_pinned[i] > 0)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bp_info",
          "args": [
            "cpu",
            "type"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "get_bp_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "65-68",
          "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cpumask"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_bp",
          "args": [
            "bp"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic void\nfetch_bp_busy_slots(struct bp_busy_slots *slots, struct perf_event *bp,\n\t\t    enum bp_type_idx type)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, type);\n\t\tint nr;\n\n\t\tnr = info->cpu_pinned;\n\t\tif (!bp->hw.target)\n\t\t\tnr += max_task_bp_pinned(cpu, type);\n\t\telse\n\t\t\tnr += task_bp_pinned(cpu, bp, type);\n\n\t\tif (nr > slots->pinned)\n\t\t\tslots->pinned = nr;\n\n\t\tnr = info->flexible;\n\t\tif (nr > slots->flexible)\n\t\t\tslots->flexible = nr;\n\t}\n}"
  },
  {
    "function_name": "cpumask_of_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "134-139",
    "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "bp->cpu"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
  },
  {
    "function_name": "task_bp_pinned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "118-132",
    "snippet": "static int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(bp_task_head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hw_breakpoint_weight",
          "args": [
            "iter"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "84-87",
          "snippet": "__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_slot_idx",
          "args": [
            "iter->attr.bp_type"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "find_slot_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "89-95",
          "snippet": "static inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "iter",
            "&bp_task_head",
            "hw.bp_list"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic LIST_HEAD(bp_task_head);\n\nstatic int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter->attr.bp_type) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "max_task_bp_pinned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "101-112",
    "snippet": "static unsigned int max_task_bp_pinned(int cpu, enum bp_type_idx type)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint i;\n\n\tfor (i = nr_slots[type] - 1; i >= 0; i--) {\n\t\tif (tsk_pinned[i] > 0)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nr_slots[TYPE_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bp_info",
          "args": [
            "cpu",
            "type"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "get_bp_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "65-68",
          "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic int nr_slots[TYPE_MAX];\n\nstatic unsigned int max_task_bp_pinned(int cpu, enum bp_type_idx type)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint i;\n\n\tfor (i = nr_slots[type] - 1; i >= 0; i--) {\n\t\tif (tsk_pinned[i] > 0)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_slot_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "89-95",
    "snippet": "static inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic inline enum bp_type_idx find_slot_idx(u64 bp_type)\n{\n\tif (bp_type & HW_BREAKPOINT_RW)\n\t\treturn TYPE_DATA;\n\n\treturn TYPE_INST;\n}"
  },
  {
    "function_name": "hw_breakpoint_weight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "84-87",
    "snippet": "__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\n__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "get_bp_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
    "lines": "65-68",
    "snippet": "static struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}",
    "includes": [
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/bug.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/irqflags.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "bp_cpuinfo + type",
            "cpu"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic DEFINE_PER_CPU(struct bp_cpuinfo, bp_cpuinfo[TYPE_MAX]);\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}"
  }
]