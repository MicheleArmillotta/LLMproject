[
  {
    "function_name": "task_cputime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "861-894",
    "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&vtime->seqcount",
            "seq"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "694-711",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "t"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_accounting_enabled",
          "args": [],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
  },
  {
    "function_name": "task_gtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "835-854",
    "snippet": "u64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_SYS && t->flags & PF_VCPU)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&vtime->seqcount",
            "seq"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "694-711",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_accounting_enabled",
          "args": [],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nu64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_SYS && t->flags & PF_VCPU)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}"
  },
  {
    "function_name": "vtime_init_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "822-833",
    "snippet": "void vtime_init_idle(struct task_struct *t, int cpu)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\twrite_seqcount_end(&vtime->seqcount);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "disable_sched_clock_irqtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "28-31",
          "snippet": "void disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define sched_clock_irqtime\t(0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_init_idle(struct task_struct *t, int cpu)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\twrite_seqcount_end(&vtime->seqcount);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "arch_vtime_task_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "806-820",
    "snippet": "void arch_vtime_task_switch(struct task_struct *prev)\n{\n\tstruct vtime *vtime = &prev->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_INACTIVE;\n\twrite_seqcount_end(&vtime->seqcount);\n\n\tvtime = &current->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "disable_sched_clock_irqtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "28-31",
          "snippet": "void disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define sched_clock_irqtime\t(0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid arch_vtime_task_switch(struct task_struct *prev)\n{\n\tstruct vtime *vtime = &prev->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_INACTIVE;\n\twrite_seqcount_end(&vtime->seqcount);\n\n\tvtime = &current->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_account_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "801-804",
    "snippet": "void vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_idle_time",
          "args": [
            "get_vtime_delta(&tsk->vtime)"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "account_idle_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "217-226",
          "snippet": "void account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vtime_delta",
          "args": [
            "&tsk->vtime"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "694-711",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}"
  },
  {
    "function_name": "vtime_guest_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "790-798",
    "snippet": "void vtime_guest_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime_account_guest(tsk, vtime);\n\tcurrent->flags &= ~PF_VCPU;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_account_guest",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "723-731",
          "snippet": "static void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_guest_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime_account_guest(tsk, vtime);\n\tcurrent->flags &= ~PF_VCPU;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_guest_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "773-787",
    "snippet": "void vtime_guest_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\t/*\n\t * The flags must be updated under the lock with\n\t * the vtime_starttime flush and update.\n\t * That enforces a right ordering and update sequence\n\t * synchronization against the reader (task_gtime())\n\t * that can thus safely catch up with a tickless delta.\n\t */\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_system(tsk, vtime);\n\tcurrent->flags |= PF_VCPU;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vtime_account_system",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "__vtime_account_system",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "713-721",
          "snippet": "static void __vtime_account_system(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __vtime_account_system(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_guest_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\t/*\n\t * The flags must be updated under the lock with\n\t * the vtime_starttime flush and update.\n\t * That enforces a right ordering and update sequence\n\t * synchronization against the reader (task_gtime())\n\t * that can thus safely catch up with a tickless delta.\n\t */\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_system(tsk, vtime);\n\tcurrent->flags |= PF_VCPU;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_user_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "759-771",
    "snippet": "void vtime_user_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->utime += get_vtime_delta(vtime);\n\tif (vtime->utime >= TICK_NSEC) {\n\t\taccount_user_time(tsk, vtime->utime);\n\t\tvtime->utime = 0;\n\t}\n\tvtime->state = VTIME_SYS;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_user_time",
          "args": [
            "tsk",
            "vtime->utime"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "account_user_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "116-131",
          "snippet": "void account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "694-711",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_user_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->utime += get_vtime_delta(vtime);\n\tif (vtime->utime >= TICK_NSEC) {\n\t\taccount_user_time(tsk, vtime->utime);\n\t\tvtime->utime = 0;\n\t}\n\tvtime->state = VTIME_SYS;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_user_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "749-757",
    "snippet": "void vtime_user_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_system(tsk, vtime);\n\tvtime->state = VTIME_USER;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vtime_account_system",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "__vtime_account_system",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "713-721",
          "snippet": "static void __vtime_account_system(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __vtime_account_system(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_user_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t__vtime_account_system(tsk, vtime);\n\tvtime->state = VTIME_USER;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_account_system",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "733-747",
    "snippet": "void vtime_account_system(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t/* We might have scheduled out from guest path */\n\tif (current->flags & PF_VCPU)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\t__vtime_account_system(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vtime_account_system",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "__vtime_account_system",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "713-721",
          "snippet": "static void __vtime_account_system(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __vtime_account_system(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_account_guest",
          "args": [
            "tsk",
            "vtime"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "723-731",
          "snippet": "static void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&vtime->seqcount"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "694-711",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_system(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t/* We might have scheduled out from guest path */\n\tif (current->flags & PF_VCPU)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\t__vtime_account_system(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}"
  },
  {
    "function_name": "vtime_account_guest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "723-731",
    "snippet": "static void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_guest_time",
          "args": [
            "tsk",
            "vtime->gtime"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "account_guest_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "138-155",
          "snippet": "void account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\tcpustat[CPUTIME_NICE] += cputime;\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\tcpustat[CPUTIME_USER] += cputime;\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\tcpustat[CPUTIME_NICE] += cputime;\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\tcpustat[CPUTIME_USER] += cputime;\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "694-711",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void vtime_account_guest(struct task_struct *tsk,\n\t\t\t\tstruct vtime *vtime)\n{\n\tvtime->gtime += get_vtime_delta(vtime);\n\tif (vtime->gtime >= TICK_NSEC) {\n\t\taccount_guest_time(tsk, vtime->gtime);\n\t\tvtime->gtime = 0;\n\t}\n}"
  },
  {
    "function_name": "__vtime_account_system",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "713-721",
    "snippet": "static void __vtime_account_system(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_system_time",
          "args": [
            "tsk",
            "irq_count()",
            "vtime->stime"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "account_system_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "183-200",
          "snippet": "void account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_count",
          "args": [],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "694-711",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void __vtime_account_system(struct task_struct *tsk,\n\t\t\t\t   struct vtime *vtime)\n{\n\tvtime->stime += get_vtime_delta(vtime);\n\tif (vtime->stime >= TICK_NSEC) {\n\t\taccount_system_time(tsk, irq_count(), vtime->stime);\n\t\tvtime->stime = 0;\n\t}\n}"
  },
  {
    "function_name": "get_vtime_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "694-711",
    "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vtime->state == VTIME_INACTIVE"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_other_time",
          "args": [
            "delta"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "account_other_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "254-266",
          "snippet": "static inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_delta",
          "args": [
            "vtime"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "get_vtime_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "694-711",
          "snippet": "static u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 get_vtime_delta(struct vtime *vtime)\n{\n\tu64 delta = vtime_delta(vtime);\n\tu64 other;\n\n\t/*\n\t * Unlike tick based timing, vtime based timing never has lost\n\t * ticks, and no need for steal time accounting to make up for\n\t * lost ticks. Vtime accounts a rounded version of actual\n\t * elapsed time. Limit account_other_time to prevent rounding\n\t * errors from causing elapsed vtime to go negative.\n\t */\n\tother = account_other_time(delta);\n\tWARN_ON_ONCE(vtime->state == VTIME_INACTIVE);\n\tvtime->starttime += delta;\n\n\treturn delta - other;\n}"
  },
  {
    "function_name": "vtime_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "683-692",
    "snippet": "static u64 vtime_delta(struct vtime *vtime)\n{\n\tunsigned long long clock;\n\n\tclock = sched_clock();\n\tif (clock < vtime->starttime)\n\t\treturn 0;\n\n\treturn clock - vtime->starttime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "disable_sched_clock_irqtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "28-31",
          "snippet": "void disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define sched_clock_irqtime\t(0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 vtime_delta(struct vtime *vtime)\n{\n\tunsigned long long clock;\n\n\tclock = sched_clock();\n\tif (clock < vtime->starttime)\n\t\treturn 0;\n\n\treturn clock - vtime->starttime;\n}"
  },
  {
    "function_name": "thread_group_cputime_adjusted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "673-679",
    "snippet": "void thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\tcputime_adjust(&cputime, &p->signal->prev_cputime, ut, st);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cputime_adjust",
          "args": [
            "&cputime",
            "&p->signal->prev_cputime",
            "ut",
            "st"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "cputime_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "590-660",
          "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicy code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = scale_stime(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicy code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = scale_stime(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "p",
            "&cputime"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "292-332",
          "snippet": "void thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\tcputime_adjust(&cputime, &p->signal->prev_cputime, ut, st);\n}"
  },
  {
    "function_name": "task_cputime_adjusted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "662-670",
    "snippet": "void task_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime = {\n\t\t.sum_exec_runtime = p->se.sum_exec_runtime,\n\t};\n\n\ttask_cputime(p, &cputime.utime, &cputime.stime);\n\tcputime_adjust(&cputime, &p->prev_cputime, ut, st);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cputime_adjust",
          "args": [
            "&cputime",
            "&p->prev_cputime",
            "ut",
            "st"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "cputime_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "590-660",
          "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicy code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = scale_stime(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicy code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = scale_stime(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "p",
            "&cputime.utime",
            "&cputime.stime"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "861-894",
          "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime = {\n\t\t.sum_exec_runtime = p->se.sum_exec_runtime,\n\t};\n\n\ttask_cputime(p, &cputime.utime, &cputime.stime);\n\tcputime_adjust(&cputime, &p->prev_cputime, ut, st);\n}"
  },
  {
    "function_name": "cputime_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "590-660",
    "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicy code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = scale_stime(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&prev->lock",
            "flags"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scale_stime",
          "args": [
            "stime",
            "rtime",
            "stime + utime"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "scale_stime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "530-568",
          "snippet": "static u64 scale_stime(u64 stime, u64 rtime, u64 total)\n{\n\tu64 scaled;\n\n\tfor (;;) {\n\t\t/* Make sure \"rtime\" is the bigger of stime/rtime */\n\t\tif (stime > rtime)\n\t\t\tswap(rtime, stime);\n\n\t\t/* Make sure 'total' fits in 32 bits */\n\t\tif (total >> 32)\n\t\t\tgoto drop_precision;\n\n\t\t/* Does rtime (and thus stime) fit in 32 bits? */\n\t\tif (!(rtime >> 32))\n\t\t\tbreak;\n\n\t\t/* Can we just balance rtime/stime rather than dropping bits? */\n\t\tif (stime >> 31)\n\t\t\tgoto drop_precision;\n\n\t\t/* We can grow stime and shrink rtime and try to make them both fit */\n\t\tstime <<= 1;\n\t\trtime >>= 1;\n\t\tcontinue;\n\ndrop_precision:\n\t\t/* We drop from rtime, it has more bits than stime */\n\t\trtime >>= 1;\n\t\ttotal >>= 1;\n\t}\n\n\t/*\n\t * Make sure gcc understands that this is a 32x32->64 multiply,\n\t * followed by a 64/32->64 divide.\n\t */\n\tscaled = div_u64((u64) (u32) stime * (u64) (u32) rtime, (u32)total);\n\treturn scaled;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 scale_stime(u64 stime, u64 rtime, u64 total)\n{\n\tu64 scaled;\n\n\tfor (;;) {\n\t\t/* Make sure \"rtime\" is the bigger of stime/rtime */\n\t\tif (stime > rtime)\n\t\t\tswap(rtime, stime);\n\n\t\t/* Make sure 'total' fits in 32 bits */\n\t\tif (total >> 32)\n\t\t\tgoto drop_precision;\n\n\t\t/* Does rtime (and thus stime) fit in 32 bits? */\n\t\tif (!(rtime >> 32))\n\t\t\tbreak;\n\n\t\t/* Can we just balance rtime/stime rather than dropping bits? */\n\t\tif (stime >> 31)\n\t\t\tgoto drop_precision;\n\n\t\t/* We can grow stime and shrink rtime and try to make them both fit */\n\t\tstime <<= 1;\n\t\trtime >>= 1;\n\t\tcontinue;\n\ndrop_precision:\n\t\t/* We drop from rtime, it has more bits than stime */\n\t\trtime >>= 1;\n\t\ttotal >>= 1;\n\t}\n\n\t/*\n\t * Make sure gcc understands that this is a 32x32->64 multiply,\n\t * followed by a 64/32->64 divide.\n\t */\n\tscaled = div_u64((u64) (u32) stime * (u64) (u32) rtime, (u32)total);\n\treturn scaled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&prev->lock",
            "flags"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\tu64 rtime, stime, utime;\n\tunsigned long flags;\n\n\t/* Serialize concurrent callers such that we can honour our guarantees */\n\traw_spin_lock_irqsave(&prev->lock, flags);\n\trtime = curr->sum_exec_runtime;\n\n\t/*\n\t * This is possible under two circumstances:\n\t *  - rtime isn't monotonic after all (a bug);\n\t *  - we got reordered by the lock.\n\t *\n\t * In both cases this acts as a filter such that the rest of the code\n\t * can assume it is monotonic regardless of anything else.\n\t */\n\tif (prev->stime + prev->utime >= rtime)\n\t\tgoto out;\n\n\tstime = curr->stime;\n\tutime = curr->utime;\n\n\t/*\n\t * If either stime or utime are 0, assume all runtime is userspace.\n\t * Once a task gets some ticks, the monotonicy code at 'update:'\n\t * will ensure things converge to the observed ratio.\n\t */\n\tif (stime == 0) {\n\t\tutime = rtime;\n\t\tgoto update;\n\t}\n\n\tif (utime == 0) {\n\t\tstime = rtime;\n\t\tgoto update;\n\t}\n\n\tstime = scale_stime(stime, rtime, stime + utime);\n\nupdate:\n\t/*\n\t * Make sure stime doesn't go backwards; this preserves monotonicity\n\t * for utime because rtime is monotonic.\n\t *\n\t *  utime_i+1 = rtime_i+1 - stime_i\n\t *            = rtime_i+1 - (rtime_i - utime_i)\n\t *            = (rtime_i+1 - rtime_i) + utime_i\n\t *            >= utime_i\n\t */\n\tif (stime < prev->stime)\n\t\tstime = prev->stime;\n\tutime = rtime - stime;\n\n\t/*\n\t * Make sure utime doesn't go backwards; this still preserves\n\t * monotonicity for stime, analogous argument to above.\n\t */\n\tif (utime < prev->utime) {\n\t\tutime = prev->utime;\n\t\tstime = rtime - utime;\n\t}\n\n\tprev->stime = stime;\n\tprev->utime = utime;\nout:\n\t*ut = prev->utime;\n\t*st = prev->stime;\n\traw_spin_unlock_irqrestore(&prev->lock, flags);\n}"
  },
  {
    "function_name": "scale_stime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "530-568",
    "snippet": "static u64 scale_stime(u64 stime, u64 rtime, u64 total)\n{\n\tu64 scaled;\n\n\tfor (;;) {\n\t\t/* Make sure \"rtime\" is the bigger of stime/rtime */\n\t\tif (stime > rtime)\n\t\t\tswap(rtime, stime);\n\n\t\t/* Make sure 'total' fits in 32 bits */\n\t\tif (total >> 32)\n\t\t\tgoto drop_precision;\n\n\t\t/* Does rtime (and thus stime) fit in 32 bits? */\n\t\tif (!(rtime >> 32))\n\t\t\tbreak;\n\n\t\t/* Can we just balance rtime/stime rather than dropping bits? */\n\t\tif (stime >> 31)\n\t\t\tgoto drop_precision;\n\n\t\t/* We can grow stime and shrink rtime and try to make them both fit */\n\t\tstime <<= 1;\n\t\trtime >>= 1;\n\t\tcontinue;\n\ndrop_precision:\n\t\t/* We drop from rtime, it has more bits than stime */\n\t\trtime >>= 1;\n\t\ttotal >>= 1;\n\t}\n\n\t/*\n\t * Make sure gcc understands that this is a 32x32->64 multiply,\n\t * followed by a 64/32->64 divide.\n\t */\n\tscaled = div_u64((u64) (u32) stime * (u64) (u32) rtime, (u32)total);\n\treturn scaled;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "(u64) (u32) stime * (u64) (u32) rtime",
            "(u32)total"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "rtime",
            "stime"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "__migrate_swap_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1185-1215",
          "snippet": "static void __migrate_swap_task(struct task_struct *p, int cpu)\n{\n\tif (task_on_rq_queued(p)) {\n\t\tstruct rq *src_rq, *dst_rq;\n\t\tstruct rq_flags srf, drf;\n\n\t\tsrc_rq = task_rq(p);\n\t\tdst_rq = cpu_rq(cpu);\n\n\t\trq_pin_lock(src_rq, &srf);\n\t\trq_pin_lock(dst_rq, &drf);\n\n\t\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\t\tdeactivate_task(src_rq, p, 0);\n\t\tset_task_cpu(p, cpu);\n\t\tactivate_task(dst_rq, p, 0);\n\t\tp->on_rq = TASK_ON_RQ_QUEUED;\n\t\tcheck_preempt_curr(dst_rq, p, 0);\n\n\t\trq_unpin_lock(dst_rq, &drf);\n\t\trq_unpin_lock(src_rq, &srf);\n\n\t} else {\n\t\t/*\n\t\t * Task isn't running anymore; make it appear like we migrated\n\t\t * it before it went to sleep. This means on wakeup we make the\n\t\t * previous CPU our target instead of where it really is.\n\t\t */\n\t\tp->wake_cpu = cpu;\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic void __migrate_swap_task(struct task_struct *p, int cpu)\n{\n\tif (task_on_rq_queued(p)) {\n\t\tstruct rq *src_rq, *dst_rq;\n\t\tstruct rq_flags srf, drf;\n\n\t\tsrc_rq = task_rq(p);\n\t\tdst_rq = cpu_rq(cpu);\n\n\t\trq_pin_lock(src_rq, &srf);\n\t\trq_pin_lock(dst_rq, &drf);\n\n\t\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\t\tdeactivate_task(src_rq, p, 0);\n\t\tset_task_cpu(p, cpu);\n\t\tactivate_task(dst_rq, p, 0);\n\t\tp->on_rq = TASK_ON_RQ_QUEUED;\n\t\tcheck_preempt_curr(dst_rq, p, 0);\n\n\t\trq_unpin_lock(dst_rq, &drf);\n\t\trq_unpin_lock(src_rq, &srf);\n\n\t} else {\n\t\t/*\n\t\t * Task isn't running anymore; make it appear like we migrated\n\t\t * it before it went to sleep. This means on wakeup we make the\n\t\t * previous CPU our target instead of where it really is.\n\t\t */\n\t\tp->wake_cpu = cpu;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 scale_stime(u64 stime, u64 rtime, u64 total)\n{\n\tu64 scaled;\n\n\tfor (;;) {\n\t\t/* Make sure \"rtime\" is the bigger of stime/rtime */\n\t\tif (stime > rtime)\n\t\t\tswap(rtime, stime);\n\n\t\t/* Make sure 'total' fits in 32 bits */\n\t\tif (total >> 32)\n\t\t\tgoto drop_precision;\n\n\t\t/* Does rtime (and thus stime) fit in 32 bits? */\n\t\tif (!(rtime >> 32))\n\t\t\tbreak;\n\n\t\t/* Can we just balance rtime/stime rather than dropping bits? */\n\t\tif (stime >> 31)\n\t\t\tgoto drop_precision;\n\n\t\t/* We can grow stime and shrink rtime and try to make them both fit */\n\t\tstime <<= 1;\n\t\trtime >>= 1;\n\t\tcontinue;\n\ndrop_precision:\n\t\t/* We drop from rtime, it has more bits than stime */\n\t\trtime >>= 1;\n\t\ttotal >>= 1;\n\t}\n\n\t/*\n\t * Make sure gcc understands that this is a 32x32->64 multiply,\n\t * followed by a 64/32->64 divide.\n\t */\n\tscaled = div_u64((u64) (u32) stime * (u64) (u32) rtime, (u32)total);\n\treturn scaled;\n}"
  },
  {
    "function_name": "account_idle_ticks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "507-524",
    "snippet": "void account_idle_ticks(unsigned long ticks)\n{\n\tu64 cputime, steal;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_idle_ticks(ticks);\n\t\treturn;\n\t}\n\n\tcputime = ticks * TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\taccount_idle_time(cputime);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define sched_clock_irqtime\t(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_idle_time",
          "args": [
            "cputime"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "account_idle_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "217-226",
          "snippet": "void account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_account_process_time",
          "args": [
            "ULONG_MAX"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "steal_account_process_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "233-249",
          "snippet": "static __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqtime_account_idle_ticks",
          "args": [
            "ticks"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "irqtime_account_idle_ticks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "399-399",
          "snippet": "static inline void irqtime_account_idle_ticks(int ticks) { }",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void irqtime_account_idle_ticks(int ticks) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid account_idle_ticks(unsigned long ticks)\n{\n\tu64 cputime, steal;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_idle_ticks(ticks);\n\t\treturn;\n\t}\n\n\tcputime = ticks * TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\taccount_idle_time(cputime);\n}"
  },
  {
    "function_name": "account_process_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "474-501",
    "snippet": "void account_process_tick(struct task_struct *p, int user_tick)\n{\n\tu64 cputime, steal;\n\tstruct rq *rq = this_rq();\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_process_tick(p, user_tick, rq, 1);\n\t\treturn;\n\t}\n\n\tcputime = TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\n\tif (user_tick)\n\t\taccount_user_time(p, cputime);\n\telse if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))\n\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime);\n\telse\n\t\taccount_idle_time(cputime);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define sched_clock_irqtime\t(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_idle_time",
          "args": [
            "cputime"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "account_idle_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "217-226",
          "snippet": "void account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_system_time",
          "args": [
            "p",
            "HARDIRQ_OFFSET",
            "cputime"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "account_system_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "183-200",
          "snippet": "void account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_count",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_user_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "account_user_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "116-131",
          "snippet": "void account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_account_process_time",
          "args": [
            "ULONG_MAX"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "steal_account_process_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "233-249",
          "snippet": "static __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqtime_account_process_tick",
          "args": [
            "p",
            "user_tick",
            "rq",
            "1"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "irqtime_account_process_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "400-401",
          "snippet": "static inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tstruct rq *rq, int nr_ticks) { }",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tstruct rq *rq, int nr_ticks) { }"
        }
      },
      {
        "call_info": {
          "callee": "vtime_accounting_cpu_enabled",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid account_process_tick(struct task_struct *p, int user_tick)\n{\n\tu64 cputime, steal;\n\tstruct rq *rq = this_rq();\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_process_tick(p, user_tick, rq, 1);\n\t\treturn;\n\t}\n\n\tcputime = TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\n\tif (user_tick)\n\t\taccount_user_time(p, cputime);\n\telse if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))\n\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime);\n\telse\n\t\taccount_idle_time(cputime);\n}"
  },
  {
    "function_name": "thread_group_cputime_adjusted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "457-465",
    "snippet": "void thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\n\t*ut = cputime.utime;\n\t*st = cputime.stime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "p",
            "&cputime"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "292-332",
          "snippet": "void thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\n\t*ut = cputime.utime;\n\t*st = cputime.stime;\n}"
  },
  {
    "function_name": "task_cputime_adjusted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "450-454",
    "snippet": "void task_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\t*ut = p->utime;\n\t*st = p->stime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\t*ut = p->utime;\n\t*st = p->stime;\n}"
  },
  {
    "function_name": "cputime_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "443-448",
    "snippet": "void cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\t*ut = curr->utime;\n\t*st = curr->stime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid cputime_adjust(struct task_cputime *curr, struct prev_cputime *prev,\n\t\t    u64 *ut, u64 *st)\n{\n\t*ut = curr->utime;\n\t*st = curr->stime;\n}"
  },
  {
    "function_name": "vtime_account_irq_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "433-439",
    "snippet": "void vtime_account_irq_enter(struct task_struct *tsk)\n{\n\tif (!in_interrupt() && is_idle_task(tsk))\n\t\tvtime_account_idle(tsk);\n\telse\n\t\tvtime_account_system(tsk);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtime_account_system",
          "args": [
            "tsk"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_system",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "733-747",
          "snippet": "void vtime_account_system(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t/* We might have scheduled out from guest path */\n\tif (current->flags & PF_VCPU)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\t__vtime_account_system(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_system(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t/* We might have scheduled out from guest path */\n\tif (current->flags & PF_VCPU)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\t__vtime_account_system(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_account_idle",
          "args": [
            "tsk"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "801-804",
          "snippet": "void vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "tsk"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_irq_enter(struct task_struct *tsk)\n{\n\tif (!in_interrupt() && is_idle_task(tsk))\n\t\tvtime_account_idle(tsk);\n\telse\n\t\tvtime_account_system(tsk);\n}"
  },
  {
    "function_name": "vtime_common_task_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "409-418",
    "snippet": "void vtime_common_task_switch(struct task_struct *prev)\n{\n\tif (is_idle_task(prev))\n\t\tvtime_account_idle(prev);\n\telse\n\t\tvtime_account_system(prev);\n\n\tvtime_flush(prev);\n\tarch_vtime_task_switch(prev);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_vtime_task_switch",
          "args": [
            "prev"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "arch_vtime_task_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "806-820",
          "snippet": "void arch_vtime_task_switch(struct task_struct *prev)\n{\n\tstruct vtime *vtime = &prev->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_INACTIVE;\n\twrite_seqcount_end(&vtime->seqcount);\n\n\tvtime = &current->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\twrite_seqcount_end(&vtime->seqcount);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid arch_vtime_task_switch(struct task_struct *prev)\n{\n\tstruct vtime *vtime = &prev->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_INACTIVE;\n\twrite_seqcount_end(&vtime->seqcount);\n\n\tvtime = &current->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->state = VTIME_SYS;\n\tvtime->starttime = sched_clock();\n\twrite_seqcount_end(&vtime->seqcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_flush",
          "args": [
            "prev"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_account_system",
          "args": [
            "prev"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_system",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "733-747",
          "snippet": "void vtime_account_system(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t/* We might have scheduled out from guest path */\n\tif (current->flags & PF_VCPU)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\t__vtime_account_system(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_system(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\tif (!vtime_delta(vtime))\n\t\treturn;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\t/* We might have scheduled out from guest path */\n\tif (current->flags & PF_VCPU)\n\t\tvtime_account_guest(tsk, vtime);\n\telse\n\t\t__vtime_account_system(tsk, vtime);\n\twrite_seqcount_end(&vtime->seqcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtime_account_idle",
          "args": [
            "prev"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_account_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "801-804",
          "snippet": "void vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_account_idle(struct task_struct *tsk)\n{\n\taccount_idle_time(get_vtime_delta(&tsk->vtime));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "prev"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_common_task_switch(struct task_struct *prev)\n{\n\tif (is_idle_task(prev))\n\t\tvtime_account_idle(prev);\n\telse\n\t\tvtime_account_system(prev);\n\n\tvtime_flush(prev);\n\tarch_vtime_task_switch(prev);\n}"
  },
  {
    "function_name": "irqtime_account_process_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "400-401",
    "snippet": "static inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tstruct rq *rq, int nr_ticks) { }",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tstruct rq *rq, int nr_ticks) { }"
  },
  {
    "function_name": "irqtime_account_idle_ticks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "399-399",
    "snippet": "static inline void irqtime_account_idle_ticks(int ticks) { }",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void irqtime_account_idle_ticks(int ticks) { }"
  },
  {
    "function_name": "irqtime_account_idle_ticks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "392-397",
    "snippet": "static void irqtime_account_idle_ticks(int ticks)\n{\n\tstruct rq *rq = this_rq();\n\n\tirqtime_account_process_tick(current, 0, rq, ticks);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqtime_account_process_tick",
          "args": [
            "current",
            "0",
            "rq",
            "ticks"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "irqtime_account_process_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "400-401",
          "snippet": "static inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tstruct rq *rq, int nr_ticks) { }",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t\tstruct rq *rq, int nr_ticks) { }"
        }
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void irqtime_account_idle_ticks(int ticks)\n{\n\tstruct rq *rq = this_rq();\n\n\tirqtime_account_process_tick(current, 0, rq, ticks);\n}"
  },
  {
    "function_name": "irqtime_account_process_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "356-390",
    "snippet": "static void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t struct rq *rq, int ticks)\n{\n\tu64 other, cputime = TICK_NSEC * ticks;\n\n\t/*\n\t * When returning from idle, many ticks can get accounted at\n\t * once, including some ticks of steal, irq, and softirq time.\n\t * Subtract those ticks from the amount of time accounted to\n\t * idle, or potentially user or system time. Due to rounding,\n\t * other time can exceed ticks occasionally.\n\t */\n\tother = account_other_time(ULONG_MAX);\n\tif (other >= cputime)\n\t\treturn;\n\n\tcputime -= other;\n\n\tif (this_cpu_ksoftirqd() == p) {\n\t\t/*\n\t\t * ksoftirqd time do not get accounted in cpu_softirq_time.\n\t\t * So, we have to handle it separately here.\n\t\t * Also, p->stime needs to be updated for ksoftirqd.\n\t\t */\n\t\taccount_system_index_time(p, cputime, CPUTIME_SOFTIRQ);\n\t} else if (user_tick) {\n\t\taccount_user_time(p, cputime);\n\t} else if (p == rq->idle) {\n\t\taccount_idle_time(cputime);\n\t} else if (p->flags & PF_VCPU) { /* System time or guest time */\n\t\taccount_guest_time(p, cputime);\n\t} else {\n\t\taccount_system_index_time(p, cputime, CPUTIME_SYSTEM);\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_system_index_time",
          "args": [
            "p",
            "cputime",
            "CPUTIME_SYSTEM"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "account_system_index_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "163-175",
          "snippet": "void account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_guest_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "account_guest_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "138-155",
          "snippet": "void account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\tcpustat[CPUTIME_NICE] += cputime;\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\tcpustat[CPUTIME_USER] += cputime;\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\tcpustat[CPUTIME_NICE] += cputime;\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\tcpustat[CPUTIME_USER] += cputime;\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_idle_time",
          "args": [
            "cputime"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "account_idle_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "217-226",
          "snippet": "void account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_user_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "account_user_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "116-131",
          "snippet": "void account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ksoftirqd",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_other_time",
          "args": [
            "ULONG_MAX"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "account_other_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "254-266",
          "snippet": "static inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void irqtime_account_process_tick(struct task_struct *p, int user_tick,\n\t\t\t\t\t struct rq *rq, int ticks)\n{\n\tu64 other, cputime = TICK_NSEC * ticks;\n\n\t/*\n\t * When returning from idle, many ticks can get accounted at\n\t * once, including some ticks of steal, irq, and softirq time.\n\t * Subtract those ticks from the amount of time accounted to\n\t * idle, or potentially user or system time. Due to rounding,\n\t * other time can exceed ticks occasionally.\n\t */\n\tother = account_other_time(ULONG_MAX);\n\tif (other >= cputime)\n\t\treturn;\n\n\tcputime -= other;\n\n\tif (this_cpu_ksoftirqd() == p) {\n\t\t/*\n\t\t * ksoftirqd time do not get accounted in cpu_softirq_time.\n\t\t * So, we have to handle it separately here.\n\t\t * Also, p->stime needs to be updated for ksoftirqd.\n\t\t */\n\t\taccount_system_index_time(p, cputime, CPUTIME_SOFTIRQ);\n\t} else if (user_tick) {\n\t\taccount_user_time(p, cputime);\n\t} else if (p == rq->idle) {\n\t\taccount_idle_time(cputime);\n\t} else if (p->flags & PF_VCPU) { /* System time or guest time */\n\t\taccount_guest_time(p, cputime);\n\t} else {\n\t\taccount_system_index_time(p, cputime, CPUTIME_SYSTEM);\n\t}\n}"
  },
  {
    "function_name": "thread_group_cputime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "292-332",
    "snippet": "void thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "done_seqretry_irqrestore",
          "args": [
            "&sig->stats_lock",
            "seq",
            "flags"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_seqretry",
          "args": [
            "&sig->stats_lock",
            "seq"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_sum_exec_runtime",
          "args": [
            "t"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "read_sum_exec_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "274-285",
          "snippet": "static u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\tu64 ns;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(t, &rf);\n\tns = t->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, t, &rf);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\tu64 ns;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(t, &rf);\n\tns = t->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, t, &rf);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "t",
            "&utime",
            "&stime"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "861-894",
          "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "tsk",
            "t"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin_or_lock_irqsave",
          "args": [
            "&sig->stats_lock",
            "&seq"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_sched_runtime",
          "args": [
            "current"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "current",
            "tsk"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tu64 utime, stime;\n\tstruct task_struct *t;\n\tunsigned int seq, nextseq;\n\tunsigned long flags;\n\n\t/*\n\t * Update current task runtime to account pending time since last\n\t * scheduler action or thread_group_cputime() call. This thread group\n\t * might have other running tasks on different CPUs, but updating\n\t * their runtime can affect syscall performance, so we skip account\n\t * those pending times and rely only on values updated on tick or\n\t * other scheduler action.\n\t */\n\tif (same_thread_group(current, tsk))\n\t\t(void) task_sched_runtime(current);\n\n\trcu_read_lock();\n\t/* Attempt a lockless read on the first round. */\n\tnextseq = 0;\n\tdo {\n\t\tseq = nextseq;\n\t\tflags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);\n\t\ttimes->utime = sig->utime;\n\t\ttimes->stime = sig->stime;\n\t\ttimes->sum_exec_runtime = sig->sum_sched_runtime;\n\n\t\tfor_each_thread(tsk, t) {\n\t\t\ttask_cputime(t, &utime, &stime);\n\t\t\ttimes->utime += utime;\n\t\t\ttimes->stime += stime;\n\t\t\ttimes->sum_exec_runtime += read_sum_exec_runtime(t);\n\t\t}\n\t\t/* If lockless access failed, take the lock. */\n\t\tnextseq = 1;\n\t} while (need_seqretry(&sig->stats_lock, seq));\n\tdone_seqretry_irqrestore(&sig->stats_lock, seq, flags);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "read_sum_exec_runtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "274-285",
    "snippet": "static u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\tu64 ns;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(t, &rf);\n\tns = t->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, t, &rf);\n\n\treturn ns;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "t",
            "&rf"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "t",
            "&rf"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\tu64 ns;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(t, &rf);\n\tns = t->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, t, &rf);\n\n\treturn ns;\n}"
  },
  {
    "function_name": "read_sum_exec_runtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "269-272",
    "snippet": "static inline u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\treturn t->se.sum_exec_runtime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline u64 read_sum_exec_runtime(struct task_struct *t)\n{\n\treturn t->se.sum_exec_runtime;\n}"
  },
  {
    "function_name": "account_other_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "254-266",
    "snippet": "static inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqtime_tick_accounted",
          "args": [
            "max - accounted"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "irqtime_tick_accounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "90-93",
          "snippet": "static u64 irqtime_tick_accounted(u64 dummy)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 irqtime_tick_accounted(u64 dummy)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "steal_account_process_time",
          "args": [
            "max"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "steal_account_process_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "233-249",
          "snippet": "static __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline u64 account_other_time(u64 max)\n{\n\tu64 accounted;\n\n\tlockdep_assert_irqs_disabled();\n\n\taccounted = steal_account_process_time(max);\n\n\tif (accounted < max)\n\t\taccounted += irqtime_tick_accounted(max - accounted);\n\n\treturn accounted;\n}"
  },
  {
    "function_name": "steal_account_process_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "233-249",
    "snippet": "static __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_steal_time",
          "args": [
            "steal"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "account_steal_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "206-211",
          "snippet": "void account_steal_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tcpustat[CPUTIME_STEAL] += cputime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_steal_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tcpustat[CPUTIME_STEAL] += cputime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "steal",
            "maxtime"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "248-251",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paravirt_steal_clock",
          "args": [
            "smp_processor_id()"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_false",
          "args": [
            "&paravirt_steal_enabled"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic __always_inline u64 steal_account_process_time(u64 maxtime)\n{\n#ifdef CONFIG_PARAVIRT\n\tif (static_key_false(&paravirt_steal_enabled)) {\n\t\tu64 steal;\n\n\t\tsteal = paravirt_steal_clock(smp_processor_id());\n\t\tsteal -= this_rq()->prev_steal_time;\n\t\tsteal = min(steal, maxtime);\n\t\taccount_steal_time(steal);\n\t\tthis_rq()->prev_steal_time += steal;\n\n\t\treturn steal;\n\t}\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "account_idle_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "217-226",
    "snippet": "void account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rq->nr_iowait"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_idle_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\tstruct rq *rq = this_rq();\n\n\tif (atomic_read(&rq->nr_iowait) > 0)\n\t\tcpustat[CPUTIME_IOWAIT] += cputime;\n\telse\n\t\tcpustat[CPUTIME_IDLE] += cputime;\n}"
  },
  {
    "function_name": "account_steal_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "206-211",
    "snippet": "void account_steal_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tcpustat[CPUTIME_STEAL] += cputime;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_steal_time(u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tcpustat[CPUTIME_STEAL] += cputime;\n}"
  },
  {
    "function_name": "account_system_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "183-200",
    "snippet": "void account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_system_index_time",
          "args": [
            "p",
            "cputime",
            "index"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "account_system_index_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "163-175",
          "snippet": "void account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_guest_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "account_guest_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "138-155",
          "snippet": "void account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\tcpustat[CPUTIME_NICE] += cputime;\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\tcpustat[CPUTIME_USER] += cputime;\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\tcpustat[CPUTIME_NICE] += cputime;\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\tcpustat[CPUTIME_USER] += cputime;\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_count",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_time(struct task_struct *p, int hardirq_offset, u64 cputime)\n{\n\tint index;\n\n\tif ((p->flags & PF_VCPU) && (irq_count() - hardirq_offset == 0)) {\n\t\taccount_guest_time(p, cputime);\n\t\treturn;\n\t}\n\n\tif (hardirq_count() - hardirq_offset)\n\t\tindex = CPUTIME_IRQ;\n\telse if (in_serving_softirq())\n\t\tindex = CPUTIME_SOFTIRQ;\n\telse\n\t\tindex = CPUTIME_SYSTEM;\n\n\taccount_system_index_time(p, cputime, index);\n}"
  },
  {
    "function_name": "account_system_index_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "163-175",
    "snippet": "void account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "acct_account_cputime",
          "args": [
            "p"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "acct_account_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tsacct.c",
          "lines": "170-173",
          "snippet": "void acct_account_cputime(struct task_struct *tsk)\n{\n\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/acct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid acct_account_cputime(struct task_struct *tsk)\n{\n\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_group_account_field",
          "args": [
            "p",
            "index",
            "cputime"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_account_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "97-109",
          "snippet": "static inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_group_system_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_system_index_time(struct task_struct *p,\n\t\t\t       u64 cputime, enum cpu_usage_stat index)\n{\n\t/* Add system time to process. */\n\tp->stime += cputime;\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for system time used */\n\tacct_account_cputime(p);\n}"
  },
  {
    "function_name": "account_guest_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "138-155",
    "snippet": "void account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\tcpustat[CPUTIME_NICE] += cputime;\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\tcpustat[CPUTIME_USER] += cputime;\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_group_user_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_guest_time(struct task_struct *p, u64 cputime)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\t/* Add guest time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\tp->gtime += cputime;\n\n\t/* Add guest time to cpustat. */\n\tif (task_nice(p) > 0) {\n\t\tcpustat[CPUTIME_NICE] += cputime;\n\t\tcpustat[CPUTIME_GUEST_NICE] += cputime;\n\t} else {\n\t\tcpustat[CPUTIME_USER] += cputime;\n\t\tcpustat[CPUTIME_GUEST] += cputime;\n\t}\n}"
  },
  {
    "function_name": "account_user_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "116-131",
    "snippet": "void account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "acct_account_cputime",
          "args": [
            "p"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "acct_account_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tsacct.c",
          "lines": "170-173",
          "snippet": "void acct_account_cputime(struct task_struct *tsk)\n{\n\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/acct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid acct_account_cputime(struct task_struct *tsk)\n{\n\t__acct_update_integrals(tsk, tsk->utime, tsk->stime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_group_account_field",
          "args": [
            "p",
            "index",
            "cputime"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_account_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "97-109",
          "snippet": "static inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_group_user_time",
          "args": [
            "p",
            "cputime"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid account_user_time(struct task_struct *p, u64 cputime)\n{\n\tint index;\n\n\t/* Add user time to process. */\n\tp->utime += cputime;\n\taccount_group_user_time(p, cputime);\n\n\tindex = (task_nice(p) > 0) ? CPUTIME_NICE : CPUTIME_USER;\n\n\t/* Add user time to cpustat. */\n\ttask_group_account_field(p, index, cputime);\n\n\t/* Account for user time used */\n\tacct_account_cputime(p);\n}"
  },
  {
    "function_name": "task_group_account_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "97-109",
    "snippet": "static inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_account_cputime_field",
          "args": [
            "p",
            "index",
            "tmp"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_account_cputime_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "371-393",
          "snippet": "void __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp);\n\n\tswitch (index) {\n\tcase CPUTIME_USER:\n\tcase CPUTIME_NICE:\n\t\trstatc->bstat.cputime.utime += delta_exec;\n\t\tbreak;\n\tcase CPUTIME_SYSTEM:\n\tcase CPUTIME_IRQ:\n\tcase CPUTIME_SOFTIRQ:\n\t\trstatc->bstat.cputime.stime += delta_exec;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp);\n\n\tswitch (index) {\n\tcase CPUTIME_USER:\n\tcase CPUTIME_NICE:\n\t\trstatc->bstat.cputime.utime += delta_exec;\n\t\tbreak;\n\tcase CPUTIME_SYSTEM:\n\tcase CPUTIME_IRQ:\n\tcase CPUTIME_SOFTIRQ:\n\t\trstatc->bstat.cputime.stime += delta_exec;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_add",
          "args": [
            "kernel_cpustat.cpustat[index]",
            "tmp"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline void task_group_account_field(struct task_struct *p, int index,\n\t\t\t\t\t    u64 tmp)\n{\n\t/*\n\t * Since all updates are sure to touch the root cgroup, we\n\t * get ourselves ahead and touch it first. If the root cgroup\n\t * is the only cgroup, then nothing else should be necessary.\n\t *\n\t */\n\t__this_cpu_add(kernel_cpustat.cpustat[index], tmp);\n\n\tcgroup_account_cputime_field(p, index, tmp);\n}"
  },
  {
    "function_name": "irqtime_tick_accounted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "90-93",
    "snippet": "static u64 irqtime_tick_accounted(u64 dummy)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 irqtime_tick_accounted(u64 dummy)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "irqtime_tick_accounted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "75-84",
    "snippet": "static u64 irqtime_tick_accounted(u64 maxtime)\n{\n\tstruct irqtime *irqtime = this_cpu_ptr(&cpu_irqtime);\n\tu64 delta;\n\n\tdelta = min(irqtime->tick_delta, maxtime);\n\tirqtime->tick_delta -= delta;\n\n\treturn delta;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "irqtime->tick_delta",
            "maxtime"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "248-251",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpu_irqtime"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic u64 irqtime_tick_accounted(u64 maxtime)\n{\n\tstruct irqtime *irqtime = this_cpu_ptr(&cpu_irqtime);\n\tu64 delta;\n\n\tdelta = min(irqtime->tick_delta, maxtime);\n\tirqtime->tick_delta -= delta;\n\n\treturn delta;\n}"
  },
  {
    "function_name": "irqtime_account_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "49-72",
    "snippet": "void irqtime_account_irq(struct task_struct *curr)\n{\n\tstruct irqtime *irqtime = this_cpu_ptr(&cpu_irqtime);\n\ts64 delta;\n\tint cpu;\n\n\tif (!sched_clock_irqtime)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tdelta = sched_clock_cpu(cpu) - irqtime->irq_start_time;\n\tirqtime->irq_start_time += delta;\n\n\t/*\n\t * We do not account for softirq time from ksoftirqd here.\n\t * We want to continue accounting softirq time to ksoftirqd thread\n\t * in that case, so as not to confuse scheduler with a special task\n\t * that do not consume any time, but still wants to run.\n\t */\n\tif (hardirq_count())\n\t\tirqtime_account_delta(irqtime, delta, CPUTIME_IRQ);\n\telse if (in_serving_softirq() && curr != this_cpu_ksoftirqd())\n\t\tirqtime_account_delta(irqtime, delta, CPUTIME_SOFTIRQ);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define sched_clock_irqtime\t(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqtime_account_delta",
          "args": [
            "irqtime",
            "delta",
            "CPUTIME_SOFTIRQ"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "irqtime_account_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "33-43",
          "snippet": "static void irqtime_account_delta(struct irqtime *irqtime, u64 delta,\n\t\t\t\t  enum cpu_usage_stat idx)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tu64_stats_update_begin(&irqtime->sync);\n\tcpustat[idx] += delta;\n\tirqtime->total += delta;\n\tirqtime->tick_delta += delta;\n\tu64_stats_update_end(&irqtime->sync);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void irqtime_account_delta(struct irqtime *irqtime, u64 delta,\n\t\t\t\t  enum cpu_usage_stat idx)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tu64_stats_update_begin(&irqtime->sync);\n\tcpustat[idx] += delta;\n\tirqtime->total += delta;\n\tirqtime->tick_delta += delta;\n\tu64_stats_update_end(&irqtime->sync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ksoftirqd",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hardirq_count",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_cpu",
          "args": [
            "cpu"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "460-466",
          "snippet": "u64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nu64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpu_irqtime"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid irqtime_account_irq(struct task_struct *curr)\n{\n\tstruct irqtime *irqtime = this_cpu_ptr(&cpu_irqtime);\n\ts64 delta;\n\tint cpu;\n\n\tif (!sched_clock_irqtime)\n\t\treturn;\n\n\tcpu = smp_processor_id();\n\tdelta = sched_clock_cpu(cpu) - irqtime->irq_start_time;\n\tirqtime->irq_start_time += delta;\n\n\t/*\n\t * We do not account for softirq time from ksoftirqd here.\n\t * We want to continue accounting softirq time to ksoftirqd thread\n\t * in that case, so as not to confuse scheduler with a special task\n\t * that do not consume any time, but still wants to run.\n\t */\n\tif (hardirq_count())\n\t\tirqtime_account_delta(irqtime, delta, CPUTIME_IRQ);\n\telse if (in_serving_softirq() && curr != this_cpu_ksoftirqd())\n\t\tirqtime_account_delta(irqtime, delta, CPUTIME_SOFTIRQ);\n}"
  },
  {
    "function_name": "irqtime_account_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "33-43",
    "snippet": "static void irqtime_account_delta(struct irqtime *irqtime, u64 delta,\n\t\t\t\t  enum cpu_usage_stat idx)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tu64_stats_update_begin(&irqtime->sync);\n\tcpustat[idx] += delta;\n\tirqtime->total += delta;\n\tirqtime->tick_delta += delta;\n\tu64_stats_update_end(&irqtime->sync);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_update_end",
          "args": [
            "&irqtime->sync"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_update_begin",
          "args": [
            "&irqtime->sync"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void irqtime_account_delta(struct irqtime *irqtime, u64 delta,\n\t\t\t\t  enum cpu_usage_stat idx)\n{\n\tu64 *cpustat = kcpustat_this_cpu->cpustat;\n\n\tu64_stats_update_begin(&irqtime->sync);\n\tcpustat[idx] += delta;\n\tirqtime->total += delta;\n\tirqtime->tick_delta += delta;\n\tu64_stats_update_end(&irqtime->sync);\n}"
  },
  {
    "function_name": "disable_sched_clock_irqtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "28-31",
    "snippet": "void disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define sched_clock_irqtime\t(0)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid disable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 0;\n}"
  },
  {
    "function_name": "enable_sched_clock_irqtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
    "lines": "23-26",
    "snippet": "void enable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 1;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define sched_clock_irqtime\t(0)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid enable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 1;\n}"
  }
]