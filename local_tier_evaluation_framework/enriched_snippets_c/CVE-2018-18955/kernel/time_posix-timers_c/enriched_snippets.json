[
  {
    "function_name": "clockid_to_kclock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1357-1370",
    "snippet": "static const struct k_clock *clockid_to_kclock(const clockid_t id)\n{\n\tclockid_t idx = id;\n\n\tif (id < 0) {\n\t\treturn (id & CLOCKFD_MASK) == CLOCKFD ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\t}\n\n\tif (id >= ARRAY_SIZE(posix_clocks))\n\t\treturn NULL;\n\n\treturn posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct k_clock * const posix_clocks[];",
      "static const struct k_clock *clockid_to_kclock(const clockid_t id);",
      "static const struct k_clock * const posix_clocks[] = {\n\t[CLOCK_REALTIME]\t\t= &clock_realtime,\n\t[CLOCK_MONOTONIC]\t\t= &clock_monotonic,\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= &clock_process,\n\t[CLOCK_THREAD_CPUTIME_ID]\t= &clock_thread,\n\t[CLOCK_MONOTONIC_RAW]\t\t= &clock_monotonic_raw,\n\t[CLOCK_REALTIME_COARSE]\t\t= &clock_realtime_coarse,\n\t[CLOCK_MONOTONIC_COARSE]\t= &clock_monotonic_coarse,\n\t[CLOCK_BOOTTIME]\t\t= &clock_boottime,\n\t[CLOCK_REALTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_BOOTTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_TAI]\t\t\t= &clock_tai,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "idx",
            "ARRAY_SIZE(posix_clocks)"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "posix_clocks"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "posix_clocks"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic const struct k_clock * const posix_clocks[];\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\nstatic const struct k_clock * const posix_clocks[] = {\n\t[CLOCK_REALTIME]\t\t= &clock_realtime,\n\t[CLOCK_MONOTONIC]\t\t= &clock_monotonic,\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= &clock_process,\n\t[CLOCK_THREAD_CPUTIME_ID]\t= &clock_thread,\n\t[CLOCK_MONOTONIC_RAW]\t\t= &clock_monotonic_raw,\n\t[CLOCK_REALTIME_COARSE]\t\t= &clock_realtime_coarse,\n\t[CLOCK_MONOTONIC_COARSE]\t= &clock_monotonic_coarse,\n\t[CLOCK_BOOTTIME]\t\t= &clock_boottime,\n\t[CLOCK_REALTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_BOOTTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_TAI]\t\t\t= &clock_tai,\n};\n\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id)\n{\n\tclockid_t idx = id;\n\n\tif (id < 0) {\n\t\treturn (id & CLOCKFD_MASK) == CLOCKFD ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\t}\n\n\tif (id >= ARRAY_SIZE(posix_clocks))\n\t\treturn NULL;\n\n\treturn posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];\n}"
  },
  {
    "function_name": "common_nsleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1204-1210",
    "snippet": "static int common_nsleep(const clockid_t which_clock, int flags,\n\t\t\t const struct timespec64 *rqtp)\n{\n\treturn hrtimer_nanosleep(rqtp, flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL,\n\t\t\t\t which_clock);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_nanosleep",
          "args": [
            "rqtp",
            "flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL",
            "which_clock"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_nanosleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1728-1759",
          "snippet": "long hrtimer_nanosleep(const struct timespec64 *rqtp,\n\t\t       const enum hrtimer_mode mode, const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tu64 slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_on_stack(&t.timer, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, timespec64_to_ktime(*rqtp), slack);\n\tret = do_nanosleep(&t, mode);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\tgoto out;\n\n\t/* Absolute timers do not update the rmtp value and restart: */\n\tif (mode == HRTIMER_MODE_ABS) {\n\t\tret = -ERESTARTNOHAND;\n\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->fn = hrtimer_nanosleep_restart;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nlong hrtimer_nanosleep(const struct timespec64 *rqtp,\n\t\t       const enum hrtimer_mode mode, const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tu64 slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_on_stack(&t.timer, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, timespec64_to_ktime(*rqtp), slack);\n\tret = do_nanosleep(&t, mode);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\tgoto out;\n\n\t/* Absolute timers do not update the rmtp value and restart: */\n\tif (mode == HRTIMER_MODE_ABS) {\n\t\tret = -ERESTARTNOHAND;\n\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->fn = hrtimer_nanosleep_restart;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic int common_nsleep(const clockid_t which_clock, int flags,\n\t\t\t const struct timespec64 *rqtp)\n{\n\treturn hrtimer_nanosleep(rqtp, flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL,\n\t\t\t\t which_clock);\n}"
  },
  {
    "function_name": "exit_itimers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1031-1039",
    "snippet": "void exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "itimer_delete",
          "args": [
            "tmr"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "itimer_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "1005-1025",
          "snippet": "static void itimer_delete(struct k_itimer *timer)\n{\n\tunsigned long flags;\n\nretry_delete:\n\tspin_lock_irqsave(&timer->it_lock, flags);\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tunlock_timer(timer, flags);\n\t\tgoto retry_delete;\n\t}\n\tlist_del(&timer->list);\n\t/*\n\t * This keeps any tasks waiting on the spin lock from thinking\n\t * they got something (see the lock code above).\n\t */\n\ttimer->it_signal = NULL;\n\n\tunlock_timer(timer, flags);\n\trelease_posix_timer(timer, IT_ID_SET);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define IT_ID_SET\t1"
          ],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\n#define IT_ID_SET\t1\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic void itimer_delete(struct k_itimer *timer)\n{\n\tunsigned long flags;\n\nretry_delete:\n\tspin_lock_irqsave(&timer->it_lock, flags);\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tunlock_timer(timer, flags);\n\t\tgoto retry_delete;\n\t}\n\tlist_del(&timer->list);\n\t/*\n\t * This keeps any tasks waiting on the spin lock from thinking\n\t * they got something (see the lock code above).\n\t */\n\ttimer->it_signal = NULL;\n\n\tunlock_timer(timer, flags);\n\trelease_posix_timer(timer, IT_ID_SET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "sig->posix_timers.next",
            "structk_itimer",
            "list"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sig->posix_timers"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nvoid exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}"
  },
  {
    "function_name": "itimer_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1005-1025",
    "snippet": "static void itimer_delete(struct k_itimer *timer)\n{\n\tunsigned long flags;\n\nretry_delete:\n\tspin_lock_irqsave(&timer->it_lock, flags);\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tunlock_timer(timer, flags);\n\t\tgoto retry_delete;\n\t}\n\tlist_del(&timer->list);\n\t/*\n\t * This keeps any tasks waiting on the spin lock from thinking\n\t * they got something (see the lock code above).\n\t */\n\ttimer->it_signal = NULL;\n\n\tunlock_timer(timer, flags);\n\trelease_posix_timer(timer, IT_ID_SET);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define IT_ID_SET\t1"
    ],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_posix_timer",
          "args": [
            "timer",
            "IT_ID_SET"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "release_posix_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "476-487",
          "snippet": "static void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->it.rcu, k_itimer_rcu_free);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(hash_lock);",
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(hash_lock);\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->it.rcu, k_itimer_rcu_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_timer",
          "args": [
            "timer",
            "flags"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "183-186",
          "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&timer->list"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_delete_hook",
          "args": [
            "timer"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "timer_delete_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "963-970",
          "snippet": "static inline int timer_delete_hook(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\tif (WARN_ON_ONCE(!kc || !kc->timer_del))\n\t\treturn -EINVAL;\n\treturn kc->timer_del(timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic inline int timer_delete_hook(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\tif (WARN_ON_ONCE(!kc || !kc->timer_del))\n\t\treturn -EINVAL;\n\treturn kc->timer_del(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&timer->it_lock",
            "flags"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\n#define IT_ID_SET\t1\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic void itimer_delete(struct k_itimer *timer)\n{\n\tunsigned long flags;\n\nretry_delete:\n\tspin_lock_irqsave(&timer->it_lock, flags);\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tunlock_timer(timer, flags);\n\t\tgoto retry_delete;\n\t}\n\tlist_del(&timer->list);\n\t/*\n\t * This keeps any tasks waiting on the spin lock from thinking\n\t * they got something (see the lock code above).\n\t */\n\ttimer->it_signal = NULL;\n\n\tunlock_timer(timer, flags);\n\trelease_posix_timer(timer, IT_ID_SET);\n}"
  },
  {
    "function_name": "timer_delete_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "963-970",
    "snippet": "static inline int timer_delete_hook(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\tif (WARN_ON_ONCE(!kc || !kc->timer_del))\n\t\treturn -EINVAL;\n\treturn kc->timer_del(timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kc->timer_del",
          "args": [
            "timer"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!kc || !kc->timer_del"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic inline int timer_delete_hook(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\tif (WARN_ON_ONCE(!kc || !kc->timer_del))\n\t\treturn -EINVAL;\n\treturn kc->timer_del(timer);\n}"
  },
  {
    "function_name": "common_timer_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "952-961",
    "snippet": "int common_timer_del(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\ttimer->it_interval = 0;\n\tif (kc->timer_try_to_cancel(timer) < 0)\n\t\treturn TIMER_RETRY;\n\ttimer->it_active = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kc->timer_try_to_cancel",
          "args": [
            "timer"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint common_timer_del(struct k_itimer *timer)\n{\n\tconst struct k_clock *kc = timer->kclock;\n\n\ttimer->it_interval = 0;\n\tif (kc->timer_try_to_cancel(timer) < 0)\n\t\treturn TIMER_RETRY;\n\ttimer->it_active = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_timer_settime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "871-904",
    "snippet": "static int do_timer_settime(timer_t timer_id, int flags,\n\t\t\t    struct itimerspec64 *new_spec64,\n\t\t\t    struct itimerspec64 *old_spec64)\n{\n\tconst struct k_clock *kc;\n\tstruct k_itimer *timr;\n\tunsigned long flag;\n\tint error = 0;\n\n\tif (!timespec64_valid(&new_spec64->it_interval) ||\n\t    !timespec64_valid(&new_spec64->it_value))\n\t\treturn -EINVAL;\n\n\tif (old_spec64)\n\t\tmemset(old_spec64, 0, sizeof(*old_spec64));\nretry:\n\ttimr = lock_timer(timer_id, &flag);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\tkc = timr->kclock;\n\tif (WARN_ON_ONCE(!kc || !kc->timer_set))\n\t\terror = -EINVAL;\n\telse\n\t\terror = kc->timer_set(timr, flags, new_spec64, old_spec64);\n\n\tunlock_timer(timr, flag);\n\tif (error == TIMER_RETRY) {\n\t\told_spec64 = NULL;\t// We already got the old time...\n\t\tgoto retry;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_timer",
          "args": [
            "timr",
            "flag"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "183-186",
          "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kc->timer_set",
          "args": [
            "timr",
            "flags",
            "new_spec64",
            "old_spec64"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!kc || !kc->timer_set"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_timer",
          "args": [
            "timer_id",
            "&flag"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "612-636",
          "snippet": "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "old_spec64",
            "0",
            "sizeof(*old_spec64)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_valid",
          "args": [
            "&new_spec64->it_value"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_valid",
          "args": [
            "&new_spec64->it_interval"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic int do_timer_settime(timer_t timer_id, int flags,\n\t\t\t    struct itimerspec64 *new_spec64,\n\t\t\t    struct itimerspec64 *old_spec64)\n{\n\tconst struct k_clock *kc;\n\tstruct k_itimer *timr;\n\tunsigned long flag;\n\tint error = 0;\n\n\tif (!timespec64_valid(&new_spec64->it_interval) ||\n\t    !timespec64_valid(&new_spec64->it_value))\n\t\treturn -EINVAL;\n\n\tif (old_spec64)\n\t\tmemset(old_spec64, 0, sizeof(*old_spec64));\nretry:\n\ttimr = lock_timer(timer_id, &flag);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\tkc = timr->kclock;\n\tif (WARN_ON_ONCE(!kc || !kc->timer_set))\n\t\terror = -EINVAL;\n\telse\n\t\terror = kc->timer_set(timr, flags, new_spec64, old_spec64);\n\n\tunlock_timer(timr, flag);\n\tif (error == TIMER_RETRY) {\n\t\told_spec64 = NULL;\t// We already got the old time...\n\t\tgoto retry;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "common_timer_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "833-869",
    "snippet": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kc->timer_arm",
          "args": [
            "timr",
            "expires",
            "flags & TIMER_ABSTIME",
            "sigev_none"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "new_setting->it_value"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "new_setting->it_interval"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kc->timer_try_to_cancel",
          "args": [
            "timr"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "common_timer_get",
          "args": [
            "timr",
            "old_setting"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "common_timer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "668-716",
          "snippet": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * The timespec64 based conversion is suboptimal, but it's not\n\t * worth to implement yet another callback.\n\t */\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nvoid common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * The timespec64 based conversion is suboptimal, but it's not\n\t * worth to implement yet another callback.\n\t */\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nint common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\t/* Prevent rearming by clearing the interval */\n\ttimr->it_interval = 0;\n\t/*\n\t * Careful here. On SMP systems the timer expiry function could be\n\t * active and spinning on timr->it_lock.\n\t */\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}"
  },
  {
    "function_name": "common_hrtimer_try_to_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "827-830",
    "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&timr->it.real.timer"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "827-830",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
  },
  {
    "function_name": "common_hrtimer_arm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "797-825",
    "snippet": "static void common_hrtimer_arm(struct k_itimer *timr, ktime_t expires,\n\t\t\t       bool absolute, bool sigev_none)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tenum hrtimer_mode mode;\n\n\tmode = absolute ? HRTIMER_MODE_ABS : HRTIMER_MODE_REL;\n\t/*\n\t * Posix magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they become CLOCK_MONOTONIC based under the\n\t * hood. See hrtimer_init(). Update timr->kclock, so the generic\n\t * functions which use timr->kclock->clock_get() work.\n\t *\n\t * Note: it_clock stays unmodified, because the next timer_set() might\n\t * use ABSTIME, so it needs to switch back.\n\t */\n\tif (timr->it_clock == CLOCK_REALTIME)\n\t\ttimr->kclock = absolute ? &clock_realtime : &clock_monotonic;\n\n\thrtimer_init(&timr->it.real.timer, timr->it_clock, mode);\n\ttimr->it.real.timer.function = posix_timer_fn;\n\n\tif (!absolute)\n\t\texpires = ktime_add_safe(expires, timer->base->get_time());\n\thrtimer_set_expires(timer, expires);\n\n\tif (!sigev_none)\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct k_clock clock_realtime, clock_monotonic;",
      "static const struct k_clock clock_realtime = {\n\t.clock_getres\t\t= posix_get_hrtimer_res,\n\t.clock_get\t\t= posix_clock_realtime_get,\n\t.clock_set\t\t= posix_clock_realtime_set,\n\t.clock_adj\t\t= posix_clock_realtime_adj,\n\t.nsleep\t\t\t= common_nsleep,\n\t.timer_create\t\t= common_timer_create,\n\t.timer_set\t\t= common_timer_set,\n\t.timer_get\t\t= common_timer_get,\n\t.timer_del\t\t= common_timer_del,\n\t.timer_rearm\t\t= common_hrtimer_rearm,\n\t.timer_forward\t\t= common_hrtimer_forward,\n\t.timer_remaining\t= common_hrtimer_remaining,\n\t.timer_try_to_cancel\t= common_hrtimer_try_to_cancel,\n\t.timer_arm\t\t= common_hrtimer_arm,\n};",
      "static const struct k_clock clock_monotonic = {\n\t.clock_getres\t\t= posix_get_hrtimer_res,\n\t.clock_get\t\t= posix_ktime_get_ts,\n\t.nsleep\t\t\t= common_nsleep,\n\t.timer_create\t\t= common_timer_create,\n\t.timer_set\t\t= common_timer_set,\n\t.timer_get\t\t= common_timer_get,\n\t.timer_del\t\t= common_timer_del,\n\t.timer_rearm\t\t= common_hrtimer_rearm,\n\t.timer_forward\t\t= common_hrtimer_forward,\n\t.timer_remaining\t= common_hrtimer_remaining,\n\t.timer_try_to_cancel\t= common_hrtimer_try_to_cancel,\n\t.timer_arm\t\t= common_hrtimer_arm,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "timer",
            "HRTIMER_MODE_ABS"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "timer",
            "expires"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "expires",
            "timer->base->get_time()"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer->base->get_time",
          "args": [],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&timr->it.real.timer",
            "timr->it_clock",
            "mode"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic const struct k_clock clock_realtime, clock_monotonic;\nstatic const struct k_clock clock_realtime = {\n\t.clock_getres\t\t= posix_get_hrtimer_res,\n\t.clock_get\t\t= posix_clock_realtime_get,\n\t.clock_set\t\t= posix_clock_realtime_set,\n\t.clock_adj\t\t= posix_clock_realtime_adj,\n\t.nsleep\t\t\t= common_nsleep,\n\t.timer_create\t\t= common_timer_create,\n\t.timer_set\t\t= common_timer_set,\n\t.timer_get\t\t= common_timer_get,\n\t.timer_del\t\t= common_timer_del,\n\t.timer_rearm\t\t= common_hrtimer_rearm,\n\t.timer_forward\t\t= common_hrtimer_forward,\n\t.timer_remaining\t= common_hrtimer_remaining,\n\t.timer_try_to_cancel\t= common_hrtimer_try_to_cancel,\n\t.timer_arm\t\t= common_hrtimer_arm,\n};\nstatic const struct k_clock clock_monotonic = {\n\t.clock_getres\t\t= posix_get_hrtimer_res,\n\t.clock_get\t\t= posix_ktime_get_ts,\n\t.nsleep\t\t\t= common_nsleep,\n\t.timer_create\t\t= common_timer_create,\n\t.timer_set\t\t= common_timer_set,\n\t.timer_get\t\t= common_timer_get,\n\t.timer_del\t\t= common_timer_del,\n\t.timer_rearm\t\t= common_hrtimer_rearm,\n\t.timer_forward\t\t= common_hrtimer_forward,\n\t.timer_remaining\t= common_hrtimer_remaining,\n\t.timer_try_to_cancel\t= common_hrtimer_try_to_cancel,\n\t.timer_arm\t\t= common_hrtimer_arm,\n};\n\nstatic void common_hrtimer_arm(struct k_itimer *timr, ktime_t expires,\n\t\t\t       bool absolute, bool sigev_none)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tenum hrtimer_mode mode;\n\n\tmode = absolute ? HRTIMER_MODE_ABS : HRTIMER_MODE_REL;\n\t/*\n\t * Posix magic: Relative CLOCK_REALTIME timers are not affected by\n\t * clock modifications, so they become CLOCK_MONOTONIC based under the\n\t * hood. See hrtimer_init(). Update timr->kclock, so the generic\n\t * functions which use timr->kclock->clock_get() work.\n\t *\n\t * Note: it_clock stays unmodified, because the next timer_set() might\n\t * use ABSTIME, so it needs to switch back.\n\t */\n\tif (timr->it_clock == CLOCK_REALTIME)\n\t\ttimr->kclock = absolute ? &clock_realtime : &clock_monotonic;\n\n\thrtimer_init(&timr->it.real.timer, timr->it_clock, mode);\n\ttimr->it.real.timer.function = posix_timer_fn;\n\n\tif (!absolute)\n\t\texpires = ktime_add_safe(expires, timer->base->get_time());\n\thrtimer_set_expires(timer, expires);\n\n\tif (!sigev_none)\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}"
  },
  {
    "function_name": "do_timer_gettime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "719-739",
    "snippet": "static int do_timer_gettime(timer_t timer_id,  struct itimerspec64 *setting)\n{\n\tstruct k_itimer *timr;\n\tconst struct k_clock *kc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\tmemset(setting, 0, sizeof(*setting));\n\tkc = timr->kclock;\n\tif (WARN_ON_ONCE(!kc || !kc->timer_get))\n\t\tret = -EINVAL;\n\telse\n\t\tkc->timer_get(timr, setting);\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_timer",
          "args": [
            "timr",
            "flags"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "183-186",
          "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kc->timer_get",
          "args": [
            "timr",
            "setting"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!kc || !kc->timer_get"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "setting",
            "0",
            "sizeof(*setting)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_timer",
          "args": [
            "timer_id",
            "&flags"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "612-636",
          "snippet": "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic int do_timer_gettime(timer_t timer_id,  struct itimerspec64 *setting)\n{\n\tstruct k_itimer *timr;\n\tconst struct k_clock *kc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\tmemset(setting, 0, sizeof(*setting));\n\tkc = timr->kclock;\n\tif (WARN_ON_ONCE(!kc || !kc->timer_get))\n\t\tret = -EINVAL;\n\telse\n\t\tkc->timer_get(timr, setting);\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "common_timer_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "668-716",
    "snippet": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * The timespec64 based conversion is suboptimal, but it's not\n\t * worth to implement yet another callback.\n\t */\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "remaining"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kc->timer_remaining",
          "args": [
            "timr",
            "now"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kc->timer_forward",
          "args": [
            "timr",
            "now"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "ts64"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kc->clock_get",
          "args": [
            "timr->it_clock",
            "&ts64"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "iv"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nvoid common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t/* interval timer ? */\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t/*\n\t\t * SIGEV_NONE oneshot timers are never queued. Check them\n\t\t * below.\n\t\t */\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * The timespec64 based conversion is suboptimal, but it's not\n\t * worth to implement yet another callback.\n\t */\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\t/*\n\t * When a requeue is pending or this is a SIGEV_NONE timer move the\n\t * expiry time forward by intervals, so expiry is > now.\n\t */\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t/* Return 0 only, when the timer is expired and not pending */\n\tif (remaining <= 0) {\n\t\t/*\n\t\t * A single shot SIGEV_NONE timer must return 0, when\n\t\t * it is expired !\n\t\t */\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}"
  },
  {
    "function_name": "common_hrtimer_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "645-650",
    "snippet": "static s64 common_hrtimer_forward(struct k_itimer *timr, ktime_t now)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\treturn hrtimer_forward(timer, now, timr->it_interval);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "timer",
            "now",
            "timr->it_interval"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "907-939",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic s64 common_hrtimer_forward(struct k_itimer *timr, ktime_t now)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\treturn hrtimer_forward(timer, now, timr->it_interval);\n}"
  },
  {
    "function_name": "common_hrtimer_remaining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "638-643",
    "snippet": "static ktime_t common_hrtimer_remaining(struct k_itimer *timr, ktime_t now)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\treturn __hrtimer_expires_remaining_adjusted(timer, now);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hrtimer_expires_remaining_adjusted",
          "args": [
            "timer",
            "now"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic ktime_t common_hrtimer_remaining(struct k_itimer *timr, ktime_t now)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\treturn __hrtimer_expires_remaining_adjusted(timer, now);\n}"
  },
  {
    "function_name": "__lock_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "612-636",
    "snippet": "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&timr->it_lock",
            "*flags"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&timr->it_lock",
            "*flags"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_timer_by_id",
          "args": [
            "timer_id"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "151-157",
          "snippet": "static struct k_itimer *posix_timer_by_id(timer_t id)\n{\n\tstruct signal_struct *sig = current->signal;\n\tstruct hlist_head *head = &posix_timers_hashtable[hash(sig, id)];\n\n\treturn __posix_timers_find(head, sig, id);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);",
            "static const struct k_clock *clockid_to_kclock(const clockid_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\n\nstatic struct k_itimer *posix_timer_by_id(timer_t id)\n{\n\tstruct signal_struct *sig = current->signal;\n\tstruct hlist_head *head = &posix_timers_hashtable[hash(sig, id)];\n\n\treturn __posix_timers_find(head, sig, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "do_timer_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "496-573",
    "snippet": "static int do_timer_create(clockid_t which_clock, struct sigevent *event,\n\t\t\t   timer_t __user *created_timer_id)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct k_itimer *new_timer;\n\tint error, new_timer_id;\n\tint it_id_set = IT_ID_NOT_SET;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->timer_create)\n\t\treturn -EOPNOTSUPP;\n\n\tnew_timer = alloc_posix_timer();\n\tif (unlikely(!new_timer))\n\t\treturn -EAGAIN;\n\n\tspin_lock_init(&new_timer->it_lock);\n\tnew_timer_id = posix_timer_add(new_timer);\n\tif (new_timer_id < 0) {\n\t\terror = new_timer_id;\n\t\tgoto out;\n\t}\n\n\tit_id_set = IT_ID_SET;\n\tnew_timer->it_id = (timer_t) new_timer_id;\n\tnew_timer->it_clock = which_clock;\n\tnew_timer->kclock = kc;\n\tnew_timer->it_overrun = -1LL;\n\n\tif (event) {\n\t\trcu_read_lock();\n\t\tnew_timer->it_pid = get_pid(good_sigevent(event));\n\t\trcu_read_unlock();\n\t\tif (!new_timer->it_pid) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_timer->it_sigev_notify     = event->sigev_notify;\n\t\tnew_timer->sigq->info.si_signo = event->sigev_signo;\n\t\tnew_timer->sigq->info.si_value = event->sigev_value;\n\t} else {\n\t\tnew_timer->it_sigev_notify     = SIGEV_SIGNAL;\n\t\tnew_timer->sigq->info.si_signo = SIGALRM;\n\t\tmemset(&new_timer->sigq->info.si_value, 0, sizeof(sigval_t));\n\t\tnew_timer->sigq->info.si_value.sival_int = new_timer->it_id;\n\t\tnew_timer->it_pid = get_pid(task_tgid(current));\n\t}\n\n\tnew_timer->sigq->info.si_tid   = new_timer->it_id;\n\tnew_timer->sigq->info.si_code  = SI_TIMER;\n\n\tif (copy_to_user(created_timer_id,\n\t\t\t &new_timer_id, sizeof (new_timer_id))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = kc->timer_create(new_timer);\n\tif (error)\n\t\tgoto out;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tnew_timer->it_signal = current->signal;\n\tlist_add(&new_timer->list, &current->signal->posix_timers);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn 0;\n\t/*\n\t * In the case of the timer belonging to another task, after\n\t * the task is unlocked, the timer is owned by the other task\n\t * and may cease to exist at any time.  Don't use or modify\n\t * new_timer after the unlock call.\n\t */\nout:\n\trelease_posix_timer(new_timer, it_id_set);\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define IT_ID_NOT_SET\t0",
      "#define IT_ID_SET\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_posix_timer",
          "args": [
            "new_timer",
            "it_id_set"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "release_posix_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "476-487",
          "snippet": "static void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->it.rcu, k_itimer_rcu_free);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(hash_lock);",
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(hash_lock);\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->it.rcu, k_itimer_rcu_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_timer->list",
            "&current->signal->posix_timers"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kc->timer_create",
          "args": [
            "new_timer"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "created_timer_id",
            "&new_timer_id",
            "sizeof (new_timer_id)"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "task_tgid(current)"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "388-397",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new_timer->sigq->info.si_value",
            "0",
            "sizeof(sigval_t)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "good_sigevent",
          "args": [
            "event"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "good_sigevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "429-451",
          "snippet": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct pid *pid = task_tgid(current);\n\tstruct task_struct *rtn;\n\n\tswitch (event->sigev_notify) {\n\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n\t\tpid = find_vpid(event->sigev_notify_thread_id);\n\t\trtn = pid_task(pid, PIDTYPE_PID);\n\t\tif (!rtn || !same_thread_group(rtn, current))\n\t\t\treturn NULL;\n\t\t/* FALLTHRU */\n\tcase SIGEV_SIGNAL:\n\tcase SIGEV_THREAD:\n\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n\t\t\treturn NULL;\n\t\t/* FALLTHRU */\n\tcase SIGEV_NONE:\n\t\treturn pid;\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct pid *pid = task_tgid(current);\n\tstruct task_struct *rtn;\n\n\tswitch (event->sigev_notify) {\n\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n\t\tpid = find_vpid(event->sigev_notify_thread_id);\n\t\trtn = pid_task(pid, PIDTYPE_PID);\n\t\tif (!rtn || !same_thread_group(rtn, current))\n\t\t\treturn NULL;\n\t\t/* FALLTHRU */\n\tcase SIGEV_SIGNAL:\n\tcase SIGEV_THREAD:\n\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n\t\t\treturn NULL;\n\t\t/* FALLTHRU */\n\tcase SIGEV_NONE:\n\t\treturn pid;\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_timer_add",
          "args": [
            "new_timer"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "159-181",
          "snippet": "static int posix_timer_add(struct k_itimer *timer)\n{\n\tstruct signal_struct *sig = current->signal;\n\tint first_free_id = sig->posix_timer_id;\n\tstruct hlist_head *head;\n\tint ret = -ENOENT;\n\n\tdo {\n\t\tspin_lock(&hash_lock);\n\t\thead = &posix_timers_hashtable[hash(sig, sig->posix_timer_id)];\n\t\tif (!__posix_timers_find(head, sig, sig->posix_timer_id)) {\n\t\t\thlist_add_head_rcu(&timer->t_hash, head);\n\t\t\tret = sig->posix_timer_id;\n\t\t}\n\t\tif (++sig->posix_timer_id < 0)\n\t\t\tsig->posix_timer_id = 0;\n\t\tif ((sig->posix_timer_id == first_free_id) && (ret == -ENOENT))\n\t\t\t/* Loop over all possible ids completed */\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&hash_lock);\n\t} while (ret == -ENOENT);\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);",
            "static DEFINE_SPINLOCK(hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\nstatic DEFINE_SPINLOCK(hash_lock);\n\nstatic int posix_timer_add(struct k_itimer *timer)\n{\n\tstruct signal_struct *sig = current->signal;\n\tint first_free_id = sig->posix_timer_id;\n\tstruct hlist_head *head;\n\tint ret = -ENOENT;\n\n\tdo {\n\t\tspin_lock(&hash_lock);\n\t\thead = &posix_timers_hashtable[hash(sig, sig->posix_timer_id)];\n\t\tif (!__posix_timers_find(head, sig, sig->posix_timer_id)) {\n\t\t\thlist_add_head_rcu(&timer->t_hash, head);\n\t\t\tret = sig->posix_timer_id;\n\t\t}\n\t\tif (++sig->posix_timer_id < 0)\n\t\t\tsig->posix_timer_id = 0;\n\t\tif ((sig->posix_timer_id == first_free_id) && (ret == -ENOENT))\n\t\t\t/* Loop over all possible ids completed */\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&hash_lock);\n\t} while (ret == -ENOENT);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&new_timer->it_lock"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new_timer"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_posix_timer",
          "args": [],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_posix_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "453-465",
          "snippet": "static struct k_itimer * alloc_posix_timer(void)\n{\n\tstruct k_itimer *tmr;\n\ttmr = kmem_cache_zalloc(posix_timers_cache, GFP_KERNEL);\n\tif (!tmr)\n\t\treturn tmr;\n\tif (unlikely(!(tmr->sigq = sigqueue_alloc()))) {\n\t\tkmem_cache_free(posix_timers_cache, tmr);\n\t\treturn NULL;\n\t}\n\tclear_siginfo(&tmr->sigq->info);\n\treturn tmr;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *posix_timers_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *posix_timers_cache;\n\nstatic struct k_itimer * alloc_posix_timer(void)\n{\n\tstruct k_itimer *tmr;\n\ttmr = kmem_cache_zalloc(posix_timers_cache, GFP_KERNEL);\n\tif (!tmr)\n\t\treturn tmr;\n\tif (unlikely(!(tmr->sigq = sigqueue_alloc()))) {\n\t\tkmem_cache_free(posix_timers_cache, tmr);\n\t\treturn NULL;\n\t}\n\tclear_siginfo(&tmr->sigq->info);\n\treturn tmr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockid_to_kclock",
          "args": [
            "which_clock"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "clockid_to_kclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "1357-1370",
          "snippet": "static const struct k_clock *clockid_to_kclock(const clockid_t id)\n{\n\tclockid_t idx = id;\n\n\tif (id < 0) {\n\t\treturn (id & CLOCKFD_MASK) == CLOCKFD ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\t}\n\n\tif (id >= ARRAY_SIZE(posix_clocks))\n\t\treturn NULL;\n\n\treturn posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct k_clock * const posix_clocks[];",
            "static const struct k_clock *clockid_to_kclock(const clockid_t id);",
            "static const struct k_clock * const posix_clocks[] = {\n\t[CLOCK_REALTIME]\t\t= &clock_realtime,\n\t[CLOCK_MONOTONIC]\t\t= &clock_monotonic,\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= &clock_process,\n\t[CLOCK_THREAD_CPUTIME_ID]\t= &clock_thread,\n\t[CLOCK_MONOTONIC_RAW]\t\t= &clock_monotonic_raw,\n\t[CLOCK_REALTIME_COARSE]\t\t= &clock_realtime_coarse,\n\t[CLOCK_MONOTONIC_COARSE]\t= &clock_monotonic_coarse,\n\t[CLOCK_BOOTTIME]\t\t= &clock_boottime,\n\t[CLOCK_REALTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_BOOTTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_TAI]\t\t\t= &clock_tai,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic const struct k_clock * const posix_clocks[];\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\nstatic const struct k_clock * const posix_clocks[] = {\n\t[CLOCK_REALTIME]\t\t= &clock_realtime,\n\t[CLOCK_MONOTONIC]\t\t= &clock_monotonic,\n\t[CLOCK_PROCESS_CPUTIME_ID]\t= &clock_process,\n\t[CLOCK_THREAD_CPUTIME_ID]\t= &clock_thread,\n\t[CLOCK_MONOTONIC_RAW]\t\t= &clock_monotonic_raw,\n\t[CLOCK_REALTIME_COARSE]\t\t= &clock_realtime_coarse,\n\t[CLOCK_MONOTONIC_COARSE]\t= &clock_monotonic_coarse,\n\t[CLOCK_BOOTTIME]\t\t= &clock_boottime,\n\t[CLOCK_REALTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_BOOTTIME_ALARM]\t\t= &alarm_clock,\n\t[CLOCK_TAI]\t\t\t= &clock_tai,\n};\n\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id)\n{\n\tclockid_t idx = id;\n\n\tif (id < 0) {\n\t\treturn (id & CLOCKFD_MASK) == CLOCKFD ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\t}\n\n\tif (id >= ARRAY_SIZE(posix_clocks))\n\t\treturn NULL;\n\n\treturn posix_clocks[array_index_nospec(idx, ARRAY_SIZE(posix_clocks))];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\n#define IT_ID_NOT_SET\t0\n#define IT_ID_SET\t1\n\nstatic int do_timer_create(clockid_t which_clock, struct sigevent *event,\n\t\t\t   timer_t __user *created_timer_id)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct k_itimer *new_timer;\n\tint error, new_timer_id;\n\tint it_id_set = IT_ID_NOT_SET;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->timer_create)\n\t\treturn -EOPNOTSUPP;\n\n\tnew_timer = alloc_posix_timer();\n\tif (unlikely(!new_timer))\n\t\treturn -EAGAIN;\n\n\tspin_lock_init(&new_timer->it_lock);\n\tnew_timer_id = posix_timer_add(new_timer);\n\tif (new_timer_id < 0) {\n\t\terror = new_timer_id;\n\t\tgoto out;\n\t}\n\n\tit_id_set = IT_ID_SET;\n\tnew_timer->it_id = (timer_t) new_timer_id;\n\tnew_timer->it_clock = which_clock;\n\tnew_timer->kclock = kc;\n\tnew_timer->it_overrun = -1LL;\n\n\tif (event) {\n\t\trcu_read_lock();\n\t\tnew_timer->it_pid = get_pid(good_sigevent(event));\n\t\trcu_read_unlock();\n\t\tif (!new_timer->it_pid) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_timer->it_sigev_notify     = event->sigev_notify;\n\t\tnew_timer->sigq->info.si_signo = event->sigev_signo;\n\t\tnew_timer->sigq->info.si_value = event->sigev_value;\n\t} else {\n\t\tnew_timer->it_sigev_notify     = SIGEV_SIGNAL;\n\t\tnew_timer->sigq->info.si_signo = SIGALRM;\n\t\tmemset(&new_timer->sigq->info.si_value, 0, sizeof(sigval_t));\n\t\tnew_timer->sigq->info.si_value.sival_int = new_timer->it_id;\n\t\tnew_timer->it_pid = get_pid(task_tgid(current));\n\t}\n\n\tnew_timer->sigq->info.si_tid   = new_timer->it_id;\n\tnew_timer->sigq->info.si_code  = SI_TIMER;\n\n\tif (copy_to_user(created_timer_id,\n\t\t\t &new_timer_id, sizeof (new_timer_id))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = kc->timer_create(new_timer);\n\tif (error)\n\t\tgoto out;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tnew_timer->it_signal = current->signal;\n\tlist_add(&new_timer->list, &current->signal->posix_timers);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn 0;\n\t/*\n\t * In the case of the timer belonging to another task, after\n\t * the task is unlocked, the timer is owned by the other task\n\t * and may cease to exist at any time.  Don't use or modify\n\t * new_timer after the unlock call.\n\t */\nout:\n\trelease_posix_timer(new_timer, it_id_set);\n\treturn error;\n}"
  },
  {
    "function_name": "common_timer_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "489-493",
    "snippet": "static int common_timer_create(struct k_itimer *new_timer)\n{\n\thrtimer_init(&new_timer->it.real.timer, new_timer->it_clock, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&new_timer->it.real.timer",
            "new_timer->it_clock",
            "0"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_timer_create(struct k_itimer *new_timer)\n{\n\thrtimer_init(&new_timer->it.real.timer, new_timer->it_clock, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "release_posix_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "476-487",
    "snippet": "static void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->it.rcu, k_itimer_rcu_free);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(hash_lock);",
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&tmr->it.rcu",
            "k_itimer_rcu_free"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigqueue_free",
          "args": [
            "tmr->sigq"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "sigqueue_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1687-1710",
          "snippet": "void sigqueue_free(struct sigqueue *q)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = &current->sighand->siglock;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\t/*\n\t * We must hold ->siglock while testing q->list\n\t * to serialize with collect_signal() or with\n\t * __exit_signal()->flush_sigqueue().\n\t */\n\tspin_lock_irqsave(lock, flags);\n\tq->flags &= ~SIGQUEUE_PREALLOC;\n\t/*\n\t * If it is queued it will be freed when dequeued,\n\t * like the \"regular\" sigqueue.\n\t */\n\tif (!list_empty(&q->list))\n\t\tq = NULL;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (q)\n\t\t__sigqueue_free(q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid sigqueue_free(struct sigqueue *q)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = &current->sighand->siglock;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\t/*\n\t * We must hold ->siglock while testing q->list\n\t * to serialize with collect_signal() or with\n\t * __exit_signal()->flush_sigqueue().\n\t */\n\tspin_lock_irqsave(lock, flags);\n\tq->flags &= ~SIGQUEUE_PREALLOC;\n\t/*\n\t * If it is queued it will be freed when dequeued,\n\t * like the \"regular\" sigqueue.\n\t */\n\tif (!list_empty(&q->list))\n\t\tq = NULL;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (q)\n\t\t__sigqueue_free(q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "tmr->it_pid"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "117-121",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&hash_lock",
            "flags"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&tmr->t_hash"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&hash_lock",
            "flags"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(hash_lock);\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->it.rcu, k_itimer_rcu_free);\n}"
  },
  {
    "function_name": "k_itimer_rcu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "467-472",
    "snippet": "static void k_itimer_rcu_free(struct rcu_head *head)\n{\n\tstruct k_itimer *tmr = container_of(head, struct k_itimer, it.rcu);\n\n\tkmem_cache_free(posix_timers_cache, tmr);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *posix_timers_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "posix_timers_cache",
            "tmr"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structk_itimer",
            "it.rcu"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *posix_timers_cache;\n\nstatic void k_itimer_rcu_free(struct rcu_head *head)\n{\n\tstruct k_itimer *tmr = container_of(head, struct k_itimer, it.rcu);\n\n\tkmem_cache_free(posix_timers_cache, tmr);\n}"
  },
  {
    "function_name": "alloc_posix_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "453-465",
    "snippet": "static struct k_itimer * alloc_posix_timer(void)\n{\n\tstruct k_itimer *tmr;\n\ttmr = kmem_cache_zalloc(posix_timers_cache, GFP_KERNEL);\n\tif (!tmr)\n\t\treturn tmr;\n\tif (unlikely(!(tmr->sigq = sigqueue_alloc()))) {\n\t\tkmem_cache_free(posix_timers_cache, tmr);\n\t\treturn NULL;\n\t}\n\tclear_siginfo(&tmr->sigq->info);\n\treturn tmr;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *posix_timers_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&tmr->sigq->info"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "posix_timers_cache",
            "tmr"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(tmr->sigq = sigqueue_alloc())"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigqueue_alloc",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "sigqueue_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1677-1685",
          "snippet": "struct sigqueue *sigqueue_alloc(void)\n{\n\tstruct sigqueue *q = __sigqueue_alloc(-1, current, GFP_KERNEL, 0);\n\n\tif (q)\n\t\tq->flags |= SIGQUEUE_PREALLOC;\n\n\treturn q;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sigqueue *sigqueue_alloc(void)\n{\n\tstruct sigqueue *q = __sigqueue_alloc(-1, current, GFP_KERNEL, 0);\n\n\tif (q)\n\t\tq->flags |= SIGQUEUE_PREALLOC;\n\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "posix_timers_cache",
            "GFP_KERNEL"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *posix_timers_cache;\n\nstatic struct k_itimer * alloc_posix_timer(void)\n{\n\tstruct k_itimer *tmr;\n\ttmr = kmem_cache_zalloc(posix_timers_cache, GFP_KERNEL);\n\tif (!tmr)\n\t\treturn tmr;\n\tif (unlikely(!(tmr->sigq = sigqueue_alloc()))) {\n\t\tkmem_cache_free(posix_timers_cache, tmr);\n\t\treturn NULL;\n\t}\n\tclear_siginfo(&tmr->sigq->info);\n\treturn tmr;\n}"
  },
  {
    "function_name": "good_sigevent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "429-451",
    "snippet": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct pid *pid = task_tgid(current);\n\tstruct task_struct *rtn;\n\n\tswitch (event->sigev_notify) {\n\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n\t\tpid = find_vpid(event->sigev_notify_thread_id);\n\t\trtn = pid_task(pid, PIDTYPE_PID);\n\t\tif (!rtn || !same_thread_group(rtn, current))\n\t\t\treturn NULL;\n\t\t/* FALLTHRU */\n\tcase SIGEV_SIGNAL:\n\tcase SIGEV_THREAD:\n\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n\t\t\treturn NULL;\n\t\t/* FALLTHRU */\n\tcase SIGEV_NONE:\n\t\treturn pid;\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "rtn",
            "current"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "376-385",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vpid",
          "args": [
            "event->sigev_notify_thread_id"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "find_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "262-265",
          "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct pid *pid = task_tgid(current);\n\tstruct task_struct *rtn;\n\n\tswitch (event->sigev_notify) {\n\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n\t\tpid = find_vpid(event->sigev_notify_thread_id);\n\t\trtn = pid_task(pid, PIDTYPE_PID);\n\t\tif (!rtn || !same_thread_group(rtn, current))\n\t\t\treturn NULL;\n\t\t/* FALLTHRU */\n\tcase SIGEV_SIGNAL:\n\tcase SIGEV_THREAD:\n\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n\t\t\treturn NULL;\n\t\t/* FALLTHRU */\n\tcase SIGEV_NONE:\n\t\treturn pid;\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "posix_timer_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "364-427",
    "snippet": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\t/*\n\t\t * signal was not sent because of sig_ignor\n\t\t * we will not get a call back to restart it AND\n\t\t * it should be restarted.\n\t\t */\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n\t\t\t/*\n\t\t\t * FIXME: What we really want, is to stop this\n\t\t\t * timer completely and restart it in case the\n\t\t\t * SIG_IGN is removed. This is a non trivial\n\t\t\t * change which involves sighand locking\n\t\t\t * (sigh !), which we don't want to do late in\n\t\t\t * the release cycle.\n\t\t\t *\n\t\t\t * For now we just let timers with an interval\n\t\t\t * less than a jiffie expire every jiffie to\n\t\t\t * avoid softirq starvation in case of SIG_IGN\n\t\t\t * and a very small interval, which would put\n\t\t\t * the timer right back on the softirq pending\n\t\t\t * list. By moving now ahead of time we trick\n\t\t\t * hrtimer_forward() to expire the timer\n\t\t\t * later, while we still maintain the overrun\n\t\t\t * accuracy, but have some inconsistency in\n\t\t\t * the timer_gettime() case. This is at least\n\t\t\t * better than a starved softirq. A more\n\t\t\t * complex fix which solves also another related\n\t\t\t * inconsistency is already in the pipeline.\n\t\t\t */\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_timer",
          "args": [
            "timr",
            "flags"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "183-186",
          "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "timer",
            "now",
            "timr->it_interval"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "907-939",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "now",
            "kj"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cb_get_time",
          "args": [
            "timer"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_timer_event",
          "args": [
            "timr",
            "si_private"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "334-355",
          "snippet": "int posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret = -1;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret = -1;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&timr->it_lock",
            "flags"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structk_itimer",
            "it.real.timer"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\t/*\n\t\t * signal was not sent because of sig_ignor\n\t\t * we will not get a call back to restart it AND\n\t\t * it should be restarted.\n\t\t */\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n\t\t\t/*\n\t\t\t * FIXME: What we really want, is to stop this\n\t\t\t * timer completely and restart it in case the\n\t\t\t * SIG_IGN is removed. This is a non trivial\n\t\t\t * change which involves sighand locking\n\t\t\t * (sigh !), which we don't want to do late in\n\t\t\t * the release cycle.\n\t\t\t *\n\t\t\t * For now we just let timers with an interval\n\t\t\t * less than a jiffie expire every jiffie to\n\t\t\t * avoid softirq starvation in case of SIG_IGN\n\t\t\t * and a very small interval, which would put\n\t\t\t * the timer right back on the softirq pending\n\t\t\t * list. By moving now ahead of time we trick\n\t\t\t * hrtimer_forward() to expire the timer\n\t\t\t * later, while we still maintain the overrun\n\t\t\t * accuracy, but have some inconsistency in\n\t\t\t * the timer_gettime() case. This is at least\n\t\t\t * better than a starved softirq. A more\n\t\t\t * complex fix which solves also another related\n\t\t\t * inconsistency is already in the pipeline.\n\t\t\t */\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "posix_timer_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "334-355",
    "snippet": "int posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret = -1;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sigqueue",
          "args": [
            "timr->sigq",
            "timr->it_pid",
            "type"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1712-1758",
          "snippet": "int send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret = -1;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}"
  },
  {
    "function_name": "posixtimer_rearm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "311-332",
    "snippet": "void posixtimer_rearm(struct kernel_siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\n\tif (timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1LL;\n\t\t++timr->it_requeue_pending;\n\n\t\tinfo->si_overrun = timer_overrun_to_int(timr, info->si_overrun);\n\t}\n\n\tunlock_timer(timr, flags);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_timer",
          "args": [
            "timr",
            "flags"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "183-186",
          "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_overrun_to_int",
          "args": [
            "timr",
            "info->si_overrun"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "timer_overrun_to_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "281-286",
          "snippet": "static inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timr->kclock->timer_rearm",
          "args": [
            "timr"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_timer",
          "args": [
            "info->si_tid",
            "&flags"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "612-636",
          "snippet": "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags)\n{\n\tstruct k_itimer *timr;\n\n\t/*\n\t * timer_t could be any type >= int and we want to make sure any\n\t * @timer_id outside positive int range fails lookup.\n\t */\n\tif ((unsigned long long)timer_id > INT_MAX)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttimr = posix_timer_by_id(timer_id);\n\tif (timr) {\n\t\tspin_lock_irqsave(&timr->it_lock, *flags);\n\t\tif (timr->it_signal == current->signal) {\n\t\t\trcu_read_unlock();\n\t\t\treturn timr;\n\t\t}\n\t\tspin_unlock_irqrestore(&timr->it_lock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nvoid posixtimer_rearm(struct kernel_siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\n\tif (timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1LL;\n\t\t++timr->it_requeue_pending;\n\n\t\tinfo->si_overrun = timer_overrun_to_int(timr, info->si_overrun);\n\t}\n\n\tunlock_timer(timr, flags);\n}"
  },
  {
    "function_name": "common_hrtimer_rearm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "288-298",
    "snippet": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\tif (!timr->it_interval)\n\t\treturn;\n\n\ttimr->it_overrun += hrtimer_forward(timer, timer->base->get_time(),\n\t\t\t\t\t    timr->it_interval);\n\thrtimer_restart(timer);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_restart",
          "args": [
            "timer"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mux_hrtimer_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1109-1128",
          "snippet": "static int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static __must_check struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic __must_check struct;\n\nstatic int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "timer",
            "timer->base->get_time()",
            "timr->it_interval"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "907-939",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer->base->get_time",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\tif (!timr->it_interval)\n\t\treturn;\n\n\ttimr->it_overrun += hrtimer_forward(timer, timer->base->get_time(),\n\t\t\t\t\t    timr->it_interval);\n\thrtimer_restart(timer);\n}"
  },
  {
    "function_name": "timer_overrun_to_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "281-286",
    "snippet": "static inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}"
  },
  {
    "function_name": "init_posix_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "268-274",
    "snippet": "static __init int init_posix_timers(void)\n{\n\tposix_timers_cache = kmem_cache_create(\"posix_timers_cache\",\n\t\t\t\t\tsizeof (struct k_itimer), 0, SLAB_PANIC,\n\t\t\t\t\tNULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *posix_timers_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"posix_timers_cache\"",
            "sizeof (struct k_itimer)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *posix_timers_cache;\n\nstatic __init int init_posix_timers(void)\n{\n\tposix_timers_cache = kmem_cache_create(\"posix_timers_cache\",\n\t\t\t\t\tsizeof (struct k_itimer), 0, SLAB_PANIC,\n\t\t\t\t\tNULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_hrtimer_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "258-263",
    "snippet": "static int posix_get_hrtimer_res(clockid_t which_clock, struct timespec64 *tp)\n{\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = hrtimer_resolution;\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_hrtimer_res(clockid_t which_clock, struct timespec64 *tp)\n{\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = hrtimer_resolution;\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_tai",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "252-256",
    "snippet": "static int posix_get_tai(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_clocktai_ts64(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_clocktai_ts64",
          "args": [
            "tp"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_tai(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_clocktai_ts64(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_boottime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "246-250",
    "snippet": "static int posix_get_boottime(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_boottime_ts64(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_boottime_ts64",
          "args": [
            "tp"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_boottime(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_boottime_ts64(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_coarse_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "240-244",
    "snippet": "static int posix_get_coarse_res(const clockid_t which_clock, struct timespec64 *tp)\n{\n\t*tp = ktime_to_timespec64(KTIME_LOW_RES);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "KTIME_LOW_RES"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_coarse_res(const clockid_t which_clock, struct timespec64 *tp)\n{\n\t*tp = ktime_to_timespec64(KTIME_LOW_RES);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_monotonic_coarse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "233-238",
    "snippet": "static int posix_get_monotonic_coarse(clockid_t which_clock,\n\t\t\t\t\t\tstruct timespec64 *tp)\n{\n\tktime_get_coarse_ts64(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_coarse_ts64",
          "args": [
            "tp"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_coarse_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2174-2189",
          "snippet": "void ktime_get_coarse_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 now, mono;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tnow = tk_xtime(tk);\n\t\tmono = tk->wall_to_monotonic;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tset_normalized_timespec64(ts, now.tv_sec + mono.tv_sec,\n\t\t\t\tnow.tv_nsec + mono.tv_nsec);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 now, mono;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tnow = tk_xtime(tk);\n\t\tmono = tk->wall_to_monotonic;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tset_normalized_timespec64(ts, now.tv_sec + mono.tv_sec,\n\t\t\t\tnow.tv_nsec + mono.tv_nsec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_monotonic_coarse(clockid_t which_clock,\n\t\t\t\t\t\tstruct timespec64 *tp)\n{\n\tktime_get_coarse_ts64(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_realtime_coarse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "227-231",
    "snippet": "static int posix_get_realtime_coarse(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_coarse_real_ts64(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_coarse_real_ts64",
          "args": [
            "tp"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_coarse_real_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2161-2171",
          "snippet": "void ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_realtime_coarse(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_coarse_real_ts64(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_get_monotonic_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "220-224",
    "snippet": "static int posix_get_monotonic_raw(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_raw_ts64(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_raw_ts64",
          "args": [
            "tp"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_raw_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1412-1427",
          "snippet": "void ktime_get_raw_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->raw_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_raw_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->raw_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_get_monotonic_raw(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_raw_ts64(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_ktime_get_ts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "211-215",
    "snippet": "static int posix_ktime_get_ts(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_ts64(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_ts64",
          "args": [
            "tp"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "876-896",
          "snippet": "void ktime_get_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 tomono;\n\tunsigned int seq;\n\tu64 nsec;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsec = timekeeping_get_ns(&tk->tkr_mono);\n\t\ttomono = tk->wall_to_monotonic;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_sec += tomono.tv_sec;\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsec + tomono.tv_nsec);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 tomono;\n\tunsigned int seq;\n\tu64 nsec;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsec = timekeeping_get_ns(&tk->tkr_mono);\n\t\ttomono = tk->wall_to_monotonic;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_sec += tomono.tv_sec;\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsec + tomono.tv_nsec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_ktime_get_ts(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_ts64(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_clock_realtime_adj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "202-206",
    "snippet": "static int posix_clock_realtime_adj(const clockid_t which_clock,\n\t\t\t\t    struct timex *t)\n{\n\treturn do_adjtimex(t);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_adjtimex",
          "args": [
            "t"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "do_adjtimex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2314-2365",
          "snippet": "int do_adjtimex(struct timex *txc)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 ts;\n\ts32 orig_tai, tai;\n\tint ret;\n\n\t/* Validate the data before disabling interrupts */\n\tret = timekeeping_validate_timex(txc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\tstruct timespec64 delta;\n\t\tdelta.tv_sec  = txc->time.tv_sec;\n\t\tdelta.tv_nsec = txc->time.tv_usec;\n\t\tif (!(txc->modes & ADJ_NANO))\n\t\t\tdelta.tv_nsec *= 1000;\n\t\tret = timekeeping_inject_offset(&delta);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tktime_get_real_ts64(&ts);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\torig_tai = tai = tk->tai_offset;\n\tret = __do_adjtimex(txc, &ts, &tai);\n\n\tif (tai != orig_tai) {\n\t\t__timekeeping_set_tai_offset(tk, tai);\n\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\t}\n\ttk_update_leap_state(tk);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Update the multiplier immediately if frequency was set directly */\n\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))\n\t\ttimekeeping_advance(TK_ADV_FREQ);\n\n\tif (tai != orig_tai)\n\t\tclock_was_set();\n\n\tntp_notify_cmos_timer();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)"
          ],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(timekeeper_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\n\nint do_adjtimex(struct timex *txc)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 ts;\n\ts32 orig_tai, tai;\n\tint ret;\n\n\t/* Validate the data before disabling interrupts */\n\tret = timekeeping_validate_timex(txc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\tstruct timespec64 delta;\n\t\tdelta.tv_sec  = txc->time.tv_sec;\n\t\tdelta.tv_nsec = txc->time.tv_usec;\n\t\tif (!(txc->modes & ADJ_NANO))\n\t\t\tdelta.tv_nsec *= 1000;\n\t\tret = timekeeping_inject_offset(&delta);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tktime_get_real_ts64(&ts);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\torig_tai = tai = tk->tai_offset;\n\tret = __do_adjtimex(txc, &ts, &tai);\n\n\tif (tai != orig_tai) {\n\t\t__timekeeping_set_tai_offset(tk, tai);\n\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\t}\n\ttk_update_leap_state(tk);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Update the multiplier immediately if frequency was set directly */\n\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))\n\t\ttimekeeping_advance(TK_ADV_FREQ);\n\n\tif (tai != orig_tai)\n\t\tclock_was_set();\n\n\tntp_notify_cmos_timer();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_clock_realtime_adj(const clockid_t which_clock,\n\t\t\t\t    struct timex *t)\n{\n\treturn do_adjtimex(t);\n}"
  },
  {
    "function_name": "posix_clock_realtime_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "196-200",
    "snippet": "static int posix_clock_realtime_set(const clockid_t which_clock,\n\t\t\t\t    const struct timespec64 *tp)\n{\n\treturn do_sys_settimeofday64(tp, NULL);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_sys_settimeofday64",
          "args": [
            "tp",
            "NULL"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "do_sys_settimeofday64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "172-200",
          "snippet": "int do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)\n{\n\tstatic int firsttime = 1;\n\tint error = 0;\n\n\tif (tv && !timespec64_valid(tv))\n\t\treturn -EINVAL;\n\n\terror = security_settime64(tv, tz);\n\tif (error)\n\t\treturn error;\n\n\tif (tz) {\n\t\t/* Verify we're witin the +-15 hrs range */\n\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)\n\t\t\treturn -EINVAL;\n\n\t\tsys_tz = *tz;\n\t\tupdate_vsyscall_tz();\n\t\tif (firsttime) {\n\t\t\tfirsttime = 0;\n\t\t\tif (!tv)\n\t\t\t\ttimekeeping_warp_clock();\n\t\t}\n\t}\n\tif (tv)\n\t\treturn do_settimeofday64(tv);\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct timezone sys_tz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timezone sys_tz;\n\nint do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)\n{\n\tstatic int firsttime = 1;\n\tint error = 0;\n\n\tif (tv && !timespec64_valid(tv))\n\t\treturn -EINVAL;\n\n\terror = security_settime64(tv, tz);\n\tif (error)\n\t\treturn error;\n\n\tif (tz) {\n\t\t/* Verify we're witin the +-15 hrs range */\n\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)\n\t\t\treturn -EINVAL;\n\n\t\tsys_tz = *tz;\n\t\tupdate_vsyscall_tz();\n\t\tif (firsttime) {\n\t\t\tfirsttime = 0;\n\t\t\tif (!tv)\n\t\t\t\ttimekeeping_warp_clock();\n\t\t}\n\t}\n\tif (tv)\n\t\treturn do_settimeofday64(tv);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_clock_realtime_set(const clockid_t which_clock,\n\t\t\t\t    const struct timespec64 *tp)\n{\n\treturn do_sys_settimeofday64(tp, NULL);\n}"
  },
  {
    "function_name": "posix_clock_realtime_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "189-193",
    "snippet": "static int posix_clock_realtime_get(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_real_ts64(tp);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "tp"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "723-741",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int posix_clock_realtime_get(clockid_t which_clock, struct timespec64 *tp)\n{\n\tktime_get_real_ts64(tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "unlock_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "183-186",
    "snippet": "static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&timr->it_lock",
            "flags"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic inline void unlock_timer(struct k_itimer *timr, unsigned long flags)\n{\n\tspin_unlock_irqrestore(&timr->it_lock, flags);\n}"
  },
  {
    "function_name": "posix_timer_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "159-181",
    "snippet": "static int posix_timer_add(struct k_itimer *timer)\n{\n\tstruct signal_struct *sig = current->signal;\n\tint first_free_id = sig->posix_timer_id;\n\tstruct hlist_head *head;\n\tint ret = -ENOENT;\n\n\tdo {\n\t\tspin_lock(&hash_lock);\n\t\thead = &posix_timers_hashtable[hash(sig, sig->posix_timer_id)];\n\t\tif (!__posix_timers_find(head, sig, sig->posix_timer_id)) {\n\t\t\thlist_add_head_rcu(&timer->t_hash, head);\n\t\t\tret = sig->posix_timer_id;\n\t\t}\n\t\tif (++sig->posix_timer_id < 0)\n\t\t\tsig->posix_timer_id = 0;\n\t\tif ((sig->posix_timer_id == first_free_id) && (ret == -ENOENT))\n\t\t\t/* Loop over all possible ids completed */\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&hash_lock);\n\t} while (ret == -ENOENT);\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);",
      "static DEFINE_SPINLOCK(hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hash_lock"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&timer->t_hash",
            "head"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__posix_timers_find",
          "args": [
            "head",
            "sig",
            "sig->posix_timer_id"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "__posix_timers_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "138-149",
          "snippet": "static struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct k_clock *clockid_to_kclock(const clockid_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\n\nstatic struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sig",
            "sig->posix_timer_id"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "133-136",
          "snippet": "static int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\n\nstatic int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hash_lock"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\nstatic DEFINE_SPINLOCK(hash_lock);\n\nstatic int posix_timer_add(struct k_itimer *timer)\n{\n\tstruct signal_struct *sig = current->signal;\n\tint first_free_id = sig->posix_timer_id;\n\tstruct hlist_head *head;\n\tint ret = -ENOENT;\n\n\tdo {\n\t\tspin_lock(&hash_lock);\n\t\thead = &posix_timers_hashtable[hash(sig, sig->posix_timer_id)];\n\t\tif (!__posix_timers_find(head, sig, sig->posix_timer_id)) {\n\t\t\thlist_add_head_rcu(&timer->t_hash, head);\n\t\t\tret = sig->posix_timer_id;\n\t\t}\n\t\tif (++sig->posix_timer_id < 0)\n\t\t\tsig->posix_timer_id = 0;\n\t\tif ((sig->posix_timer_id == first_free_id) && (ret == -ENOENT))\n\t\t\t/* Loop over all possible ids completed */\n\t\t\tret = -EAGAIN;\n\t\tspin_unlock(&hash_lock);\n\t} while (ret == -ENOENT);\n\treturn ret;\n}"
  },
  {
    "function_name": "posix_timer_by_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "151-157",
    "snippet": "static struct k_itimer *posix_timer_by_id(timer_t id)\n{\n\tstruct signal_struct *sig = current->signal;\n\tstruct hlist_head *head = &posix_timers_hashtable[hash(sig, id)];\n\n\treturn __posix_timers_find(head, sig, id);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);",
      "static const struct k_clock *clockid_to_kclock(const clockid_t id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__posix_timers_find",
          "args": [
            "head",
            "sig",
            "id"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__posix_timers_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "138-149",
          "snippet": "static struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct k_clock *clockid_to_kclock(const clockid_t id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\n\nstatic struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sig",
            "id"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "133-136",
          "snippet": "static int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\n\nstatic int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\n\nstatic struct k_itimer *posix_timer_by_id(timer_t id)\n{\n\tstruct signal_struct *sig = current->signal;\n\tstruct hlist_head *head = &posix_timers_hashtable[hash(sig, id)];\n\n\treturn __posix_timers_find(head, sig, id);\n}"
  },
  {
    "function_name": "__posix_timers_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "138-149",
    "snippet": "static struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct k_clock *clockid_to_kclock(const clockid_t id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "timer",
            "head",
            "t_hash"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic const struct k_clock *clockid_to_kclock(const clockid_t id);\n\nstatic struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\n\thlist_for_each_entry_rcu(timer, head, t_hash) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "133-136",
    "snippet": "static int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_HASHTABLE(posix_timers_hashtable, 9);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "hash32_ptr(sig) ^ nr",
            "HASH_BITS(posix_timers_hashtable)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH_BITS",
          "args": [
            "posix_timers_hashtable"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash32_ptr",
          "args": [
            "sig"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic DEFINE_HASHTABLE(posix_timers_hashtable, 9);\n\nstatic int hash(struct signal_struct *sig, unsigned int nr)\n{\n\treturn hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));\n}"
  },
  {
    "function_name": "timer_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "575-587",
    "snippet": "SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,\n\t\tstruct sigevent __user *, timer_event_spec,\n\t\ttimer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (copy_from_user(&event, timer_event_spec, sizeof (event)))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,\n\t\tstruct sigevent __user *, timer_event_spec,\n\t\ttimer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (copy_from_user(&event, timer_event_spec, sizeof (event)))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}"
  },
  {
    "function_name": "timer_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "590-602",
    "snippet": "SYSCALL_DEFINE3(timer_create, clockid_t, which_clock,\n\t\t       struct compat_sigevent __user *, timer_event_spec,\n\t\t       timer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (get_compat_sigevent(&event, timer_event_spec))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(timer_create, clockid_t, which_clock,\n\t\t       struct compat_sigevent __user *, timer_event_spec,\n\t\t       timer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (get_compat_sigevent(&event, timer_event_spec))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}"
  },
  {
    "function_name": "timer_gettime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "742-753",
    "snippet": "SYSCALL_DEFINE2(timer_gettime, timer_t, timer_id,\n\t\tstruct __kernel_itimerspec __user *, setting)\n{\n\tstruct itimerspec64 cur_setting;\n\n\tint ret = do_timer_gettime(timer_id, &cur_setting);\n\tif (!ret) {\n\t\tif (put_itimerspec64(&cur_setting, setting))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(timer_gettime, timer_t, timer_id,\n\t\tstruct __kernel_itimerspec __user *, setting)\n{\n\tstruct itimerspec64 cur_setting;\n\n\tint ret = do_timer_gettime(timer_id, &cur_setting);\n\tif (!ret) {\n\t\tif (put_itimerspec64(&cur_setting, setting))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "timer_gettime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "757-768",
    "snippet": "SYSCALL_DEFINE2(timer_gettime, timer_t, timer_id,\n\t\t       struct old_itimerspec32 __user *, setting)\n{\n\tstruct itimerspec64 cur_setting;\n\n\tint ret = do_timer_gettime(timer_id, &cur_setting);\n\tif (!ret) {\n\t\tif (put_old_itimerspec32(&cur_setting, setting))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(timer_gettime, timer_t, timer_id,\n\t\t       struct old_itimerspec32 __user *, setting)\n{\n\tstruct itimerspec64 cur_setting;\n\n\tint ret = do_timer_gettime(timer_id, &cur_setting);\n\tif (!ret) {\n\t\tif (put_old_itimerspec32(&cur_setting, setting))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "timer_getoverrun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "781-795",
    "snippet": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\toverrun = timer_overrun_to_int(timr, 0);\n\tunlock_timer(timr, flags);\n\n\treturn overrun;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\toverrun = timer_overrun_to_int(timr, 0);\n\tunlock_timer(timr, flags);\n\n\treturn overrun;\n}"
  },
  {
    "function_name": "timer_settime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "907-927",
    "snippet": "SYSCALL_DEFINE4(timer_settime, timer_t, timer_id, int, flags,\n\t\tconst struct __kernel_itimerspec __user *, new_setting,\n\t\tstruct __kernel_itimerspec __user *, old_setting)\n{\n\tstruct itimerspec64 new_spec, old_spec;\n\tstruct itimerspec64 *rtn = old_setting ? &old_spec : NULL;\n\tint error = 0;\n\n\tif (!new_setting)\n\t\treturn -EINVAL;\n\n\tif (get_itimerspec64(&new_spec, new_setting))\n\t\treturn -EFAULT;\n\n\terror = do_timer_settime(timer_id, flags, &new_spec, rtn);\n\tif (!error && old_setting) {\n\t\tif (put_itimerspec64(&old_spec, old_setting))\n\t\t\terror = -EFAULT;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE4(timer_settime, timer_t, timer_id, int, flags,\n\t\tconst struct __kernel_itimerspec __user *, new_setting,\n\t\tstruct __kernel_itimerspec __user *, old_setting)\n{\n\tstruct itimerspec64 new_spec, old_spec;\n\tstruct itimerspec64 *rtn = old_setting ? &old_spec : NULL;\n\tint error = 0;\n\n\tif (!new_setting)\n\t\treturn -EINVAL;\n\n\tif (get_itimerspec64(&new_spec, new_setting))\n\t\treturn -EFAULT;\n\n\terror = do_timer_settime(timer_id, flags, &new_spec, rtn);\n\tif (!error && old_setting) {\n\t\tif (put_itimerspec64(&old_spec, old_setting))\n\t\t\terror = -EFAULT;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "timer_settime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "930-949",
    "snippet": "SYSCALL_DEFINE4(timer_settime, timer_t, timer_id, int, flags,\n\t\t       struct old_itimerspec32 __user *, new,\n\t\t       struct old_itimerspec32 __user *, old)\n{\n\tstruct itimerspec64 new_spec, old_spec;\n\tstruct itimerspec64 *rtn = old ? &old_spec : NULL;\n\tint error = 0;\n\n\tif (!new)\n\t\treturn -EINVAL;\n\tif (get_old_itimerspec32(&new_spec, new))\n\t\treturn -EFAULT;\n\n\terror = do_timer_settime(timer_id, flags, &new_spec, rtn);\n\tif (!error && old) {\n\t\tif (put_old_itimerspec32(&old_spec, old))\n\t\t\terror = -EFAULT;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE4(timer_settime, timer_t, timer_id, int, flags,\n\t\t       struct old_itimerspec32 __user *, new,\n\t\t       struct old_itimerspec32 __user *, old)\n{\n\tstruct itimerspec64 new_spec, old_spec;\n\tstruct itimerspec64 *rtn = old ? &old_spec : NULL;\n\tint error = 0;\n\n\tif (!new)\n\t\treturn -EINVAL;\n\tif (get_old_itimerspec32(&new_spec, new))\n\t\treturn -EFAULT;\n\n\terror = do_timer_settime(timer_id, flags, &new_spec, rtn);\n\tif (!error && old) {\n\t\tif (put_old_itimerspec32(&old_spec, old))\n\t\t\terror = -EFAULT;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "timer_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "973-1000",
    "snippet": "SYSCALL_DEFINE1(timer_delete, timer_t, timer_id)\n{\n\tstruct k_itimer *timer;\n\tunsigned long flags;\n\nretry_delete:\n\ttimer = lock_timer(timer_id, &flags);\n\tif (!timer)\n\t\treturn -EINVAL;\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tunlock_timer(timer, flags);\n\t\tgoto retry_delete;\n\t}\n\n\tspin_lock(&current->sighand->siglock);\n\tlist_del(&timer->list);\n\tspin_unlock(&current->sighand->siglock);\n\t/*\n\t * This keeps any tasks waiting on the spin lock from thinking\n\t * they got something (see the lock code above).\n\t */\n\ttimer->it_signal = NULL;\n\n\tunlock_timer(timer, flags);\n\trelease_posix_timer(timer, IT_ID_SET);\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define IT_ID_SET\t1"
    ],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\n#define IT_ID_SET\t1\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE1(timer_delete, timer_t, timer_id)\n{\n\tstruct k_itimer *timer;\n\tunsigned long flags;\n\nretry_delete:\n\ttimer = lock_timer(timer_id, &flags);\n\tif (!timer)\n\t\treturn -EINVAL;\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tunlock_timer(timer, flags);\n\t\tgoto retry_delete;\n\t}\n\n\tspin_lock(&current->sighand->siglock);\n\tlist_del(&timer->list);\n\tspin_unlock(&current->sighand->siglock);\n\t/*\n\t * This keeps any tasks waiting on the spin lock from thinking\n\t * they got something (see the lock code above).\n\t */\n\ttimer->it_signal = NULL;\n\n\tunlock_timer(timer, flags);\n\trelease_posix_timer(timer, IT_ID_SET);\n\treturn 0;\n}"
  },
  {
    "function_name": "clock_settime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1041-1054",
    "snippet": "SYSCALL_DEFINE2(clock_settime, const clockid_t, which_clock,\n\t\tconst struct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 new_tp;\n\n\tif (!kc || !kc->clock_set)\n\t\treturn -EINVAL;\n\n\tif (get_timespec64(&new_tp, tp))\n\t\treturn -EFAULT;\n\n\treturn kc->clock_set(which_clock, &new_tp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_settime, const clockid_t, which_clock,\n\t\tconst struct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 new_tp;\n\n\tif (!kc || !kc->clock_set)\n\t\treturn -EINVAL;\n\n\tif (get_timespec64(&new_tp, tp))\n\t\treturn -EFAULT;\n\n\treturn kc->clock_set(which_clock, &new_tp);\n}"
  },
  {
    "function_name": "clock_gettime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1056-1072",
    "snippet": "SYSCALL_DEFINE2(clock_gettime, const clockid_t, which_clock,\n\t\tstruct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 kernel_tp;\n\tint error;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terror = kc->clock_get(which_clock, &kernel_tp);\n\n\tif (!error && put_timespec64(&kernel_tp, tp))\n\t\terror = -EFAULT;\n\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_gettime, const clockid_t, which_clock,\n\t\tstruct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 kernel_tp;\n\tint error;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terror = kc->clock_get(which_clock, &kernel_tp);\n\n\tif (!error && put_timespec64(&kernel_tp, tp))\n\t\terror = -EFAULT;\n\n\treturn error;\n}"
  },
  {
    "function_name": "clock_adjtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1074-1095",
    "snippet": "SYSCALL_DEFINE2(clock_adjtime, const clockid_t, which_clock,\n\t\tstruct timex __user *, utx)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timex ktx;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->clock_adj)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&ktx, utx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\n\terr = kc->clock_adj(which_clock, &ktx);\n\n\tif (err >= 0 && copy_to_user(utx, &ktx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_adjtime, const clockid_t, which_clock,\n\t\tstruct timex __user *, utx)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timex ktx;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->clock_adj)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&ktx, utx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\n\terr = kc->clock_adj(which_clock, &ktx);\n\n\tif (err >= 0 && copy_to_user(utx, &ktx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\n\treturn err;\n}"
  },
  {
    "function_name": "clock_getres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1097-1113",
    "snippet": "SYSCALL_DEFINE2(clock_getres, const clockid_t, which_clock,\n\t\tstruct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 rtn_tp;\n\tint error;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terror = kc->clock_getres(which_clock, &rtn_tp);\n\n\tif (!error && tp && put_timespec64(&rtn_tp, tp))\n\t\terror = -EFAULT;\n\n\treturn error;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_getres, const clockid_t, which_clock,\n\t\tstruct __kernel_timespec __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 rtn_tp;\n\tint error;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terror = kc->clock_getres(which_clock, &rtn_tp);\n\n\tif (!error && tp && put_timespec64(&rtn_tp, tp))\n\t\terror = -EFAULT;\n\n\treturn error;\n}"
  },
  {
    "function_name": "clock_settime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1117-1130",
    "snippet": "SYSCALL_DEFINE2(clock_settime, clockid_t, which_clock,\n\t\t       struct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\n\tif (!kc || !kc->clock_set)\n\t\treturn -EINVAL;\n\n\tif (get_old_timespec32(&ts, tp))\n\t\treturn -EFAULT;\n\n\treturn kc->clock_set(which_clock, &ts);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_settime, clockid_t, which_clock,\n\t\t       struct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\n\tif (!kc || !kc->clock_set)\n\t\treturn -EINVAL;\n\n\tif (get_old_timespec32(&ts, tp))\n\t\treturn -EFAULT;\n\n\treturn kc->clock_set(which_clock, &ts);\n}"
  },
  {
    "function_name": "clock_gettime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1132-1148",
    "snippet": "SYSCALL_DEFINE2(clock_gettime, clockid_t, which_clock,\n\t\t       struct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terr = kc->clock_get(which_clock, &ts);\n\n\tif (!err && put_old_timespec32(&ts, tp))\n\t\terr = -EFAULT;\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_gettime, clockid_t, which_clock,\n\t\t       struct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terr = kc->clock_get(which_clock, &ts);\n\n\tif (!err && put_old_timespec32(&ts, tp))\n\t\terr = -EFAULT;\n\n\treturn err;\n}"
  },
  {
    "function_name": "clock_adjtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1154-1176",
    "snippet": "SYSCALL_DEFINE2(clock_adjtime, clockid_t, which_clock,\n\t\t       struct compat_timex __user *, utp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timex ktx;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->clock_adj)\n\t\treturn -EOPNOTSUPP;\n\n\terr = compat_get_timex(&ktx, utp);\n\tif (err)\n\t\treturn err;\n\n\terr = kc->clock_adj(which_clock, &ktx);\n\n\tif (err >= 0)\n\t\terr = compat_put_timex(utp, &ktx);\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_adjtime, clockid_t, which_clock,\n\t\t       struct compat_timex __user *, utp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timex ktx;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->clock_adj)\n\t\treturn -EOPNOTSUPP;\n\n\terr = compat_get_timex(&ktx, utp);\n\tif (err)\n\t\treturn err;\n\n\terr = kc->clock_adj(which_clock, &ktx);\n\n\tif (err >= 0)\n\t\terr = compat_put_timex(utp, &ktx);\n\n\treturn err;\n}"
  },
  {
    "function_name": "clock_getres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1182-1197",
    "snippet": "SYSCALL_DEFINE2(clock_getres, clockid_t, which_clock,\n\t\t       struct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terr = kc->clock_getres(which_clock, &ts);\n\tif (!err && tp && put_old_timespec32(&ts, tp))\n\t\treturn -EFAULT;\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(clock_getres, clockid_t, which_clock,\n\t\t       struct old_timespec32 __user *, tp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 ts;\n\tint err;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\n\terr = kc->clock_getres(which_clock, &ts);\n\tif (!err && tp && put_old_timespec32(&ts, tp))\n\t\treturn -EFAULT;\n\n\treturn err;\n}"
  },
  {
    "function_name": "clock_nanosleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1212-1235",
    "snippet": "SYSCALL_DEFINE4(clock_nanosleep, const clockid_t, which_clock, int, flags,\n\t\tconst struct __kernel_timespec __user *, rqtp,\n\t\tstruct __kernel_timespec __user *, rmtp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 t;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->nsleep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (get_timespec64(&t, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&t))\n\t\treturn -EINVAL;\n\tif (flags & TIMER_ABSTIME)\n\t\trmtp = NULL;\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;\n\tcurrent->restart_block.nanosleep.rmtp = rmtp;\n\n\treturn kc->nsleep(which_clock, flags, &t);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE4(clock_nanosleep, const clockid_t, which_clock, int, flags,\n\t\tconst struct __kernel_timespec __user *, rqtp,\n\t\tstruct __kernel_timespec __user *, rmtp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 t;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->nsleep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (get_timespec64(&t, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&t))\n\t\treturn -EINVAL;\n\tif (flags & TIMER_ABSTIME)\n\t\trmtp = NULL;\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;\n\tcurrent->restart_block.nanosleep.rmtp = rmtp;\n\n\treturn kc->nsleep(which_clock, flags, &t);\n}"
  },
  {
    "function_name": "clock_nanosleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
    "lines": "1239-1262",
    "snippet": "SYSCALL_DEFINE4(clock_nanosleep, clockid_t, which_clock, int, flags,\n\t\t       struct old_timespec32 __user *, rqtp,\n\t\t       struct old_timespec32 __user *, rmtp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 t;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->nsleep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (get_old_timespec32(&t, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&t))\n\t\treturn -EINVAL;\n\tif (flags & TIMER_ABSTIME)\n\t\trmtp = NULL;\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;\n\tcurrent->restart_block.nanosleep.compat_rmtp = rmtp;\n\n\treturn kc->nsleep(which_clock, flags, &t);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include \"timekeeping.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/compat.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/export.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/wait.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/hash.h>",
      "#include <linux/compiler.h>",
      "#include <linux/init.h>",
      "#include <linux/list.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/mutex.h>",
      "#include <linux/time.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nSYSCALL_DEFINE4(clock_nanosleep, clockid_t, which_clock, int, flags,\n\t\t       struct old_timespec32 __user *, rqtp,\n\t\t       struct old_timespec32 __user *, rmtp)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timespec64 t;\n\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->nsleep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (get_old_timespec32(&t, rqtp))\n\t\treturn -EFAULT;\n\n\tif (!timespec64_valid(&t))\n\t\treturn -EINVAL;\n\tif (flags & TIMER_ABSTIME)\n\t\trmtp = NULL;\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;\n\tcurrent->restart_block.nanosleep.compat_rmtp = rmtp;\n\n\treturn kc->nsleep(which_clock, flags, &t);\n}"
  }
]