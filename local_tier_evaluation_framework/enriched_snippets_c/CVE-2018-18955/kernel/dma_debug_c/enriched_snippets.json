[
  {
    "function_name": "dma_debug_driver_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1772-1788",
    "snippet": "static int __init dma_debug_driver_setup(char *str)\n{\n\tint i;\n\n\tfor (i = 0; i < NAME_MAX_LEN - 1; ++i, ++str) {\n\t\tcurrent_driver_name[i] = *str;\n\t\tif (*str == 0)\n\t\t\tbreak;\n\t}\n\n\tif (current_driver_name[0])\n\t\tpr_info(\"DMA-API: enable driver filter for driver [%s]\\n\",\n\t\t\tcurrent_driver_name);\n\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define NAME_MAX_LEN\t64"
    ],
    "globals_used": [
      "static char                  current_driver_name[NAME_MAX_LEN]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"DMA-API: enable driver filter for driver [%s]\\n\"",
            "current_driver_name"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define NAME_MAX_LEN\t64\n\nstatic char                  current_driver_name[NAME_MAX_LEN];\n\nstatic int __init dma_debug_driver_setup(char *str)\n{\n\tint i;\n\n\tfor (i = 0; i < NAME_MAX_LEN - 1; ++i, ++str) {\n\t\tcurrent_driver_name[i] = *str;\n\t\tif (*str == 0)\n\t\t\tbreak;\n\t}\n\n\tif (current_driver_name[0])\n\t\tpr_info(\"DMA-API: enable driver filter for driver [%s]\\n\",\n\t\t\tcurrent_driver_name);\n\n\n\treturn 1;\n}"
  },
  {
    "function_name": "debug_dma_sync_sg_for_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1740-1769",
    "snippet": "void debug_dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,\n\t\t\t\t  int nelems, int direction)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = direction,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tif (i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tcheck_sync(dev, &ref, false);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sync",
          "args": [
            "dev",
            "&ref",
            "false"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1214-1287",
          "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_mapped_entries",
          "args": [
            "dev",
            "&ref"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_mapped_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1468-1485",
          "snippet": "static int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, &flags);\n\n\treturn mapped_ents;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, &flags);\n\n\treturn mapped_ents;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "s"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "s"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "sg_page(s)"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sg",
            "s",
            "nelems",
            "i"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,\n\t\t\t\t  int nelems, int direction)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = direction,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tif (i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tcheck_sync(dev, &ref, false);\n\t}\n}"
  },
  {
    "function_name": "debug_dma_sync_sg_for_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1707-1737",
    "snippet": "void debug_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,\n\t\t\t       int nelems, int direction)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = direction,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tif (i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tcheck_sync(dev, &ref, true);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sync",
          "args": [
            "dev",
            "&ref",
            "true"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1214-1287",
          "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_mapped_entries",
          "args": [
            "dev",
            "&ref"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_mapped_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1468-1485",
          "snippet": "static int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, &flags);\n\n\treturn mapped_ents;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, &flags);\n\n\treturn mapped_ents;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "s"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "s"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "sg_page(s)"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sg",
            "s",
            "nelems",
            "i"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,\n\t\t\t       int nelems, int direction)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = direction,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tif (i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tcheck_sync(dev, &ref, true);\n\t}\n}"
  },
  {
    "function_name": "debug_dma_sync_single_range_for_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1686-1704",
    "snippet": "void debug_dma_sync_single_range_for_device(struct device *dev,\n\t\t\t\t\t    dma_addr_t dma_handle,\n\t\t\t\t\t    unsigned long offset,\n\t\t\t\t\t    size_t size, int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = offset + size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, false);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sync",
          "args": [
            "dev",
            "&ref",
            "false"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1214-1287",
          "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_sync_single_range_for_device(struct device *dev,\n\t\t\t\t\t    dma_addr_t dma_handle,\n\t\t\t\t\t    unsigned long offset,\n\t\t\t\t\t    size_t size, int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = offset + size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, false);\n}"
  },
  {
    "function_name": "debug_dma_sync_single_range_for_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1665-1683",
    "snippet": "void debug_dma_sync_single_range_for_cpu(struct device *dev,\n\t\t\t\t\t dma_addr_t dma_handle,\n\t\t\t\t\t unsigned long offset, size_t size,\n\t\t\t\t\t int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = offset + size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, true);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sync",
          "args": [
            "dev",
            "&ref",
            "true"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1214-1287",
          "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_sync_single_range_for_cpu(struct device *dev,\n\t\t\t\t\t dma_addr_t dma_handle,\n\t\t\t\t\t unsigned long offset, size_t size,\n\t\t\t\t\t int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = offset + size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, true);\n}"
  },
  {
    "function_name": "debug_dma_sync_single_for_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1645-1662",
    "snippet": "void debug_dma_sync_single_for_device(struct device *dev,\n\t\t\t\t      dma_addr_t dma_handle, size_t size,\n\t\t\t\t      int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, false);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sync",
          "args": [
            "dev",
            "&ref",
            "false"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1214-1287",
          "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_sync_single_for_device(struct device *dev,\n\t\t\t\t      dma_addr_t dma_handle, size_t size,\n\t\t\t\t      int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, false);\n}"
  },
  {
    "function_name": "debug_dma_sync_single_for_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1626-1642",
    "snippet": "void debug_dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,\n\t\t\t\t   size_t size, int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, true);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_sync",
          "args": [
            "dev",
            "&ref",
            "true"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "check_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1214-1287",
          "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,\n\t\t\t\t   size_t size, int direction)\n{\n\tstruct dma_debug_entry ref;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.type         = dma_debug_single;\n\tref.dev          = dev;\n\tref.dev_addr     = dma_handle;\n\tref.size         = size;\n\tref.direction    = direction;\n\tref.sg_call_ents = 0;\n\n\tcheck_sync(dev, &ref, true);\n}"
  },
  {
    "function_name": "debug_dma_unmap_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1608-1623",
    "snippet": "void debug_dma_unmap_resource(struct device *dev, dma_addr_t dma_addr,\n\t\t\t      size_t size, int direction)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_resource,\n\t\t.dev            = dev,\n\t\t.dev_addr       = dma_addr,\n\t\t.size           = size,\n\t\t.direction      = direction,\n\t};\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tcheck_unmap(&ref);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_unmap",
          "args": [
            "&ref"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "check_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1073-1167",
          "snippet": "static void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, &flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/DMA-API.txt.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };",
            "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, &flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/DMA-API.txt.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_unmap_resource(struct device *dev, dma_addr_t dma_addr,\n\t\t\t      size_t size, int direction)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_resource,\n\t\t.dev            = dev,\n\t\t.dev_addr       = dma_addr,\n\t\t.size           = size,\n\t\t.direction      = direction,\n\t};\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tcheck_unmap(&ref);\n}"
  },
  {
    "function_name": "debug_dma_map_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1583-1605",
    "snippet": "void debug_dma_map_resource(struct device *dev, phys_addr_t addr, size_t size,\n\t\t\t    int direction, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->type\t\t= dma_debug_resource;\n\tentry->dev\t\t= dev;\n\tentry->pfn\t\t= PHYS_PFN(addr);\n\tentry->offset\t\t= offset_in_page(addr);\n\tentry->size\t\t= size;\n\tentry->dev_addr\t\t= dma_addr;\n\tentry->direction\t= direction;\n\tentry->map_err_type\t= MAP_ERR_NOT_CHECKED;\n\n\tadd_dma_entry(entry);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_dma_entry",
          "args": [
            "entry"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "add_dma_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "625-644",
          "snippet": "static void add_dma_entry(struct dma_debug_entry *entry)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, &flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\t/* TODO: report -EEXIST errors here as overlapping mappings are\n\t * not supported by the DMA API\n\t */\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic void add_dma_entry(struct dma_debug_entry *entry)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, &flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\t/* TODO: report -EEXIST errors here as overlapping mappings are\n\t * not supported by the DMA API\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "addr"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_entry_alloc",
          "args": [],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "dma_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "666-692",
          "snippet": "static struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (list_empty(&free_entries)) {\n\t\tglobal_disable = true;\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\tpr_err(\"DMA-API: debugging out of memory - disabling\\n\");\n\t\treturn NULL;\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;\n\tentry->stacktrace.entries = entry->st_entries;\n\tentry->stacktrace.skip = 2;\n\tsave_stack_trace(&entry->stacktrace);\n#endif\n\n\treturn entry;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define DMA_DEBUG_STACKTRACE_ENTRIES 5"
          ],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_STACKTRACE_ENTRIES 5\n\nstatic LIST_HEAD(free_entries);\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic bool global_disable;\n\nstatic struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (list_empty(&free_entries)) {\n\t\tglobal_disable = true;\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\tpr_err(\"DMA-API: debugging out of memory - disabling\\n\");\n\t\treturn NULL;\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;\n\tentry->stacktrace.entries = entry->st_entries;\n\tentry->stacktrace.skip = 2;\n\tsave_stack_trace(&entry->stacktrace);\n#endif\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_map_resource(struct device *dev, phys_addr_t addr, size_t size,\n\t\t\t    int direction, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->type\t\t= dma_debug_resource;\n\tentry->dev\t\t= dev;\n\tentry->pfn\t\t= PHYS_PFN(addr);\n\tentry->offset\t\t= offset_in_page(addr);\n\tentry->size\t\t= size;\n\tentry->dev_addr\t\t= dma_addr;\n\tentry->direction\t= direction;\n\tentry->map_err_type\t= MAP_ERR_NOT_CHECKED;\n\n\tadd_dma_entry(entry);\n}"
  },
  {
    "function_name": "debug_dma_free_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1555-1580",
    "snippet": "void debug_dma_free_coherent(struct device *dev, size_t size,\n\t\t\t void *virt, dma_addr_t addr)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_coherent,\n\t\t.dev            = dev,\n\t\t.offset\t\t= offset_in_page(virt),\n\t\t.dev_addr       = addr,\n\t\t.size           = size,\n\t\t.direction      = DMA_BIDIRECTIONAL,\n\t};\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tif (is_vmalloc_addr(virt))\n\t\tref.pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tref.pfn = page_to_pfn(virt_to_page(virt));\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tcheck_unmap(&ref);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_unmap",
          "args": [
            "&ref"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "check_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1073-1167",
          "snippet": "static void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, &flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/DMA-API.txt.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };",
            "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, &flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/DMA-API.txt.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "virt_to_page(virt)"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "virt"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_pfn",
          "args": [
            "virt"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "virt"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "virt"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "virt"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "virt"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_free_coherent(struct device *dev, size_t size,\n\t\t\t void *virt, dma_addr_t addr)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_coherent,\n\t\t.dev            = dev,\n\t\t.offset\t\t= offset_in_page(virt),\n\t\t.dev_addr       = addr,\n\t\t.size           = size,\n\t\t.direction      = DMA_BIDIRECTIONAL,\n\t};\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tif (is_vmalloc_addr(virt))\n\t\tref.pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tref.pfn = page_to_pfn(virt_to_page(virt));\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tcheck_unmap(&ref);\n}"
  },
  {
    "function_name": "debug_dma_alloc_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1520-1552",
    "snippet": "void debug_dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t      dma_addr_t dma_addr, void *virt)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (unlikely(virt == NULL))\n\t\treturn;\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->type      = dma_debug_coherent;\n\tentry->dev       = dev;\n\tentry->offset\t = offset_in_page(virt);\n\tentry->size      = size;\n\tentry->dev_addr  = dma_addr;\n\tentry->direction = DMA_BIDIRECTIONAL;\n\n\tif (is_vmalloc_addr(virt))\n\t\tentry->pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tentry->pfn = page_to_pfn(virt_to_page(virt));\n\n\tadd_dma_entry(entry);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_dma_entry",
          "args": [
            "entry"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "add_dma_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "625-644",
          "snippet": "static void add_dma_entry(struct dma_debug_entry *entry)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, &flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\t/* TODO: report -EEXIST errors here as overlapping mappings are\n\t * not supported by the DMA API\n\t */\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic void add_dma_entry(struct dma_debug_entry *entry)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, &flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\t/* TODO: report -EEXIST errors here as overlapping mappings are\n\t * not supported by the DMA API\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "virt_to_page(virt)"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "virt"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_pfn",
          "args": [
            "virt"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "virt"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "virt"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_entry_alloc",
          "args": [],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "dma_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "666-692",
          "snippet": "static struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (list_empty(&free_entries)) {\n\t\tglobal_disable = true;\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\tpr_err(\"DMA-API: debugging out of memory - disabling\\n\");\n\t\treturn NULL;\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;\n\tentry->stacktrace.entries = entry->st_entries;\n\tentry->stacktrace.skip = 2;\n\tsave_stack_trace(&entry->stacktrace);\n#endif\n\n\treturn entry;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define DMA_DEBUG_STACKTRACE_ENTRIES 5"
          ],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_STACKTRACE_ENTRIES 5\n\nstatic LIST_HEAD(free_entries);\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic bool global_disable;\n\nstatic struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (list_empty(&free_entries)) {\n\t\tglobal_disable = true;\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\tpr_err(\"DMA-API: debugging out of memory - disabling\\n\");\n\t\treturn NULL;\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;\n\tentry->stacktrace.entries = entry->st_entries;\n\tentry->stacktrace.skip = 2;\n\tsave_stack_trace(&entry->stacktrace);\n#endif\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "virt"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "virt"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "virt == NULL"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t      dma_addr_t dma_addr, void *virt)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (unlikely(virt == NULL))\n\t\treturn;\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->type      = dma_debug_coherent;\n\tentry->dev       = dev;\n\tentry->offset\t = offset_in_page(virt);\n\tentry->size      = size;\n\tentry->dev_addr  = dma_addr;\n\tentry->direction = DMA_BIDIRECTIONAL;\n\n\tif (is_vmalloc_addr(virt))\n\t\tentry->pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tentry->pfn = page_to_pfn(virt_to_page(virt));\n\n\tadd_dma_entry(entry);\n}"
  },
  {
    "function_name": "debug_dma_unmap_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1487-1517",
    "snippet": "void debug_dma_unmap_sg(struct device *dev, struct scatterlist *sglist,\n\t\t\tint nelems, int dir)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sglist, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = dir,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\n\t\tif (mapped_ents && i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tcheck_unmap(&ref);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_unmap",
          "args": [
            "&ref"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "check_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1073-1167",
          "snippet": "static void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, &flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/DMA-API.txt.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };",
            "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, &flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/DMA-API.txt.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_mapped_entries",
          "args": [
            "dev",
            "&ref"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_mapped_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1468-1485",
          "snippet": "static int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, &flags);\n\n\treturn mapped_ents;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, &flags);\n\n\treturn mapped_ents;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "s"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "s"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "sg_page(s)"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sglist",
            "s",
            "nelems",
            "i"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_unmap_sg(struct device *dev, struct scatterlist *sglist,\n\t\t\tint nelems, int dir)\n{\n\tstruct scatterlist *s;\n\tint mapped_ents = 0, i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sglist, s, nelems, i) {\n\n\t\tstruct dma_debug_entry ref = {\n\t\t\t.type           = dma_debug_sg,\n\t\t\t.dev            = dev,\n\t\t\t.pfn\t\t= page_to_pfn(sg_page(s)),\n\t\t\t.offset\t\t= s->offset,\n\t\t\t.dev_addr       = sg_dma_address(s),\n\t\t\t.size           = sg_dma_len(s),\n\t\t\t.direction      = dir,\n\t\t\t.sg_call_ents   = nelems,\n\t\t};\n\n\t\tif (mapped_ents && i >= mapped_ents)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tmapped_ents = get_nr_mapped_entries(dev, &ref);\n\n\t\tcheck_unmap(&ref);\n\t}\n}"
  },
  {
    "function_name": "get_nr_mapped_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1468-1485",
    "snippet": "static int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, &flags);\n\n\treturn mapped_ents;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "bucket",
            "&flags"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "279-286",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_find_exact",
          "args": [
            "bucket",
            "ref"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "bucket_find_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "360-364",
          "snippet": "static struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "ref",
            "&flags"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "264-274",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int get_nr_mapped_entries(struct device *dev,\n\t\t\t\t struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint mapped_ents;\n\n\tbucket       = get_hash_bucket(ref, &flags);\n\tentry        = bucket_find_exact(bucket, ref);\n\tmapped_ents  = 0;\n\n\tif (entry)\n\t\tmapped_ents = entry->sg_mapped_ents;\n\tput_hash_bucket(bucket, &flags);\n\n\treturn mapped_ents;\n}"
  },
  {
    "function_name": "debug_dma_map_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1430-1465",
    "snippet": "void debug_dma_map_sg(struct device *dev, struct scatterlist *sg,\n\t\t      int nents, int mapped_ents, int direction)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct scatterlist *s;\n\tint i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, mapped_ents, i) {\n\t\tentry = dma_entry_alloc();\n\t\tif (!entry)\n\t\t\treturn;\n\n\t\tentry->type           = dma_debug_sg;\n\t\tentry->dev            = dev;\n\t\tentry->pfn\t      = page_to_pfn(sg_page(s));\n\t\tentry->offset\t      = s->offset,\n\t\tentry->size           = sg_dma_len(s);\n\t\tentry->dev_addr       = sg_dma_address(s);\n\t\tentry->direction      = direction;\n\t\tentry->sg_call_ents   = nents;\n\t\tentry->sg_mapped_ents = mapped_ents;\n\n\t\tcheck_for_stack(dev, sg_page(s), s->offset);\n\n\t\tif (!PageHighMem(sg_page(s))) {\n\t\t\tcheck_for_illegal_area(dev, sg_virt(s), sg_dma_len(s));\n\t\t}\n\n\t\tcheck_sg_segment(dev, s);\n\n\t\tadd_dma_entry(entry);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_dma_entry",
          "args": [
            "entry"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "add_dma_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "625-644",
          "snippet": "static void add_dma_entry(struct dma_debug_entry *entry)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, &flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\t/* TODO: report -EEXIST errors here as overlapping mappings are\n\t * not supported by the DMA API\n\t */\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic void add_dma_entry(struct dma_debug_entry *entry)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, &flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\t/* TODO: report -EEXIST errors here as overlapping mappings are\n\t * not supported by the DMA API\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_sg_segment",
          "args": [
            "dev",
            "s"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "check_sg_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1289-1313",
          "snippet": "static void check_sg_segment(struct device *dev, struct scatterlist *sg)\n{\n#ifdef CONFIG_DMA_API_DEBUG_SG\n\tunsigned int max_seg = dma_get_max_seg_size(dev);\n\tu64 start, end, boundary = dma_get_seg_boundary(dev);\n\n\t/*\n\t * Either the driver forgot to set dma_parms appropriately, or\n\t * whoever generated the list forgot to check them.\n\t */\n\tif (sg->length > max_seg)\n\t\terr_printk(dev, NULL, \"DMA-API: mapping sg segment longer than device claims to support [len=%u] [max=%u]\\n\",\n\t\t\t   sg->length, max_seg);\n\t/*\n\t * In some cases this could potentially be the DMA API\n\t * implementation's fault, but it would usually imply that\n\t * the scatterlist was built inappropriately to begin with.\n\t */\n\tstart = sg_dma_address(sg);\n\tend = start + sg_dma_len(sg) - 1;\n\tif ((start ^ end) & ~boundary)\n\t\terr_printk(dev, NULL, \"DMA-API: mapping sg segment across boundary [start=0x%016llx] [end=0x%016llx] [boundary=0x%016llx]\\n\",\n\t\t\t   start, end, boundary);\n#endif\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_sg_segment(struct device *dev, struct scatterlist *sg)\n{\n#ifdef CONFIG_DMA_API_DEBUG_SG\n\tunsigned int max_seg = dma_get_max_seg_size(dev);\n\tu64 start, end, boundary = dma_get_seg_boundary(dev);\n\n\t/*\n\t * Either the driver forgot to set dma_parms appropriately, or\n\t * whoever generated the list forgot to check them.\n\t */\n\tif (sg->length > max_seg)\n\t\terr_printk(dev, NULL, \"DMA-API: mapping sg segment longer than device claims to support [len=%u] [max=%u]\\n\",\n\t\t\t   sg->length, max_seg);\n\t/*\n\t * In some cases this could potentially be the DMA API\n\t * implementation's fault, but it would usually imply that\n\t * the scatterlist was built inappropriately to begin with.\n\t */\n\tstart = sg_dma_address(sg);\n\tend = start + sg_dma_len(sg) - 1;\n\tif ((start ^ end) & ~boundary)\n\t\terr_printk(dev, NULL, \"DMA-API: mapping sg segment across boundary [start=0x%016llx] [end=0x%016llx] [boundary=0x%016llx]\\n\",\n\t\t\t   start, end, boundary);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_for_illegal_area",
          "args": [
            "dev",
            "sg_virt(s)",
            "sg_dma_len(s)"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_illegal_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1207-1212",
          "snippet": "static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (overlap(addr, len, _stext, _etext) ||\n\t    overlap(addr, len, __start_rodata, __end_rodata))\n\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (overlap(addr, len, _stext, _etext) ||\n\t    overlap(addr, len, __start_rodata, __end_rodata))\n\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "s"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_virt",
          "args": [
            "s"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "sg_page(s)"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_stack",
          "args": [
            "dev",
            "sg_page(s)",
            "s->offset"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1169-1195",
          "snippet": "static void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "s"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "s"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "sg_page(s)"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_page",
          "args": [
            "s"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_entry_alloc",
          "args": [],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "dma_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "666-692",
          "snippet": "static struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (list_empty(&free_entries)) {\n\t\tglobal_disable = true;\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\tpr_err(\"DMA-API: debugging out of memory - disabling\\n\");\n\t\treturn NULL;\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;\n\tentry->stacktrace.entries = entry->st_entries;\n\tentry->stacktrace.skip = 2;\n\tsave_stack_trace(&entry->stacktrace);\n#endif\n\n\treturn entry;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define DMA_DEBUG_STACKTRACE_ENTRIES 5"
          ],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_STACKTRACE_ENTRIES 5\n\nstatic LIST_HEAD(free_entries);\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic bool global_disable;\n\nstatic struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (list_empty(&free_entries)) {\n\t\tglobal_disable = true;\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\tpr_err(\"DMA-API: debugging out of memory - disabling\\n\");\n\t\treturn NULL;\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;\n\tentry->stacktrace.entries = entry->st_entries;\n\tentry->stacktrace.skip = 2;\n\tsave_stack_trace(&entry->stacktrace);\n#endif\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sg",
            "s",
            "mapped_ents",
            "i"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_map_sg(struct device *dev, struct scatterlist *sg,\n\t\t      int nents, int mapped_ents, int direction)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct scatterlist *s;\n\tint i;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tfor_each_sg(sg, s, mapped_ents, i) {\n\t\tentry = dma_entry_alloc();\n\t\tif (!entry)\n\t\t\treturn;\n\n\t\tentry->type           = dma_debug_sg;\n\t\tentry->dev            = dev;\n\t\tentry->pfn\t      = page_to_pfn(sg_page(s));\n\t\tentry->offset\t      = s->offset,\n\t\tentry->size           = sg_dma_len(s);\n\t\tentry->dev_addr       = sg_dma_address(s);\n\t\tentry->direction      = direction;\n\t\tentry->sg_call_ents   = nents;\n\t\tentry->sg_mapped_ents = mapped_ents;\n\n\t\tcheck_for_stack(dev, sg_page(s), s->offset);\n\n\t\tif (!PageHighMem(sg_page(s))) {\n\t\t\tcheck_for_illegal_area(dev, sg_virt(s), sg_dma_len(s));\n\t\t}\n\n\t\tcheck_sg_segment(dev, s);\n\n\t\tadd_dma_entry(entry);\n\t}\n}"
  },
  {
    "function_name": "debug_dma_unmap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1409-1427",
    "snippet": "void debug_dma_unmap_page(struct device *dev, dma_addr_t addr,\n\t\t\t  size_t size, int direction, bool map_single)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_page,\n\t\t.dev            = dev,\n\t\t.dev_addr       = addr,\n\t\t.size           = size,\n\t\t.direction      = direction,\n\t};\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (map_single)\n\t\tref.type = dma_debug_single;\n\n\tcheck_unmap(&ref);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_unmap",
          "args": [
            "&ref"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "check_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1073-1167",
          "snippet": "static void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, &flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/DMA-API.txt.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };",
            "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, &flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/DMA-API.txt.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_unmap_page(struct device *dev, dma_addr_t addr,\n\t\t\t  size_t size, int direction, bool map_single)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_page,\n\t\t.dev            = dev,\n\t\t.dev_addr       = addr,\n\t\t.size           = size,\n\t\t.direction      = direction,\n\t};\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (map_single)\n\t\tref.type = dma_debug_single;\n\n\tcheck_unmap(&ref);\n}"
  },
  {
    "function_name": "debug_dma_mapping_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1371-1406",
    "snippet": "void debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, &flags);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "bucket",
            "&flags"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "279-286",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exact_match",
          "args": [
            "&ref",
            "entry"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "exact_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "288-292",
          "snippet": "static bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)\n{\n\treturn ((a->dev_addr == b->dev_addr) &&\n\t\t(a->dev == b->dev)) ? true : false;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)\n{\n\treturn ((a->dev_addr == b->dev_addr) &&\n\t\t(a->dev == b->dev)) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&bucket->list",
            "list"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "&ref",
            "&flags"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "264-274",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, &flags);\n}"
  },
  {
    "function_name": "debug_dma_map_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1331-1368",
    "snippet": "void debug_dma_map_page(struct device *dev, struct page *page, size_t offset,\n\t\t\tsize_t size, int direction, dma_addr_t dma_addr,\n\t\t\tbool map_single)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (dma_mapping_error(dev, dma_addr))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->dev       = dev;\n\tentry->type      = dma_debug_page;\n\tentry->pfn\t = page_to_pfn(page);\n\tentry->offset\t = offset,\n\tentry->dev_addr  = dma_addr;\n\tentry->size      = size;\n\tentry->direction = direction;\n\tentry->map_err_type = MAP_ERR_NOT_CHECKED;\n\n\tif (map_single)\n\t\tentry->type = dma_debug_single;\n\n\tcheck_for_stack(dev, page, offset);\n\n\tif (!PageHighMem(page)) {\n\t\tvoid *addr = page_address(page) + offset;\n\n\t\tcheck_for_illegal_area(dev, addr, size);\n\t}\n\n\tadd_dma_entry(entry);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_dma_entry",
          "args": [
            "entry"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "add_dma_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "625-644",
          "snippet": "static void add_dma_entry(struct dma_debug_entry *entry)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, &flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\t/* TODO: report -EEXIST errors here as overlapping mappings are\n\t * not supported by the DMA API\n\t */\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic void add_dma_entry(struct dma_debug_entry *entry)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, &flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\t/* TODO: report -EEXIST errors here as overlapping mappings are\n\t * not supported by the DMA API\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_for_illegal_area",
          "args": [
            "dev",
            "addr",
            "size"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_illegal_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1207-1212",
          "snippet": "static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (overlap(addr, len, _stext, _etext) ||\n\t    overlap(addr, len, __start_rodata, __end_rodata))\n\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (overlap(addr, len, _stext, _etext) ||\n\t    overlap(addr, len, __start_rodata, __end_rodata))\n\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_stack",
          "args": [
            "dev",
            "page",
            "offset"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1169-1195",
          "snippet": "static void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_entry_alloc",
          "args": [],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "dma_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "666-692",
          "snippet": "static struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (list_empty(&free_entries)) {\n\t\tglobal_disable = true;\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\tpr_err(\"DMA-API: debugging out of memory - disabling\\n\");\n\t\treturn NULL;\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;\n\tentry->stacktrace.entries = entry->st_entries;\n\tentry->stacktrace.skip = 2;\n\tsave_stack_trace(&entry->stacktrace);\n#endif\n\n\treturn entry;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define DMA_DEBUG_STACKTRACE_ENTRIES 5"
          ],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "static bool global_disable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_STACKTRACE_ENTRIES 5\n\nstatic LIST_HEAD(free_entries);\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic bool global_disable;\n\nstatic struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (list_empty(&free_entries)) {\n\t\tglobal_disable = true;\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\tpr_err(\"DMA-API: debugging out of memory - disabling\\n\");\n\t\treturn NULL;\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;\n\tentry->stacktrace.entries = entry->st_entries;\n\tentry->stacktrace.skip = 2;\n\tsave_stack_trace(&entry->stacktrace);\n#endif\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_mapping_error",
          "args": [
            "dev",
            "dma_addr"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_mapping_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1371-1406",
          "snippet": "void debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_map_page(struct device *dev, struct page *page, size_t offset,\n\t\t\tsize_t size, int direction, dma_addr_t dma_addr,\n\t\t\tbool map_single)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (dma_mapping_error(dev, dma_addr))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->dev       = dev;\n\tentry->type      = dma_debug_page;\n\tentry->pfn\t = page_to_pfn(page);\n\tentry->offset\t = offset,\n\tentry->dev_addr  = dma_addr;\n\tentry->size      = size;\n\tentry->direction = direction;\n\tentry->map_err_type = MAP_ERR_NOT_CHECKED;\n\n\tif (map_single)\n\t\tentry->type = dma_debug_single;\n\n\tcheck_for_stack(dev, page, offset);\n\n\tif (!PageHighMem(page)) {\n\t\tvoid *addr = page_address(page) + offset;\n\n\t\tcheck_for_illegal_area(dev, addr, size);\n\t}\n\n\tadd_dma_entry(entry);\n}"
  },
  {
    "function_name": "debug_dma_map_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1315-1328",
    "snippet": "void debug_dma_map_single(struct device *dev, const void *addr,\n\t\t\t    unsigned long len)\n{\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (!virt_addr_valid(addr))\n\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from invalid area [addr=%p] [len=%lu]\\n\",\n\t\t\t   addr, len);\n\n\tif (is_vmalloc_addr(addr))\n\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from vmalloc area [addr=%p] [len=%lu]\\n\",\n\t\t\t   addr, len);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"DMA-API: device driver maps memory from vmalloc area [addr=%p] [len=%lu]\\n\"",
            "addr",
            "len"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "addr"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"DMA-API: device driver maps memory from invalid area [addr=%p] [len=%lu]\\n\"",
            "addr",
            "len"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "addr"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dma_debug_disabled()"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_map_single(struct device *dev, const void *addr,\n\t\t\t    unsigned long len)\n{\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (!virt_addr_valid(addr))\n\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from invalid area [addr=%p] [len=%lu]\\n\",\n\t\t\t   addr, len);\n\n\tif (is_vmalloc_addr(addr))\n\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from vmalloc area [addr=%p] [len=%lu]\\n\",\n\t\t\t   addr, len);\n}"
  },
  {
    "function_name": "check_sg_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1289-1313",
    "snippet": "static void check_sg_segment(struct device *dev, struct scatterlist *sg)\n{\n#ifdef CONFIG_DMA_API_DEBUG_SG\n\tunsigned int max_seg = dma_get_max_seg_size(dev);\n\tu64 start, end, boundary = dma_get_seg_boundary(dev);\n\n\t/*\n\t * Either the driver forgot to set dma_parms appropriately, or\n\t * whoever generated the list forgot to check them.\n\t */\n\tif (sg->length > max_seg)\n\t\terr_printk(dev, NULL, \"DMA-API: mapping sg segment longer than device claims to support [len=%u] [max=%u]\\n\",\n\t\t\t   sg->length, max_seg);\n\t/*\n\t * In some cases this could potentially be the DMA API\n\t * implementation's fault, but it would usually imply that\n\t * the scatterlist was built inappropriately to begin with.\n\t */\n\tstart = sg_dma_address(sg);\n\tend = start + sg_dma_len(sg) - 1;\n\tif ((start ^ end) & ~boundary)\n\t\terr_printk(dev, NULL, \"DMA-API: mapping sg segment across boundary [start=0x%016llx] [end=0x%016llx] [boundary=0x%016llx]\\n\",\n\t\t\t   start, end, boundary);\n#endif\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"DMA-API: mapping sg segment across boundary [start=0x%016llx] [end=0x%016llx] [boundary=0x%016llx]\\n\"",
            "start",
            "end",
            "boundary"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_len",
          "args": [
            "sg"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_dma_address",
          "args": [
            "sg"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"DMA-API: mapping sg segment longer than device claims to support [len=%u] [max=%u]\\n\"",
            "sg->length",
            "max_seg"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_seg_boundary",
          "args": [
            "dev"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_max_seg_size",
          "args": [
            "dev"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_sg_segment(struct device *dev, struct scatterlist *sg)\n{\n#ifdef CONFIG_DMA_API_DEBUG_SG\n\tunsigned int max_seg = dma_get_max_seg_size(dev);\n\tu64 start, end, boundary = dma_get_seg_boundary(dev);\n\n\t/*\n\t * Either the driver forgot to set dma_parms appropriately, or\n\t * whoever generated the list forgot to check them.\n\t */\n\tif (sg->length > max_seg)\n\t\terr_printk(dev, NULL, \"DMA-API: mapping sg segment longer than device claims to support [len=%u] [max=%u]\\n\",\n\t\t\t   sg->length, max_seg);\n\t/*\n\t * In some cases this could potentially be the DMA API\n\t * implementation's fault, but it would usually imply that\n\t * the scatterlist was built inappropriately to begin with.\n\t */\n\tstart = sg_dma_address(sg);\n\tend = start + sg_dma_len(sg) - 1;\n\tif ((start ^ end) & ~boundary)\n\t\terr_printk(dev, NULL, \"DMA-API: mapping sg segment across boundary [start=0x%016llx] [end=0x%016llx] [boundary=0x%016llx]\\n\",\n\t\t\t   start, end, boundary);\n#endif\n}"
  },
  {
    "function_name": "check_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1214-1287",
    "snippet": "static void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "bucket",
            "&flags"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "279-286",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\"",
            "entry->sg_call_ents",
            "ref->sg_call_ents"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "entry",
            "\"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\"",
            "(unsigned long long)ref->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "dir2name[ref->direction]"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "entry",
            "\"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\"",
            "(unsigned long long)ref->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "dir2name[ref->direction]"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "entry",
            "\"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\"",
            "(unsigned long long)ref->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "dir2name[ref->direction]"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "entry",
            "\"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\"",
            "entry->dev_addr",
            "entry->size",
            "ref->size"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\"",
            "(unsigned long long)ref->dev_addr",
            "ref->size"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bucket_find_contain",
          "args": [
            "&bucket",
            "ref",
            "&flags"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "bucket_find_contain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "366-391",
          "snippet": "static struct dma_debug_entry *bucket_find_contain(struct hash_bucket **bucket,\n\t\t\t\t\t\t   struct dma_debug_entry *ref,\n\t\t\t\t\t\t   unsigned long *flags)\n{\n\n\tunsigned int max_range = dma_get_max_seg_size(ref->dev);\n\tstruct dma_debug_entry *entry, index = *ref;\n\tunsigned int range = 0;\n\n\twhile (range <= max_range) {\n\t\tentry = __hash_bucket_find(*bucket, ref, containing_match);\n\n\t\tif (entry)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * Nothing found, go back a hash bucket\n\t\t */\n\t\tput_hash_bucket(*bucket, flags);\n\t\trange          += (1 << HASH_FN_SHIFT);\n\t\tindex.dev_addr -= (1 << HASH_FN_SHIFT);\n\t\t*bucket = get_hash_bucket(&index, flags);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define HASH_FN_SHIFT   13"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_FN_SHIFT   13\n\nstatic struct dma_debug_entry *bucket_find_contain(struct hash_bucket **bucket,\n\t\t\t\t\t\t   struct dma_debug_entry *ref,\n\t\t\t\t\t\t   unsigned long *flags)\n{\n\n\tunsigned int max_range = dma_get_max_seg_size(ref->dev);\n\tstruct dma_debug_entry *entry, index = *ref;\n\tunsigned int range = 0;\n\n\twhile (range <= max_range) {\n\t\tentry = __hash_bucket_find(*bucket, ref, containing_match);\n\n\t\tif (entry)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * Nothing found, go back a hash bucket\n\t\t */\n\t\tput_hash_bucket(*bucket, flags);\n\t\trange          += (1 << HASH_FN_SHIFT);\n\t\tindex.dev_addr -= (1 << HASH_FN_SHIFT);\n\t\t*bucket = get_hash_bucket(&index, flags);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "ref",
            "&flags"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "264-274",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_sync(struct device *dev,\n\t\t       struct dma_debug_entry *ref,\n\t\t       bool to_cpu)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\n\tentry = bucket_find_contain(&bucket, ref, &flags);\n\n\tif (!entry) {\n\t\terr_printk(dev, NULL, \"DMA-API: device driver tries \"\n\t\t\t\t\"to sync DMA memory it has not allocated \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, ref->size);\n\t\tgoto out;\n\t}\n\n\tif (ref->size > entry->size) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs\"\n\t\t\t\t\" DMA memory outside allocated range \"\n\t\t\t\t\"[device address=0x%016llx] \"\n\t\t\t\t\"[allocation size=%llu bytes] \"\n\t\t\t\t\"[sync offset+size=%llu]\\n\",\n\t\t\t\tentry->dev_addr, entry->size,\n\t\t\t\tref->size);\n\t}\n\n\tif (entry->direction == DMA_BIDIRECTIONAL)\n\t\tgoto out;\n\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"DMA memory with different direction \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\t}\n\n\tif (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&\n\t\t      !(ref->direction == DMA_TO_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device read-only DMA memory for cpu \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&\n\t\t       !(ref->direction == DMA_FROM_DEVICE))\n\t\terr_printk(dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t\t\"device write-only DMA memory to device \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [synced with %s]\\n\",\n\t\t\t\t(unsigned long long)ref->dev_addr, entry->size,\n\t\t\t\tdir2name[entry->direction],\n\t\t\t\tdir2name[ref->direction]);\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver syncs \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [sync count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\nout:\n\tput_hash_bucket(bucket, &flags);\n}"
  },
  {
    "function_name": "check_for_illegal_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1207-1212",
    "snippet": "static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (overlap(addr, len, _stext, _etext) ||\n\t    overlap(addr, len, __start_rodata, __end_rodata))\n\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\"",
            "addr",
            "len"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "overlap",
          "args": [
            "addr",
            "len",
            "__start_rodata",
            "__end_rodata"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1197-1205",
          "snippet": "static inline bool overlap(void *addr, unsigned long len, void *start, void *end)\n{\n\tunsigned long a1 = (unsigned long)addr;\n\tunsigned long b1 = a1 + len;\n\tunsigned long a2 = (unsigned long)start;\n\tunsigned long b2 = (unsigned long)end;\n\n\treturn !(b1 <= a2 || a1 >= b2);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic inline bool overlap(void *addr, unsigned long len, void *start, void *end)\n{\n\tunsigned long a1 = (unsigned long)addr;\n\tunsigned long b1 = a1 + len;\n\tunsigned long a2 = (unsigned long)start;\n\tunsigned long b2 = (unsigned long)end;\n\n\treturn !(b1 <= a2 || a1 >= b2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)\n{\n\tif (overlap(addr, len, _stext, _etext) ||\n\t    overlap(addr, len, __start_rodata, __end_rodata))\n\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\\n\", addr, len);\n}"
  },
  {
    "function_name": "overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1197-1205",
    "snippet": "static inline bool overlap(void *addr, unsigned long len, void *start, void *end)\n{\n\tunsigned long a1 = (unsigned long)addr;\n\tunsigned long b1 = a1 + len;\n\tunsigned long a2 = (unsigned long)start;\n\tunsigned long b2 = (unsigned long)end;\n\n\treturn !(b1 <= a2 || a1 >= b2);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic inline bool overlap(void *addr, unsigned long len, void *start, void *end)\n{\n\tunsigned long a1 = (unsigned long)addr;\n\tunsigned long b1 = a1 + len;\n\tunsigned long a2 = (unsigned long)start;\n\tunsigned long b2 = (unsigned long)end;\n\n\treturn !(b1 <= a2 || a1 >= b2);\n}"
  },
  {
    "function_name": "check_for_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1169-1195",
    "snippet": "static void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"DMA-API: device driver maps memory from stack [probable addr=%p]\\n\"",
            "addr"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "NULL",
            "\"DMA-API: device driver maps memory from stack [addr=%p]\\n\"",
            "addr"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_is_on_stack",
          "args": [
            "addr"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_stack_vm_area",
          "args": [
            "current"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void check_for_stack(struct device *dev,\n\t\t\t    struct page *page, size_t offset)\n{\n\tvoid *addr;\n\tstruct vm_struct *stack_vm_area = task_stack_vm_area(current);\n\n\tif (!stack_vm_area) {\n\t\t/* Stack is direct-mapped. */\n\t\tif (PageHighMem(page))\n\t\t\treturn;\n\t\taddr = page_address(page) + offset;\n\t\tif (object_is_on_stack(addr))\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [addr=%p]\\n\", addr);\n\t} else {\n\t\t/* Stack is vmalloced. */\n\t\tint i;\n\n\t\tfor (i = 0; i < stack_vm_area->nr_pages; i++) {\n\t\t\tif (page != stack_vm_area->pages[i])\n\t\t\t\tcontinue;\n\n\t\t\taddr = (u8 *)current->stack + i * PAGE_SIZE + offset;\n\t\t\terr_printk(dev, NULL, \"DMA-API: device driver maps memory from stack [probable addr=%p]\\n\", addr);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1073-1167",
    "snippet": "static void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, &flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/DMA-API.txt.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, &flags);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };",
      "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "bucket",
            "&flags"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "279-286",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_entry_free",
          "args": [
            "entry"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "dma_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "694-708",
          "snippet": "static void dma_entry_free(struct dma_debug_entry *entry)\n{\n\tunsigned long flags;\n\n\tactive_cacheline_remove(entry);\n\n\t/*\n\t * add to beginning of the list - this way the entries are\n\t * more likely cache hot when they are reallocated.\n\t */\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tlist_add(&entry->list, &free_entries);\n\tnum_free_entries += 1;\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static DEFINE_SPINLOCK(free_entries_lock);",
            "static u32 num_free_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic u32 num_free_entries;\n\nstatic void dma_entry_free(struct dma_debug_entry *entry)\n{\n\tunsigned long flags;\n\n\tactive_cacheline_remove(entry);\n\n\t/*\n\t * add to beginning of the list - this way the entries are\n\t * more likely cache hot when they are reallocated.\n\t */\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tlist_add(&entry->list, &free_entries);\n\tnum_free_entries += 1;\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_bucket_del",
          "args": [
            "entry"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "hash_bucket_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "405-408",
          "snippet": "static void hash_bucket_del(struct dma_debug_entry *entry)\n{\n\tlist_del(&entry->list);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void hash_bucket_del(struct dma_debug_entry *entry)\n{\n\tlist_del(&entry->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\"",
            "ref->dev_addr",
            "ref->size",
            "type2name[entry->type]"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\"",
            "ref->dev_addr",
            "ref->size",
            "dir2name[entry->direction]",
            "dir2name[ref->direction]"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\"",
            "entry->sg_call_ents",
            "ref->sg_call_ents"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\"",
            "ref->dev_addr",
            "ref->size",
            "phys_addr(entry)",
            "phys_addr(ref)"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_addr",
          "args": [
            "ref"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "phys_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "410-416",
          "snippet": "static unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\"",
            "ref->dev_addr",
            "ref->size",
            "type2name[entry->type]",
            "type2name[ref->type]"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "entry",
            "\"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\"",
            "ref->dev_addr",
            "entry->size",
            "ref->size"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "NULL",
            "\"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\"",
            "ref->dev_addr",
            "ref->size"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "ref->dev",
            "NULL",
            "\"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\""
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_mapping_error",
          "args": [
            "ref->dev",
            "ref->dev_addr"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_mapping_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1371-1406",
          "snippet": "void debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, &flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\n{\n\tstruct dma_debug_entry ref;\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tref.dev = dev;\n\tref.dev_addr = dma_addr;\n\tbucket = get_hash_bucket(&ref, &flags);\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!exact_match(&ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The same physical address can be mapped multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which updates the first entry\n\t\t * from the hash which fits the reference value and is\n\t\t * not currently listed as being checked.\n\t\t */\n\t\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\t\tentry->map_err_type = MAP_ERR_CHECKED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_hash_bucket(bucket, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bucket_find_exact",
          "args": [
            "bucket",
            "ref"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "bucket_find_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "360-364",
          "snippet": "static struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "ref",
            "&flags"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "264-274",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic void check_unmap(struct dma_debug_entry *ref)\n{\n\tstruct dma_debug_entry *entry;\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\n\tbucket = get_hash_bucket(ref, &flags);\n\tentry = bucket_find_exact(bucket, ref);\n\n\tif (!entry) {\n\t\t/* must drop lock before calling dma_mapping_error */\n\t\tput_hash_bucket(bucket, &flags);\n\n\t\tif (dma_mapping_error(ref->dev, ref->dev_addr)) {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free an \"\n\t\t\t\t   \"invalid DMA memory address\\n\");\n\t\t} else {\n\t\t\terr_printk(ref->dev, NULL,\n\t\t\t\t   \"DMA-API: device driver tries to free DMA \"\n\t\t\t\t   \"memory it has not allocated [device \"\n\t\t\t\t   \"address=0x%016llx] [size=%llu bytes]\\n\",\n\t\t\t\t   ref->dev_addr, ref->size);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ref->size != entry->size) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different size \"\n\t\t\t   \"[device address=0x%016llx] [map size=%llu bytes] \"\n\t\t\t   \"[unmap size=%llu bytes]\\n\",\n\t\t\t   ref->dev_addr, entry->size, ref->size);\n\t}\n\n\tif (ref->type != entry->type) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with wrong function \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s] [unmapped as %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type], type2name[ref->type]);\n\t} else if ((entry->type == dma_debug_coherent) &&\n\t\t   (phys_addr(ref) != phys_addr(entry))) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different CPU address \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[cpu alloc address=0x%016llx] \"\n\t\t\t   \"[cpu free address=0x%016llx]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   phys_addr(entry),\n\t\t\t   phys_addr(ref));\n\t}\n\n\tif (ref->sg_call_ents && ref->type == dma_debug_sg &&\n\t    ref->sg_call_ents != entry->sg_call_ents) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA sg list with different entry count \"\n\t\t\t   \"[map count=%d] [unmap count=%d]\\n\",\n\t\t\t   entry->sg_call_ents, ref->sg_call_ents);\n\t}\n\n\t/*\n\t * This may be no bug in reality - but most implementations of the\n\t * DMA API don't handle this properly, so check for it here\n\t */\n\tif (ref->direction != entry->direction) {\n\t\terr_printk(ref->dev, entry, \"DMA-API: device driver frees \"\n\t\t\t   \"DMA memory with different direction \"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped with %s] [unmapped with %s]\\n\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   dir2name[entry->direction],\n\t\t\t   dir2name[ref->direction]);\n\t}\n\n\t/*\n\t * Drivers should use dma_mapping_error() to check the returned\n\t * addresses of dma_map_single() and dma_map_page().\n\t * If not, print this warning message. See Documentation/DMA-API.txt.\n\t */\n\tif (entry->map_err_type == MAP_ERR_NOT_CHECKED) {\n\t\terr_printk(ref->dev, entry,\n\t\t\t   \"DMA-API: device driver failed to check map error\"\n\t\t\t   \"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t   \"[mapped as %s]\",\n\t\t\t   ref->dev_addr, ref->size,\n\t\t\t   type2name[entry->type]);\n\t}\n\n\thash_bucket_del(entry);\n\tdma_entry_free(entry);\n\n\tput_hash_bucket(bucket, &flags);\n}"
  },
  {
    "function_name": "dma_debug_entries_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1061-1068",
    "snippet": "static __init int dma_debug_entries_cmdline(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\tif (!get_option(&str, &nr_prealloc_entries))\n\t\tnr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)"
    ],
    "globals_used": [
      "static u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&nr_prealloc_entries"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)\n\nstatic u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;\n\nstatic __init int dma_debug_entries_cmdline(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\tif (!get_option(&str, &nr_prealloc_entries))\n\t\tnr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_debug_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1048-1059",
    "snippet": "static __init int dma_debug_cmdline(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (strncmp(str, \"off\", 3) == 0) {\n\t\tpr_info(\"DMA-API: debugging disabled on kernel command line\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool global_disable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"DMA-API: debugging disabled on kernel command line\\n\""
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"off\"",
            "3"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic __init int dma_debug_cmdline(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (strncmp(str, \"off\", 3) == 0) {\n\t\tpr_info(\"DMA-API: debugging disabled on kernel command line\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_debug_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "1010-1045",
    "snippet": "static int dma_debug_init(void)\n{\n\tint i;\n\n\t/* Do not use dma_debug_initialized here, since we really want to be\n\t * called to set dma_debug_initialized\n\t */\n\tif (global_disable)\n\t\treturn 0;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tINIT_LIST_HEAD(&dma_entry_hash[i].list);\n\t\tspin_lock_init(&dma_entry_hash[i].lock);\n\t}\n\n\tif (dma_debug_fs_init() != 0) {\n\t\tpr_err(\"DMA-API: error creating debugfs entries - disabling\\n\");\n\t\tglobal_disable = true;\n\n\t\treturn 0;\n\t}\n\n\tif (prealloc_memory(nr_prealloc_entries) != 0) {\n\t\tpr_err(\"DMA-API: debugging out of memory error - disabled\\n\");\n\t\tglobal_disable = true;\n\n\t\treturn 0;\n\t}\n\n\tnr_total_entries = num_free_entries;\n\n\tdma_debug_initialized = true;\n\n\tpr_info(\"DMA-API: debugging enabled by kernel config\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE       1024ULL"
    ],
    "globals_used": [
      "static struct hash_bucket dma_entry_hash[HASH_SIZE];",
      "static bool global_disable",
      "static bool dma_debug_initialized",
      "static u32 num_free_entries;",
      "static u32 nr_total_entries;",
      "static u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"DMA-API: debugging enabled by kernel config\\n\""
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"DMA-API: debugging out of memory error - disabled\\n\""
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prealloc_memory",
          "args": [
            "nr_prealloc_entries"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "764-792",
          "snippet": "static int prealloc_memory(u32 num_entries)\n{\n\tstruct dma_debug_entry *entry, *next_entry;\n\tint i;\n\n\tfor (i = 0; i < num_entries; ++i) {\n\t\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\t\tif (!entry)\n\t\t\tgoto out_err;\n\n\t\tlist_add_tail(&entry->list, &free_entries);\n\t}\n\n\tnum_free_entries = num_entries;\n\tmin_free_entries = num_entries;\n\n\tpr_info(\"DMA-API: preallocated %d debug entries\\n\", num_entries);\n\n\treturn 0;\n\nout_err:\n\n\tlist_for_each_entry_safe(entry, next_entry, &free_entries, list) {\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static u32 num_free_entries;",
            "static u32 min_free_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic u32 num_free_entries;\nstatic u32 min_free_entries;\n\nstatic int prealloc_memory(u32 num_entries)\n{\n\tstruct dma_debug_entry *entry, *next_entry;\n\tint i;\n\n\tfor (i = 0; i < num_entries; ++i) {\n\t\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\t\tif (!entry)\n\t\t\tgoto out_err;\n\n\t\tlist_add_tail(&entry->list, &free_entries);\n\t}\n\n\tnum_free_entries = num_entries;\n\tmin_free_entries = num_entries;\n\n\tpr_info(\"DMA-API: preallocated %d debug entries\\n\", num_entries);\n\n\treturn 0;\n\nout_err:\n\n\tlist_for_each_entry_safe(entry, next_entry, &free_entries, list) {\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"DMA-API: error creating debugfs entries - disabling\\n\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_fs_init",
          "args": [],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_fs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "886-940",
          "snippet": "static int dma_debug_fs_init(void)\n{\n\tdma_debug_dent = debugfs_create_dir(\"dma-api\", NULL);\n\tif (!dma_debug_dent) {\n\t\tpr_err(\"DMA-API: can not create debugfs directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tglobal_disable_dent = debugfs_create_bool(\"disabled\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&global_disable);\n\tif (!global_disable_dent)\n\t\tgoto out_err;\n\n\terror_count_dent = debugfs_create_u32(\"error_count\", 0444,\n\t\t\tdma_debug_dent, &error_count);\n\tif (!error_count_dent)\n\t\tgoto out_err;\n\n\tshow_all_errors_dent = debugfs_create_u32(\"all_errors\", 0644,\n\t\t\tdma_debug_dent,\n\t\t\t&show_all_errors);\n\tif (!show_all_errors_dent)\n\t\tgoto out_err;\n\n\tshow_num_errors_dent = debugfs_create_u32(\"num_errors\", 0644,\n\t\t\tdma_debug_dent,\n\t\t\t&show_num_errors);\n\tif (!show_num_errors_dent)\n\t\tgoto out_err;\n\n\tnum_free_entries_dent = debugfs_create_u32(\"num_free_entries\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&num_free_entries);\n\tif (!num_free_entries_dent)\n\t\tgoto out_err;\n\n\tmin_free_entries_dent = debugfs_create_u32(\"min_free_entries\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&min_free_entries);\n\tif (!min_free_entries_dent)\n\t\tgoto out_err;\n\n\tfilter_dent = debugfs_create_file(\"driver_filter\", 0644,\n\t\t\t\t\t  dma_debug_dent, NULL, &filter_fops);\n\tif (!filter_dent)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tdebugfs_remove_recursive(dma_debug_dent);\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static u32 error_count;",
            "static u32 show_all_errors",
            "static u32 show_num_errors = 1;",
            "static u32 num_free_entries;",
            "static u32 min_free_entries;",
            "static struct dentry *dma_debug_dent",
            "static struct dentry *global_disable_dent",
            "static struct dentry *error_count_dent",
            "static struct dentry *show_all_errors_dent",
            "static struct dentry *show_num_errors_dent",
            "static struct dentry *num_free_entries_dent",
            "static struct dentry *min_free_entries_dent",
            "static struct dentry *filter_dent",
            "static const struct file_operations filter_fops = {\n\t.read  = filter_read,\n\t.write = filter_write,\n\t.llseek = default_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic u32 error_count;\nstatic u32 show_all_errors;\nstatic u32 show_num_errors = 1;\nstatic u32 num_free_entries;\nstatic u32 min_free_entries;\nstatic struct dentry *dma_debug_dent;\nstatic struct dentry *global_disable_dent;\nstatic struct dentry *error_count_dent;\nstatic struct dentry *show_all_errors_dent;\nstatic struct dentry *show_num_errors_dent;\nstatic struct dentry *num_free_entries_dent;\nstatic struct dentry *min_free_entries_dent;\nstatic struct dentry *filter_dent;\nstatic const struct file_operations filter_fops = {\n\t.read  = filter_read,\n\t.write = filter_write,\n\t.llseek = default_llseek,\n};\n\nstatic int dma_debug_fs_init(void)\n{\n\tdma_debug_dent = debugfs_create_dir(\"dma-api\", NULL);\n\tif (!dma_debug_dent) {\n\t\tpr_err(\"DMA-API: can not create debugfs directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tglobal_disable_dent = debugfs_create_bool(\"disabled\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&global_disable);\n\tif (!global_disable_dent)\n\t\tgoto out_err;\n\n\terror_count_dent = debugfs_create_u32(\"error_count\", 0444,\n\t\t\tdma_debug_dent, &error_count);\n\tif (!error_count_dent)\n\t\tgoto out_err;\n\n\tshow_all_errors_dent = debugfs_create_u32(\"all_errors\", 0644,\n\t\t\tdma_debug_dent,\n\t\t\t&show_all_errors);\n\tif (!show_all_errors_dent)\n\t\tgoto out_err;\n\n\tshow_num_errors_dent = debugfs_create_u32(\"num_errors\", 0644,\n\t\t\tdma_debug_dent,\n\t\t\t&show_num_errors);\n\tif (!show_num_errors_dent)\n\t\tgoto out_err;\n\n\tnum_free_entries_dent = debugfs_create_u32(\"num_free_entries\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&num_free_entries);\n\tif (!num_free_entries_dent)\n\t\tgoto out_err;\n\n\tmin_free_entries_dent = debugfs_create_u32(\"min_free_entries\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&min_free_entries);\n\tif (!min_free_entries_dent)\n\t\tgoto out_err;\n\n\tfilter_dent = debugfs_create_file(\"driver_filter\", 0644,\n\t\t\t\t\t  dma_debug_dent, NULL, &filter_fops);\n\tif (!filter_dent)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tdebugfs_remove_recursive(dma_debug_dent);\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dma_entry_hash[i].lock"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dma_entry_hash[i].list"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_SIZE       1024ULL\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\nstatic u32 num_free_entries;\nstatic u32 nr_total_entries;\nstatic u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;\n\nstatic int dma_debug_init(void)\n{\n\tint i;\n\n\t/* Do not use dma_debug_initialized here, since we really want to be\n\t * called to set dma_debug_initialized\n\t */\n\tif (global_disable)\n\t\treturn 0;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tINIT_LIST_HEAD(&dma_entry_hash[i].list);\n\t\tspin_lock_init(&dma_entry_hash[i].lock);\n\t}\n\n\tif (dma_debug_fs_init() != 0) {\n\t\tpr_err(\"DMA-API: error creating debugfs entries - disabling\\n\");\n\t\tglobal_disable = true;\n\n\t\treturn 0;\n\t}\n\n\tif (prealloc_memory(nr_prealloc_entries) != 0) {\n\t\tpr_err(\"DMA-API: debugging out of memory error - disabled\\n\");\n\t\tglobal_disable = true;\n\n\t\treturn 0;\n\t}\n\n\tnr_total_entries = num_free_entries;\n\n\tdma_debug_initialized = true;\n\n\tpr_info(\"DMA-API: debugging enabled by kernel config\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "dma_debug_add_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "992-1008",
    "snippet": "void dma_debug_add_bus(struct bus_type *bus)\n{\n\tstruct notifier_block *nb;\n\n\tif (dma_debug_disabled())\n\t\treturn;\n\n\tnb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);\n\tif (nb == NULL) {\n\t\tpr_err(\"dma_debug_add_bus: out of memory\\n\");\n\t\treturn;\n\t}\n\n\tnb->notifier_call = dma_debug_device_change;\n\n\tbus_register_notifier(bus, nb);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_register_notifier",
          "args": [
            "bus",
            "nb"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"dma_debug_add_bus: out of memory\\n\""
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct notifier_block)",
            "GFP_KERNEL"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid dma_debug_add_bus(struct bus_type *bus)\n{\n\tstruct notifier_block *nb;\n\n\tif (dma_debug_disabled())\n\t\treturn;\n\n\tnb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);\n\tif (nb == NULL) {\n\t\tpr_err(\"dma_debug_add_bus: out of memory\\n\");\n\t\treturn;\n\t}\n\n\tnb->notifier_call = dma_debug_device_change;\n\n\tbus_register_notifier(bus, nb);\n}"
  },
  {
    "function_name": "dma_debug_device_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "962-990",
    "snippet": "static int dma_debug_device_change(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct dma_debug_entry *uninitialized_var(entry);\n\tint count;\n\n\tif (dma_debug_disabled())\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_UNBOUND_DRIVER:\n\t\tcount = device_dma_allocations(dev, &entry);\n\t\tif (count == 0)\n\t\t\tbreak;\n\t\terr_printk(dev, entry, \"DMA-API: device driver has pending \"\n\t\t\t\t\"DMA allocations while released from device \"\n\t\t\t\t\"[count=%d]\\n\"\n\t\t\t\t\"One of leaked entries details: \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [mapped as %s]\\n\",\n\t\t\tcount, entry->dev_addr, entry->size,\n\t\t\tdir2name[entry->direction], type2name[entry->type]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };",
      "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "dev",
            "entry",
            "\"DMA-API: device driver has pending \"\n\t\t\t\t\"DMA allocations while released from device \"\n\t\t\t\t\"[count=%d]\\n\"\n\t\t\t\t\"One of leaked entries details: \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [mapped as %s]\\n\"",
            "count",
            "entry->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "type2name[entry->type]"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_dma_allocations",
          "args": [
            "dev",
            "&entry"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "device_dma_allocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "942-960",
          "snippet": "static int device_dma_allocations(struct device *dev, struct dma_debug_entry **out_entry)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\tint count = 0, i;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tspin_lock_irqsave(&dma_entry_hash[i].lock, flags);\n\t\tlist_for_each_entry(entry, &dma_entry_hash[i].list, list) {\n\t\t\tif (entry->dev == dev) {\n\t\t\t\tcount += 1;\n\t\t\t\t*out_entry = entry;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&dma_entry_hash[i].lock, flags);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define HASH_SIZE       1024ULL"
          ],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_SIZE       1024ULL\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic int device_dma_allocations(struct device *dev, struct dma_debug_entry **out_entry)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\tint count = 0, i;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tspin_lock_irqsave(&dma_entry_hash[i].lock, flags);\n\t\tlist_for_each_entry(entry, &dma_entry_hash[i].list, list) {\n\t\t\tif (entry->dev == dev) {\n\t\t\t\tcount += 1;\n\t\t\t\t*out_entry = entry;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&dma_entry_hash[i].lock, flags);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nstatic int dma_debug_device_change(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct dma_debug_entry *uninitialized_var(entry);\n\tint count;\n\n\tif (dma_debug_disabled())\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_UNBOUND_DRIVER:\n\t\tcount = device_dma_allocations(dev, &entry);\n\t\tif (count == 0)\n\t\t\tbreak;\n\t\terr_printk(dev, entry, \"DMA-API: device driver has pending \"\n\t\t\t\t\"DMA allocations while released from device \"\n\t\t\t\t\"[count=%d]\\n\"\n\t\t\t\t\"One of leaked entries details: \"\n\t\t\t\t\"[device address=0x%016llx] [size=%llu bytes] \"\n\t\t\t\t\"[mapped with %s] [mapped as %s]\\n\",\n\t\t\tcount, entry->dev_addr, entry->size,\n\t\t\tdir2name[entry->direction], type2name[entry->type]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "device_dma_allocations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "942-960",
    "snippet": "static int device_dma_allocations(struct device *dev, struct dma_debug_entry **out_entry)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\tint count = 0, i;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tspin_lock_irqsave(&dma_entry_hash[i].lock, flags);\n\t\tlist_for_each_entry(entry, &dma_entry_hash[i].list, list) {\n\t\t\tif (entry->dev == dev) {\n\t\t\t\tcount += 1;\n\t\t\t\t*out_entry = entry;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&dma_entry_hash[i].lock, flags);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE       1024ULL"
    ],
    "globals_used": [
      "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&dma_entry_hash[i].lock",
            "flags"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&dma_entry_hash[i].list",
            "list"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&dma_entry_hash[i].lock",
            "flags"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_SIZE       1024ULL\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic int device_dma_allocations(struct device *dev, struct dma_debug_entry **out_entry)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\tint count = 0, i;\n\n\tfor (i = 0; i < HASH_SIZE; ++i) {\n\t\tspin_lock_irqsave(&dma_entry_hash[i].lock, flags);\n\t\tlist_for_each_entry(entry, &dma_entry_hash[i].list, list) {\n\t\t\tif (entry->dev == dev) {\n\t\t\t\tcount += 1;\n\t\t\t\t*out_entry = entry;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&dma_entry_hash[i].lock, flags);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "dma_debug_fs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "886-940",
    "snippet": "static int dma_debug_fs_init(void)\n{\n\tdma_debug_dent = debugfs_create_dir(\"dma-api\", NULL);\n\tif (!dma_debug_dent) {\n\t\tpr_err(\"DMA-API: can not create debugfs directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tglobal_disable_dent = debugfs_create_bool(\"disabled\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&global_disable);\n\tif (!global_disable_dent)\n\t\tgoto out_err;\n\n\terror_count_dent = debugfs_create_u32(\"error_count\", 0444,\n\t\t\tdma_debug_dent, &error_count);\n\tif (!error_count_dent)\n\t\tgoto out_err;\n\n\tshow_all_errors_dent = debugfs_create_u32(\"all_errors\", 0644,\n\t\t\tdma_debug_dent,\n\t\t\t&show_all_errors);\n\tif (!show_all_errors_dent)\n\t\tgoto out_err;\n\n\tshow_num_errors_dent = debugfs_create_u32(\"num_errors\", 0644,\n\t\t\tdma_debug_dent,\n\t\t\t&show_num_errors);\n\tif (!show_num_errors_dent)\n\t\tgoto out_err;\n\n\tnum_free_entries_dent = debugfs_create_u32(\"num_free_entries\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&num_free_entries);\n\tif (!num_free_entries_dent)\n\t\tgoto out_err;\n\n\tmin_free_entries_dent = debugfs_create_u32(\"min_free_entries\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&min_free_entries);\n\tif (!min_free_entries_dent)\n\t\tgoto out_err;\n\n\tfilter_dent = debugfs_create_file(\"driver_filter\", 0644,\n\t\t\t\t\t  dma_debug_dent, NULL, &filter_fops);\n\tif (!filter_dent)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tdebugfs_remove_recursive(dma_debug_dent);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool global_disable",
      "static u32 error_count;",
      "static u32 show_all_errors",
      "static u32 show_num_errors = 1;",
      "static u32 num_free_entries;",
      "static u32 min_free_entries;",
      "static struct dentry *dma_debug_dent",
      "static struct dentry *global_disable_dent",
      "static struct dentry *error_count_dent",
      "static struct dentry *show_all_errors_dent",
      "static struct dentry *show_num_errors_dent",
      "static struct dentry *num_free_entries_dent",
      "static struct dentry *min_free_entries_dent",
      "static struct dentry *filter_dent",
      "static const struct file_operations filter_fops = {\n\t.read  = filter_read,\n\t.write = filter_write,\n\t.llseek = default_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "dma_debug_dent"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"driver_filter\"",
            "0644",
            "dma_debug_dent",
            "NULL",
            "&filter_fops"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"min_free_entries\"",
            "0444",
            "dma_debug_dent",
            "&min_free_entries"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"num_free_entries\"",
            "0444",
            "dma_debug_dent",
            "&num_free_entries"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"num_errors\"",
            "0644",
            "dma_debug_dent",
            "&show_num_errors"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"all_errors\"",
            "0644",
            "dma_debug_dent",
            "&show_all_errors"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"error_count\"",
            "0444",
            "dma_debug_dent",
            "&error_count"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_bool",
          "args": [
            "\"disabled\"",
            "0444",
            "dma_debug_dent",
            "&global_disable"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"DMA-API: can not create debugfs directory\\n\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"dma-api\"",
            "NULL"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic u32 error_count;\nstatic u32 show_all_errors;\nstatic u32 show_num_errors = 1;\nstatic u32 num_free_entries;\nstatic u32 min_free_entries;\nstatic struct dentry *dma_debug_dent;\nstatic struct dentry *global_disable_dent;\nstatic struct dentry *error_count_dent;\nstatic struct dentry *show_all_errors_dent;\nstatic struct dentry *show_num_errors_dent;\nstatic struct dentry *num_free_entries_dent;\nstatic struct dentry *min_free_entries_dent;\nstatic struct dentry *filter_dent;\nstatic const struct file_operations filter_fops = {\n\t.read  = filter_read,\n\t.write = filter_write,\n\t.llseek = default_llseek,\n};\n\nstatic int dma_debug_fs_init(void)\n{\n\tdma_debug_dent = debugfs_create_dir(\"dma-api\", NULL);\n\tif (!dma_debug_dent) {\n\t\tpr_err(\"DMA-API: can not create debugfs directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tglobal_disable_dent = debugfs_create_bool(\"disabled\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&global_disable);\n\tif (!global_disable_dent)\n\t\tgoto out_err;\n\n\terror_count_dent = debugfs_create_u32(\"error_count\", 0444,\n\t\t\tdma_debug_dent, &error_count);\n\tif (!error_count_dent)\n\t\tgoto out_err;\n\n\tshow_all_errors_dent = debugfs_create_u32(\"all_errors\", 0644,\n\t\t\tdma_debug_dent,\n\t\t\t&show_all_errors);\n\tif (!show_all_errors_dent)\n\t\tgoto out_err;\n\n\tshow_num_errors_dent = debugfs_create_u32(\"num_errors\", 0644,\n\t\t\tdma_debug_dent,\n\t\t\t&show_num_errors);\n\tif (!show_num_errors_dent)\n\t\tgoto out_err;\n\n\tnum_free_entries_dent = debugfs_create_u32(\"num_free_entries\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&num_free_entries);\n\tif (!num_free_entries_dent)\n\t\tgoto out_err;\n\n\tmin_free_entries_dent = debugfs_create_u32(\"min_free_entries\", 0444,\n\t\t\tdma_debug_dent,\n\t\t\t&min_free_entries);\n\tif (!min_free_entries_dent)\n\t\tgoto out_err;\n\n\tfilter_dent = debugfs_create_file(\"driver_filter\", 0644,\n\t\t\t\t\t  dma_debug_dent, NULL, &filter_fops);\n\tif (!filter_dent)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tdebugfs_remove_recursive(dma_debug_dent);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "filter_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "816-878",
    "snippet": "static ssize_t filter_write(struct file *file, const char __user *userbuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar buf[NAME_MAX_LEN];\n\tunsigned long flags;\n\tsize_t len;\n\tint i;\n\n\t/*\n\t * We can't copy from userspace directly. Access to\n\t * current_driver_name is protected with a write_lock with irqs\n\t * disabled. Since copy_from_user can fault and may sleep we\n\t * need to copy to temporary buffer first\n\t */\n\tlen = min(count, (size_t)(NAME_MAX_LEN - 1));\n\tif (copy_from_user(buf, userbuf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = 0;\n\n\twrite_lock_irqsave(&driver_name_lock, flags);\n\n\t/*\n\t * Now handle the string we got from userspace very carefully.\n\t * The rules are:\n\t *         - only use the first token we got\n\t *         - token delimiter is everything looking like a space\n\t *           character (' ', '\\n', '\\t' ...)\n\t *\n\t */\n\tif (!isalnum(buf[0])) {\n\t\t/*\n\t\t * If the first character userspace gave us is not\n\t\t * alphanumerical then assume the filter should be\n\t\t * switched off.\n\t\t */\n\t\tif (current_driver_name[0])\n\t\t\tpr_info(\"DMA-API: switching off dma-debug driver filter\\n\");\n\t\tcurrent_driver_name[0] = 0;\n\t\tcurrent_driver = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Now parse out the first token and use it as the name for the\n\t * driver to filter for.\n\t */\n\tfor (i = 0; i < NAME_MAX_LEN - 1; ++i) {\n\t\tcurrent_driver_name[i] = buf[i];\n\t\tif (isspace(buf[i]) || buf[i] == ' ' || buf[i] == 0)\n\t\t\tbreak;\n\t}\n\tcurrent_driver_name[i] = 0;\n\tcurrent_driver = NULL;\n\n\tpr_info(\"DMA-API: enable driver filter for driver [%s]\\n\",\n\t\tcurrent_driver_name);\n\nout_unlock:\n\twrite_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define NAME_MAX_LEN\t64"
    ],
    "globals_used": [
      "static char                  current_driver_name[NAME_MAX_LEN]",
      "static struct device_driver *current_driver",
      "static DEFINE_RWLOCK(driver_name_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "326-329",
          "snippet": "void __lockfunc _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_write_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_write_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"DMA-API: enable driver filter for driver [%s]\\n\"",
            "current_driver_name"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "buf[i]"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"DMA-API: switching off dma-debug driver filter\\n\""
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "buf[0]"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "userbuf",
            "len"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "(size_t)(NAME_MAX_LEN - 1)"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define NAME_MAX_LEN\t64\n\nstatic char                  current_driver_name[NAME_MAX_LEN];\nstatic struct device_driver *current_driver;\nstatic DEFINE_RWLOCK(driver_name_lock);\n\nstatic ssize_t filter_write(struct file *file, const char __user *userbuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar buf[NAME_MAX_LEN];\n\tunsigned long flags;\n\tsize_t len;\n\tint i;\n\n\t/*\n\t * We can't copy from userspace directly. Access to\n\t * current_driver_name is protected with a write_lock with irqs\n\t * disabled. Since copy_from_user can fault and may sleep we\n\t * need to copy to temporary buffer first\n\t */\n\tlen = min(count, (size_t)(NAME_MAX_LEN - 1));\n\tif (copy_from_user(buf, userbuf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = 0;\n\n\twrite_lock_irqsave(&driver_name_lock, flags);\n\n\t/*\n\t * Now handle the string we got from userspace very carefully.\n\t * The rules are:\n\t *         - only use the first token we got\n\t *         - token delimiter is everything looking like a space\n\t *           character (' ', '\\n', '\\t' ...)\n\t *\n\t */\n\tif (!isalnum(buf[0])) {\n\t\t/*\n\t\t * If the first character userspace gave us is not\n\t\t * alphanumerical then assume the filter should be\n\t\t * switched off.\n\t\t */\n\t\tif (current_driver_name[0])\n\t\t\tpr_info(\"DMA-API: switching off dma-debug driver filter\\n\");\n\t\tcurrent_driver_name[0] = 0;\n\t\tcurrent_driver = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Now parse out the first token and use it as the name for the\n\t * driver to filter for.\n\t */\n\tfor (i = 0; i < NAME_MAX_LEN - 1; ++i) {\n\t\tcurrent_driver_name[i] = buf[i];\n\t\tif (isspace(buf[i]) || buf[i] == ' ' || buf[i] == 0)\n\t\t\tbreak;\n\t}\n\tcurrent_driver_name[i] = 0;\n\tcurrent_driver = NULL;\n\n\tpr_info(\"DMA-API: enable driver filter for driver [%s]\\n\",\n\t\tcurrent_driver_name);\n\nout_unlock:\n\twrite_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn count;\n}"
  },
  {
    "function_name": "filter_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "794-814",
    "snippet": "static ssize_t filter_read(struct file *file, char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tchar buf[NAME_MAX_LEN + 1];\n\tunsigned long flags;\n\tint len;\n\n\tif (!current_driver_name[0])\n\t\treturn 0;\n\n\t/*\n\t * We can't copy to userspace directly because current_driver_name can\n\t * only be read under the driver_name_lock with irqs disabled. So\n\t * create a temporary copy first.\n\t */\n\tread_lock_irqsave(&driver_name_lock, flags);\n\tlen = scnprintf(buf, NAME_MAX_LEN + 1, \"%s\\n\", current_driver_name);\n\tread_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define NAME_MAX_LEN\t64"
    ],
    "globals_used": [
      "static char                  current_driver_name[NAME_MAX_LEN]",
      "static DEFINE_RWLOCK(driver_name_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "user_buf",
            "count",
            "ppos",
            "buf",
            "len"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_read_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "254-257",
          "snippet": "void __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "NAME_MAX_LEN + 1",
            "\"%s\\n\"",
            "current_driver_name"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define NAME_MAX_LEN\t64\n\nstatic char                  current_driver_name[NAME_MAX_LEN];\nstatic DEFINE_RWLOCK(driver_name_lock);\n\nstatic ssize_t filter_read(struct file *file, char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tchar buf[NAME_MAX_LEN + 1];\n\tunsigned long flags;\n\tint len;\n\n\tif (!current_driver_name[0])\n\t\treturn 0;\n\n\t/*\n\t * We can't copy to userspace directly because current_driver_name can\n\t * only be read under the driver_name_lock with irqs disabled. So\n\t * create a temporary copy first.\n\t */\n\tread_lock_irqsave(&driver_name_lock, flags);\n\tlen = scnprintf(buf, NAME_MAX_LEN + 1, \"%s\\n\", current_driver_name);\n\tread_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}"
  },
  {
    "function_name": "prealloc_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "764-792",
    "snippet": "static int prealloc_memory(u32 num_entries)\n{\n\tstruct dma_debug_entry *entry, *next_entry;\n\tint i;\n\n\tfor (i = 0; i < num_entries; ++i) {\n\t\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\t\tif (!entry)\n\t\t\tgoto out_err;\n\n\t\tlist_add_tail(&entry->list, &free_entries);\n\t}\n\n\tnum_free_entries = num_entries;\n\tmin_free_entries = num_entries;\n\n\tpr_info(\"DMA-API: preallocated %d debug entries\\n\", num_entries);\n\n\treturn 0;\n\nout_err:\n\n\tlist_for_each_entry_safe(entry, next_entry, &free_entries, list) {\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(free_entries);",
      "static u32 num_free_entries;",
      "static u32 min_free_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "next_entry",
            "&free_entries",
            "list"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"DMA-API: preallocated %d debug entries\\n\"",
            "num_entries"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->list",
            "&free_entries"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_KERNEL"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic u32 num_free_entries;\nstatic u32 min_free_entries;\n\nstatic int prealloc_memory(u32 num_entries)\n{\n\tstruct dma_debug_entry *entry, *next_entry;\n\tint i;\n\n\tfor (i = 0; i < num_entries; ++i) {\n\t\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\t\tif (!entry)\n\t\t\tgoto out_err;\n\n\t\tlist_add_tail(&entry->list, &free_entries);\n\t}\n\n\tnum_free_entries = num_entries;\n\tmin_free_entries = num_entries;\n\n\tpr_info(\"DMA-API: preallocated %d debug entries\\n\", num_entries);\n\n\treturn 0;\n\nout_err:\n\n\tlist_for_each_entry_safe(entry, next_entry, &free_entries, list) {\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "dma_debug_resize_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "710-754",
    "snippet": "int dma_debug_resize_entries(u32 num_entries)\n{\n\tint i, delta, ret = 0;\n\tunsigned long flags;\n\tstruct dma_debug_entry *entry;\n\tLIST_HEAD(tmp);\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (nr_total_entries < num_entries) {\n\t\tdelta = num_entries - nr_total_entries;\n\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n\t\tfor (i = 0; i < delta; i++) {\n\t\t\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\t\t\tif (!entry)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&entry->list, &tmp);\n\t\t}\n\n\t\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\t\tlist_splice(&tmp, &free_entries);\n\t\tnr_total_entries += i;\n\t\tnum_free_entries += i;\n\t} else {\n\t\tdelta = nr_total_entries - num_entries;\n\n\t\tfor (i = 0; i < delta && !list_empty(&free_entries); i++) {\n\t\t\tentry = __dma_entry_alloc();\n\t\t\tkfree(entry);\n\t\t}\n\n\t\tnr_total_entries -= i;\n\t}\n\n\tif (nr_total_entries != num_entries)\n\t\tret = 1;\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(free_entries);",
      "static DEFINE_SPINLOCK(free_entries_lock);",
      "static u32 num_free_entries;",
      "static u32 nr_total_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&free_entries_lock",
            "flags"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dma_entry_alloc",
          "args": [],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "646-659",
          "snippet": "static struct dma_debug_entry *__dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\n\tentry = list_entry(free_entries.next, struct dma_debug_entry, list);\n\tlist_del(&entry->list);\n\tmemset(entry, 0, sizeof(*entry));\n\n\tnum_free_entries -= 1;\n\tif (num_free_entries < min_free_entries)\n\t\tmin_free_entries = num_free_entries;\n\n\treturn entry;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static u32 num_free_entries;",
            "static u32 min_free_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic u32 num_free_entries;\nstatic u32 min_free_entries;\n\nstatic struct dma_debug_entry *__dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\n\tentry = list_entry(free_entries.next, struct dma_debug_entry, list);\n\tlist_del(&entry->list);\n\tmemset(entry, 0, sizeof(*entry));\n\n\tnum_free_entries -= 1;\n\tif (num_free_entries < min_free_entries)\n\t\tmin_free_entries = num_free_entries;\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&free_entries"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&tmp",
            "&free_entries"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&free_entries_lock",
            "flags"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->list",
            "&tmp"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_KERNEL"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic u32 num_free_entries;\nstatic u32 nr_total_entries;\n\nint dma_debug_resize_entries(u32 num_entries)\n{\n\tint i, delta, ret = 0;\n\tunsigned long flags;\n\tstruct dma_debug_entry *entry;\n\tLIST_HEAD(tmp);\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (nr_total_entries < num_entries) {\n\t\tdelta = num_entries - nr_total_entries;\n\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n\t\tfor (i = 0; i < delta; i++) {\n\t\t\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\t\t\tif (!entry)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&entry->list, &tmp);\n\t\t}\n\n\t\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\t\tlist_splice(&tmp, &free_entries);\n\t\tnr_total_entries += i;\n\t\tnum_free_entries += i;\n\t} else {\n\t\tdelta = nr_total_entries - num_entries;\n\n\t\tfor (i = 0; i < delta && !list_empty(&free_entries); i++) {\n\t\t\tentry = __dma_entry_alloc();\n\t\t\tkfree(entry);\n\t\t}\n\n\t\tnr_total_entries -= i;\n\t}\n\n\tif (nr_total_entries != num_entries)\n\t\tret = 1;\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dma_entry_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "694-708",
    "snippet": "static void dma_entry_free(struct dma_debug_entry *entry)\n{\n\tunsigned long flags;\n\n\tactive_cacheline_remove(entry);\n\n\t/*\n\t * add to beginning of the list - this way the entries are\n\t * more likely cache hot when they are reallocated.\n\t */\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tlist_add(&entry->list, &free_entries);\n\tnum_free_entries += 1;\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(free_entries);",
      "static DEFINE_SPINLOCK(free_entries_lock);",
      "static u32 num_free_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&free_entries_lock",
            "flags"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&entry->list",
            "&free_entries"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&free_entries_lock",
            "flags"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "active_cacheline_remove",
          "args": [
            "entry"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "555-572",
          "snippet": "static void active_cacheline_remove(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\n\t/* ...mirror the insert case */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\t/* since we are counting overlaps the final put of the\n\t * cacheline will occur when the overlap count is 0.\n\t * active_cacheline_dec_overlap() returns -1 in that case\n\t */\n\tif (active_cacheline_dec_overlap(cln) < 0)\n\t\tradix_tree_delete(&dma_active_cacheline, cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(radix_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic DEFINE_SPINLOCK(radix_lock);\n\nstatic void active_cacheline_remove(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\n\t/* ...mirror the insert case */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\t/* since we are counting overlaps the final put of the\n\t * cacheline will occur when the overlap count is 0.\n\t * active_cacheline_dec_overlap() returns -1 in that case\n\t */\n\tif (active_cacheline_dec_overlap(cln) < 0)\n\t\tradix_tree_delete(&dma_active_cacheline, cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic u32 num_free_entries;\n\nstatic void dma_entry_free(struct dma_debug_entry *entry)\n{\n\tunsigned long flags;\n\n\tactive_cacheline_remove(entry);\n\n\t/*\n\t * add to beginning of the list - this way the entries are\n\t * more likely cache hot when they are reallocated.\n\t */\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\tlist_add(&entry->list, &free_entries);\n\tnum_free_entries += 1;\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n}"
  },
  {
    "function_name": "dma_entry_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "666-692",
    "snippet": "static struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (list_empty(&free_entries)) {\n\t\tglobal_disable = true;\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\tpr_err(\"DMA-API: debugging out of memory - disabling\\n\");\n\t\treturn NULL;\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;\n\tentry->stacktrace.entries = entry->st_entries;\n\tentry->stacktrace.skip = 2;\n\tsave_stack_trace(&entry->stacktrace);\n#endif\n\n\treturn entry;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define DMA_DEBUG_STACKTRACE_ENTRIES 5"
    ],
    "globals_used": [
      "static LIST_HEAD(free_entries);",
      "static DEFINE_SPINLOCK(free_entries_lock);",
      "static bool global_disable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_stack_trace",
          "args": [
            "&entry->stacktrace"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&free_entries_lock",
            "flags"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dma_entry_alloc",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "646-659",
          "snippet": "static struct dma_debug_entry *__dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\n\tentry = list_entry(free_entries.next, struct dma_debug_entry, list);\n\tlist_del(&entry->list);\n\tmemset(entry, 0, sizeof(*entry));\n\n\tnum_free_entries -= 1;\n\tif (num_free_entries < min_free_entries)\n\t\tmin_free_entries = num_free_entries;\n\n\treturn entry;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(free_entries);",
            "static u32 num_free_entries;",
            "static u32 min_free_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic u32 num_free_entries;\nstatic u32 min_free_entries;\n\nstatic struct dma_debug_entry *__dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\n\tentry = list_entry(free_entries.next, struct dma_debug_entry, list);\n\tlist_del(&entry->list);\n\tmemset(entry, 0, sizeof(*entry));\n\n\tnum_free_entries -= 1;\n\tif (num_free_entries < min_free_entries)\n\t\tmin_free_entries = num_free_entries;\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"DMA-API: debugging out of memory - disabling\\n\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&free_entries"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&free_entries_lock",
            "flags"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define DMA_DEBUG_STACKTRACE_ENTRIES 5\n\nstatic LIST_HEAD(free_entries);\nstatic DEFINE_SPINLOCK(free_entries_lock);\nstatic bool global_disable;\n\nstatic struct dma_debug_entry *dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&free_entries_lock, flags);\n\n\tif (list_empty(&free_entries)) {\n\t\tglobal_disable = true;\n\t\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\t\tpr_err(\"DMA-API: debugging out of memory - disabling\\n\");\n\t\treturn NULL;\n\t}\n\n\tentry = __dma_entry_alloc();\n\n\tspin_unlock_irqrestore(&free_entries_lock, flags);\n\n#ifdef CONFIG_STACKTRACE\n\tentry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;\n\tentry->stacktrace.entries = entry->st_entries;\n\tentry->stacktrace.skip = 2;\n\tsave_stack_trace(&entry->stacktrace);\n#endif\n\n\treturn entry;\n}"
  },
  {
    "function_name": "__dma_entry_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "646-659",
    "snippet": "static struct dma_debug_entry *__dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\n\tentry = list_entry(free_entries.next, struct dma_debug_entry, list);\n\tlist_del(&entry->list);\n\tmemset(entry, 0, sizeof(*entry));\n\n\tnum_free_entries -= 1;\n\tif (num_free_entries < min_free_entries)\n\t\tmin_free_entries = num_free_entries;\n\n\treturn entry;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(free_entries);",
      "static u32 num_free_entries;",
      "static u32 min_free_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "entry",
            "0",
            "sizeof(*entry)"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "free_entries.next",
            "structdma_debug_entry",
            "list"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic LIST_HEAD(free_entries);\nstatic u32 num_free_entries;\nstatic u32 min_free_entries;\n\nstatic struct dma_debug_entry *__dma_entry_alloc(void)\n{\n\tstruct dma_debug_entry *entry;\n\n\tentry = list_entry(free_entries.next, struct dma_debug_entry, list);\n\tlist_del(&entry->list);\n\tmemset(entry, 0, sizeof(*entry));\n\n\tnum_free_entries -= 1;\n\tif (num_free_entries < min_free_entries)\n\t\tmin_free_entries = num_free_entries;\n\n\treturn entry;\n}"
  },
  {
    "function_name": "add_dma_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "625-644",
    "snippet": "static void add_dma_entry(struct dma_debug_entry *entry)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, &flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\t/* TODO: report -EEXIST errors here as overlapping mappings are\n\t * not supported by the DMA API\n\t */\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool global_disable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "active_cacheline_insert",
          "args": [
            "entry"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "533-553",
          "snippet": "static int active_cacheline_insert(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\tint rc;\n\n\t/* If the device is not writing memory then we don't have any\n\t * concerns about the cpu consuming stale data.  This mitigates\n\t * legitimate usages of overlapping mappings.\n\t */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\trc = radix_tree_insert(&dma_active_cacheline, cln, entry);\n\tif (rc == -EEXIST)\n\t\tactive_cacheline_inc_overlap(cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(radix_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic DEFINE_SPINLOCK(radix_lock);\n\nstatic int active_cacheline_insert(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\tint rc;\n\n\t/* If the device is not writing memory then we don't have any\n\t * concerns about the cpu consuming stale data.  This mitigates\n\t * legitimate usages of overlapping mappings.\n\t */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\trc = radix_tree_insert(&dma_active_cacheline, cln, entry);\n\tif (rc == -EEXIST)\n\t\tactive_cacheline_inc_overlap(cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "bucket",
            "&flags"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "279-286",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_bucket_add",
          "args": [
            "bucket",
            "entry"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "hash_bucket_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "396-400",
          "snippet": "static void hash_bucket_add(struct hash_bucket *bucket,\n\t\t\t    struct dma_debug_entry *entry)\n{\n\tlist_add_tail(&entry->list, &bucket->list);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void hash_bucket_add(struct hash_bucket *bucket,\n\t\t\t    struct dma_debug_entry *entry)\n{\n\tlist_add_tail(&entry->list, &bucket->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "entry",
            "&flags"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "264-274",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\n\nstatic void add_dma_entry(struct dma_debug_entry *entry)\n{\n\tstruct hash_bucket *bucket;\n\tunsigned long flags;\n\tint rc;\n\n\tbucket = get_hash_bucket(entry, &flags);\n\thash_bucket_add(bucket, entry);\n\tput_hash_bucket(bucket, &flags);\n\n\trc = active_cacheline_insert(entry);\n\tif (rc == -ENOMEM) {\n\t\tpr_err(\"DMA-API: cacheline tracking ENOMEM, dma-debug disabled\\n\");\n\t\tglobal_disable = true;\n\t}\n\n\t/* TODO: report -EEXIST errors here as overlapping mappings are\n\t * not supported by the DMA API\n\t */\n}"
  },
  {
    "function_name": "debug_dma_assert_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "582-619",
    "snippet": "void debug_dma_assert_idle(struct page *page)\n{\n\tstatic struct dma_debug_entry *ents[CACHELINES_PER_PAGE];\n\tstruct dma_debug_entry *entry = NULL;\n\tvoid **results = (void **) &ents;\n\tunsigned int nents, i;\n\tunsigned long flags;\n\tphys_addr_t cln;\n\n\tif (dma_debug_disabled())\n\t\treturn;\n\n\tif (!page)\n\t\treturn;\n\n\tcln = (phys_addr_t) page_to_pfn(page) << CACHELINE_PER_PAGE_SHIFT;\n\tspin_lock_irqsave(&radix_lock, flags);\n\tnents = radix_tree_gang_lookup(&dma_active_cacheline, results, cln,\n\t\t\t\t       CACHELINES_PER_PAGE);\n\tfor (i = 0; i < nents; i++) {\n\t\tphys_addr_t ent_cln = to_cacheline_number(ents[i]);\n\n\t\tif (ent_cln == cln) {\n\t\t\tentry = ents[i];\n\t\t\tbreak;\n\t\t} else if (ent_cln >= cln + CACHELINES_PER_PAGE)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&radix_lock, flags);\n\n\tif (!entry)\n\t\treturn;\n\n\tcln = to_cacheline_number(entry);\n\terr_printk(entry->dev, entry,\n\t\t   \"DMA-API: cpu touching an active dma mapped cacheline [cln=%pa]\\n\",\n\t\t   &cln);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define CACHELINES_PER_PAGE (1 << CACHELINE_PER_PAGE_SHIFT)",
      "#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(radix_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_printk",
          "args": [
            "entry->dev",
            "entry",
            "\"DMA-API: cpu touching an active dma mapped cacheline [cln=%pa]\\n\"",
            "&cln"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cacheline_number",
          "args": [
            "entry"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "to_cacheline_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "477-481",
          "snippet": "static phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)\n\nstatic phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&radix_lock",
            "flags"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&dma_active_cacheline",
            "results",
            "cln",
            "CACHELINES_PER_PAGE"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&radix_lock",
            "flags"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_debug_disabled",
          "args": [],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "dma_debug_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "117-120",
          "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool global_disable",
            "static bool dma_debug_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define CACHELINES_PER_PAGE (1 << CACHELINE_PER_PAGE_SHIFT)\n#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)\n\nstatic DEFINE_SPINLOCK(radix_lock);\n\nvoid debug_dma_assert_idle(struct page *page)\n{\n\tstatic struct dma_debug_entry *ents[CACHELINES_PER_PAGE];\n\tstruct dma_debug_entry *entry = NULL;\n\tvoid **results = (void **) &ents;\n\tunsigned int nents, i;\n\tunsigned long flags;\n\tphys_addr_t cln;\n\n\tif (dma_debug_disabled())\n\t\treturn;\n\n\tif (!page)\n\t\treturn;\n\n\tcln = (phys_addr_t) page_to_pfn(page) << CACHELINE_PER_PAGE_SHIFT;\n\tspin_lock_irqsave(&radix_lock, flags);\n\tnents = radix_tree_gang_lookup(&dma_active_cacheline, results, cln,\n\t\t\t\t       CACHELINES_PER_PAGE);\n\tfor (i = 0; i < nents; i++) {\n\t\tphys_addr_t ent_cln = to_cacheline_number(ents[i]);\n\n\t\tif (ent_cln == cln) {\n\t\t\tentry = ents[i];\n\t\t\tbreak;\n\t\t} else if (ent_cln >= cln + CACHELINES_PER_PAGE)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&radix_lock, flags);\n\n\tif (!entry)\n\t\treturn;\n\n\tcln = to_cacheline_number(entry);\n\terr_printk(entry->dev, entry,\n\t\t   \"DMA-API: cpu touching an active dma mapped cacheline [cln=%pa]\\n\",\n\t\t   &cln);\n}"
  },
  {
    "function_name": "active_cacheline_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "555-572",
    "snippet": "static void active_cacheline_remove(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\n\t/* ...mirror the insert case */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\t/* since we are counting overlaps the final put of the\n\t * cacheline will occur when the overlap count is 0.\n\t * active_cacheline_dec_overlap() returns -1 in that case\n\t */\n\tif (active_cacheline_dec_overlap(cln) < 0)\n\t\tradix_tree_delete(&dma_active_cacheline, cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(radix_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&radix_lock",
            "flags"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&dma_active_cacheline",
            "cln"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "active_cacheline_dec_overlap",
          "args": [
            "cln"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_dec_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "526-531",
          "snippet": "static int active_cacheline_dec_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\treturn active_cacheline_set_overlap(cln, --overlap);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int active_cacheline_dec_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\treturn active_cacheline_set_overlap(cln, --overlap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&radix_lock",
            "flags"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_cacheline_number",
          "args": [
            "entry"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "to_cacheline_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "477-481",
          "snippet": "static phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)\n\nstatic phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic DEFINE_SPINLOCK(radix_lock);\n\nstatic void active_cacheline_remove(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\n\t/* ...mirror the insert case */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\t/* since we are counting overlaps the final put of the\n\t * cacheline will occur when the overlap count is 0.\n\t * active_cacheline_dec_overlap() returns -1 in that case\n\t */\n\tif (active_cacheline_dec_overlap(cln) < 0)\n\t\tradix_tree_delete(&dma_active_cacheline, cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n}"
  },
  {
    "function_name": "active_cacheline_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "533-553",
    "snippet": "static int active_cacheline_insert(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\tint rc;\n\n\t/* If the device is not writing memory then we don't have any\n\t * concerns about the cpu consuming stale data.  This mitigates\n\t * legitimate usages of overlapping mappings.\n\t */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\trc = radix_tree_insert(&dma_active_cacheline, cln, entry);\n\tif (rc == -EEXIST)\n\t\tactive_cacheline_inc_overlap(cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(radix_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&radix_lock",
            "flags"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "active_cacheline_inc_overlap",
          "args": [
            "cln"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_inc_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "509-524",
          "snippet": "static void active_cacheline_inc_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\toverlap = active_cacheline_set_overlap(cln, ++overlap);\n\n\t/* If we overflowed the overlap counter then we're potentially\n\t * leaking dma-mappings.  Otherwise, if maps and unmaps are\n\t * balanced then this overflow may cause false negatives in\n\t * debug_dma_assert_idle() as the cacheline may be marked idle\n\t * prematurely.\n\t */\n\tWARN_ONCE(overlap > ACTIVE_CACHELINE_MAX_OVERLAP,\n\t\t  \"DMA-API: exceeded %d overlapping mappings of cacheline %pa\\n\",\n\t\t  ACTIVE_CACHELINE_MAX_OVERLAP, &cln);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)\n\nstatic void active_cacheline_inc_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\toverlap = active_cacheline_set_overlap(cln, ++overlap);\n\n\t/* If we overflowed the overlap counter then we're potentially\n\t * leaking dma-mappings.  Otherwise, if maps and unmaps are\n\t * balanced then this overflow may cause false negatives in\n\t * debug_dma_assert_idle() as the cacheline may be marked idle\n\t * prematurely.\n\t */\n\tWARN_ONCE(overlap > ACTIVE_CACHELINE_MAX_OVERLAP,\n\t\t  \"DMA-API: exceeded %d overlapping mappings of cacheline %pa\\n\",\n\t\t  ACTIVE_CACHELINE_MAX_OVERLAP, &cln);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&dma_active_cacheline",
            "cln",
            "entry"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&radix_lock",
            "flags"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_cacheline_number",
          "args": [
            "entry"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "to_cacheline_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "477-481",
          "snippet": "static phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)\n\nstatic phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic DEFINE_SPINLOCK(radix_lock);\n\nstatic int active_cacheline_insert(struct dma_debug_entry *entry)\n{\n\tphys_addr_t cln = to_cacheline_number(entry);\n\tunsigned long flags;\n\tint rc;\n\n\t/* If the device is not writing memory then we don't have any\n\t * concerns about the cpu consuming stale data.  This mitigates\n\t * legitimate usages of overlapping mappings.\n\t */\n\tif (entry->direction == DMA_TO_DEVICE)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&radix_lock, flags);\n\trc = radix_tree_insert(&dma_active_cacheline, cln, entry);\n\tif (rc == -EEXIST)\n\t\tactive_cacheline_inc_overlap(cln);\n\tspin_unlock_irqrestore(&radix_lock, flags);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "active_cacheline_dec_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "526-531",
    "snippet": "static int active_cacheline_dec_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\treturn active_cacheline_set_overlap(cln, --overlap);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "active_cacheline_set_overlap",
          "args": [
            "cln",
            "--overlap"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_set_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "493-507",
          "snippet": "static int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)\n\nstatic int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "active_cacheline_read_overlap",
          "args": [
            "cln"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_read_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "483-491",
          "snippet": "static int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int active_cacheline_dec_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\treturn active_cacheline_set_overlap(cln, --overlap);\n}"
  },
  {
    "function_name": "active_cacheline_inc_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "509-524",
    "snippet": "static void active_cacheline_inc_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\toverlap = active_cacheline_set_overlap(cln, ++overlap);\n\n\t/* If we overflowed the overlap counter then we're potentially\n\t * leaking dma-mappings.  Otherwise, if maps and unmaps are\n\t * balanced then this overflow may cause false negatives in\n\t * debug_dma_assert_idle() as the cacheline may be marked idle\n\t * prematurely.\n\t */\n\tWARN_ONCE(overlap > ACTIVE_CACHELINE_MAX_OVERLAP,\n\t\t  \"DMA-API: exceeded %d overlapping mappings of cacheline %pa\\n\",\n\t\t  ACTIVE_CACHELINE_MAX_OVERLAP, &cln);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "overlap > ACTIVE_CACHELINE_MAX_OVERLAP",
            "\"DMA-API: exceeded %d overlapping mappings of cacheline %pa\\n\"",
            "ACTIVE_CACHELINE_MAX_OVERLAP",
            "&cln"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "active_cacheline_set_overlap",
          "args": [
            "cln",
            "++overlap"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_set_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "493-507",
          "snippet": "static int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)\n\nstatic int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "active_cacheline_read_overlap",
          "args": [
            "cln"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "active_cacheline_read_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "483-491",
          "snippet": "static int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)\n\nstatic void active_cacheline_inc_overlap(phys_addr_t cln)\n{\n\tint overlap = active_cacheline_read_overlap(cln);\n\n\toverlap = active_cacheline_set_overlap(cln, ++overlap);\n\n\t/* If we overflowed the overlap counter then we're potentially\n\t * leaking dma-mappings.  Otherwise, if maps and unmaps are\n\t * balanced then this overflow may cause false negatives in\n\t * debug_dma_assert_idle() as the cacheline may be marked idle\n\t * prematurely.\n\t */\n\tWARN_ONCE(overlap > ACTIVE_CACHELINE_MAX_OVERLAP,\n\t\t  \"DMA-API: exceeded %d overlapping mappings of cacheline %pa\\n\",\n\t\t  ACTIVE_CACHELINE_MAX_OVERLAP, &cln);\n}"
  },
  {
    "function_name": "active_cacheline_set_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "493-507",
    "snippet": "static int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&dma_active_cacheline",
            "cln",
            "i"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&dma_active_cacheline",
            "cln",
            "i"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)\n\nstatic int active_cacheline_set_overlap(phys_addr_t cln, int overlap)\n{\n\tint i;\n\n\tif (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)\n\t\treturn overlap;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (overlap & 1 << i)\n\t\t\tradix_tree_tag_set(&dma_active_cacheline, cln, i);\n\t\telse\n\t\t\tradix_tree_tag_clear(&dma_active_cacheline, cln, i);\n\n\treturn overlap;\n}"
  },
  {
    "function_name": "active_cacheline_read_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "483-491",
    "snippet": "static int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_tag_get",
          "args": [
            "&dma_active_cacheline",
            "cln",
            "i"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic int active_cacheline_read_overlap(phys_addr_t cln)\n{\n\tint overlap = 0, i;\n\n\tfor (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)\n\t\tif (radix_tree_tag_get(&dma_active_cacheline, cln, i))\n\t\t\toverlap |= 1 << i;\n\treturn overlap;\n}"
  },
  {
    "function_name": "to_cacheline_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "477-481",
    "snippet": "static phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)\n\nstatic phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)\n{\n\treturn (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +\n\t\t(entry->offset >> L1_CACHE_SHIFT);\n}"
  },
  {
    "function_name": "debug_dma_dump_mappings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "421-446",
    "snippet": "void debug_dma_dump_mappings(struct device *dev)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HASH_SIZE; idx++) {\n\t\tstruct hash_bucket *bucket = &dma_entry_hash[idx];\n\t\tstruct dma_debug_entry *entry;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bucket->lock, flags);\n\n\t\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\t\tif (!dev || dev == entry->dev) {\n\t\t\t\tdev_info(entry->dev,\n\t\t\t\t\t \"%s idx %d P=%Lx N=%lx D=%Lx L=%Lx %s %s\\n\",\n\t\t\t\t\t type2name[entry->type], idx,\n\t\t\t\t\t phys_addr(entry), entry->pfn,\n\t\t\t\t\t entry->dev_addr, entry->size,\n\t\t\t\t\t dir2name[entry->direction],\n\t\t\t\t\t maperr2str[entry->map_err_type]);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_irqrestore(&bucket->lock, flags);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE       1024ULL"
    ],
    "globals_used": [
      "static struct hash_bucket dma_entry_hash[HASH_SIZE];",
      "static const char *const maperr2str[] = {\n\t[MAP_ERR_CHECK_NOT_APPLICABLE] = \"dma map error check not applicable\",\n\t[MAP_ERR_NOT_CHECKED] = \"dma map error not checked\",\n\t[MAP_ERR_CHECKED] = \"dma map error checked\",\n};",
      "static const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };",
      "static const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&bucket->lock",
            "flags"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "entry->dev",
            "\"%s idx %d P=%Lx N=%lx D=%Lx L=%Lx %s %s\\n\"",
            "type2name[entry->type]",
            "idx",
            "phys_addr(entry)",
            "entry->pfn",
            "entry->dev_addr",
            "entry->size",
            "dir2name[entry->direction]",
            "maperr2str[entry->map_err_type]"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_addr",
          "args": [
            "entry"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "phys_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "410-416",
          "snippet": "static unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&bucket->list",
            "list"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&bucket->lock",
            "flags"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_SIZE       1024ULL\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\nstatic const char *const maperr2str[] = {\n\t[MAP_ERR_CHECK_NOT_APPLICABLE] = \"dma map error check not applicable\",\n\t[MAP_ERR_NOT_CHECKED] = \"dma map error not checked\",\n\t[MAP_ERR_CHECKED] = \"dma map error checked\",\n};\nstatic const char *type2name[5] = { \"single\", \"page\",\n\t\t\t\t    \"scather-gather\", \"coherent\",\n\t\t\t\t    \"resource\" };\nstatic const char *dir2name[4] = { \"DMA_BIDIRECTIONAL\", \"DMA_TO_DEVICE\",\n\t\t\t\t   \"DMA_FROM_DEVICE\", \"DMA_NONE\" };\n\nvoid debug_dma_dump_mappings(struct device *dev)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < HASH_SIZE; idx++) {\n\t\tstruct hash_bucket *bucket = &dma_entry_hash[idx];\n\t\tstruct dma_debug_entry *entry;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&bucket->lock, flags);\n\n\t\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\t\tif (!dev || dev == entry->dev) {\n\t\t\t\tdev_info(entry->dev,\n\t\t\t\t\t \"%s idx %d P=%Lx N=%lx D=%Lx L=%Lx %s %s\\n\",\n\t\t\t\t\t type2name[entry->type], idx,\n\t\t\t\t\t phys_addr(entry), entry->pfn,\n\t\t\t\t\t entry->dev_addr, entry->size,\n\t\t\t\t\t dir2name[entry->direction],\n\t\t\t\t\t maperr2str[entry->map_err_type]);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_irqrestore(&bucket->lock, flags);\n\t}\n}"
  },
  {
    "function_name": "phys_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "410-416",
    "snippet": "static unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "pfn_to_page(entry->pfn)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "entry->pfn"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pfn_to_phys",
          "args": [
            "entry->pfn"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long long phys_addr(struct dma_debug_entry *entry)\n{\n\tif (entry->type == dma_debug_resource)\n\t\treturn __pfn_to_phys(entry->pfn) + entry->offset;\n\n\treturn page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;\n}"
  },
  {
    "function_name": "hash_bucket_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "405-408",
    "snippet": "static void hash_bucket_del(struct dma_debug_entry *entry)\n{\n\tlist_del(&entry->list);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void hash_bucket_del(struct dma_debug_entry *entry)\n{\n\tlist_del(&entry->list);\n}"
  },
  {
    "function_name": "hash_bucket_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "396-400",
    "snippet": "static void hash_bucket_add(struct hash_bucket *bucket,\n\t\t\t    struct dma_debug_entry *entry)\n{\n\tlist_add_tail(&entry->list, &bucket->list);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->list",
            "&bucket->list"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void hash_bucket_add(struct hash_bucket *bucket,\n\t\t\t    struct dma_debug_entry *entry)\n{\n\tlist_add_tail(&entry->list, &bucket->list);\n}"
  },
  {
    "function_name": "bucket_find_contain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "366-391",
    "snippet": "static struct dma_debug_entry *bucket_find_contain(struct hash_bucket **bucket,\n\t\t\t\t\t\t   struct dma_debug_entry *ref,\n\t\t\t\t\t\t   unsigned long *flags)\n{\n\n\tunsigned int max_range = dma_get_max_seg_size(ref->dev);\n\tstruct dma_debug_entry *entry, index = *ref;\n\tunsigned int range = 0;\n\n\twhile (range <= max_range) {\n\t\tentry = __hash_bucket_find(*bucket, ref, containing_match);\n\n\t\tif (entry)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * Nothing found, go back a hash bucket\n\t\t */\n\t\tput_hash_bucket(*bucket, flags);\n\t\trange          += (1 << HASH_FN_SHIFT);\n\t\tindex.dev_addr -= (1 << HASH_FN_SHIFT);\n\t\t*bucket = get_hash_bucket(&index, flags);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define HASH_FN_SHIFT   13"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_hash_bucket",
          "args": [
            "&index",
            "flags"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "get_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "264-274",
          "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_hash_bucket",
          "args": [
            "*bucket",
            "flags"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "put_hash_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "279-286",
          "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hash_bucket_find",
          "args": [
            "*bucket",
            "ref",
            "containing_match"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "__hash_bucket_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "310-358",
          "snippet": "static struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_get_max_seg_size",
          "args": [
            "ref->dev"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_FN_SHIFT   13\n\nstatic struct dma_debug_entry *bucket_find_contain(struct hash_bucket **bucket,\n\t\t\t\t\t\t   struct dma_debug_entry *ref,\n\t\t\t\t\t\t   unsigned long *flags)\n{\n\n\tunsigned int max_range = dma_get_max_seg_size(ref->dev);\n\tstruct dma_debug_entry *entry, index = *ref;\n\tunsigned int range = 0;\n\n\twhile (range <= max_range) {\n\t\tentry = __hash_bucket_find(*bucket, ref, containing_match);\n\n\t\tif (entry)\n\t\t\treturn entry;\n\n\t\t/*\n\t\t * Nothing found, go back a hash bucket\n\t\t */\n\t\tput_hash_bucket(*bucket, flags);\n\t\trange          += (1 << HASH_FN_SHIFT);\n\t\tindex.dev_addr -= (1 << HASH_FN_SHIFT);\n\t\t*bucket = get_hash_bucket(&index, flags);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "bucket_find_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "360-364",
    "snippet": "static struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hash_bucket_find",
          "args": [
            "bucket",
            "ref",
            "exact_match"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__hash_bucket_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "310-358",
          "snippet": "static struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,\n\t\t\t\t\t\t struct dma_debug_entry *ref)\n{\n\treturn __hash_bucket_find(bucket, ref, exact_match);\n}"
  },
  {
    "function_name": "__hash_bucket_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "310-358",
    "snippet": "static struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match",
          "args": [
            "ref",
            "entry"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "containing_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "294-305",
          "snippet": "static bool containing_match(struct dma_debug_entry *a,\n\t\t\t     struct dma_debug_entry *b)\n{\n\tif (a->dev != b->dev)\n\t\treturn false;\n\n\tif ((b->dev_addr <= a->dev_addr) &&\n\t    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool containing_match(struct dma_debug_entry *a,\n\t\t\t     struct dma_debug_entry *b)\n{\n\tif (a->dev != b->dev)\n\t\treturn false;\n\n\tif ((b->dev_addr <= a->dev_addr) &&\n\t    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&bucket->list",
            "list"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,\n\t\t\t\t\t\t  struct dma_debug_entry *ref,\n\t\t\t\t\t\t  match_fn match)\n{\n\tstruct dma_debug_entry *entry, *ret = NULL;\n\tint matches = 0, match_lvl, last_lvl = -1;\n\n\tlist_for_each_entry(entry, &bucket->list, list) {\n\t\tif (!match(ref, entry))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Some drivers map the same physical address multiple\n\t\t * times. Without a hardware IOMMU this results in the\n\t\t * same device addresses being put into the dma-debug\n\t\t * hash multiple times too. This can result in false\n\t\t * positives being reported. Therefore we implement a\n\t\t * best-fit algorithm here which returns the entry from\n\t\t * the hash which fits best to the reference value\n\t\t * instead of the first-fit.\n\t\t */\n\t\tmatches += 1;\n\t\tmatch_lvl = 0;\n\t\tentry->size         == ref->size         ? ++match_lvl : 0;\n\t\tentry->type         == ref->type         ? ++match_lvl : 0;\n\t\tentry->direction    == ref->direction    ? ++match_lvl : 0;\n\t\tentry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;\n\n\t\tif (match_lvl == 4) {\n\t\t\t/* perfect-fit - return the result */\n\t\t\treturn entry;\n\t\t} else if (match_lvl > last_lvl) {\n\t\t\t/*\n\t\t\t * We found an entry that fits better then the\n\t\t\t * previous one or it is the 1st match.\n\t\t\t */\n\t\t\tlast_lvl = match_lvl;\n\t\t\tret      = entry;\n\t\t}\n\t}\n\n\t/*\n\t * If we have multiple matches but no perfect-fit, just return\n\t * NULL.\n\t */\n\tret = (matches == 1) ? ret : NULL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "containing_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "294-305",
    "snippet": "static bool containing_match(struct dma_debug_entry *a,\n\t\t\t     struct dma_debug_entry *b)\n{\n\tif (a->dev != b->dev)\n\t\treturn false;\n\n\tif ((b->dev_addr <= a->dev_addr) &&\n\t    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool containing_match(struct dma_debug_entry *a,\n\t\t\t     struct dma_debug_entry *b)\n{\n\tif (a->dev != b->dev)\n\t\treturn false;\n\n\tif ((b->dev_addr <= a->dev_addr) &&\n\t    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "exact_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "288-292",
    "snippet": "static bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)\n{\n\treturn ((a->dev_addr == b->dev_addr) &&\n\t\t(a->dev == b->dev)) ? true : false;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)\n{\n\treturn ((a->dev_addr == b->dev_addr) &&\n\t\t(a->dev == b->dev)) ? true : false;\n}"
  },
  {
    "function_name": "put_hash_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "279-286",
    "snippet": "static void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&bucket->lock",
            "__flags"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&bucket->lock"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic void put_hash_bucket(struct hash_bucket *bucket,\n\t\t\t    unsigned long *flags)\n\t__releases(&bucket->lock)\n{\n\tunsigned long __flags = *flags;\n\n\tspin_unlock_irqrestore(&bucket->lock, __flags);\n}"
  },
  {
    "function_name": "get_hash_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "264-274",
    "snippet": "static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hash_bucket dma_entry_hash[HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&dma_entry_hash[idx].lock",
            "__flags"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_fn",
          "args": [
            "entry"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "hash_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "252-259",
          "snippet": "static int hash_fn(struct dma_debug_entry *entry)\n{\n\t/*\n\t * Hash function is based on the dma address.\n\t * We use bits 20-27 here as the index into the hash\n\t */\n\treturn (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [
            "#define HASH_FN_MASK    (HASH_SIZE - 1)",
            "#define HASH_FN_SHIFT   13"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_FN_MASK    (HASH_SIZE - 1)\n#define HASH_FN_SHIFT   13\n\nstatic int hash_fn(struct dma_debug_entry *entry)\n{\n\t/*\n\t * Hash function is based on the dma address.\n\t * We use bits 20-27 here as the index into the hash\n\t */\n\treturn (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&dma_entry_hash"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic struct hash_bucket dma_entry_hash[HASH_SIZE];\n\nstatic struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,\n\t\t\t\t\t   unsigned long *flags)\n\t__acquires(&dma_entry_hash[idx].lock)\n{\n\tint idx = hash_fn(entry);\n\tunsigned long __flags;\n\n\tspin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);\n\t*flags = __flags;\n\treturn &dma_entry_hash[idx];\n}"
  },
  {
    "function_name": "hash_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "252-259",
    "snippet": "static int hash_fn(struct dma_debug_entry *entry)\n{\n\t/*\n\t * Hash function is based on the dma address.\n\t * We use bits 20-27 here as the index into the hash\n\t */\n\treturn (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define HASH_FN_MASK    (HASH_SIZE - 1)",
      "#define HASH_FN_SHIFT   13"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define HASH_FN_MASK    (HASH_SIZE - 1)\n#define HASH_FN_SHIFT   13\n\nstatic int hash_fn(struct dma_debug_entry *entry)\n{\n\t/*\n\t * Hash function is based on the dma address.\n\t * We use bits 20-27 here as the index into the hash\n\t */\n\treturn (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;\n}"
  },
  {
    "function_name": "driver_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "192-231",
    "snippet": "static bool driver_filter(struct device *dev)\n{\n\tstruct device_driver *drv;\n\tunsigned long flags;\n\tbool ret;\n\n\t/* driver filter off */\n\tif (likely(!current_driver_name[0]))\n\t\treturn true;\n\n\t/* driver filter on and initialized */\n\tif (current_driver && dev && dev->driver == current_driver)\n\t\treturn true;\n\n\t/* driver filter on, but we can't filter on a NULL device... */\n\tif (!dev)\n\t\treturn false;\n\n\tif (current_driver || !current_driver_name[0])\n\t\treturn false;\n\n\t/* driver filter on but not yet initialized */\n\tdrv = dev->driver;\n\tif (!drv)\n\t\treturn false;\n\n\t/* lock to protect against change of current_driver_name */\n\tread_lock_irqsave(&driver_name_lock, flags);\n\n\tret = false;\n\tif (drv->name &&\n\t    strncmp(current_driver_name, drv->name, NAME_MAX_LEN - 1) == 0) {\n\t\tcurrent_driver = drv;\n\t\tret = true;\n\t}\n\n\tread_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [
      "#define NAME_MAX_LEN\t64"
    ],
    "globals_used": [
      "static char                  current_driver_name[NAME_MAX_LEN]",
      "static struct device_driver *current_driver",
      "static DEFINE_RWLOCK(driver_name_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_read_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "254-257",
          "snippet": "void __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "current_driver_name",
            "drv->name",
            "NAME_MAX_LEN - 1"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&driver_name_lock",
            "flags"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!current_driver_name[0]"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\n#define NAME_MAX_LEN\t64\n\nstatic char                  current_driver_name[NAME_MAX_LEN];\nstatic struct device_driver *current_driver;\nstatic DEFINE_RWLOCK(driver_name_lock);\n\nstatic bool driver_filter(struct device *dev)\n{\n\tstruct device_driver *drv;\n\tunsigned long flags;\n\tbool ret;\n\n\t/* driver filter off */\n\tif (likely(!current_driver_name[0]))\n\t\treturn true;\n\n\t/* driver filter on and initialized */\n\tif (current_driver && dev && dev->driver == current_driver)\n\t\treturn true;\n\n\t/* driver filter on, but we can't filter on a NULL device... */\n\tif (!dev)\n\t\treturn false;\n\n\tif (current_driver || !current_driver_name[0])\n\t\treturn false;\n\n\t/* driver filter on but not yet initialized */\n\tdrv = dev->driver;\n\tif (!drv)\n\t\treturn false;\n\n\t/* lock to protect against change of current_driver_name */\n\tread_lock_irqsave(&driver_name_lock, flags);\n\n\tret = false;\n\tif (drv->name &&\n\t    strncmp(current_driver_name, drv->name, NAME_MAX_LEN - 1) == 0) {\n\t\tcurrent_driver = drv;\n\t\tret = true;\n\t}\n\n\tread_unlock_irqrestore(&driver_name_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dump_entry_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "182-190",
    "snippet": "static inline void dump_entry_trace(struct dma_debug_entry *entry)\n{\n#ifdef CONFIG_STACKTRACE\n\tif (entry) {\n\t\tpr_warning(\"Mapped at:\\n\");\n\t\tprint_stack_trace(&entry->stacktrace, 0);\n\t}\n#endif\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_stack_trace",
          "args": [
            "&entry->stacktrace",
            "0"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "print_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stacktrace.c",
          "lines": "14-23",
          "snippet": "void print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n\nvoid print_stack_trace(struct stack_trace *trace, int spaces)\n{\n\tint i;\n\n\tif (WARN_ON(!trace->entries))\n\t\treturn;\n\n\tfor (i = 0; i < trace->nr_entries; i++)\n\t\tprintk(\"%*c%pS\\n\", 1 + spaces, ' ', (void *)trace->entries[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warning",
          "args": [
            "\"Mapped at:\\n\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic inline void dump_entry_trace(struct dma_debug_entry *entry)\n{\n#ifdef CONFIG_STACKTRACE\n\tif (entry) {\n\t\tpr_warning(\"Mapped at:\\n\");\n\t\tprint_stack_trace(&entry->stacktrace, 0);\n\t}\n#endif\n}"
  },
  {
    "function_name": "dma_debug_disabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
    "lines": "117-120",
    "snippet": "static inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>",
      "#include <linux/export.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/dma-debug.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool global_disable",
      "static bool dma_debug_initialized"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nstatic bool global_disable;\nstatic bool dma_debug_initialized;\n\nstatic inline bool dma_debug_disabled(void)\n{\n\treturn global_disable || !dma_debug_initialized;\n}"
  }
]