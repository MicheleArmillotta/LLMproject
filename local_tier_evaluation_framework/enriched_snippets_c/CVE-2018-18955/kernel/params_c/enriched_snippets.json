[
  {
    "function_name": "param_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "943-957",
    "snippet": "static int __init param_sysfs_init(void)\n{\n\tmodule_kset = kset_create_and_add(\"module\", &module_uevent_ops, NULL);\n\tif (!module_kset) {\n\t\tprintk(KERN_WARNING \"%s (%d): error creating kset\\n\",\n\t\t\t__FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\tmodule_sysfs_initialized = 1;\n\n\tversion_sysfs_builtin();\n\tparam_sysfs_builtin();\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_sysfs_builtin",
          "args": [],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "param_sysfs_builtin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "812-835",
          "snippet": "static void __init param_sysfs_builtin(void)\n{\n\tconst struct kernel_param *kp;\n\tunsigned int name_len;\n\tchar modname[MODULE_NAME_LEN];\n\n\tfor (kp = __start___param; kp < __stop___param; kp++) {\n\t\tchar *dot;\n\n\t\tif (kp->perm == 0)\n\t\t\tcontinue;\n\n\t\tdot = strchr(kp->name, '.');\n\t\tif (!dot) {\n\t\t\t/* This happens for core_param() */\n\t\t\tstrcpy(modname, \"kernel\");\n\t\t\tname_len = 0;\n\t\t} else {\n\t\t\tname_len = dot - kp->name + 1;\n\t\t\tstrlcpy(modname, kp->name, name_len);\n\t\t}\n\t\tkernel_add_sysfs_param(modname, kp, name_len);\n\t}\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void __init param_sysfs_builtin(void)\n{\n\tconst struct kernel_param *kp;\n\tunsigned int name_len;\n\tchar modname[MODULE_NAME_LEN];\n\n\tfor (kp = __start___param; kp < __stop___param; kp++) {\n\t\tchar *dot;\n\n\t\tif (kp->perm == 0)\n\t\t\tcontinue;\n\n\t\tdot = strchr(kp->name, '.');\n\t\tif (!dot) {\n\t\t\t/* This happens for core_param() */\n\t\t\tstrcpy(modname, \"kernel\");\n\t\t\tname_len = 0;\n\t\t} else {\n\t\t\tname_len = dot - kp->name + 1;\n\t\t\tstrlcpy(modname, kp->name, name_len);\n\t\t}\n\t\tkernel_add_sysfs_param(modname, kp, name_len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "version_sysfs_builtin",
          "args": [],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "version_sysfs_builtin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "849-866",
          "snippet": "static void __init version_sysfs_builtin(void)\n{\n\tconst struct module_version_attribute **p;\n\tstruct module_kobject *mk;\n\tint err;\n\n\tfor (p = __start___modver; p < __stop___modver; p++) {\n\t\tconst struct module_version_attribute *vattr = *p;\n\n\t\tmk = locate_module_kobject(vattr->module_name);\n\t\tif (mk) {\n\t\t\terr = sysfs_create_file(&mk->kobj, &vattr->mattr.attr);\n\t\t\tWARN_ON_ONCE(err);\n\t\t\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\t\t\tkobject_put(&mk->kobj);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void __init version_sysfs_builtin(void)\n{\n\tconst struct module_version_attribute **p;\n\tstruct module_kobject *mk;\n\tint err;\n\n\tfor (p = __start___modver; p < __stop___modver; p++) {\n\t\tconst struct module_version_attribute *vattr = *p;\n\n\t\tmk = locate_module_kobject(vattr->module_name);\n\t\tif (mk) {\n\t\t\terr = sysfs_create_file(&mk->kobj, &vattr->mattr.attr);\n\t\t\tWARN_ON_ONCE(err);\n\t\t\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\t\t\tkobject_put(&mk->kobj);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s (%d): error creating kset\\n\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kset_create_and_add",
          "args": [
            "\"module\"",
            "&module_uevent_ops",
            "NULL"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic int __init param_sysfs_init(void)\n{\n\tmodule_kset = kset_create_and_add(\"module\", &module_uevent_ops, NULL);\n\tif (!module_kset) {\n\t\tprintk(KERN_WARNING \"%s (%d): error creating kset\\n\",\n\t\t\t__FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\tmodule_sysfs_initialized = 1;\n\n\tversion_sysfs_builtin();\n\tparam_sysfs_builtin();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "module_kobj_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "929-933",
    "snippet": "static void module_kobj_release(struct kobject *kobj)\n{\n\tstruct module_kobject *mk = to_module_kobject(kobj);\n\tcomplete(mk->kobj_completion);\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "mk->kobj_completion"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_module_kobject",
          "args": [
            "kobj"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void module_kobj_release(struct kobject *kobj)\n{\n\tstruct module_kobject *mk = to_module_kobject(kobj);\n\tcomplete(mk->kobj_completion);\n}"
  },
  {
    "function_name": "uevent_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "913-920",
    "snippet": "static int uevent_filter(struct kset *kset, struct kobject *kobj)\n{\n\tstruct kobj_type *ktype = get_ktype(kobj);\n\n\tif (ktype == &module_ktype)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_ktype",
          "args": [
            "kobj"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic int uevent_filter(struct kset *kset, struct kobject *kobj)\n{\n\tstruct kobj_type *ktype = get_ktype(kobj);\n\n\tif (ktype == &module_ktype)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "module_attr_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "889-906",
    "snippet": "static ssize_t module_attr_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct module_attribute *attribute;\n\tstruct module_kobject *mk;\n\tint ret;\n\n\tattribute = to_module_attr(attr);\n\tmk = to_module_kobject(kobj);\n\n\tif (!attribute->store)\n\t\treturn -EIO;\n\n\tret = attribute->store(attribute, mk, buf, len);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attribute->store",
          "args": [
            "attribute",
            "mk",
            "buf",
            "len"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_module_kobject",
          "args": [
            "kobj"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_module_attr",
          "args": [
            "attr"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic ssize_t module_attr_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct module_attribute *attribute;\n\tstruct module_kobject *mk;\n\tint ret;\n\n\tattribute = to_module_attr(attr);\n\tmk = to_module_kobject(kobj);\n\n\tif (!attribute->store)\n\t\treturn -EIO;\n\n\tret = attribute->store(attribute, mk, buf, len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "module_attr_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "870-887",
    "snippet": "static ssize_t module_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct module_attribute *attribute;\n\tstruct module_kobject *mk;\n\tint ret;\n\n\tattribute = to_module_attr(attr);\n\tmk = to_module_kobject(kobj);\n\n\tif (!attribute->show)\n\t\treturn -EIO;\n\n\tret = attribute->show(attribute, mk, buf);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attribute->show",
          "args": [
            "attribute",
            "mk",
            "buf"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_module_kobject",
          "args": [
            "kobj"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_module_attr",
          "args": [
            "attr"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic ssize_t module_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct module_attribute *attribute;\n\tstruct module_kobject *mk;\n\tint ret;\n\n\tattribute = to_module_attr(attr);\n\tmk = to_module_kobject(kobj);\n\n\tif (!attribute->show)\n\t\treturn -EIO;\n\n\tret = attribute->show(attribute, mk, buf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "version_sysfs_builtin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "849-866",
    "snippet": "static void __init version_sysfs_builtin(void)\n{\n\tconst struct module_version_attribute **p;\n\tstruct module_kobject *mk;\n\tint err;\n\n\tfor (p = __start___modver; p < __stop___modver; p++) {\n\t\tconst struct module_version_attribute *vattr = *p;\n\n\t\tmk = locate_module_kobject(vattr->module_name);\n\t\tif (mk) {\n\t\t\terr = sysfs_create_file(&mk->kobj, &vattr->mattr.attr);\n\t\t\tWARN_ON_ONCE(err);\n\t\t\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\t\t\tkobject_put(&mk->kobj);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&mk->kobj"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1742-1748",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&mk->kobj",
            "KOBJ_ADD"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "err"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_file",
          "args": [
            "&mk->kobj",
            "&vattr->mattr.attr"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locate_module_kobject",
          "args": [
            "vattr->module_name"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "locate_module_kobject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "743-776",
          "snippet": "static struct module_kobject * __init locate_module_kobject(const char *name)\n{\n\tstruct module_kobject *mk;\n\tstruct kobject *kobj;\n\tint err;\n\n\tkobj = kset_find_obj(module_kset, name);\n\tif (kobj) {\n\t\tmk = to_module_kobject(kobj);\n\t} else {\n\t\tmk = kzalloc(sizeof(struct module_kobject), GFP_KERNEL);\n\t\tBUG_ON(!mk);\n\n\t\tmk->mod = THIS_MODULE;\n\t\tmk->kobj.kset = module_kset;\n\t\terr = kobject_init_and_add(&mk->kobj, &module_ktype, NULL,\n\t\t\t\t\t   \"%s\", name);\n#ifdef CONFIG_MODULES\n\t\tif (!err)\n\t\t\terr = sysfs_create_file(&mk->kobj, &module_uevent.attr);\n#endif\n\t\tif (err) {\n\t\t\tkobject_put(&mk->kobj);\n\t\t\tpr_crit(\"Adding module '%s' to sysfs failed (%d), the system may be unstable.\\n\",\n\t\t\t\tname, err);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* So that we hold reference in both cases. */\n\t\tkobject_get(&mk->kobj);\n\t}\n\n\treturn mk;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic struct module_kobject * __init locate_module_kobject(const char *name)\n{\n\tstruct module_kobject *mk;\n\tstruct kobject *kobj;\n\tint err;\n\n\tkobj = kset_find_obj(module_kset, name);\n\tif (kobj) {\n\t\tmk = to_module_kobject(kobj);\n\t} else {\n\t\tmk = kzalloc(sizeof(struct module_kobject), GFP_KERNEL);\n\t\tBUG_ON(!mk);\n\n\t\tmk->mod = THIS_MODULE;\n\t\tmk->kobj.kset = module_kset;\n\t\terr = kobject_init_and_add(&mk->kobj, &module_ktype, NULL,\n\t\t\t\t\t   \"%s\", name);\n#ifdef CONFIG_MODULES\n\t\tif (!err)\n\t\t\terr = sysfs_create_file(&mk->kobj, &module_uevent.attr);\n#endif\n\t\tif (err) {\n\t\t\tkobject_put(&mk->kobj);\n\t\t\tpr_crit(\"Adding module '%s' to sysfs failed (%d), the system may be unstable.\\n\",\n\t\t\t\tname, err);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* So that we hold reference in both cases. */\n\t\tkobject_get(&mk->kobj);\n\t}\n\n\treturn mk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void __init version_sysfs_builtin(void)\n{\n\tconst struct module_version_attribute **p;\n\tstruct module_kobject *mk;\n\tint err;\n\n\tfor (p = __start___modver; p < __stop___modver; p++) {\n\t\tconst struct module_version_attribute *vattr = *p;\n\n\t\tmk = locate_module_kobject(vattr->module_name);\n\t\tif (mk) {\n\t\t\terr = sysfs_create_file(&mk->kobj, &vattr->mattr.attr);\n\t\t\tWARN_ON_ONCE(err);\n\t\t\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\t\t\tkobject_put(&mk->kobj);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__modver_version_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "837-844",
    "snippet": "ssize_t __modver_version_show(struct module_attribute *mattr,\n\t\t\t      struct module_kobject *mk, char *buf)\n{\n\tstruct module_version_attribute *vattr =\n\t\tcontainer_of(mattr, struct module_version_attribute, mattr);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", vattr->version);\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%s\\n\"",
            "vattr->version"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "mattr",
            "structmodule_version_attribute",
            "mattr"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nssize_t __modver_version_show(struct module_attribute *mattr,\n\t\t\t      struct module_kobject *mk, char *buf)\n{\n\tstruct module_version_attribute *vattr =\n\t\tcontainer_of(mattr, struct module_version_attribute, mattr);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", vattr->version);\n}"
  },
  {
    "function_name": "param_sysfs_builtin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "812-835",
    "snippet": "static void __init param_sysfs_builtin(void)\n{\n\tconst struct kernel_param *kp;\n\tunsigned int name_len;\n\tchar modname[MODULE_NAME_LEN];\n\n\tfor (kp = __start___param; kp < __stop___param; kp++) {\n\t\tchar *dot;\n\n\t\tif (kp->perm == 0)\n\t\t\tcontinue;\n\n\t\tdot = strchr(kp->name, '.');\n\t\tif (!dot) {\n\t\t\t/* This happens for core_param() */\n\t\t\tstrcpy(modname, \"kernel\");\n\t\t\tname_len = 0;\n\t\t} else {\n\t\t\tname_len = dot - kp->name + 1;\n\t\t\tstrlcpy(modname, kp->name, name_len);\n\t\t}\n\t\tkernel_add_sysfs_param(modname, kp, name_len);\n\t}\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_add_sysfs_param",
          "args": [
            "modname",
            "kp",
            "name_len"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_add_sysfs_param",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "778-800",
          "snippet": "static void __init kernel_add_sysfs_param(const char *name,\n\t\t\t\t\t  const struct kernel_param *kparam,\n\t\t\t\t\t  unsigned int name_skip)\n{\n\tstruct module_kobject *mk;\n\tint err;\n\n\tmk = locate_module_kobject(name);\n\tif (!mk)\n\t\treturn;\n\n\t/* We need to remove old parameters before adding more. */\n\tif (mk->mp)\n\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);\n\n\t/* These should not fail at boot. */\n\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);\n\tBUG_ON(err);\n\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);\n\tBUG_ON(err);\n\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\tkobject_put(&mk->kobj);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void __init kernel_add_sysfs_param(const char *name,\n\t\t\t\t\t  const struct kernel_param *kparam,\n\t\t\t\t\t  unsigned int name_skip)\n{\n\tstruct module_kobject *mk;\n\tint err;\n\n\tmk = locate_module_kobject(name);\n\tif (!mk)\n\t\treturn;\n\n\t/* We need to remove old parameters before adding more. */\n\tif (mk->mp)\n\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);\n\n\t/* These should not fail at boot. */\n\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);\n\tBUG_ON(err);\n\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);\n\tBUG_ON(err);\n\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\tkobject_put(&mk->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "modname",
            "kp->name",
            "name_len"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "modname",
            "\"kernel\""
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "kp->name",
            "'.'"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void __init param_sysfs_builtin(void)\n{\n\tconst struct kernel_param *kp;\n\tunsigned int name_len;\n\tchar modname[MODULE_NAME_LEN];\n\n\tfor (kp = __start___param; kp < __stop___param; kp++) {\n\t\tchar *dot;\n\n\t\tif (kp->perm == 0)\n\t\t\tcontinue;\n\n\t\tdot = strchr(kp->name, '.');\n\t\tif (!dot) {\n\t\t\t/* This happens for core_param() */\n\t\t\tstrcpy(modname, \"kernel\");\n\t\t\tname_len = 0;\n\t\t} else {\n\t\t\tname_len = dot - kp->name + 1;\n\t\t\tstrlcpy(modname, kp->name, name_len);\n\t\t}\n\t\tkernel_add_sysfs_param(modname, kp, name_len);\n\t}\n}"
  },
  {
    "function_name": "kernel_add_sysfs_param",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "778-800",
    "snippet": "static void __init kernel_add_sysfs_param(const char *name,\n\t\t\t\t\t  const struct kernel_param *kparam,\n\t\t\t\t\t  unsigned int name_skip)\n{\n\tstruct module_kobject *mk;\n\tint err;\n\n\tmk = locate_module_kobject(name);\n\tif (!mk)\n\t\treturn;\n\n\t/* We need to remove old parameters before adding more. */\n\tif (mk->mp)\n\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);\n\n\t/* These should not fail at boot. */\n\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);\n\tBUG_ON(err);\n\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);\n\tBUG_ON(err);\n\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\tkobject_put(&mk->kobj);\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&mk->kobj"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1742-1748",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&mk->kobj",
            "KOBJ_ADD"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&mk->kobj",
            "&mk->mp->grp"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_sysfs_param",
          "args": [
            "mk",
            "kparam",
            "kparam->name + name_skip"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_add_sysfs_param",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "778-800",
          "snippet": "static void __init kernel_add_sysfs_param(const char *name,\n\t\t\t\t\t  const struct kernel_param *kparam,\n\t\t\t\t\t  unsigned int name_skip)\n{\n\tstruct module_kobject *mk;\n\tint err;\n\n\tmk = locate_module_kobject(name);\n\tif (!mk)\n\t\treturn;\n\n\t/* We need to remove old parameters before adding more. */\n\tif (mk->mp)\n\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);\n\n\t/* These should not fail at boot. */\n\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);\n\tBUG_ON(err);\n\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);\n\tBUG_ON(err);\n\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\tkobject_put(&mk->kobj);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "&mk->kobj",
            "&mk->mp->grp"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locate_module_kobject",
          "args": [
            "name"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "locate_module_kobject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "743-776",
          "snippet": "static struct module_kobject * __init locate_module_kobject(const char *name)\n{\n\tstruct module_kobject *mk;\n\tstruct kobject *kobj;\n\tint err;\n\n\tkobj = kset_find_obj(module_kset, name);\n\tif (kobj) {\n\t\tmk = to_module_kobject(kobj);\n\t} else {\n\t\tmk = kzalloc(sizeof(struct module_kobject), GFP_KERNEL);\n\t\tBUG_ON(!mk);\n\n\t\tmk->mod = THIS_MODULE;\n\t\tmk->kobj.kset = module_kset;\n\t\terr = kobject_init_and_add(&mk->kobj, &module_ktype, NULL,\n\t\t\t\t\t   \"%s\", name);\n#ifdef CONFIG_MODULES\n\t\tif (!err)\n\t\t\terr = sysfs_create_file(&mk->kobj, &module_uevent.attr);\n#endif\n\t\tif (err) {\n\t\t\tkobject_put(&mk->kobj);\n\t\t\tpr_crit(\"Adding module '%s' to sysfs failed (%d), the system may be unstable.\\n\",\n\t\t\t\tname, err);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* So that we hold reference in both cases. */\n\t\tkobject_get(&mk->kobj);\n\t}\n\n\treturn mk;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic struct module_kobject * __init locate_module_kobject(const char *name)\n{\n\tstruct module_kobject *mk;\n\tstruct kobject *kobj;\n\tint err;\n\n\tkobj = kset_find_obj(module_kset, name);\n\tif (kobj) {\n\t\tmk = to_module_kobject(kobj);\n\t} else {\n\t\tmk = kzalloc(sizeof(struct module_kobject), GFP_KERNEL);\n\t\tBUG_ON(!mk);\n\n\t\tmk->mod = THIS_MODULE;\n\t\tmk->kobj.kset = module_kset;\n\t\terr = kobject_init_and_add(&mk->kobj, &module_ktype, NULL,\n\t\t\t\t\t   \"%s\", name);\n#ifdef CONFIG_MODULES\n\t\tif (!err)\n\t\t\terr = sysfs_create_file(&mk->kobj, &module_uevent.attr);\n#endif\n\t\tif (err) {\n\t\t\tkobject_put(&mk->kobj);\n\t\t\tpr_crit(\"Adding module '%s' to sysfs failed (%d), the system may be unstable.\\n\",\n\t\t\t\tname, err);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* So that we hold reference in both cases. */\n\t\tkobject_get(&mk->kobj);\n\t}\n\n\treturn mk;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void __init kernel_add_sysfs_param(const char *name,\n\t\t\t\t\t  const struct kernel_param *kparam,\n\t\t\t\t\t  unsigned int name_skip)\n{\n\tstruct module_kobject *mk;\n\tint err;\n\n\tmk = locate_module_kobject(name);\n\tif (!mk)\n\t\treturn;\n\n\t/* We need to remove old parameters before adding more. */\n\tif (mk->mp)\n\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);\n\n\t/* These should not fail at boot. */\n\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);\n\tBUG_ON(err);\n\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);\n\tBUG_ON(err);\n\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\tkobject_put(&mk->kobj);\n}"
  },
  {
    "function_name": "locate_module_kobject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "743-776",
    "snippet": "static struct module_kobject * __init locate_module_kobject(const char *name)\n{\n\tstruct module_kobject *mk;\n\tstruct kobject *kobj;\n\tint err;\n\n\tkobj = kset_find_obj(module_kset, name);\n\tif (kobj) {\n\t\tmk = to_module_kobject(kobj);\n\t} else {\n\t\tmk = kzalloc(sizeof(struct module_kobject), GFP_KERNEL);\n\t\tBUG_ON(!mk);\n\n\t\tmk->mod = THIS_MODULE;\n\t\tmk->kobj.kset = module_kset;\n\t\terr = kobject_init_and_add(&mk->kobj, &module_ktype, NULL,\n\t\t\t\t\t   \"%s\", name);\n#ifdef CONFIG_MODULES\n\t\tif (!err)\n\t\t\terr = sysfs_create_file(&mk->kobj, &module_uevent.attr);\n#endif\n\t\tif (err) {\n\t\t\tkobject_put(&mk->kobj);\n\t\t\tpr_crit(\"Adding module '%s' to sysfs failed (%d), the system may be unstable.\\n\",\n\t\t\t\tname, err);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* So that we hold reference in both cases. */\n\t\tkobject_get(&mk->kobj);\n\t}\n\n\treturn mk;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_get",
          "args": [
            "&mk->kobj"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Adding module '%s' to sysfs failed (%d), the system may be unstable.\\n\"",
            "name",
            "err"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&mk->kobj"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1742-1748",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_file",
          "args": [
            "&mk->kobj",
            "&module_uevent.attr"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_init_and_add",
          "args": [
            "&mk->kobj",
            "&module_ktype",
            "NULL",
            "\"%s\"",
            "name"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mk"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct module_kobject)",
            "GFP_KERNEL"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_module_kobject",
          "args": [
            "kobj"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kset_find_obj",
          "args": [
            "module_kset",
            "name"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic struct module_kobject * __init locate_module_kobject(const char *name)\n{\n\tstruct module_kobject *mk;\n\tstruct kobject *kobj;\n\tint err;\n\n\tkobj = kset_find_obj(module_kset, name);\n\tif (kobj) {\n\t\tmk = to_module_kobject(kobj);\n\t} else {\n\t\tmk = kzalloc(sizeof(struct module_kobject), GFP_KERNEL);\n\t\tBUG_ON(!mk);\n\n\t\tmk->mod = THIS_MODULE;\n\t\tmk->kobj.kset = module_kset;\n\t\terr = kobject_init_and_add(&mk->kobj, &module_ktype, NULL,\n\t\t\t\t\t   \"%s\", name);\n#ifdef CONFIG_MODULES\n\t\tif (!err)\n\t\t\terr = sysfs_create_file(&mk->kobj, &module_uevent.attr);\n#endif\n\t\tif (err) {\n\t\t\tkobject_put(&mk->kobj);\n\t\t\tpr_crit(\"Adding module '%s' to sysfs failed (%d), the system may be unstable.\\n\",\n\t\t\t\tname, err);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* So that we hold reference in both cases. */\n\t\tkobject_get(&mk->kobj);\n\t}\n\n\treturn mk;\n}"
  },
  {
    "function_name": "destroy_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "734-741",
    "snippet": "void destroy_params(const struct kernel_param *params, unsigned num)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++)\n\t\tif (params[i].ops->free)\n\t\t\tparams[i].ops->free(params[i].arg);\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "params[i].ops->free",
          "args": [
            "params[i].arg"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid destroy_params(const struct kernel_param *params, unsigned num)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++)\n\t\tif (params[i].ops->free)\n\t\t\tparams[i].ops->free(params[i].arg);\n}"
  },
  {
    "function_name": "module_param_sysfs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "723-731",
    "snippet": "void module_param_sysfs_remove(struct module *mod)\n{\n\tif (mod->mkobj.mp) {\n\t\tsysfs_remove_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);\n\t\t/* We are positive that no one is using any param\n\t\t * attrs at this point.  Deallocate immediately. */\n\t\tfree_module_param_attrs(&mod->mkobj);\n\t}\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_module_param_attrs",
          "args": [
            "&mod->mkobj"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_param_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "671-677",
          "snippet": "static void free_module_param_attrs(struct module_kobject *mk)\n{\n\tif (mk->mp)\n\t\tkfree(mk->mp->grp.attrs);\n\tkfree(mk->mp);\n\tmk->mp = NULL;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void free_module_param_attrs(struct module_kobject *mk)\n{\n\tif (mk->mp)\n\t\tkfree(mk->mp->grp.attrs);\n\tkfree(mk->mp);\n\tmk->mp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "&mod->mkobj.kobj",
            "&mod->mkobj.mp->grp"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid module_param_sysfs_remove(struct module *mod)\n{\n\tif (mod->mkobj.mp) {\n\t\tsysfs_remove_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);\n\t\t/* We are positive that no one is using any param\n\t\t * attrs at this point.  Deallocate immediately. */\n\t\tfree_module_param_attrs(&mod->mkobj);\n\t}\n}"
  },
  {
    "function_name": "module_param_sysfs_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "688-714",
    "snippet": "int module_param_sysfs_setup(struct module *mod,\n\t\t\t     const struct kernel_param *kparam,\n\t\t\t     unsigned int num_params)\n{\n\tint i, err;\n\tbool params = false;\n\n\tfor (i = 0; i < num_params; i++) {\n\t\tif (kparam[i].perm == 0)\n\t\t\tcontinue;\n\t\terr = add_sysfs_param(&mod->mkobj, &kparam[i], kparam[i].name);\n\t\tif (err) {\n\t\t\tfree_module_param_attrs(&mod->mkobj);\n\t\t\treturn err;\n\t\t}\n\t\tparams = true;\n\t}\n\n\tif (!params)\n\t\treturn 0;\n\n\t/* Create the param group. */\n\terr = sysfs_create_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);\n\tif (err)\n\t\tfree_module_param_attrs(&mod->mkobj);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_module_param_attrs",
          "args": [
            "&mod->mkobj"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "free_module_param_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "671-677",
          "snippet": "static void free_module_param_attrs(struct module_kobject *mk)\n{\n\tif (mk->mp)\n\t\tkfree(mk->mp->grp.attrs);\n\tkfree(mk->mp);\n\tmk->mp = NULL;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void free_module_param_attrs(struct module_kobject *mk)\n{\n\tif (mk->mp)\n\t\tkfree(mk->mp->grp.attrs);\n\tkfree(mk->mp);\n\tmk->mp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&mod->mkobj.kobj",
            "&mod->mkobj.mp->grp"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_sysfs_param",
          "args": [
            "&mod->mkobj",
            "&kparam[i]",
            "kparam[i].name"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_add_sysfs_param",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "778-800",
          "snippet": "static void __init kernel_add_sysfs_param(const char *name,\n\t\t\t\t\t  const struct kernel_param *kparam,\n\t\t\t\t\t  unsigned int name_skip)\n{\n\tstruct module_kobject *mk;\n\tint err;\n\n\tmk = locate_module_kobject(name);\n\tif (!mk)\n\t\treturn;\n\n\t/* We need to remove old parameters before adding more. */\n\tif (mk->mp)\n\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);\n\n\t/* These should not fail at boot. */\n\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);\n\tBUG_ON(err);\n\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);\n\tBUG_ON(err);\n\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\tkobject_put(&mk->kobj);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void __init kernel_add_sysfs_param(const char *name,\n\t\t\t\t\t  const struct kernel_param *kparam,\n\t\t\t\t\t  unsigned int name_skip)\n{\n\tstruct module_kobject *mk;\n\tint err;\n\n\tmk = locate_module_kobject(name);\n\tif (!mk)\n\t\treturn;\n\n\t/* We need to remove old parameters before adding more. */\n\tif (mk->mp)\n\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);\n\n\t/* These should not fail at boot. */\n\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);\n\tBUG_ON(err);\n\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);\n\tBUG_ON(err);\n\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\tkobject_put(&mk->kobj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint module_param_sysfs_setup(struct module *mod,\n\t\t\t     const struct kernel_param *kparam,\n\t\t\t     unsigned int num_params)\n{\n\tint i, err;\n\tbool params = false;\n\n\tfor (i = 0; i < num_params; i++) {\n\t\tif (kparam[i].perm == 0)\n\t\t\tcontinue;\n\t\terr = add_sysfs_param(&mod->mkobj, &kparam[i], kparam[i].name);\n\t\tif (err) {\n\t\t\tfree_module_param_attrs(&mod->mkobj);\n\t\t\treturn err;\n\t\t}\n\t\tparams = true;\n\t}\n\n\tif (!params)\n\t\treturn 0;\n\n\t/* Create the param group. */\n\terr = sysfs_create_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);\n\tif (err)\n\t\tfree_module_param_attrs(&mod->mkobj);\n\treturn err;\n}"
  },
  {
    "function_name": "free_module_param_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "671-677",
    "snippet": "static void free_module_param_attrs(struct module_kobject *mk)\n{\n\tif (mk->mp)\n\t\tkfree(mk->mp->grp.attrs);\n\tkfree(mk->mp);\n\tmk->mp = NULL;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mk->mp"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void free_module_param_attrs(struct module_kobject *mk)\n{\n\tif (mk->mp)\n\t\tkfree(mk->mp->grp.attrs);\n\tkfree(mk->mp);\n\tmk->mp = NULL;\n}"
  },
  {
    "function_name": "add_sysfs_param",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "607-668",
    "snippet": "static __modinit int add_sysfs_param(struct module_kobject *mk,\n\t\t\t\t     const struct kernel_param *kp,\n\t\t\t\t     const char *name)\n{\n\tstruct module_param_attrs *new_mp;\n\tstruct attribute **new_attrs;\n\tunsigned int i;\n\n\t/* We don't bother calling this with invisible parameters. */\n\tBUG_ON(!kp->perm);\n\n\tif (!mk->mp) {\n\t\t/* First allocation. */\n\t\tmk->mp = kzalloc(sizeof(*mk->mp), GFP_KERNEL);\n\t\tif (!mk->mp)\n\t\t\treturn -ENOMEM;\n\t\tmk->mp->grp.name = \"parameters\";\n\t\t/* NULL-terminated attribute array. */\n\t\tmk->mp->grp.attrs = kzalloc(sizeof(mk->mp->grp.attrs[0]),\n\t\t\t\t\t    GFP_KERNEL);\n\t\t/* Caller will cleanup via free_module_param_attrs */\n\t\tif (!mk->mp->grp.attrs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Enlarge allocations. */\n\tnew_mp = krealloc(mk->mp,\n\t\t\t  sizeof(*mk->mp) +\n\t\t\t  sizeof(mk->mp->attrs[0]) * (mk->mp->num + 1),\n\t\t\t  GFP_KERNEL);\n\tif (!new_mp)\n\t\treturn -ENOMEM;\n\tmk->mp = new_mp;\n\n\t/* Extra pointer for NULL terminator */\n\tnew_attrs = krealloc(mk->mp->grp.attrs,\n\t\t\t     sizeof(mk->mp->grp.attrs[0]) * (mk->mp->num + 2),\n\t\t\t     GFP_KERNEL);\n\tif (!new_attrs)\n\t\treturn -ENOMEM;\n\tmk->mp->grp.attrs = new_attrs;\n\n\t/* Tack new one on the end. */\n\tmemset(&mk->mp->attrs[mk->mp->num], 0, sizeof(mk->mp->attrs[0]));\n\tsysfs_attr_init(&mk->mp->attrs[mk->mp->num].mattr.attr);\n\tmk->mp->attrs[mk->mp->num].param = kp;\n\tmk->mp->attrs[mk->mp->num].mattr.show = param_attr_show;\n\t/* Do not allow runtime DAC changes to make param writable. */\n\tif ((kp->perm & (S_IWUSR | S_IWGRP | S_IWOTH)) != 0)\n\t\tmk->mp->attrs[mk->mp->num].mattr.store = param_attr_store;\n\telse\n\t\tmk->mp->attrs[mk->mp->num].mattr.store = NULL;\n\tmk->mp->attrs[mk->mp->num].mattr.attr.name = (char *)name;\n\tmk->mp->attrs[mk->mp->num].mattr.attr.mode = kp->perm;\n\tmk->mp->num++;\n\n\t/* Fix up all the pointers, since krealloc can move us */\n\tfor (i = 0; i < mk->mp->num; i++)\n\t\tmk->mp->grp.attrs[i] = &mk->mp->attrs[i].mattr.attr;\n\tmk->mp->grp.attrs[mk->mp->num] = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define __modinit __init",
      "#define __modinit"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_attr_init",
          "args": [
            "&mk->mp->attrs[mk->mp->num].mattr.attr"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&mk->mp->attrs[mk->mp->num]",
            "0",
            "sizeof(mk->mp->attrs[0])"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "mk->mp->grp.attrs",
            "sizeof(mk->mp->grp.attrs[0]) * (mk->mp->num + 2)",
            "GFP_KERNEL"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "mk->mp",
            "sizeof(*mk->mp) +\n\t\t\t  sizeof(mk->mp->attrs[0]) * (mk->mp->num + 1)",
            "GFP_KERNEL"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(mk->mp->grp.attrs[0])",
            "GFP_KERNEL"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*mk->mp)",
            "GFP_KERNEL"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!kp->perm"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\n#define __modinit __init\n#define __modinit\n\nstatic __modinit int add_sysfs_param(struct module_kobject *mk,\n\t\t\t\t     const struct kernel_param *kp,\n\t\t\t\t     const char *name)\n{\n\tstruct module_param_attrs *new_mp;\n\tstruct attribute **new_attrs;\n\tunsigned int i;\n\n\t/* We don't bother calling this with invisible parameters. */\n\tBUG_ON(!kp->perm);\n\n\tif (!mk->mp) {\n\t\t/* First allocation. */\n\t\tmk->mp = kzalloc(sizeof(*mk->mp), GFP_KERNEL);\n\t\tif (!mk->mp)\n\t\t\treturn -ENOMEM;\n\t\tmk->mp->grp.name = \"parameters\";\n\t\t/* NULL-terminated attribute array. */\n\t\tmk->mp->grp.attrs = kzalloc(sizeof(mk->mp->grp.attrs[0]),\n\t\t\t\t\t    GFP_KERNEL);\n\t\t/* Caller will cleanup via free_module_param_attrs */\n\t\tif (!mk->mp->grp.attrs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Enlarge allocations. */\n\tnew_mp = krealloc(mk->mp,\n\t\t\t  sizeof(*mk->mp) +\n\t\t\t  sizeof(mk->mp->attrs[0]) * (mk->mp->num + 1),\n\t\t\t  GFP_KERNEL);\n\tif (!new_mp)\n\t\treturn -ENOMEM;\n\tmk->mp = new_mp;\n\n\t/* Extra pointer for NULL terminator */\n\tnew_attrs = krealloc(mk->mp->grp.attrs,\n\t\t\t     sizeof(mk->mp->grp.attrs[0]) * (mk->mp->num + 2),\n\t\t\t     GFP_KERNEL);\n\tif (!new_attrs)\n\t\treturn -ENOMEM;\n\tmk->mp->grp.attrs = new_attrs;\n\n\t/* Tack new one on the end. */\n\tmemset(&mk->mp->attrs[mk->mp->num], 0, sizeof(mk->mp->attrs[0]));\n\tsysfs_attr_init(&mk->mp->attrs[mk->mp->num].mattr.attr);\n\tmk->mp->attrs[mk->mp->num].param = kp;\n\tmk->mp->attrs[mk->mp->num].mattr.show = param_attr_show;\n\t/* Do not allow runtime DAC changes to make param writable. */\n\tif ((kp->perm & (S_IWUSR | S_IWGRP | S_IWOTH)) != 0)\n\t\tmk->mp->attrs[mk->mp->num].mattr.store = param_attr_store;\n\telse\n\t\tmk->mp->attrs[mk->mp->num].mattr.store = NULL;\n\tmk->mp->attrs[mk->mp->num].mattr.attr.name = (char *)name;\n\tmk->mp->attrs[mk->mp->num].mattr.attr.mode = kp->perm;\n\tmk->mp->num++;\n\n\t/* Fix up all the pointers, since krealloc can move us */\n\tfor (i = 0; i < mk->mp->num; i++)\n\t\tmk->mp->grp.attrs[i] = &mk->mp->attrs[i].mattr.attr;\n\tmk->mp->grp.attrs[mk->mp->num] = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "kernel_param_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "589-592",
    "snippet": "void kernel_param_unlock(struct module *mod)\n{\n\tmutex_unlock(KPARAM_MUTEX(mod));\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "KPARAM_MUTEX(mod)"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KPARAM_MUTEX",
          "args": [
            "mod"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_param_unlock(struct module *mod)\n{\n\tmutex_unlock(KPARAM_MUTEX(mod));\n}"
  },
  {
    "function_name": "kernel_param_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "584-587",
    "snippet": "void kernel_param_lock(struct module *mod)\n{\n\tmutex_lock(KPARAM_MUTEX(mod));\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "KPARAM_MUTEX(mod)"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KPARAM_MUTEX",
          "args": [
            "mod"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_param_lock(struct module *mod)\n{\n\tmutex_lock(KPARAM_MUTEX(mod));\n}"
  },
  {
    "function_name": "param_attr_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "557-574",
    "snippet": "static ssize_t param_attr_store(struct module_attribute *mattr,\n\t\t\t\tstruct module_kobject *mk,\n\t\t\t\tconst char *buf, size_t len)\n{\n \tint err;\n\tstruct param_attribute *attribute = to_param_attr(mattr);\n\n\tif (!attribute->param->ops->set)\n\t\treturn -EPERM;\n\n\tkernel_param_lock(mk->mod);\n\tparam_check_unsafe(attribute->param);\n\terr = attribute->param->ops->set(buf, attribute->param);\n\tkernel_param_unlock(mk->mod);\n\tif (!err)\n\t\treturn len;\n\treturn err;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_param_unlock",
          "args": [
            "mk->mod"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_param_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "589-592",
          "snippet": "void kernel_param_unlock(struct module *mod)\n{\n\tmutex_unlock(KPARAM_MUTEX(mod));\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_param_unlock(struct module *mod)\n{\n\tmutex_unlock(KPARAM_MUTEX(mod));\n}"
        }
      },
      {
        "call_info": {
          "callee": "attribute->param->ops->set",
          "args": [
            "buf",
            "attribute->param"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param_check_unsafe",
          "args": [
            "attribute->param"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "param_check_unsafe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "111-118",
          "snippet": "static void param_check_unsafe(const struct kernel_param *kp)\n{\n\tif (kp->flags & KERNEL_PARAM_FL_UNSAFE) {\n\t\tpr_notice(\"Setting dangerous option %s - tainting kernel\\n\",\n\t\t\t  kp->name);\n\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t}\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void param_check_unsafe(const struct kernel_param *kp)\n{\n\tif (kp->flags & KERNEL_PARAM_FL_UNSAFE) {\n\t\tpr_notice(\"Setting dangerous option %s - tainting kernel\\n\",\n\t\t\t  kp->name);\n\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_param_lock",
          "args": [
            "mk->mod"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_param_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "584-587",
          "snippet": "void kernel_param_lock(struct module *mod)\n{\n\tmutex_lock(KPARAM_MUTEX(mod));\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_param_lock(struct module *mod)\n{\n\tmutex_lock(KPARAM_MUTEX(mod));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_param_attr",
          "args": [
            "mattr"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic ssize_t param_attr_store(struct module_attribute *mattr,\n\t\t\t\tstruct module_kobject *mk,\n\t\t\t\tconst char *buf, size_t len)\n{\n \tint err;\n\tstruct param_attribute *attribute = to_param_attr(mattr);\n\n\tif (!attribute->param->ops->set)\n\t\treturn -EPERM;\n\n\tkernel_param_lock(mk->mod);\n\tparam_check_unsafe(attribute->param);\n\terr = attribute->param->ops->set(buf, attribute->param);\n\tkernel_param_unlock(mk->mod);\n\tif (!err)\n\t\treturn len;\n\treturn err;\n}"
  },
  {
    "function_name": "param_attr_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "541-554",
    "snippet": "static ssize_t param_attr_show(struct module_attribute *mattr,\n\t\t\t       struct module_kobject *mk, char *buf)\n{\n\tint count;\n\tstruct param_attribute *attribute = to_param_attr(mattr);\n\n\tif (!attribute->param->ops->get)\n\t\treturn -EPERM;\n\n\tkernel_param_lock(mk->mod);\n\tcount = attribute->param->ops->get(buf, attribute->param);\n\tkernel_param_unlock(mk->mod);\n\treturn count;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_param_unlock",
          "args": [
            "mk->mod"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_param_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "589-592",
          "snippet": "void kernel_param_unlock(struct module *mod)\n{\n\tmutex_unlock(KPARAM_MUTEX(mod));\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_param_unlock(struct module *mod)\n{\n\tmutex_unlock(KPARAM_MUTEX(mod));\n}"
        }
      },
      {
        "call_info": {
          "callee": "attribute->param->ops->get",
          "args": [
            "buf",
            "attribute->param"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_param_lock",
          "args": [
            "mk->mod"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_param_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "584-587",
          "snippet": "void kernel_param_lock(struct module *mod)\n{\n\tmutex_lock(KPARAM_MUTEX(mod));\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_param_lock(struct module *mod)\n{\n\tmutex_lock(KPARAM_MUTEX(mod));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_param_attr",
          "args": [
            "mattr"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic ssize_t param_attr_show(struct module_attribute *mattr,\n\t\t\t       struct module_kobject *mk, char *buf)\n{\n\tint count;\n\tstruct param_attribute *attribute = to_param_attr(mattr);\n\n\tif (!attribute->param->ops->get)\n\t\treturn -EPERM;\n\n\tkernel_param_lock(mk->mod);\n\tcount = attribute->param->ops->get(buf, attribute->param);\n\tkernel_param_unlock(mk->mod);\n\treturn count;\n}"
  },
  {
    "function_name": "param_get_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "508-512",
    "snippet": "int param_get_string(char *buffer, const struct kernel_param *kp)\n{\n\tconst struct kparam_string *kps = kp->str;\n\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", kps->string);\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buffer",
            "PAGE_SIZE",
            "\"%s\\n\"",
            "kps->string"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_get_string(char *buffer, const struct kernel_param *kp)\n{\n\tconst struct kparam_string *kps = kp->str;\n\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", kps->string);\n}"
  },
  {
    "function_name": "param_set_copystring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "494-505",
    "snippet": "int param_set_copystring(const char *val, const struct kernel_param *kp)\n{\n\tconst struct kparam_string *kps = kp->str;\n\n\tif (strlen(val)+1 > kps->maxlen) {\n\t\tpr_err(\"%s: string doesn't fit in %u chars.\\n\",\n\t\t       kp->name, kps->maxlen-1);\n\t\treturn -ENOSPC;\n\t}\n\tstrcpy(kps->string, val);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "kps->string",
            "val"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: string doesn't fit in %u chars.\\n\"",
            "kp->name",
            "kps->maxlen-1"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "val"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_set_copystring(const char *val, const struct kernel_param *kp)\n{\n\tconst struct kparam_string *kps = kp->str;\n\n\tif (strlen(val)+1 > kps->maxlen) {\n\t\tpr_err(\"%s: string doesn't fit in %u chars.\\n\",\n\t\t       kp->name, kps->maxlen-1);\n\t\treturn -ENOSPC;\n\t}\n\tstrcpy(kps->string, val);\n\treturn 0;\n}"
  },
  {
    "function_name": "param_array_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "477-485",
    "snippet": "static void param_array_free(void *arg)\n{\n\tunsigned int i;\n\tconst struct kparam_array *arr = arg;\n\n\tif (arr->ops->free)\n\t\tfor (i = 0; i < (arr->num ? *arr->num : arr->max); i++)\n\t\t\tarr->ops->free(arr->elem + arr->elemsize * i);\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arr->ops->free",
          "args": [
            "arr->elem + arr->elemsize * i"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void param_array_free(void *arg)\n{\n\tunsigned int i;\n\tconst struct kparam_array *arr = arg;\n\n\tif (arr->ops->free)\n\t\tfor (i = 0; i < (arr->num ? *arr->num : arr->max); i++)\n\t\t\tarr->ops->free(arr->elem + arr->elemsize * i);\n}"
  },
  {
    "function_name": "param_array_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "456-475",
    "snippet": "static int param_array_get(char *buffer, const struct kernel_param *kp)\n{\n\tint i, off, ret;\n\tconst struct kparam_array *arr = kp->arr;\n\tstruct kernel_param p = *kp;\n\n\tfor (i = off = 0; i < (arr->num ? *arr->num : arr->max); i++) {\n\t\t/* Replace \\n with comma */\n\t\tif (i)\n\t\t\tbuffer[off - 1] = ',';\n\t\tp.arg = arr->elem + arr->elemsize * i;\n\t\tcheck_kparam_locked(p.mod);\n\t\tret = arr->ops->get(buffer + off, &p);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toff += ret;\n\t}\n\tbuffer[off] = '\\0';\n\treturn off;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arr->ops->get",
          "args": [
            "buffer + off",
            "&p"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_kparam_locked",
          "args": [
            "p.mod"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "check_kparam_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "44-46",
          "snippet": "static inline void check_kparam_locked(struct module *mod)\n{\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic inline void check_kparam_locked(struct module *mod)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic int param_array_get(char *buffer, const struct kernel_param *kp)\n{\n\tint i, off, ret;\n\tconst struct kparam_array *arr = kp->arr;\n\tstruct kernel_param p = *kp;\n\n\tfor (i = off = 0; i < (arr->num ? *arr->num : arr->max); i++) {\n\t\t/* Replace \\n with comma */\n\t\tif (i)\n\t\t\tbuffer[off - 1] = ',';\n\t\tp.arg = arr->elem + arr->elemsize * i;\n\t\tcheck_kparam_locked(p.mod);\n\t\tret = arr->ops->get(buffer + off, &p);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toff += ret;\n\t}\n\tbuffer[off] = '\\0';\n\treturn off;\n}"
  },
  {
    "function_name": "param_array_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "446-454",
    "snippet": "static int param_array_set(const char *val, const struct kernel_param *kp)\n{\n\tconst struct kparam_array *arr = kp->arr;\n\tunsigned int temp_num;\n\n\treturn param_array(kp->mod, kp->name, val, 1, arr->max, arr->elem,\n\t\t\t   arr->elemsize, arr->ops->set, kp->level,\n\t\t\t   arr->num ?: &temp_num);\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_array",
          "args": [
            "kp->mod",
            "kp->name",
            "val",
            "1",
            "arr->max",
            "arr->elem",
            "arr->elemsize",
            "arr->ops->set",
            "kp->level",
            "arr->num ?: &temp_num"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "param_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "397-444",
          "snippet": "static int param_array(struct module *mod,\n\t\t       const char *name,\n\t\t       const char *val,\n\t\t       unsigned int min, unsigned int max,\n\t\t       void *elem, int elemsize,\n\t\t       int (*set)(const char *, const struct kernel_param *kp),\n\t\t       s16 level,\n\t\t       unsigned int *num)\n{\n\tint ret;\n\tstruct kernel_param kp;\n\tchar save;\n\n\t/* Get the name right for errors. */\n\tkp.name = name;\n\tkp.arg = elem;\n\tkp.level = level;\n\n\t*num = 0;\n\t/* We expect a comma-separated list of values. */\n\tdo {\n\t\tint len;\n\n\t\tif (*num == max) {\n\t\t\tpr_err(\"%s: can only take %i arguments\\n\", name, max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlen = strcspn(val, \",\");\n\n\t\t/* nul-terminate and parse */\n\t\tsave = val[len];\n\t\t((char *)val)[len] = '\\0';\n\t\tcheck_kparam_locked(mod);\n\t\tret = set(val, &kp);\n\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tkp.arg += elemsize;\n\t\tval += len+1;\n\t\t(*num)++;\n\t} while (save == ',');\n\n\tif (*num < min) {\n\t\tpr_err(\"%s: needs at least %i arguments\\n\", name, min);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic int param_array(struct module *mod,\n\t\t       const char *name,\n\t\t       const char *val,\n\t\t       unsigned int min, unsigned int max,\n\t\t       void *elem, int elemsize,\n\t\t       int (*set)(const char *, const struct kernel_param *kp),\n\t\t       s16 level,\n\t\t       unsigned int *num)\n{\n\tint ret;\n\tstruct kernel_param kp;\n\tchar save;\n\n\t/* Get the name right for errors. */\n\tkp.name = name;\n\tkp.arg = elem;\n\tkp.level = level;\n\n\t*num = 0;\n\t/* We expect a comma-separated list of values. */\n\tdo {\n\t\tint len;\n\n\t\tif (*num == max) {\n\t\t\tpr_err(\"%s: can only take %i arguments\\n\", name, max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlen = strcspn(val, \",\");\n\n\t\t/* nul-terminate and parse */\n\t\tsave = val[len];\n\t\t((char *)val)[len] = '\\0';\n\t\tcheck_kparam_locked(mod);\n\t\tret = set(val, &kp);\n\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tkp.arg += elemsize;\n\t\tval += len+1;\n\t\t(*num)++;\n\t} while (save == ',');\n\n\tif (*num < min) {\n\t\tpr_err(\"%s: needs at least %i arguments\\n\", name, min);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic int param_array_set(const char *val, const struct kernel_param *kp)\n{\n\tconst struct kparam_array *arr = kp->arr;\n\tunsigned int temp_num;\n\n\treturn param_array(kp->mod, kp->name, val, 1, arr->max, arr->elem,\n\t\t\t   arr->elemsize, arr->ops->set, kp->level,\n\t\t\t   arr->num ?: &temp_num);\n}"
  },
  {
    "function_name": "param_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "397-444",
    "snippet": "static int param_array(struct module *mod,\n\t\t       const char *name,\n\t\t       const char *val,\n\t\t       unsigned int min, unsigned int max,\n\t\t       void *elem, int elemsize,\n\t\t       int (*set)(const char *, const struct kernel_param *kp),\n\t\t       s16 level,\n\t\t       unsigned int *num)\n{\n\tint ret;\n\tstruct kernel_param kp;\n\tchar save;\n\n\t/* Get the name right for errors. */\n\tkp.name = name;\n\tkp.arg = elem;\n\tkp.level = level;\n\n\t*num = 0;\n\t/* We expect a comma-separated list of values. */\n\tdo {\n\t\tint len;\n\n\t\tif (*num == max) {\n\t\t\tpr_err(\"%s: can only take %i arguments\\n\", name, max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlen = strcspn(val, \",\");\n\n\t\t/* nul-terminate and parse */\n\t\tsave = val[len];\n\t\t((char *)val)[len] = '\\0';\n\t\tcheck_kparam_locked(mod);\n\t\tret = set(val, &kp);\n\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tkp.arg += elemsize;\n\t\tval += len+1;\n\t\t(*num)++;\n\t} while (save == ',');\n\n\tif (*num < min) {\n\t\tpr_err(\"%s: needs at least %i arguments\\n\", name, min);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: needs at least %i arguments\\n\"",
            "name",
            "min"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set",
          "args": [
            "val",
            "&kp"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "param_set_copystring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "494-505",
          "snippet": "int param_set_copystring(const char *val, const struct kernel_param *kp)\n{\n\tconst struct kparam_string *kps = kp->str;\n\n\tif (strlen(val)+1 > kps->maxlen) {\n\t\tpr_err(\"%s: string doesn't fit in %u chars.\\n\",\n\t\t       kp->name, kps->maxlen-1);\n\t\treturn -ENOSPC;\n\t}\n\tstrcpy(kps->string, val);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_set_copystring(const char *val, const struct kernel_param *kp)\n{\n\tconst struct kparam_string *kps = kp->str;\n\n\tif (strlen(val)+1 > kps->maxlen) {\n\t\tpr_err(\"%s: string doesn't fit in %u chars.\\n\",\n\t\t       kp->name, kps->maxlen-1);\n\t\treturn -ENOSPC;\n\t}\n\tstrcpy(kps->string, val);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_kparam_locked",
          "args": [
            "mod"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "check_kparam_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "44-46",
          "snippet": "static inline void check_kparam_locked(struct module *mod)\n{\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic inline void check_kparam_locked(struct module *mod)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "val",
            "\",\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: can only take %i arguments\\n\"",
            "name",
            "max"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic int param_array(struct module *mod,\n\t\t       const char *name,\n\t\t       const char *val,\n\t\t       unsigned int min, unsigned int max,\n\t\t       void *elem, int elemsize,\n\t\t       int (*set)(const char *, const struct kernel_param *kp),\n\t\t       s16 level,\n\t\t       unsigned int *num)\n{\n\tint ret;\n\tstruct kernel_param kp;\n\tchar save;\n\n\t/* Get the name right for errors. */\n\tkp.name = name;\n\tkp.arg = elem;\n\tkp.level = level;\n\n\t*num = 0;\n\t/* We expect a comma-separated list of values. */\n\tdo {\n\t\tint len;\n\n\t\tif (*num == max) {\n\t\t\tpr_err(\"%s: can only take %i arguments\\n\", name, max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlen = strcspn(val, \",\");\n\n\t\t/* nul-terminate and parse */\n\t\tsave = val[len];\n\t\t((char *)val)[len] = '\\0';\n\t\tcheck_kparam_locked(mod);\n\t\tret = set(val, &kp);\n\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tkp.arg += elemsize;\n\t\tval += len+1;\n\t\t(*num)++;\n\t} while (save == ',');\n\n\tif (*num < min) {\n\t\tpr_err(\"%s: needs at least %i arguments\\n\", name, min);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "param_set_bint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "373-386",
    "snippet": "int param_set_bint(const char *val, const struct kernel_param *kp)\n{\n\t/* Match bool exactly, by re-using it. */\n\tstruct kernel_param boolkp = *kp;\n\tbool v;\n\tint ret;\n\n\tboolkp.arg = &v;\n\n\tret = param_set_bool(val, &boolkp);\n\tif (ret == 0)\n\t\t*(int *)kp->arg = v;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_set_bool",
          "args": [
            "val",
            "&boolkp"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "param_set_bool_enable_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "315-336",
          "snippet": "int param_set_bool_enable_only(const char *val, const struct kernel_param *kp)\n{\n\tint err = 0;\n\tbool new_value;\n\tbool orig_value = *(bool *)kp->arg;\n\tstruct kernel_param dummy_kp = *kp;\n\n\tdummy_kp.arg = &new_value;\n\n\terr = param_set_bool(val, &dummy_kp);\n\tif (err)\n\t\treturn err;\n\n\t/* Don't let them unset it once it's set! */\n\tif (!new_value && orig_value)\n\t\treturn -EROFS;\n\n\tif (new_value)\n\t\terr = param_set_bool(val, kp);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_set_bool_enable_only(const char *val, const struct kernel_param *kp)\n{\n\tint err = 0;\n\tbool new_value;\n\tbool orig_value = *(bool *)kp->arg;\n\tstruct kernel_param dummy_kp = *kp;\n\n\tdummy_kp.arg = &new_value;\n\n\terr = param_set_bool(val, &dummy_kp);\n\tif (err)\n\t\treturn err;\n\n\t/* Don't let them unset it once it's set! */\n\tif (!new_value && orig_value)\n\t\treturn -EROFS;\n\n\tif (new_value)\n\t\terr = param_set_bool(val, kp);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_set_bint(const char *val, const struct kernel_param *kp)\n{\n\t/* Match bool exactly, by re-using it. */\n\tstruct kernel_param boolkp = *kp;\n\tbool v;\n\tint ret;\n\n\tboolkp.arg = &v;\n\n\tret = param_set_bool(val, &boolkp);\n\tif (ret == 0)\n\t\t*(int *)kp->arg = v;\n\treturn ret;\n}"
  },
  {
    "function_name": "param_get_invbool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "361-364",
    "snippet": "int param_get_invbool(char *buffer, const struct kernel_param *kp)\n{\n\treturn sprintf(buffer, \"%c\\n\", (*(bool *)kp->arg) ? 'N' : 'Y');\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"%c\\n\"",
            "(*(bool *)kp->arg) ? 'N' : 'Y'"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_get_invbool(char *buffer, const struct kernel_param *kp)\n{\n\treturn sprintf(buffer, \"%c\\n\", (*(bool *)kp->arg) ? 'N' : 'Y');\n}"
  },
  {
    "function_name": "param_set_invbool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "347-358",
    "snippet": "int param_set_invbool(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tbool boolval;\n\tstruct kernel_param dummy;\n\n\tdummy.arg = &boolval;\n\tret = param_set_bool(val, &dummy);\n\tif (ret == 0)\n\t\t*(bool *)kp->arg = !boolval;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_set_bool",
          "args": [
            "val",
            "&dummy"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "param_set_bool_enable_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "315-336",
          "snippet": "int param_set_bool_enable_only(const char *val, const struct kernel_param *kp)\n{\n\tint err = 0;\n\tbool new_value;\n\tbool orig_value = *(bool *)kp->arg;\n\tstruct kernel_param dummy_kp = *kp;\n\n\tdummy_kp.arg = &new_value;\n\n\terr = param_set_bool(val, &dummy_kp);\n\tif (err)\n\t\treturn err;\n\n\t/* Don't let them unset it once it's set! */\n\tif (!new_value && orig_value)\n\t\treturn -EROFS;\n\n\tif (new_value)\n\t\terr = param_set_bool(val, kp);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_set_bool_enable_only(const char *val, const struct kernel_param *kp)\n{\n\tint err = 0;\n\tbool new_value;\n\tbool orig_value = *(bool *)kp->arg;\n\tstruct kernel_param dummy_kp = *kp;\n\n\tdummy_kp.arg = &new_value;\n\n\terr = param_set_bool(val, &dummy_kp);\n\tif (err)\n\t\treturn err;\n\n\t/* Don't let them unset it once it's set! */\n\tif (!new_value && orig_value)\n\t\treturn -EROFS;\n\n\tif (new_value)\n\t\terr = param_set_bool(val, kp);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_set_invbool(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tbool boolval;\n\tstruct kernel_param dummy;\n\n\tdummy.arg = &boolval;\n\tret = param_set_bool(val, &dummy);\n\tif (ret == 0)\n\t\t*(bool *)kp->arg = !boolval;\n\treturn ret;\n}"
  },
  {
    "function_name": "param_set_bool_enable_only",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "315-336",
    "snippet": "int param_set_bool_enable_only(const char *val, const struct kernel_param *kp)\n{\n\tint err = 0;\n\tbool new_value;\n\tbool orig_value = *(bool *)kp->arg;\n\tstruct kernel_param dummy_kp = *kp;\n\n\tdummy_kp.arg = &new_value;\n\n\terr = param_set_bool(val, &dummy_kp);\n\tif (err)\n\t\treturn err;\n\n\t/* Don't let them unset it once it's set! */\n\tif (!new_value && orig_value)\n\t\treturn -EROFS;\n\n\tif (new_value)\n\t\terr = param_set_bool(val, kp);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_set_bool",
          "args": [
            "val",
            "kp"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "param_set_bool_enable_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "315-336",
          "snippet": "int param_set_bool_enable_only(const char *val, const struct kernel_param *kp)\n{\n\tint err = 0;\n\tbool new_value;\n\tbool orig_value = *(bool *)kp->arg;\n\tstruct kernel_param dummy_kp = *kp;\n\n\tdummy_kp.arg = &new_value;\n\n\terr = param_set_bool(val, &dummy_kp);\n\tif (err)\n\t\treturn err;\n\n\t/* Don't let them unset it once it's set! */\n\tif (!new_value && orig_value)\n\t\treturn -EROFS;\n\n\tif (new_value)\n\t\terr = param_set_bool(val, kp);\n\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_set_bool_enable_only(const char *val, const struct kernel_param *kp)\n{\n\tint err = 0;\n\tbool new_value;\n\tbool orig_value = *(bool *)kp->arg;\n\tstruct kernel_param dummy_kp = *kp;\n\n\tdummy_kp.arg = &new_value;\n\n\terr = param_set_bool(val, &dummy_kp);\n\tif (err)\n\t\treturn err;\n\n\t/* Don't let them unset it once it's set! */\n\tif (!new_value && orig_value)\n\t\treturn -EROFS;\n\n\tif (new_value)\n\t\terr = param_set_bool(val, kp);\n\n\treturn err;\n}"
  },
  {
    "function_name": "param_get_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "301-305",
    "snippet": "int param_get_bool(char *buffer, const struct kernel_param *kp)\n{\n\t/* Y and N chosen as being relatively non-coder friendly */\n\treturn sprintf(buffer, \"%c\\n\", *(bool *)kp->arg ? 'Y' : 'N');\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"%c\\n\"",
            "*(bool *)kp->arg ? 'Y' : 'N'"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_get_bool(char *buffer, const struct kernel_param *kp)\n{\n\t/* Y and N chosen as being relatively non-coder friendly */\n\treturn sprintf(buffer, \"%c\\n\", *(bool *)kp->arg ? 'Y' : 'N');\n}"
  },
  {
    "function_name": "param_set_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "291-298",
    "snippet": "int param_set_bool(const char *val, const struct kernel_param *kp)\n{\n\t/* No equals means \"set\"... */\n\tif (!val) val = \"1\";\n\n\t/* One of =[yYnN01] */\n\treturn strtobool(val, kp->arg);\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtobool",
          "args": [
            "val",
            "kp->arg"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_set_bool(const char *val, const struct kernel_param *kp)\n{\n\t/* No equals means \"set\"... */\n\tif (!val) val = \"1\";\n\n\t/* One of =[yYnN01] */\n\treturn strtobool(val, kp->arg);\n}"
  },
  {
    "function_name": "param_free_charp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "277-280",
    "snippet": "void param_free_charp(void *arg)\n{\n\tmaybe_kfree_parameter(*((char **)arg));\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maybe_kfree_parameter",
          "args": [
            "*((char **)arg)"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid param_free_charp(void *arg)\n{\n\tmaybe_kfree_parameter(*((char **)arg));\n}"
  },
  {
    "function_name": "param_get_charp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "271-274",
    "snippet": "int param_get_charp(char *buffer, const struct kernel_param *kp)\n{\n\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", *((char **)kp->arg));\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buffer",
            "PAGE_SIZE",
            "\"%s\\n\"",
            "*((char **)kp->arg)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_get_charp(char *buffer, const struct kernel_param *kp)\n{\n\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", *((char **)kp->arg));\n}"
  },
  {
    "function_name": "param_set_charp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "248-268",
    "snippet": "int param_set_charp(const char *val, const struct kernel_param *kp)\n{\n\tif (strlen(val) > 1024) {\n\t\tpr_err(\"%s: string parameter too long\\n\", kp->name);\n\t\treturn -ENOSPC;\n\t}\n\n\tmaybe_kfree_parameter(*(char **)kp->arg);\n\n\t/* This is a hack.  We can't kmalloc in early boot, and we\n\t * don't need to; this mangled commandline is preserved. */\n\tif (slab_is_available()) {\n\t\t*(char **)kp->arg = kmalloc_parameter(strlen(val)+1);\n\t\tif (!*(char **)kp->arg)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(*(char **)kp->arg, val);\n\t} else\n\t\t*(const char **)kp->arg = val;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "*(char **)kp->arg",
            "val"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_parameter",
          "args": [
            "strlen(val)+1"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "57-70",
          "snippet": "static void *kmalloc_parameter(unsigned int size)\n{\n\tstruct kmalloced_param *p;\n\n\tp = kmalloc(sizeof(*p) + size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_add(&p->list, &kmalloced_params);\n\tspin_unlock(&kmalloced_params_lock);\n\n\treturn p->val;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void *kmalloc_parameter(unsigned int size)\n{\n\tstruct kmalloced_param *p;\n\n\tp = kmalloc(sizeof(*p) + size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_add(&p->list, &kmalloced_params);\n\tspin_unlock(&kmalloced_params_lock);\n\n\treturn p->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "val"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_kfree_parameter",
          "args": [
            "*(char **)kp->arg"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: string parameter too long\\n\"",
            "kp->name"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint param_set_charp(const char *val, const struct kernel_param *kp)\n{\n\tif (strlen(val) > 1024) {\n\t\tpr_err(\"%s: string parameter too long\\n\", kp->name);\n\t\treturn -ENOSPC;\n\t}\n\n\tmaybe_kfree_parameter(*(char **)kp->arg);\n\n\t/* This is a hack.  We can't kmalloc in early boot, and we\n\t * don't need to; this mangled commandline is preserved. */\n\tif (slab_is_available()) {\n\t\t*(char **)kp->arg = kmalloc_parameter(strlen(val)+1);\n\t\tif (!*(char **)kp->arg)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(*(char **)kp->arg, val);\n\t} else\n\t\t*(const char **)kp->arg = val;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "164-217",
    "snippet": "char *parse_args(const char *doing,\n\t\t char *args,\n\t\t const struct kernel_param *params,\n\t\t unsigned num,\n\t\t s16 min_level,\n\t\t s16 max_level,\n\t\t void *arg,\n\t\t int (*unknown)(char *param, char *val,\n\t\t\t\tconst char *doing, void *arg))\n{\n\tchar *param, *val, *err = NULL;\n\n\t/* Chew leading spaces */\n\targs = skip_spaces(args);\n\n\tif (*args)\n\t\tpr_debug(\"doing %s, parsing ARGS: '%s'\\n\", doing, args);\n\n\twhile (*args) {\n\t\tint ret;\n\t\tint irq_was_disabled;\n\n\t\targs = next_arg(args, &param, &val);\n\t\t/* Stop at -- */\n\t\tif (!val && strcmp(param, \"--\") == 0)\n\t\t\treturn err ?: args;\n\t\tirq_was_disabled = irqs_disabled();\n\t\tret = parse_one(param, val, doing, params, num,\n\t\t\t\tmin_level, max_level, arg, unknown);\n\t\tif (irq_was_disabled && !irqs_disabled())\n\t\t\tpr_warn(\"%s: option '%s' enabled irq's!\\n\",\n\t\t\t\tdoing, param);\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase -ENOENT:\n\t\t\tpr_err(\"%s: Unknown parameter `%s'\\n\", doing, param);\n\t\t\tbreak;\n\t\tcase -ENOSPC:\n\t\t\tpr_err(\"%s: `%s' too large for parameter `%s'\\n\",\n\t\t\t       doing, val ?: \"\", param);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s: `%s' invalid for parameter `%s'\\n\",\n\t\t\t       doing, val ?: \"\", param);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = ERR_PTR(ret);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: `%s' invalid for parameter `%s'\\n\"",
            "doing",
            "val ?: \"\"",
            "param"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: `%s' too large for parameter `%s'\\n\"",
            "doing",
            "val ?: \"\"",
            "param"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Unknown parameter `%s'\\n\"",
            "doing",
            "param"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: option '%s' enabled irq's!\\n\"",
            "doing",
            "param"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_one",
          "args": [
            "param",
            "val",
            "doing",
            "params",
            "num",
            "min_level",
            "max_level",
            "arg",
            "unknown"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "parse_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "120-161",
          "snippet": "static int parse_one(char *param,\n\t\t     char *val,\n\t\t     const char *doing,\n\t\t     const struct kernel_param *params,\n\t\t     unsigned num_params,\n\t\t     s16 min_level,\n\t\t     s16 max_level,\n\t\t     void *arg,\n\t\t     int (*handle_unknown)(char *param, char *val,\n\t\t\t\t     const char *doing, void *arg))\n{\n\tunsigned int i;\n\tint err;\n\n\t/* Find parameter */\n\tfor (i = 0; i < num_params; i++) {\n\t\tif (parameq(param, params[i].name)) {\n\t\t\tif (params[i].level < min_level\n\t\t\t    || params[i].level > max_level)\n\t\t\t\treturn 0;\n\t\t\t/* No one handled NULL, so do it here. */\n\t\t\tif (!val &&\n\t\t\t    !(params[i].ops->flags & KERNEL_PARAM_OPS_FL_NOARG))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"handling %s with %p\\n\", param,\n\t\t\t\tparams[i].ops->set);\n\t\t\tkernel_param_lock(params[i].mod);\n\t\t\tparam_check_unsafe(&params[i]);\n\t\t\terr = params[i].ops->set(val, &params[i]);\n\t\t\tkernel_param_unlock(params[i].mod);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (handle_unknown) {\n\t\tpr_debug(\"doing %s: %s='%s'\\n\", doing, param, val);\n\t\treturn handle_unknown(param, val, doing, arg);\n\t}\n\n\tpr_debug(\"Unknown argument '%s'\\n\", param);\n\treturn -ENOENT;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic int parse_one(char *param,\n\t\t     char *val,\n\t\t     const char *doing,\n\t\t     const struct kernel_param *params,\n\t\t     unsigned num_params,\n\t\t     s16 min_level,\n\t\t     s16 max_level,\n\t\t     void *arg,\n\t\t     int (*handle_unknown)(char *param, char *val,\n\t\t\t\t     const char *doing, void *arg))\n{\n\tunsigned int i;\n\tint err;\n\n\t/* Find parameter */\n\tfor (i = 0; i < num_params; i++) {\n\t\tif (parameq(param, params[i].name)) {\n\t\t\tif (params[i].level < min_level\n\t\t\t    || params[i].level > max_level)\n\t\t\t\treturn 0;\n\t\t\t/* No one handled NULL, so do it here. */\n\t\t\tif (!val &&\n\t\t\t    !(params[i].ops->flags & KERNEL_PARAM_OPS_FL_NOARG))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"handling %s with %p\\n\", param,\n\t\t\t\tparams[i].ops->set);\n\t\t\tkernel_param_lock(params[i].mod);\n\t\t\tparam_check_unsafe(&params[i]);\n\t\t\terr = params[i].ops->set(val, &params[i]);\n\t\t\tkernel_param_unlock(params[i].mod);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (handle_unknown) {\n\t\tpr_debug(\"doing %s: %s='%s'\\n\", doing, param, val);\n\t\treturn handle_unknown(param, val, doing, arg);\n\t}\n\n\tpr_debug(\"Unknown argument '%s'\\n\", param);\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "param",
            "\"--\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_arg",
          "args": [
            "args",
            "&param",
            "&val"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"doing %s, parsing ARGS: '%s'\\n\"",
            "doing",
            "args"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "args"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "2061-2068",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nchar *parse_args(const char *doing,\n\t\t char *args,\n\t\t const struct kernel_param *params,\n\t\t unsigned num,\n\t\t s16 min_level,\n\t\t s16 max_level,\n\t\t void *arg,\n\t\t int (*unknown)(char *param, char *val,\n\t\t\t\tconst char *doing, void *arg))\n{\n\tchar *param, *val, *err = NULL;\n\n\t/* Chew leading spaces */\n\targs = skip_spaces(args);\n\n\tif (*args)\n\t\tpr_debug(\"doing %s, parsing ARGS: '%s'\\n\", doing, args);\n\n\twhile (*args) {\n\t\tint ret;\n\t\tint irq_was_disabled;\n\n\t\targs = next_arg(args, &param, &val);\n\t\t/* Stop at -- */\n\t\tif (!val && strcmp(param, \"--\") == 0)\n\t\t\treturn err ?: args;\n\t\tirq_was_disabled = irqs_disabled();\n\t\tret = parse_one(param, val, doing, params, num,\n\t\t\t\tmin_level, max_level, arg, unknown);\n\t\tif (irq_was_disabled && !irqs_disabled())\n\t\t\tpr_warn(\"%s: option '%s' enabled irq's!\\n\",\n\t\t\t\tdoing, param);\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase -ENOENT:\n\t\t\tpr_err(\"%s: Unknown parameter `%s'\\n\", doing, param);\n\t\t\tbreak;\n\t\tcase -ENOSPC:\n\t\t\tpr_err(\"%s: `%s' too large for parameter `%s'\\n\",\n\t\t\t       doing, val ?: \"\", param);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s: `%s' invalid for parameter `%s'\\n\",\n\t\t\t       doing, val ?: \"\", param);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = ERR_PTR(ret);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "parse_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "120-161",
    "snippet": "static int parse_one(char *param,\n\t\t     char *val,\n\t\t     const char *doing,\n\t\t     const struct kernel_param *params,\n\t\t     unsigned num_params,\n\t\t     s16 min_level,\n\t\t     s16 max_level,\n\t\t     void *arg,\n\t\t     int (*handle_unknown)(char *param, char *val,\n\t\t\t\t     const char *doing, void *arg))\n{\n\tunsigned int i;\n\tint err;\n\n\t/* Find parameter */\n\tfor (i = 0; i < num_params; i++) {\n\t\tif (parameq(param, params[i].name)) {\n\t\t\tif (params[i].level < min_level\n\t\t\t    || params[i].level > max_level)\n\t\t\t\treturn 0;\n\t\t\t/* No one handled NULL, so do it here. */\n\t\t\tif (!val &&\n\t\t\t    !(params[i].ops->flags & KERNEL_PARAM_OPS_FL_NOARG))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"handling %s with %p\\n\", param,\n\t\t\t\tparams[i].ops->set);\n\t\t\tkernel_param_lock(params[i].mod);\n\t\t\tparam_check_unsafe(&params[i]);\n\t\t\terr = params[i].ops->set(val, &params[i]);\n\t\t\tkernel_param_unlock(params[i].mod);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (handle_unknown) {\n\t\tpr_debug(\"doing %s: %s='%s'\\n\", doing, param, val);\n\t\treturn handle_unknown(param, val, doing, arg);\n\t}\n\n\tpr_debug(\"Unknown argument '%s'\\n\", param);\n\treturn -ENOENT;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Unknown argument '%s'\\n\"",
            "param"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_unknown",
          "args": [
            "param",
            "val",
            "doing",
            "arg"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"doing %s: %s='%s'\\n\"",
            "doing",
            "param",
            "val"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_param_unlock",
          "args": [
            "params[i].mod"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_param_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "589-592",
          "snippet": "void kernel_param_unlock(struct module *mod)\n{\n\tmutex_unlock(KPARAM_MUTEX(mod));\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_param_unlock(struct module *mod)\n{\n\tmutex_unlock(KPARAM_MUTEX(mod));\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[i].ops->set",
          "args": [
            "val",
            "&params[i]"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param_check_unsafe",
          "args": [
            "&params[i]"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "param_check_unsafe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "111-118",
          "snippet": "static void param_check_unsafe(const struct kernel_param *kp)\n{\n\tif (kp->flags & KERNEL_PARAM_FL_UNSAFE) {\n\t\tpr_notice(\"Setting dangerous option %s - tainting kernel\\n\",\n\t\t\t  kp->name);\n\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t}\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void param_check_unsafe(const struct kernel_param *kp)\n{\n\tif (kp->flags & KERNEL_PARAM_FL_UNSAFE) {\n\t\tpr_notice(\"Setting dangerous option %s - tainting kernel\\n\",\n\t\t\t  kp->name);\n\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_param_lock",
          "args": [
            "params[i].mod"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_param_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "584-587",
          "snippet": "void kernel_param_lock(struct module *mod)\n{\n\tmutex_lock(KPARAM_MUTEX(mod));\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_param_lock(struct module *mod)\n{\n\tmutex_lock(KPARAM_MUTEX(mod));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"handling %s with %p\\n\"",
            "param",
            "params[i].ops->set"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameq",
          "args": [
            "param",
            "params[i].name"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "parameq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "106-109",
          "snippet": "bool parameq(const char *a, const char *b)\n{\n\treturn parameqn(a, b, strlen(a)+1);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nbool parameq(const char *a, const char *b)\n{\n\treturn parameqn(a, b, strlen(a)+1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic int parse_one(char *param,\n\t\t     char *val,\n\t\t     const char *doing,\n\t\t     const struct kernel_param *params,\n\t\t     unsigned num_params,\n\t\t     s16 min_level,\n\t\t     s16 max_level,\n\t\t     void *arg,\n\t\t     int (*handle_unknown)(char *param, char *val,\n\t\t\t\t     const char *doing, void *arg))\n{\n\tunsigned int i;\n\tint err;\n\n\t/* Find parameter */\n\tfor (i = 0; i < num_params; i++) {\n\t\tif (parameq(param, params[i].name)) {\n\t\t\tif (params[i].level < min_level\n\t\t\t    || params[i].level > max_level)\n\t\t\t\treturn 0;\n\t\t\t/* No one handled NULL, so do it here. */\n\t\t\tif (!val &&\n\t\t\t    !(params[i].ops->flags & KERNEL_PARAM_OPS_FL_NOARG))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"handling %s with %p\\n\", param,\n\t\t\t\tparams[i].ops->set);\n\t\t\tkernel_param_lock(params[i].mod);\n\t\t\tparam_check_unsafe(&params[i]);\n\t\t\terr = params[i].ops->set(val, &params[i]);\n\t\t\tkernel_param_unlock(params[i].mod);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (handle_unknown) {\n\t\tpr_debug(\"doing %s: %s='%s'\\n\", doing, param, val);\n\t\treturn handle_unknown(param, val, doing, arg);\n\t}\n\n\tpr_debug(\"Unknown argument '%s'\\n\", param);\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "param_check_unsafe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "111-118",
    "snippet": "static void param_check_unsafe(const struct kernel_param *kp)\n{\n\tif (kp->flags & KERNEL_PARAM_FL_UNSAFE) {\n\t\tpr_notice(\"Setting dangerous option %s - tainting kernel\\n\",\n\t\t\t  kp->name);\n\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t}\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_USER",
            "LOCKDEP_STILL_OK"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "add_taint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "386-392",
          "snippet": "void add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\n\nvoid add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Setting dangerous option %s - tainting kernel\\n\"",
            "kp->name"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic void param_check_unsafe(const struct kernel_param *kp)\n{\n\tif (kp->flags & KERNEL_PARAM_FL_UNSAFE) {\n\t\tpr_notice(\"Setting dangerous option %s - tainting kernel\\n\",\n\t\t\t  kp->name);\n\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t}\n}"
  },
  {
    "function_name": "parameq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "106-109",
    "snippet": "bool parameq(const char *a, const char *b)\n{\n\treturn parameqn(a, b, strlen(a)+1);\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parameqn",
          "args": [
            "a",
            "b",
            "strlen(a)+1"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "parameqn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "95-104",
          "snippet": "bool parameqn(const char *a, const char *b, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (dash2underscore(a[i]) != dash2underscore(b[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nbool parameqn(const char *a, const char *b, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (dash2underscore(a[i]) != dash2underscore(b[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "a"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nbool parameq(const char *a, const char *b)\n{\n\treturn parameqn(a, b, strlen(a)+1);\n}"
  },
  {
    "function_name": "parameqn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "95-104",
    "snippet": "bool parameqn(const char *a, const char *b, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (dash2underscore(a[i]) != dash2underscore(b[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dash2underscore",
          "args": [
            "b[i]"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "dash2underscore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "88-93",
          "snippet": "static char dash2underscore(char c)\n{\n\tif (c == '-')\n\t\treturn '_';\n\treturn c;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic char dash2underscore(char c)\n{\n\tif (c == '-')\n\t\treturn '_';\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nbool parameqn(const char *a, const char *b, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (dash2underscore(a[i]) != dash2underscore(b[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "dash2underscore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "88-93",
    "snippet": "static char dash2underscore(char c)\n{\n\tif (c == '-')\n\t\treturn '_';\n\treturn c;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic char dash2underscore(char c)\n{\n\tif (c == '-')\n\t\treturn '_';\n\treturn c;\n}"
  },
  {
    "function_name": "maybe_kfree_parameter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "73-86",
    "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kmalloced_params);",
      "static DEFINE_SPINLOCK(kmalloced_params_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kmalloced_params_lock"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&p->list"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&kmalloced_params",
            "list"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kmalloced_params_lock"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
  },
  {
    "function_name": "kmalloc_parameter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "57-70",
    "snippet": "static void *kmalloc_parameter(unsigned int size)\n{\n\tstruct kmalloced_param *p;\n\n\tp = kmalloc(sizeof(*p) + size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_add(&p->list, &kmalloced_params);\n\tspin_unlock(&kmalloced_params_lock);\n\n\treturn p->val;\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kmalloced_params);",
      "static DEFINE_SPINLOCK(kmalloced_params_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kmalloced_params_lock"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&p->list",
            "&kmalloced_params"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kmalloced_params_lock"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*p) + size",
            "GFP_KERNEL"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void *kmalloc_parameter(unsigned int size)\n{\n\tstruct kmalloced_param *p;\n\n\tp = kmalloc(sizeof(*p) + size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_add(&p->list, &kmalloced_params);\n\tspin_unlock(&kmalloced_params_lock);\n\n\treturn p->val;\n}"
  },
  {
    "function_name": "check_kparam_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "44-46",
    "snippet": "static inline void check_kparam_locked(struct module *mod)\n{\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic inline void check_kparam_locked(struct module *mod)\n{\n}"
  },
  {
    "function_name": "check_kparam_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
    "lines": "39-42",
    "snippet": "static inline void check_kparam_locked(struct module *mod)\n{\n\tBUG_ON(!mutex_is_locked(KPARAM_MUTEX(mod)));\n}",
    "includes": [
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/device.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(KPARAM_MUTEX(mod))"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "KPARAM_MUTEX(mod)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KPARAM_MUTEX",
          "args": [
            "mod"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic inline void check_kparam_locked(struct module *mod)\n{\n\tBUG_ON(!mutex_is_locked(KPARAM_MUTEX(mod)));\n}"
  }
]