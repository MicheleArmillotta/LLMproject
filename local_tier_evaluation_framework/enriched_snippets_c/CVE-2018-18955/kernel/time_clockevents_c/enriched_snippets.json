[
  {
    "function_name": "clockevents_init_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "765-772",
    "snippet": "static int __init clockevents_init_sysfs(void)\n{\n\tint err = subsys_system_register(&clockevents_subsys, NULL);\n\n\tif (!err)\n\t\terr = tick_init_sysfs();\n\treturn err;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_init_sysfs",
          "args": [],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "tick_init_sysfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "744-763",
          "snippet": "static int __init tick_init_sysfs(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = &per_cpu(tick_percpu_dev, cpu);\n\t\tint err;\n\n\t\tdev->id = cpu;\n\t\tdev->bus = &clockevents_subsys;\n\t\terr = device_register(dev);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_current_device);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_unbind_device);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn tick_broadcast_init_sysfs();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __init tick_init_sysfs(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = &per_cpu(tick_percpu_dev, cpu);\n\t\tint err;\n\n\t\tdev->id = cpu;\n\t\tdev->bus = &clockevents_subsys;\n\t\terr = device_register(dev);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_current_device);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_unbind_device);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn tick_broadcast_init_sysfs();\n}"
        }
      },
      {
        "call_info": {
          "callee": "subsys_system_register",
          "args": [
            "&clockevents_subsys",
            "NULL"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __init clockevents_init_sysfs(void)\n{\n\tint err = subsys_system_register(&clockevents_subsys, NULL);\n\n\tif (!err)\n\t\terr = tick_init_sysfs();\n\treturn err;\n}"
  },
  {
    "function_name": "tick_init_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "744-763",
    "snippet": "static int __init tick_init_sysfs(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = &per_cpu(tick_percpu_dev, cpu);\n\t\tint err;\n\n\t\tdev->id = cpu;\n\t\tdev->bus = &clockevents_subsys;\n\t\terr = device_register(dev);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_current_device);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_unbind_device);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn tick_broadcast_init_sysfs();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_broadcast_init_sysfs",
          "args": [],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_init_sysfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "741-741",
          "snippet": "static inline int tick_broadcast_init_sysfs(void) { return 0; }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic inline int tick_broadcast_init_sysfs(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "dev",
            "&dev_attr_unbind_device"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "dev",
            "&dev_attr_current_device"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_register",
          "args": [
            "dev"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_percpu_dev",
            "cpu"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __init tick_init_sysfs(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = &per_cpu(tick_percpu_dev, cpu);\n\t\tint err;\n\n\t\tdev->id = cpu;\n\t\tdev->bus = &clockevents_subsys;\n\t\terr = device_register(dev);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_current_device);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_unbind_device);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn tick_broadcast_init_sysfs();\n}"
  },
  {
    "function_name": "tick_broadcast_init_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "741-741",
    "snippet": "static inline int tick_broadcast_init_sysfs(void) { return 0; }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic inline int tick_broadcast_init_sysfs(void) { return 0; }"
  },
  {
    "function_name": "tick_get_tick_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "737-740",
    "snippet": "static struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn &per_cpu(tick_cpu_device, dev->id);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "dev->id"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn &per_cpu(tick_cpu_device, dev->id);\n}"
  },
  {
    "function_name": "tick_broadcast_init_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "728-735",
    "snippet": "static __init int tick_broadcast_init_sysfs(void)\n{\n\tint err = device_register(&tick_bc_dev);\n\n\tif (!err)\n\t\terr = device_create_file(&tick_bc_dev, &dev_attr_current_device);\n\treturn err;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "&tick_bc_dev",
            "&dev_attr_current_device"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_register",
          "args": [
            "&tick_bc_dev"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic __init int tick_broadcast_init_sysfs(void)\n{\n\tint err = device_register(&tick_bc_dev);\n\n\tif (!err)\n\t\terr = device_create_file(&tick_bc_dev, &dev_attr_current_device);\n\treturn err;\n}"
  },
  {
    "function_name": "tick_get_tick_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "722-726",
    "snippet": "static struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn dev == &tick_bc_dev ? tick_get_broadcast_device() :\n\t\t&per_cpu(tick_cpu_device, dev->id);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "dev->id"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_get_broadcast_device",
          "args": [],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_broadcast_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "52-55",
          "snippet": "struct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstruct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn dev == &tick_bc_dev ? tick_get_broadcast_device() :\n\t\t&per_cpu(tick_cpu_device, dev->id);\n}"
  },
  {
    "function_name": "sysfs_unbind_tick_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "684-712",
    "snippet": "static ssize_t sysfs_unbind_tick_dev(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tchar name[CS_NAME_LEN];\n\tssize_t ret = sysfs_get_uname(buf, name, count);\n\tstruct clock_event_device *ce;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ENODEV;\n\tmutex_lock(&clockevents_mutex);\n\traw_spin_lock_irq(&clockevents_lock);\n\tlist_for_each_entry(ce, &clockevent_devices, list) {\n\t\tif (!strcmp(ce->name, name)) {\n\t\t\tret = __clockevents_try_unbind(ce, dev->id);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irq(&clockevents_lock);\n\t/*\n\t * We hold clockevents_mutex, so ce can't go away\n\t */\n\tif (ret == -EAGAIN)\n\t\tret = clockevents_unbind(ce, dev->id);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);",
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);",
      "static DEFINE_MUTEX(clockevents_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clockevents_mutex"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_unbind",
          "args": [
            "ce",
            "dev->id"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_unbind_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "439-447",
          "snippet": "int clockevents_unbind_device(struct clock_event_device *ced, int cpu)\n{\n\tint ret;\n\n\tmutex_lock(&clockevents_mutex);\n\tret = clockevents_unbind(ced, cpu);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(clockevents_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic DEFINE_MUTEX(clockevents_mutex);\n\nint clockevents_unbind_device(struct clock_event_device *ced, int cpu)\n{\n\tint ret;\n\n\tmutex_lock(&clockevents_mutex);\n\tret = clockevents_unbind(ced, cpu);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&clockevents_lock"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clockevents_try_unbind",
          "args": [
            "ce",
            "dev->id"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_try_unbind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "397-406",
          "snippet": "static int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ce->name",
            "name"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ce",
            "&clockevent_devices",
            "list"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&clockevents_lock"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clockevents_mutex"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_get_uname",
          "args": [
            "buf",
            "name",
            "count"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_get_uname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "1065-1080",
          "snippet": "ssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\nstatic DEFINE_MUTEX(clockevents_mutex);\n\nstatic ssize_t sysfs_unbind_tick_dev(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tchar name[CS_NAME_LEN];\n\tssize_t ret = sysfs_get_uname(buf, name, count);\n\tstruct clock_event_device *ce;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ENODEV;\n\tmutex_lock(&clockevents_mutex);\n\traw_spin_lock_irq(&clockevents_lock);\n\tlist_for_each_entry(ce, &clockevent_devices, list) {\n\t\tif (!strcmp(ce->name, name)) {\n\t\t\tret = __clockevents_try_unbind(ce, dev->id);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irq(&clockevents_lock);\n\t/*\n\t * We hold clockevents_mutex, so ce can't go away\n\t */\n\tif (ret == -EAGAIN)\n\t\tret = clockevents_unbind(ce, dev->id);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "sysfs_show_current_tick_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "667-680",
    "snippet": "static ssize_t sysfs_show_current_tick_dev(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct tick_device *td;\n\tssize_t count = 0;\n\n\traw_spin_lock_irq(&clockevents_lock);\n\ttd = tick_get_tick_dev(dev);\n\tif (td && td->evtdev)\n\t\tcount = snprintf(buf, PAGE_SIZE, \"%s\\n\", td->evtdev->name);\n\traw_spin_unlock_irq(&clockevents_lock);\n\treturn count;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&clockevents_lock"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%s\\n\"",
            "td->evtdev->name"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_get_tick_dev",
          "args": [
            "dev"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_tick_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "737-740",
          "snippet": "static struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn &per_cpu(tick_cpu_device, dev->id);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn &per_cpu(tick_cpu_device, dev->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&clockevents_lock"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nstatic ssize_t sysfs_show_current_tick_dev(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct tick_device *td;\n\tssize_t count = 0;\n\n\traw_spin_lock_irq(&clockevents_lock);\n\ttd = tick_get_tick_dev(dev);\n\tif (td && td->evtdev)\n\t\tcount = snprintf(buf, PAGE_SIZE, \"%s\\n\", td->evtdev->name);\n\traw_spin_unlock_irq(&clockevents_lock);\n\treturn count;\n}"
  },
  {
    "function_name": "tick_cleanup_dead_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "627-655",
    "snippet": "void tick_cleanup_dead_cpu(int cpu)\n{\n\tstruct clock_event_device *dev, *tmp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\ttick_shutdown_broadcast_oneshot(cpu);\n\ttick_shutdown_broadcast(cpu);\n\ttick_shutdown(cpu);\n\t/*\n\t * Unregister the clock event devices which were\n\t * released from the users in the notify chain.\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevents_released, list)\n\t\tlist_del(&dev->list);\n\t/*\n\t * Now check whether the CPU has left unused per cpu devices\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevent_devices, list) {\n\t\tif (cpumask_test_cpu(cpu, dev->cpumask) &&\n\t\t    cpumask_weight(dev->cpumask) == 1 &&\n\t\t    !tick_is_broadcast_device(dev)) {\n\t\t\tBUG_ON(!clockevent_state_detached(dev));\n\t\t\tlist_del(&dev->list);\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);",
      "static LIST_HEAD(clockevents_released);",
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&clockevents_lock",
            "flags"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&dev->list"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!clockevent_state_detached(dev)"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "dev"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_is_broadcast_device",
          "args": [
            "dev"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "tick_is_broadcast_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "123-126",
          "snippet": "int tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "dev->cpumask"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "dev->cpumask"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dev",
            "tmp",
            "&clockevent_devices",
            "list"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dev",
            "tmp",
            "&clockevents_released",
            "list"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_shutdown",
          "args": [
            "cpu"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "tick_shutdown_broadcast_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "958-973",
          "snippet": "void tick_shutdown_broadcast_oneshot(unsigned int cpu)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Clear the broadcast masks for the dead cpu, but do not stop\n\t * the broadcast device!\n\t */\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_force_mask);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_shutdown_broadcast_oneshot(unsigned int cpu)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Clear the broadcast masks for the dead cpu, but do not stop\n\t * the broadcast device!\n\t */\n\tcpumask_clear_cpu(cpu, tick_broadcast_oneshot_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_pending_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_force_mask);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&clockevents_lock",
            "flags"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic LIST_HEAD(clockevents_released);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid tick_cleanup_dead_cpu(int cpu)\n{\n\tstruct clock_event_device *dev, *tmp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\ttick_shutdown_broadcast_oneshot(cpu);\n\ttick_shutdown_broadcast(cpu);\n\ttick_shutdown(cpu);\n\t/*\n\t * Unregister the clock event devices which were\n\t * released from the users in the notify chain.\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevents_released, list)\n\t\tlist_del(&dev->list);\n\t/*\n\t * Now check whether the CPU has left unused per cpu devices\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevent_devices, list) {\n\t\tif (cpumask_test_cpu(cpu, dev->cpumask) &&\n\t\t    cpumask_weight(dev->cpumask) == 1 &&\n\t\t    !tick_is_broadcast_device(dev)) {\n\t\t\tBUG_ON(!clockevent_state_detached(dev));\n\t\t\tlist_del(&dev->list);\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}"
  },
  {
    "function_name": "clockevents_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "614-621",
    "snippet": "void clockevents_resume(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list)\n\t\tif (dev->resume && !clockevent_state_detached(dev))\n\t\t\tdev->resume(dev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev->resume",
          "args": [
            "dev"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "dev"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&clockevent_devices",
            "list"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nvoid clockevents_resume(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list)\n\t\tif (dev->resume && !clockevent_state_detached(dev))\n\t\t\tdev->resume(dev);\n}"
  },
  {
    "function_name": "clockevents_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "602-609",
    "snippet": "void clockevents_suspend(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry_reverse(dev, &clockevent_devices, list)\n\t\tif (dev->suspend && !clockevent_state_detached(dev))\n\t\t\tdev->suspend(dev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev->suspend",
          "args": [
            "dev"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "dev"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "dev",
            "&clockevent_devices",
            "list"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nvoid clockevents_suspend(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry_reverse(dev, &clockevent_devices, list)\n\t\tif (dev->suspend && !clockevent_state_detached(dev))\n\t\t\tdev->suspend(dev);\n}"
  },
  {
    "function_name": "clockevents_exchange_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "579-597",
    "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_del(&old->list);\n\t\tlist_add(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevents_released);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "new"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "179-183",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!clockevent_state_detached(new)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "new"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&old->list",
            "&clockevents_released"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&old->list"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "old",
            "CLOCK_EVT_STATE_DETACHED"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "153-173",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "old->owner"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_del(&old->list);\n\t\tlist_add(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
  },
  {
    "function_name": "clockevents_handle_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "567-569",
    "snippet": "void clockevents_handle_noop(struct clock_event_device *dev)\n{\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_handle_noop(struct clock_event_device *dev)\n{\n}"
  },
  {
    "function_name": "clockevents_update_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "551-562",
    "snippet": "int clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = tick_broadcast_update_freq(dev, freq);\n\tif (ret == -ENODEV)\n\t\tret = __clockevents_update_freq(dev, freq);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clockevents_update_freq",
          "args": [
            "dev",
            "freq"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_update_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "526-537",
          "snippet": "int __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_update_freq",
          "args": [
            "dev",
            "freq"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_update_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "128-138",
          "snippet": "int tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tint ret = -ENODEV;\n\n\tif (tick_is_broadcast_device(dev)) {\n\t\traw_spin_lock(&tick_broadcast_lock);\n\t\tret = __clockevents_update_freq(dev, freq);\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nint tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tint ret = -ENODEV;\n\n\tif (tick_is_broadcast_device(dev)) {\n\t\traw_spin_lock(&tick_broadcast_lock);\n\t\tret = __clockevents_update_freq(dev, freq);\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = tick_broadcast_update_freq(dev, freq);\n\tif (ret == -ENODEV)\n\t\tret = __clockevents_update_freq(dev, freq);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__clockevents_update_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "526-537",
    "snippet": "int __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clockevents_switch_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_PERIODIC"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "97-144",
          "snippet": "static int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_periodic",
          "args": [
            "dev"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "dev",
            "dev->next_event",
            "false"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "311-347",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_config",
          "args": [
            "dev",
            "freq"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "482-504",
          "snippet": "static void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "clockevents_config_and_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "515-523",
    "snippet": "void clockevents_config_and_register(struct clock_event_device *dev,\n\t\t\t\t     u32 freq, unsigned long min_delta,\n\t\t\t\t     unsigned long max_delta)\n{\n\tdev->min_delta_ticks = min_delta;\n\tdev->max_delta_ticks = max_delta;\n\tclockevents_config(dev, freq);\n\tclockevents_register_device(dev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_register_device",
          "args": [
            "dev"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_register_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "454-479",
          "snippet": "void clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);",
            "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_config",
          "args": [
            "dev",
            "freq"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "482-504",
          "snippet": "static void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_config_and_register(struct clock_event_device *dev,\n\t\t\t\t     u32 freq, unsigned long min_delta,\n\t\t\t\t     unsigned long max_delta)\n{\n\tdev->min_delta_ticks = min_delta;\n\tdev->max_delta_ticks = max_delta;\n\tclockevents_config(dev, freq);\n\tclockevents_register_device(dev);\n}"
  },
  {
    "function_name": "clockevents_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "482-504",
    "snippet": "static void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cev_delta2ns",
          "args": [
            "dev->max_delta_ticks",
            "dev",
            "true"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "cev_delta2ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "36-82",
          "snippet": "static u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (unlikely(!evt->mult)) {\n\t\tevt->mult = 1;\n\t\tWARN_ON(1);\n\t}\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (unlikely(!evt->mult)) {\n\t\tevt->mult = 1;\n\t\tWARN_ON(1);\n\t}\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_calc_mult_shift",
          "args": [
            "dev",
            "freq",
            "sec"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "sec",
            "freq"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}"
  },
  {
    "function_name": "clockevents_register_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "454-479",
    "snippet": "void clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);",
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&clockevents_lock",
            "flags"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_notify_released",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_notify_released",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "353-364",
          "snippet": "static void clockevents_notify_released(void)\n{\n\tstruct clock_event_device *dev;\n\n\twhile (!list_empty(&clockevents_released)) {\n\t\tdev = list_entry(clockevents_released.next,\n\t\t\t\t struct clock_event_device, list);\n\t\tlist_del(&dev->list);\n\t\tlist_add(&dev->list, &clockevent_devices);\n\t\ttick_check_new_device(dev);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);",
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic LIST_HEAD(clockevents_released);\n\nstatic void clockevents_notify_released(void)\n{\n\tstruct clock_event_device *dev;\n\n\twhile (!list_empty(&clockevents_released)) {\n\t\tdev = list_entry(clockevents_released.next,\n\t\t\t\t struct clock_event_device, list);\n\t\tlist_del(&dev->list);\n\t\tlist_add(&dev->list, &clockevent_devices);\n\t\ttick_check_new_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_new_device",
          "args": [
            "dev"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_new_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "300-341",
          "snippet": "void tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\t/* cpu local device ? */\n\tif (!tick_check_percpu(curdev, newdev, cpu))\n\t\tgoto out_bc;\n\n\t/* Preference decision */\n\tif (!tick_check_preferred(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\t/* cpu local device ? */\n\tif (!tick_check_percpu(curdev, newdev, cpu))\n\t\tgoto out_bc;\n\n\t/* Preference decision */\n\tif (!tick_check_preferred(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dev->list",
            "&clockevent_devices"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&clockevents_lock",
            "flags"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\"",
            "dev->name"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "smp_processor_id()"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "num_possible_cpus() > 1"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_set_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_DETACHED"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-internal.h",
          "lines": "45-49",
          "snippet": "static inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}"
  },
  {
    "function_name": "clockevents_unbind_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "439-447",
    "snippet": "int clockevents_unbind_device(struct clock_event_device *ced, int cpu)\n{\n\tint ret;\n\n\tmutex_lock(&clockevents_mutex);\n\tret = clockevents_unbind(ced, cpu);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clockevents_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clockevents_mutex"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_unbind",
          "args": [
            "ced",
            "cpu"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_unbind_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "439-447",
          "snippet": "int clockevents_unbind_device(struct clock_event_device *ced, int cpu)\n{\n\tint ret;\n\n\tmutex_lock(&clockevents_mutex);\n\tret = clockevents_unbind(ced, cpu);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clockevents_mutex"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic DEFINE_MUTEX(clockevents_mutex);\n\nint clockevents_unbind_device(struct clock_event_device *ced, int cpu)\n{\n\tint ret;\n\n\tmutex_lock(&clockevents_mutex);\n\tret = clockevents_unbind(ced, cpu);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "clockevents_unbind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "428-434",
    "snippet": "static int clockevents_unbind(struct clock_event_device *ced, int cpu)\n{\n\tstruct ce_unbind cu = { .ce = ced, .res = -ENODEV };\n\n\tsmp_call_function_single(cpu, __clockevents_unbind, &cu, 1);\n\treturn cu.res;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "__clockevents_unbind",
            "&cu",
            "1"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "11-23",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int clockevents_unbind(struct clock_event_device *ced, int cpu)\n{\n\tstruct ce_unbind cu = { .ce = ced, .res = -ENODEV };\n\n\tsmp_call_function_single(cpu, __clockevents_unbind, &cu, 1);\n\treturn cu.res;\n}"
  },
  {
    "function_name": "__clockevents_unbind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "411-422",
    "snippet": "static void __clockevents_unbind(void *arg)\n{\n\tstruct ce_unbind *cu = arg;\n\tint res;\n\n\traw_spin_lock(&clockevents_lock);\n\tres = __clockevents_try_unbind(cu->ce, smp_processor_id());\n\tif (res == -EAGAIN)\n\t\tres = clockevents_replace(cu->ce);\n\tcu->res = res;\n\traw_spin_unlock(&clockevents_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&clockevents_lock"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_replace",
          "args": [
            "cu->ce"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "369-392",
          "snippet": "static int clockevents_replace(struct clock_event_device *ced)\n{\n\tstruct clock_event_device *dev, *newdev = NULL;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list) {\n\t\tif (dev == ced || !clockevent_state_detached(dev))\n\t\t\tcontinue;\n\n\t\tif (!tick_check_replacement(newdev, dev))\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(dev->owner))\n\t\t\tcontinue;\n\n\t\tif (newdev)\n\t\t\tmodule_put(newdev->owner);\n\t\tnewdev = dev;\n\t}\n\tif (newdev) {\n\t\ttick_install_replacement(newdev);\n\t\tlist_del_init(&ced->list);\n\t}\n\treturn newdev ? 0 : -EBUSY;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nstatic int clockevents_replace(struct clock_event_device *ced)\n{\n\tstruct clock_event_device *dev, *newdev = NULL;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list) {\n\t\tif (dev == ced || !clockevent_state_detached(dev))\n\t\t\tcontinue;\n\n\t\tif (!tick_check_replacement(newdev, dev))\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(dev->owner))\n\t\t\tcontinue;\n\n\t\tif (newdev)\n\t\t\tmodule_put(newdev->owner);\n\t\tnewdev = dev;\n\t}\n\tif (newdev) {\n\t\ttick_install_replacement(newdev);\n\t\tlist_del_init(&ced->list);\n\t}\n\treturn newdev ? 0 : -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clockevents_try_unbind",
          "args": [
            "cu->ce",
            "smp_processor_id()"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_try_unbind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "397-406",
          "snippet": "static int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&clockevents_lock"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nstatic void __clockevents_unbind(void *arg)\n{\n\tstruct ce_unbind *cu = arg;\n\tint res;\n\n\traw_spin_lock(&clockevents_lock);\n\tres = __clockevents_try_unbind(cu->ce, smp_processor_id());\n\tif (res == -EAGAIN)\n\t\tres = clockevents_replace(cu->ce);\n\tcu->res = res;\n\traw_spin_unlock(&clockevents_lock);\n}"
  },
  {
    "function_name": "__clockevents_try_unbind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "397-406",
    "snippet": "static int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ced->list"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "ced"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}"
  },
  {
    "function_name": "clockevents_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "369-392",
    "snippet": "static int clockevents_replace(struct clock_event_device *ced)\n{\n\tstruct clock_event_device *dev, *newdev = NULL;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list) {\n\t\tif (dev == ced || !clockevent_state_detached(dev))\n\t\t\tcontinue;\n\n\t\tif (!tick_check_replacement(newdev, dev))\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(dev->owner))\n\t\t\tcontinue;\n\n\t\tif (newdev)\n\t\t\tmodule_put(newdev->owner);\n\t\tnewdev = dev;\n\t}\n\tif (newdev) {\n\t\ttick_install_replacement(newdev);\n\t\tlist_del_init(&ced->list);\n\t}\n\treturn newdev ? 0 : -EBUSY;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ced->list"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_install_replacement",
          "args": [
            "newdev"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "tick_install_replacement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "236-245",
          "snippet": "void tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "newdev->owner"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "dev->owner"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1113-1129",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_replacement",
          "args": [
            "newdev",
            "dev"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_replacement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "287-294",
          "snippet": "bool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nbool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "dev"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&clockevent_devices",
            "list"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nstatic int clockevents_replace(struct clock_event_device *ced)\n{\n\tstruct clock_event_device *dev, *newdev = NULL;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list) {\n\t\tif (dev == ced || !clockevent_state_detached(dev))\n\t\t\tcontinue;\n\n\t\tif (!tick_check_replacement(newdev, dev))\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(dev->owner))\n\t\t\tcontinue;\n\n\t\tif (newdev)\n\t\t\tmodule_put(newdev->owner);\n\t\tnewdev = dev;\n\t}\n\tif (newdev) {\n\t\ttick_install_replacement(newdev);\n\t\tlist_del_init(&ced->list);\n\t}\n\treturn newdev ? 0 : -EBUSY;\n}"
  },
  {
    "function_name": "clockevents_notify_released",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "353-364",
    "snippet": "static void clockevents_notify_released(void)\n{\n\tstruct clock_event_device *dev;\n\n\twhile (!list_empty(&clockevents_released)) {\n\t\tdev = list_entry(clockevents_released.next,\n\t\t\t\t struct clock_event_device, list);\n\t\tlist_del(&dev->list);\n\t\tlist_add(&dev->list, &clockevent_devices);\n\t\ttick_check_new_device(dev);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);",
      "static LIST_HEAD(clockevents_released);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_check_new_device",
          "args": [
            "dev"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_new_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "300-341",
          "snippet": "void tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\t/* cpu local device ? */\n\tif (!tick_check_percpu(curdev, newdev, cpu))\n\t\tgoto out_bc;\n\n\t/* Preference decision */\n\tif (!tick_check_preferred(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\t/* cpu local device ? */\n\tif (!tick_check_percpu(curdev, newdev, cpu))\n\t\tgoto out_bc;\n\n\t/* Preference decision */\n\tif (!tick_check_preferred(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dev->list",
            "&clockevent_devices"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&dev->list"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "clockevents_released.next",
            "structclock_event_device",
            "list"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clockevents_released"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic LIST_HEAD(clockevents_released);\n\nstatic void clockevents_notify_released(void)\n{\n\tstruct clock_event_device *dev;\n\n\twhile (!list_empty(&clockevents_released)) {\n\t\tdev = list_entry(clockevents_released.next,\n\t\t\t\t struct clock_event_device, list);\n\t\tlist_del(&dev->list);\n\t\tlist_add(&dev->list, &clockevent_devices);\n\t\ttick_check_new_device(dev);\n\t}\n}"
  },
  {
    "function_name": "clockevents_program_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "311-347",
    "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_program_min_delta",
          "args": [
            "dev"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_min_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "280-299",
          "snippet": "static int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta = 0;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tdelta += dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -ETIME;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta = 0;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tdelta += dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -ETIME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev->set_next_event",
          "args": [
            "(unsigned long) clc",
            "dev"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "delta",
            "(int64_t) dev->min_delta_ns"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "delta",
            "(int64_t) dev->max_delta_ns"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "574-606",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(expires, ktime_get())"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "expires",
            "ktime_get()"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev->set_next_ktime",
          "args": [
            "expires",
            "dev"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!clockevent_state_oneshot(dev)",
            "\"Current state: %d\\n\"",
            "clockevent_get_state(dev)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_get_state",
          "args": [
            "dev"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_get_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-internal.h",
          "lines": "40-43",
          "snippet": "static inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_shutdown",
          "args": [
            "dev"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "expires < 0"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
  },
  {
    "function_name": "clockevents_program_min_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "280-299",
    "snippet": "static int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta = 0;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tdelta += dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -ETIME;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev->set_next_event",
          "args": [
            "(unsigned long) clc",
            "dev"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_shutdown",
          "args": [
            "dev"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "ktime_get()",
            "delta"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta = 0;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tdelta += dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -ETIME;\n}"
  },
  {
    "function_name": "clockevents_program_min_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "241-270",
    "snippet": "static int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint i;\n\n\tfor (i = 0;;) {\n\t\tdelta = dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\n\t\tif (++i > 2) {\n\t\t\t/*\n\t\t\t * We tried 3 times to program the device with the\n\t\t\t * given min_delta_ns. Try to increase the minimum\n\t\t\t * delta, if that fails as well get out of here.\n\t\t\t */\n\t\t\tif (clockevents_increase_min_delta(dev))\n\t\t\t\treturn -ETIME;\n\t\t\ti = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_increase_min_delta",
          "args": [
            "dev"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_increase_min_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "210-233",
          "snippet": "static int clockevents_increase_min_delta(struct clock_event_device *dev)\n{\n\t/* Nothing to do if we already reached the limit */\n\tif (dev->min_delta_ns >= MIN_DELTA_LIMIT) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"CE: Reprogramming failure. Giving up\\n\");\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn -ETIME;\n\t}\n\n\tif (dev->min_delta_ns < 5000)\n\t\tdev->min_delta_ns = 5000;\n\telse\n\t\tdev->min_delta_ns += dev->min_delta_ns >> 1;\n\n\tif (dev->min_delta_ns > MIN_DELTA_LIMIT)\n\t\tdev->min_delta_ns = MIN_DELTA_LIMIT;\n\n\tprintk_deferred(KERN_WARNING\n\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\",\n\t\t\tdev->name ? dev->name : \"?\",\n\t\t\t(unsigned long long) dev->min_delta_ns);\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [
            "#define MIN_DELTA_LIMIT\t\t(NSEC_PER_SEC / HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\n#define MIN_DELTA_LIMIT\t\t(NSEC_PER_SEC / HZ)\n\nstatic int clockevents_increase_min_delta(struct clock_event_device *dev)\n{\n\t/* Nothing to do if we already reached the limit */\n\tif (dev->min_delta_ns >= MIN_DELTA_LIMIT) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"CE: Reprogramming failure. Giving up\\n\");\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn -ETIME;\n\t}\n\n\tif (dev->min_delta_ns < 5000)\n\t\tdev->min_delta_ns = 5000;\n\telse\n\t\tdev->min_delta_ns += dev->min_delta_ns >> 1;\n\n\tif (dev->min_delta_ns > MIN_DELTA_LIMIT)\n\t\tdev->min_delta_ns = MIN_DELTA_LIMIT;\n\n\tprintk_deferred(KERN_WARNING\n\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\",\n\t\t\tdev->name ? dev->name : \"?\",\n\t\t\t(unsigned long long) dev->min_delta_ns);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev->set_next_event",
          "args": [
            "(unsigned long) clc",
            "dev"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_shutdown",
          "args": [
            "dev"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "ktime_get()",
            "delta"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint i;\n\n\tfor (i = 0;;) {\n\t\tdelta = dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\n\t\tif (++i > 2) {\n\t\t\t/*\n\t\t\t * We tried 3 times to program the device with the\n\t\t\t * given min_delta_ns. Try to increase the minimum\n\t\t\t * delta, if that fails as well get out of here.\n\t\t\t */\n\t\t\tif (clockevents_increase_min_delta(dev))\n\t\t\t\treturn -ETIME;\n\t\t\ti = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "clockevents_increase_min_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "210-233",
    "snippet": "static int clockevents_increase_min_delta(struct clock_event_device *dev)\n{\n\t/* Nothing to do if we already reached the limit */\n\tif (dev->min_delta_ns >= MIN_DELTA_LIMIT) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"CE: Reprogramming failure. Giving up\\n\");\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn -ETIME;\n\t}\n\n\tif (dev->min_delta_ns < 5000)\n\t\tdev->min_delta_ns = 5000;\n\telse\n\t\tdev->min_delta_ns += dev->min_delta_ns >> 1;\n\n\tif (dev->min_delta_ns > MIN_DELTA_LIMIT)\n\t\tdev->min_delta_ns = MIN_DELTA_LIMIT;\n\n\tprintk_deferred(KERN_WARNING\n\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\",\n\t\t\tdev->name ? dev->name : \"?\",\n\t\t\t(unsigned long long) dev->min_delta_ns);\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [
      "#define MIN_DELTA_LIMIT\t\t(NSEC_PER_SEC / HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_WARNING\n\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\"",
            "dev->name ? dev->name : \"?\"",
            "(unsigned long long) dev->min_delta_ns"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\n#define MIN_DELTA_LIMIT\t\t(NSEC_PER_SEC / HZ)\n\nstatic int clockevents_increase_min_delta(struct clock_event_device *dev)\n{\n\t/* Nothing to do if we already reached the limit */\n\tif (dev->min_delta_ns >= MIN_DELTA_LIMIT) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"CE: Reprogramming failure. Giving up\\n\");\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn -ETIME;\n\t}\n\n\tif (dev->min_delta_ns < 5000)\n\t\tdev->min_delta_ns = 5000;\n\telse\n\t\tdev->min_delta_ns += dev->min_delta_ns >> 1;\n\n\tif (dev->min_delta_ns > MIN_DELTA_LIMIT)\n\t\tdev->min_delta_ns = MIN_DELTA_LIMIT;\n\n\tprintk_deferred(KERN_WARNING\n\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\",\n\t\t\tdev->name ? dev->name : \"?\",\n\t\t\t(unsigned long long) dev->min_delta_ns);\n\treturn 0;\n}"
  },
  {
    "function_name": "clockevents_tick_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "189-197",
    "snippet": "int clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev->tick_resume",
          "args": [
            "dev"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "clockevents_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "179-183",
    "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_SHUTDOWN"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "153-173",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
  },
  {
    "function_name": "clockevents_switch_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "153-173",
    "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dev->mult"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_set_state",
          "args": [
            "dev",
            "state"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-internal.h",
          "lines": "45-49",
          "snippet": "static inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clockevents_switch_state",
          "args": [
            "dev",
            "state"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "97-144",
          "snippet": "static int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_get_state",
          "args": [
            "dev"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_get_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-internal.h",
          "lines": "40-43",
          "snippet": "static inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__clockevents_switch_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "97-144",
    "snippet": "static int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev->set_state_oneshot_stopped",
          "args": [
            "dev"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!clockevent_state_oneshot(dev)",
            "\"Current state: %d\\n\"",
            "clockevent_get_state(dev)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_get_state",
          "args": [
            "dev"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_get_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-internal.h",
          "lines": "40-43",
          "snippet": "static inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev->set_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev->set_state_periodic",
          "args": [
            "dev"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev->set_state_shutdown",
          "args": [
            "dev"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
  },
  {
    "function_name": "clockevent_delta2ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "91-94",
    "snippet": "u64 clockevent_delta2ns(unsigned long latch, struct clock_event_device *evt)\n{\n\treturn cev_delta2ns(latch, evt, false);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cev_delta2ns",
          "args": [
            "latch",
            "evt",
            "false"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "cev_delta2ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "36-82",
          "snippet": "static u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (unlikely(!evt->mult)) {\n\t\tevt->mult = 1;\n\t\tWARN_ON(1);\n\t}\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (unlikely(!evt->mult)) {\n\t\tevt->mult = 1;\n\t\tWARN_ON(1);\n\t}\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nu64 clockevent_delta2ns(unsigned long latch, struct clock_event_device *evt)\n{\n\treturn cev_delta2ns(latch, evt, false);\n}"
  },
  {
    "function_name": "cev_delta2ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
    "lines": "36-82",
    "snippet": "static u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (unlikely(!evt->mult)) {\n\t\tevt->mult = 1;\n\t\tWARN_ON(1);\n\t}\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "clc",
            "evt->mult"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!evt->mult"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (unlikely(!evt->mult)) {\n\t\tevt->mult = 1;\n\t\tWARN_ON(1);\n\t}\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}"
  }
]