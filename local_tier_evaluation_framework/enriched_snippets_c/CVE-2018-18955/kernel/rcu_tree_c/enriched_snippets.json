[
  {
    "function_name": "rcu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3711-3742",
    "snippet": "void __init rcu_init(void)\n{\n\tint cpu;\n\n\trcu_early_boot_tests();\n\n\trcu_bootup_announce();\n\trcu_init_geometry();\n\trcu_init_one();\n\tif (dump_tree)\n\t\trcu_dump_rcu_node_tree();\n\topen_softirq(RCU_SOFTIRQ, rcu_process_callbacks);\n\n\t/*\n\t * We don't need protection against CPU-hotplug here because\n\t * this is called early in boot, before either interrupts\n\t * or the scheduler are operational.\n\t */\n\tpm_notifier(rcu_pm_notify, 0);\n\tfor_each_online_cpu(cpu) {\n\t\trcutree_prepare_cpu(cpu);\n\t\trcu_cpu_starting(cpu);\n\t\trcutree_online_cpu(cpu);\n\t}\n\n\t/* Create workqueue for expedited GPs and for Tree SRCU. */\n\trcu_gp_wq = alloc_workqueue(\"rcu_gp\", WQ_MEM_RECLAIM, 0);\n\tWARN_ON(!rcu_gp_wq);\n\trcu_par_gp_wq = alloc_workqueue(\"rcu_par_gp\", WQ_MEM_RECLAIM, 0);\n\tWARN_ON(!rcu_par_gp_wq);\n\tsrcu_init();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool dump_tree;",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "struct workqueue_struct *rcu_gp_wq;",
      "struct workqueue_struct *rcu_par_gp_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_init",
          "args": [],
          "line": 3741
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1319-1331",
          "snippet": "void __init srcu_init(void)\n{\n\tstruct srcu_struct *sp;\n\n\tsrcu_init_done = true;\n\twhile (!list_empty(&srcu_boot_list)) {\n\t\tsp = list_first_entry(&srcu_boot_list, struct srcu_struct,\n\t\t\t\t      work.work.entry);\n\t\tcheck_init_srcu_struct(sp);\n\t\tlist_del_init(&sp->work.work.entry);\n\t\tqueue_work(rcu_gp_wq, &sp->work.work);\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(srcu_boot_list);",
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(srcu_boot_list);\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid __init srcu_init(void)\n{\n\tstruct srcu_struct *sp;\n\n\tsrcu_init_done = true;\n\twhile (!list_empty(&srcu_boot_list)) {\n\t\tsp = list_first_entry(&srcu_boot_list, struct srcu_struct,\n\t\t\t\t      work.work.entry);\n\t\tcheck_init_srcu_struct(sp);\n\t\tlist_del_init(&sp->work.work.entry);\n\t\tqueue_work(rcu_gp_wq, &sp->work.work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rcu_par_gp_wq"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"rcu_par_gp\"",
            "WQ_MEM_RECLAIM",
            "0"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rcu_gp_wq"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"rcu_gp\"",
            "WQ_MEM_RECLAIM",
            "0"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutree_online_cpu",
          "args": [
            "cpu"
          ],
          "line": 3733
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_online_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3264-3282",
          "snippet": "int rcutree_online_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask |= rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (IS_ENABLED(CONFIG_TREE_SRCU))\n\t\tsrcu_online_cpu(cpu);\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn 0; /* Too early in boot for scheduler work. */\n\tsync_sched_exp_online_cleanup(cpu);\n\trcutree_affinity_setting(cpu, -1);\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "int rcu_scheduler_active",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nint rcu_scheduler_active;\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_online_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask |= rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (IS_ENABLED(CONFIG_TREE_SRCU))\n\t\tsrcu_online_cpu(cpu);\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn 0; /* Too early in boot for scheduler work. */\n\tsync_sched_exp_online_cleanup(cpu);\n\trcutree_affinity_setting(cpu, -1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cpu_starting",
          "args": [
            "cpu"
          ],
          "line": 3732
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cpu_starting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3319-3354",
          "snippet": "void rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tint nbits;\n\tunsigned long oldmask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tif (per_cpu(rcu_cpu_started, cpu))\n\t\treturn;\n\n\tper_cpu(rcu_cpu_started, cpu) = 1;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->qsmaskinitnext |= mask;\n\toldmask = rnp->expmaskinitnext;\n\trnp->expmaskinitnext |= mask;\n\toldmask ^= rnp->expmaskinitnext;\n\tnbits = bitmap_weight(&oldmask, BITS_PER_LONG);\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + nbits); /* ^^^ */\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on incoming CPU? */\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
            "static DEFINE_PER_CPU(int, rcu_cpu_started);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic DEFINE_PER_CPU(int, rcu_cpu_started);\n\nvoid rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tint nbits;\n\tunsigned long oldmask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tif (per_cpu(rcu_cpu_started, cpu))\n\t\treturn;\n\n\tper_cpu(rcu_cpu_started, cpu) = 1;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->qsmaskinitnext |= mask;\n\toldmask = rnp->expmaskinitnext;\n\trnp->expmaskinitnext |= mask;\n\toldmask ^= rnp->expmaskinitnext;\n\tnbits = bitmap_weight(&oldmask, BITS_PER_LONG);\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + nbits); /* ^^^ */\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on incoming CPU? */\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutree_prepare_cpu",
          "args": [
            "cpu"
          ],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_prepare_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3210-3248",
          "snippet": "int rcutree_prepare_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trdp->qlen_last_fqs_check = 0;\n\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\trdp->blimit = blimit;\n\tif (rcu_segcblist_empty(&rdp->cblist) && /* No early-boot CBs? */\n\t    !init_nocb_callback_list(rdp))\n\t\trcu_segcblist_init(&rdp->cblist);  /* Re-enable callbacks. */\n\trdp->dynticks_nesting = 1;\t/* CPU not up, no tearing. */\n\trcu_dynticks_eqs_online();\n\traw_spin_unlock_rcu_node(rnp);\t\t/* irqs remain disabled. */\n\n\t/*\n\t * Add CPU to leaf rcu_node pending-online bitmask.  Any needed\n\t * propagation up the rcu_node tree will happen at the beginning\n\t * of the next grace period.\n\t */\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\t\t/* irqs already disabled. */\n\trdp->beenonline = true;\t /* We have now been online. */\n\trdp->gp_seq = rnp->gp_seq;\n\trdp->gp_seq_needed = rnp->gp_seq;\n\trdp->cpu_no_qs.b.norm = true;\n\trdp->core_needs_qs = false;\n\trdp->rcu_iw_pending = false;\n\trdp->rcu_iw_gp_seq = rnp->gp_seq - 1;\n\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuonl\"));\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_prepare_kthreads(cpu);\n\trcu_spawn_all_nocb_kthreads(cpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static long blimit = DEFAULT_RCU_BLIMIT;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_prepare_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trdp->qlen_last_fqs_check = 0;\n\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\trdp->blimit = blimit;\n\tif (rcu_segcblist_empty(&rdp->cblist) && /* No early-boot CBs? */\n\t    !init_nocb_callback_list(rdp))\n\t\trcu_segcblist_init(&rdp->cblist);  /* Re-enable callbacks. */\n\trdp->dynticks_nesting = 1;\t/* CPU not up, no tearing. */\n\trcu_dynticks_eqs_online();\n\traw_spin_unlock_rcu_node(rnp);\t\t/* irqs remain disabled. */\n\n\t/*\n\t * Add CPU to leaf rcu_node pending-online bitmask.  Any needed\n\t * propagation up the rcu_node tree will happen at the beginning\n\t * of the next grace period.\n\t */\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\t\t/* irqs already disabled. */\n\trdp->beenonline = true;\t /* We have now been online. */\n\trdp->gp_seq = rnp->gp_seq;\n\trdp->gp_seq_needed = rnp->gp_seq;\n\trdp->cpu_no_qs.b.norm = true;\n\trdp->core_needs_qs = false;\n\trdp->rcu_iw_pending = false;\n\trdp->rcu_iw_gp_seq = rnp->gp_seq - 1;\n\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuonl\"));\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_prepare_kthreads(cpu);\n\trcu_spawn_all_nocb_kthreads(cpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_notifier",
          "args": [
            "rcu_pm_notify",
            "0"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_softirq",
          "args": [
            "RCU_SOFTIRQ",
            "rcu_process_callbacks"
          ],
          "line": 3722
        },
        "resolved": true,
        "details": {
          "function_name": "open_softirq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "455-458",
          "snippet": "void open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct softirq_action softirq_vec[NR_SOFTIRQS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS];\n\nvoid open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dump_rcu_node_tree",
          "args": [],
          "line": 3721
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dump_rcu_node_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3690-3706",
          "snippet": "static void __init rcu_dump_rcu_node_tree(void)\n{\n\tint level = 0;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"rcu_node tree layout dump\\n\");\n\tpr_info(\" \");\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (rnp->level != level) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tpr_info(\" \");\n\t\t\tlevel = rnp->level;\n\t\t}\n\t\tpr_cont(\"%d:%d ^%d  \", rnp->grplo, rnp->grphi, rnp->grpnum);\n\t}\n\tpr_cont(\"\\n\");\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void __init rcu_dump_rcu_node_tree(void)\n{\n\tint level = 0;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"rcu_node tree layout dump\\n\");\n\tpr_info(\" \");\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (rnp->level != level) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tpr_info(\" \");\n\t\t\tlevel = rnp->level;\n\t\t}\n\t\tpr_cont(\"%d:%d ^%d  \", rnp->grplo, rnp->grphi, rnp->grpnum);\n\t}\n\tpr_cont(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_init_one",
          "args": [],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3526-3603",
          "snippet": "static void __init rcu_init_one(void)\n{\n\tstatic const char * const buf[] = RCU_NODE_NAME_INIT;\n\tstatic const char * const fqs[] = RCU_FQS_NAME_INIT;\n\tstatic struct lock_class_key rcu_node_class[RCU_NUM_LVLS];\n\tstatic struct lock_class_key rcu_fqs_class[RCU_NUM_LVLS];\n\n\tint levelspread[RCU_NUM_LVLS];\t\t/* kids/node in each level. */\n\tint cpustride = 1;\n\tint i;\n\tint j;\n\tstruct rcu_node *rnp;\n\n\tBUILD_BUG_ON(RCU_NUM_LVLS > ARRAY_SIZE(buf));  /* Fix buf[] init! */\n\n\t/* Silence gcc 4.8 false positive about array index out of range. */\n\tif (rcu_num_lvls <= 0 || rcu_num_lvls > RCU_NUM_LVLS)\n\t\tpanic(\"rcu_init_one: rcu_num_lvls out of range\");\n\n\t/* Initialize the level-tracking arrays. */\n\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\trcu_state.level[i] =\n\t\t\trcu_state.level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Initialize the elements themselves, starting from the leaves. */\n\n\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\tcpustride *= levelspread[i];\n\t\trnp = rcu_state.level[i];\n\t\tfor (j = 0; j < num_rcu_lvl[i]; j++, rnp++) {\n\t\t\traw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));\n\t\t\tlockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),\n\t\t\t\t\t\t   &rcu_node_class[i], buf[i]);\n\t\t\traw_spin_lock_init(&rnp->fqslock);\n\t\t\tlockdep_set_class_and_name(&rnp->fqslock,\n\t\t\t\t\t\t   &rcu_fqs_class[i], fqs[i]);\n\t\t\trnp->gp_seq = rcu_state.gp_seq;\n\t\t\trnp->gp_seq_needed = rcu_state.gp_seq;\n\t\t\trnp->completedqs = rcu_state.gp_seq;\n\t\t\trnp->qsmask = 0;\n\t\t\trnp->qsmaskinit = 0;\n\t\t\trnp->grplo = j * cpustride;\n\t\t\trnp->grphi = (j + 1) * cpustride - 1;\n\t\t\tif (rnp->grphi >= nr_cpu_ids)\n\t\t\t\trnp->grphi = nr_cpu_ids - 1;\n\t\t\tif (i == 0) {\n\t\t\t\trnp->grpnum = 0;\n\t\t\t\trnp->grpmask = 0;\n\t\t\t\trnp->parent = NULL;\n\t\t\t} else {\n\t\t\t\trnp->grpnum = j % levelspread[i - 1];\n\t\t\t\trnp->grpmask = BIT(rnp->grpnum);\n\t\t\t\trnp->parent = rcu_state.level[i - 1] +\n\t\t\t\t\t      j / levelspread[i - 1];\n\t\t\t}\n\t\t\trnp->level = i;\n\t\t\tINIT_LIST_HEAD(&rnp->blkd_tasks);\n\t\t\trcu_init_one_nocb(rnp);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[0]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[1]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[2]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[3]);\n\t\t\tspin_lock_init(&rnp->exp_lock);\n\t\t}\n\t}\n\n\tinit_swait_queue_head(&rcu_state.gp_wq);\n\tinit_swait_queue_head(&rcu_state.expedited_wq);\n\trnp = rcu_first_leaf_node();\n\tfor_each_possible_cpu(i) {\n\t\twhile (i > rnp->grphi)\n\t\t\trnp++;\n\t\tper_cpu_ptr(&rcu_data, i)->mynode = rnp;\n\t\trcu_boot_init_percpu_data(i);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "int rcu_num_lvls",
            "int num_rcu_lvl[] = NUM_RCU_LVL_INIT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_num_lvls;\nint num_rcu_lvl[] = NUM_RCU_LVL_INIT;\n\nstatic void __init rcu_init_one(void)\n{\n\tstatic const char * const buf[] = RCU_NODE_NAME_INIT;\n\tstatic const char * const fqs[] = RCU_FQS_NAME_INIT;\n\tstatic struct lock_class_key rcu_node_class[RCU_NUM_LVLS];\n\tstatic struct lock_class_key rcu_fqs_class[RCU_NUM_LVLS];\n\n\tint levelspread[RCU_NUM_LVLS];\t\t/* kids/node in each level. */\n\tint cpustride = 1;\n\tint i;\n\tint j;\n\tstruct rcu_node *rnp;\n\n\tBUILD_BUG_ON(RCU_NUM_LVLS > ARRAY_SIZE(buf));  /* Fix buf[] init! */\n\n\t/* Silence gcc 4.8 false positive about array index out of range. */\n\tif (rcu_num_lvls <= 0 || rcu_num_lvls > RCU_NUM_LVLS)\n\t\tpanic(\"rcu_init_one: rcu_num_lvls out of range\");\n\n\t/* Initialize the level-tracking arrays. */\n\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\trcu_state.level[i] =\n\t\t\trcu_state.level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Initialize the elements themselves, starting from the leaves. */\n\n\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\tcpustride *= levelspread[i];\n\t\trnp = rcu_state.level[i];\n\t\tfor (j = 0; j < num_rcu_lvl[i]; j++, rnp++) {\n\t\t\traw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));\n\t\t\tlockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),\n\t\t\t\t\t\t   &rcu_node_class[i], buf[i]);\n\t\t\traw_spin_lock_init(&rnp->fqslock);\n\t\t\tlockdep_set_class_and_name(&rnp->fqslock,\n\t\t\t\t\t\t   &rcu_fqs_class[i], fqs[i]);\n\t\t\trnp->gp_seq = rcu_state.gp_seq;\n\t\t\trnp->gp_seq_needed = rcu_state.gp_seq;\n\t\t\trnp->completedqs = rcu_state.gp_seq;\n\t\t\trnp->qsmask = 0;\n\t\t\trnp->qsmaskinit = 0;\n\t\t\trnp->grplo = j * cpustride;\n\t\t\trnp->grphi = (j + 1) * cpustride - 1;\n\t\t\tif (rnp->grphi >= nr_cpu_ids)\n\t\t\t\trnp->grphi = nr_cpu_ids - 1;\n\t\t\tif (i == 0) {\n\t\t\t\trnp->grpnum = 0;\n\t\t\t\trnp->grpmask = 0;\n\t\t\t\trnp->parent = NULL;\n\t\t\t} else {\n\t\t\t\trnp->grpnum = j % levelspread[i - 1];\n\t\t\t\trnp->grpmask = BIT(rnp->grpnum);\n\t\t\t\trnp->parent = rcu_state.level[i - 1] +\n\t\t\t\t\t      j / levelspread[i - 1];\n\t\t\t}\n\t\t\trnp->level = i;\n\t\t\tINIT_LIST_HEAD(&rnp->blkd_tasks);\n\t\t\trcu_init_one_nocb(rnp);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[0]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[1]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[2]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[3]);\n\t\t\tspin_lock_init(&rnp->exp_lock);\n\t\t}\n\t}\n\n\tinit_swait_queue_head(&rcu_state.gp_wq);\n\tinit_swait_queue_head(&rcu_state.expedited_wq);\n\trnp = rcu_first_leaf_node();\n\tfor_each_possible_cpu(i) {\n\t\twhile (i > rnp->grphi)\n\t\t\trnp++;\n\t\tper_cpu_ptr(&rcu_data, i)->mynode = rnp;\n\t\trcu_boot_init_percpu_data(i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_init_geometry",
          "args": [],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_geometry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3610-3684",
          "snippet": "static void __init rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tif (jiffies_till_sched_qs == ULONG_MAX)\n\t\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_fanout_leaf = RCU_FANOUT_LEAF;",
            "int rcu_num_lvls",
            "int num_rcu_lvl[] = NUM_RCU_LVL_INIT;",
            "int rcu_num_nodes",
            "static ulong jiffies_till_first_fqs = ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;",
            "static ulong jiffies_till_sched_qs = ULONG_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_fanout_leaf = RCU_FANOUT_LEAF;\nint rcu_num_lvls;\nint num_rcu_lvl[] = NUM_RCU_LVL_INIT;\nint rcu_num_nodes;\nstatic ulong jiffies_till_first_fqs = ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\n\nstatic void __init rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tif (jiffies_till_sched_qs == ULONG_MAX)\n\t\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_bootup_announce",
          "args": [],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_bootup_announce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1310-1316",
          "snippet": "static int __init srcu_bootup_announce(void)\n{\n\tpr_info(\"Hierarchical SRCU implementation.\\n\");\n\tif (exp_holdoff != DEFAULT_SRCU_EXP_HOLDOFF)\n\t\tpr_info(\"\\tNon-default auto-expedite holdoff of %lu ns.\\n\", exp_holdoff);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define DEFAULT_SRCU_EXP_HOLDOFF (25 * 1000)"
          ],
          "globals_used": [
            "static ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define DEFAULT_SRCU_EXP_HOLDOFF (25 * 1000)\n\nstatic ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;\n\nstatic int __init srcu_bootup_announce(void)\n{\n\tpr_info(\"Hierarchical SRCU implementation.\\n\");\n\tif (exp_holdoff != DEFAULT_SRCU_EXP_HOLDOFF)\n\t\tpr_info(\"\\tNon-default auto-expedite holdoff of %lu ns.\\n\", exp_holdoff);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_early_boot_tests",
          "args": [],
          "line": 3715
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_early_boot_tests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "926-926",
          "snippet": "void rcu_early_boot_tests(void) {}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_early_boot_tests(void) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic bool dump_tree;\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstruct workqueue_struct *rcu_gp_wq;\nstruct workqueue_struct *rcu_par_gp_wq;\n\nvoid __init rcu_init(void)\n{\n\tint cpu;\n\n\trcu_early_boot_tests();\n\n\trcu_bootup_announce();\n\trcu_init_geometry();\n\trcu_init_one();\n\tif (dump_tree)\n\t\trcu_dump_rcu_node_tree();\n\topen_softirq(RCU_SOFTIRQ, rcu_process_callbacks);\n\n\t/*\n\t * We don't need protection against CPU-hotplug here because\n\t * this is called early in boot, before either interrupts\n\t * or the scheduler are operational.\n\t */\n\tpm_notifier(rcu_pm_notify, 0);\n\tfor_each_online_cpu(cpu) {\n\t\trcutree_prepare_cpu(cpu);\n\t\trcu_cpu_starting(cpu);\n\t\trcutree_online_cpu(cpu);\n\t}\n\n\t/* Create workqueue for expedited GPs and for Tree SRCU. */\n\trcu_gp_wq = alloc_workqueue(\"rcu_gp\", WQ_MEM_RECLAIM, 0);\n\tWARN_ON(!rcu_gp_wq);\n\trcu_par_gp_wq = alloc_workqueue(\"rcu_par_gp\", WQ_MEM_RECLAIM, 0);\n\tWARN_ON(!rcu_par_gp_wq);\n\tsrcu_init();\n}"
  },
  {
    "function_name": "rcu_dump_rcu_node_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3690-3706",
    "snippet": "static void __init rcu_dump_rcu_node_tree(void)\n{\n\tint level = 0;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"rcu_node tree layout dump\\n\");\n\tpr_info(\" \");\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (rnp->level != level) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tpr_info(\" \");\n\t\t\tlevel = rnp->level;\n\t\t}\n\t\tpr_cont(\"%d:%d ^%d  \", rnp->grplo, rnp->grphi, rnp->grpnum);\n\t}\n\tpr_cont(\"\\n\");\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%d:%d ^%d  \"",
            "rnp->grplo",
            "rnp->grphi",
            "rnp->grpnum"
          ],
          "line": 3703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\" \""
          ],
          "line": 3700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\" \""
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"rcu_node tree layout dump\\n\""
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void __init rcu_dump_rcu_node_tree(void)\n{\n\tint level = 0;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"rcu_node tree layout dump\\n\");\n\tpr_info(\" \");\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (rnp->level != level) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tpr_info(\" \");\n\t\t\tlevel = rnp->level;\n\t\t}\n\t\tpr_cont(\"%d:%d ^%d  \", rnp->grplo, rnp->grphi, rnp->grpnum);\n\t}\n\tpr_cont(\"\\n\");\n}"
  },
  {
    "function_name": "rcu_init_geometry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3610-3684",
    "snippet": "static void __init rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tif (jiffies_till_sched_qs == ULONG_MAX)\n\t\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_fanout_leaf = RCU_FANOUT_LEAF;",
      "int rcu_num_lvls",
      "int num_rcu_lvl[] = NUM_RCU_LVL_INIT;",
      "int rcu_num_nodes",
      "static ulong jiffies_till_first_fqs = ULONG_MAX;",
      "static ulong jiffies_till_next_fqs = ULONG_MAX;",
      "static ulong jiffies_till_sched_qs = ULONG_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "nr_cpu_ids",
            "cap"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 3647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\"",
            "rcu_fanout_leaf",
            "nr_cpu_ids"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_jiffies_till_sched_qs",
          "args": [],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_jiffies_till_sched_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "413-428",
          "snippet": "static void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong jiffies_till_first_fqs = ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;",
            "static ulong jiffies_till_sched_qs = ULONG_MAX;",
            "static ulong jiffies_to_sched_qs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ulong jiffies_till_first_fqs = ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\nstatic ulong jiffies_to_sched_qs;\n\nstatic void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_fanout_leaf = RCU_FANOUT_LEAF;\nint rcu_num_lvls;\nint num_rcu_lvl[] = NUM_RCU_LVL_INIT;\nint rcu_num_nodes;\nstatic ulong jiffies_till_first_fqs = ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\n\nstatic void __init rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tif (jiffies_till_sched_qs == ULONG_MAX)\n\t\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}"
  },
  {
    "function_name": "rcu_init_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3526-3603",
    "snippet": "static void __init rcu_init_one(void)\n{\n\tstatic const char * const buf[] = RCU_NODE_NAME_INIT;\n\tstatic const char * const fqs[] = RCU_FQS_NAME_INIT;\n\tstatic struct lock_class_key rcu_node_class[RCU_NUM_LVLS];\n\tstatic struct lock_class_key rcu_fqs_class[RCU_NUM_LVLS];\n\n\tint levelspread[RCU_NUM_LVLS];\t\t/* kids/node in each level. */\n\tint cpustride = 1;\n\tint i;\n\tint j;\n\tstruct rcu_node *rnp;\n\n\tBUILD_BUG_ON(RCU_NUM_LVLS > ARRAY_SIZE(buf));  /* Fix buf[] init! */\n\n\t/* Silence gcc 4.8 false positive about array index out of range. */\n\tif (rcu_num_lvls <= 0 || rcu_num_lvls > RCU_NUM_LVLS)\n\t\tpanic(\"rcu_init_one: rcu_num_lvls out of range\");\n\n\t/* Initialize the level-tracking arrays. */\n\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\trcu_state.level[i] =\n\t\t\trcu_state.level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Initialize the elements themselves, starting from the leaves. */\n\n\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\tcpustride *= levelspread[i];\n\t\trnp = rcu_state.level[i];\n\t\tfor (j = 0; j < num_rcu_lvl[i]; j++, rnp++) {\n\t\t\traw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));\n\t\t\tlockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),\n\t\t\t\t\t\t   &rcu_node_class[i], buf[i]);\n\t\t\traw_spin_lock_init(&rnp->fqslock);\n\t\t\tlockdep_set_class_and_name(&rnp->fqslock,\n\t\t\t\t\t\t   &rcu_fqs_class[i], fqs[i]);\n\t\t\trnp->gp_seq = rcu_state.gp_seq;\n\t\t\trnp->gp_seq_needed = rcu_state.gp_seq;\n\t\t\trnp->completedqs = rcu_state.gp_seq;\n\t\t\trnp->qsmask = 0;\n\t\t\trnp->qsmaskinit = 0;\n\t\t\trnp->grplo = j * cpustride;\n\t\t\trnp->grphi = (j + 1) * cpustride - 1;\n\t\t\tif (rnp->grphi >= nr_cpu_ids)\n\t\t\t\trnp->grphi = nr_cpu_ids - 1;\n\t\t\tif (i == 0) {\n\t\t\t\trnp->grpnum = 0;\n\t\t\t\trnp->grpmask = 0;\n\t\t\t\trnp->parent = NULL;\n\t\t\t} else {\n\t\t\t\trnp->grpnum = j % levelspread[i - 1];\n\t\t\t\trnp->grpmask = BIT(rnp->grpnum);\n\t\t\t\trnp->parent = rcu_state.level[i - 1] +\n\t\t\t\t\t      j / levelspread[i - 1];\n\t\t\t}\n\t\t\trnp->level = i;\n\t\t\tINIT_LIST_HEAD(&rnp->blkd_tasks);\n\t\t\trcu_init_one_nocb(rnp);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[0]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[1]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[2]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[3]);\n\t\t\tspin_lock_init(&rnp->exp_lock);\n\t\t}\n\t}\n\n\tinit_swait_queue_head(&rcu_state.gp_wq);\n\tinit_swait_queue_head(&rcu_state.expedited_wq);\n\trnp = rcu_first_leaf_node();\n\tfor_each_possible_cpu(i) {\n\t\twhile (i > rnp->grphi)\n\t\t\trnp++;\n\t\tper_cpu_ptr(&rcu_data, i)->mynode = rnp;\n\t\trcu_boot_init_percpu_data(i);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "int rcu_num_lvls",
      "int num_rcu_lvl[] = NUM_RCU_LVL_INIT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_boot_init_percpu_data",
          "args": [
            "i"
          ],
          "line": 3601
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_boot_init_percpu_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3184-3199",
          "snippet": "static void __init\nrcu_boot_init_percpu_data(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\trdp->grpmask = leaf_node_cpu_bit(rdp->mynode, cpu);\n\tWARN_ON_ONCE(rdp->dynticks_nesting != 1);\n\tWARN_ON_ONCE(rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp)));\n\trdp->rcu_ofl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_ofl_gp_flags = RCU_GP_CLEANED;\n\trdp->rcu_onl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_onl_gp_flags = RCU_GP_CLEANED;\n\trdp->cpu = cpu;\n\trcu_boot_init_nocb_percpu_data(rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __init\nrcu_boot_init_percpu_data(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\trdp->grpmask = leaf_node_cpu_bit(rdp->mynode, cpu);\n\tWARN_ON_ONCE(rdp->dynticks_nesting != 1);\n\tWARN_ON_ONCE(rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp)));\n\trdp->rcu_ofl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_ofl_gp_flags = RCU_GP_CLEANED;\n\trdp->rcu_onl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_onl_gp_flags = RCU_GP_CLEANED;\n\trdp->cpu = cpu;\n\trcu_boot_init_nocb_percpu_data(rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "i"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_first_leaf_node",
          "args": [],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rcu_state.expedited_wq"
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&rcu_state.gp_wq"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&rnp->exp_lock"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rnp->exp_wq[3]"
          ],
          "line": 3589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rnp->exp_wq[2]"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rnp->exp_wq[1]"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rnp->exp_wq[0]"
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_init_one_nocb",
          "args": [
            "rnp"
          ],
          "line": 3585
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_one_nocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2607-2609",
          "snippet": "static void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_init_one_nocb(struct rcu_node *rnp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rnp->blkd_tasks"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "rnp->grpnum"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class_and_name",
          "args": [
            "&rnp->fqslock",
            "&rcu_fqs_class[i]",
            "fqs[i]"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&rnp->fqslock"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class_and_name",
          "args": [
            "&ACCESS_PRIVATE(rnp, lock)",
            "&rcu_node_class[i]",
            "buf[i]"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "rnp",
            "lock"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&ACCESS_PRIVATE(rnp, lock)"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "rnp",
            "lock"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_init_levelspread",
          "args": [
            "levelspread",
            "num_rcu_lvl"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_levelspread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "314-333",
          "snippet": "static inline void rcu_init_levelspread(int *levelspread, const int *levelcnt)\n{\n\tint i;\n\n\tif (rcu_fanout_exact) {\n\t\tlevelspread[rcu_num_lvls - 1] = rcu_fanout_leaf;\n\t\tfor (i = rcu_num_lvls - 2; i >= 0; i--)\n\t\t\tlevelspread[i] = RCU_FANOUT;\n\t} else {\n\t\tint ccur;\n\t\tint cprv;\n\n\t\tcprv = nr_cpu_ids;\n\t\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\t\tccur = levelcnt[i];\n\t\t\tlevelspread[i] = (cprv + ccur - 1) / ccur;\n\t\t\tcprv = ccur;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_init_levelspread(int *levelspread, const int *levelcnt)\n{\n\tint i;\n\n\tif (rcu_fanout_exact) {\n\t\tlevelspread[rcu_num_lvls - 1] = rcu_fanout_leaf;\n\t\tfor (i = rcu_num_lvls - 2; i >= 0; i--)\n\t\t\tlevelspread[i] = RCU_FANOUT;\n\t} else {\n\t\tint ccur;\n\t\tint cprv;\n\n\t\tcprv = nr_cpu_ids;\n\t\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\t\tccur = levelcnt[i];\n\t\t\tlevelspread[i] = (cprv + ccur - 1) / ccur;\n\t\t\tcprv = ccur;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rcu_init_one: rcu_num_lvls out of range\""
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_panic_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "181-185",
          "snippet": "static int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "RCU_NUM_LVLS > ARRAY_SIZE(buf)"
          ],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_num_lvls;\nint num_rcu_lvl[] = NUM_RCU_LVL_INIT;\n\nstatic void __init rcu_init_one(void)\n{\n\tstatic const char * const buf[] = RCU_NODE_NAME_INIT;\n\tstatic const char * const fqs[] = RCU_FQS_NAME_INIT;\n\tstatic struct lock_class_key rcu_node_class[RCU_NUM_LVLS];\n\tstatic struct lock_class_key rcu_fqs_class[RCU_NUM_LVLS];\n\n\tint levelspread[RCU_NUM_LVLS];\t\t/* kids/node in each level. */\n\tint cpustride = 1;\n\tint i;\n\tint j;\n\tstruct rcu_node *rnp;\n\n\tBUILD_BUG_ON(RCU_NUM_LVLS > ARRAY_SIZE(buf));  /* Fix buf[] init! */\n\n\t/* Silence gcc 4.8 false positive about array index out of range. */\n\tif (rcu_num_lvls <= 0 || rcu_num_lvls > RCU_NUM_LVLS)\n\t\tpanic(\"rcu_init_one: rcu_num_lvls out of range\");\n\n\t/* Initialize the level-tracking arrays. */\n\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\trcu_state.level[i] =\n\t\t\trcu_state.level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Initialize the elements themselves, starting from the leaves. */\n\n\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\tcpustride *= levelspread[i];\n\t\trnp = rcu_state.level[i];\n\t\tfor (j = 0; j < num_rcu_lvl[i]; j++, rnp++) {\n\t\t\traw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));\n\t\t\tlockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),\n\t\t\t\t\t\t   &rcu_node_class[i], buf[i]);\n\t\t\traw_spin_lock_init(&rnp->fqslock);\n\t\t\tlockdep_set_class_and_name(&rnp->fqslock,\n\t\t\t\t\t\t   &rcu_fqs_class[i], fqs[i]);\n\t\t\trnp->gp_seq = rcu_state.gp_seq;\n\t\t\trnp->gp_seq_needed = rcu_state.gp_seq;\n\t\t\trnp->completedqs = rcu_state.gp_seq;\n\t\t\trnp->qsmask = 0;\n\t\t\trnp->qsmaskinit = 0;\n\t\t\trnp->grplo = j * cpustride;\n\t\t\trnp->grphi = (j + 1) * cpustride - 1;\n\t\t\tif (rnp->grphi >= nr_cpu_ids)\n\t\t\t\trnp->grphi = nr_cpu_ids - 1;\n\t\t\tif (i == 0) {\n\t\t\t\trnp->grpnum = 0;\n\t\t\t\trnp->grpmask = 0;\n\t\t\t\trnp->parent = NULL;\n\t\t\t} else {\n\t\t\t\trnp->grpnum = j % levelspread[i - 1];\n\t\t\t\trnp->grpmask = BIT(rnp->grpnum);\n\t\t\t\trnp->parent = rcu_state.level[i - 1] +\n\t\t\t\t\t      j / levelspread[i - 1];\n\t\t\t}\n\t\t\trnp->level = i;\n\t\t\tINIT_LIST_HEAD(&rnp->blkd_tasks);\n\t\t\trcu_init_one_nocb(rnp);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[0]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[1]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[2]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[3]);\n\t\t\tspin_lock_init(&rnp->exp_lock);\n\t\t}\n\t}\n\n\tinit_swait_queue_head(&rcu_state.gp_wq);\n\tinit_swait_queue_head(&rcu_state.expedited_wq);\n\trnp = rcu_first_leaf_node();\n\tfor_each_possible_cpu(i) {\n\t\twhile (i > rnp->grphi)\n\t\t\trnp++;\n\t\tper_cpu_ptr(&rcu_data, i)->mynode = rnp;\n\t\trcu_boot_init_percpu_data(i);\n\t}\n}"
  },
  {
    "function_name": "rcu_scheduler_starting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3514-3521",
    "snippet": "void rcu_scheduler_starting(void)\n{\n\tWARN_ON(num_online_cpus() != 1);\n\tWARN_ON(nr_context_switches() > 0);\n\trcu_test_sync_prims();\n\trcu_scheduler_active = RCU_SCHEDULER_INIT;\n\trcu_test_sync_prims();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int rcu_scheduler_active"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_test_sync_prims",
          "args": [],
          "line": 3520
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_test_sync_prims",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "201-207",
          "snippet": "void rcu_test_sync_prims(void)\n{\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU))\n\t\treturn;\n\tsynchronize_rcu();\n\tsynchronize_rcu_expedited();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_test_sync_prims(void)\n{\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU))\n\t\treturn;\n\tsynchronize_rcu();\n\tsynchronize_rcu_expedited();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nr_context_switches() > 0"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_context_switches",
          "args": [],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "nr_context_switches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2872-3341",
          "snippet": "unsigned long long nr_context_switches(void)\n{\n\tint i;\n\tunsigned long long sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned long nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}\n\n/*\n * IO-wait accounting, and how its mostly bollocks (on SMP).\n *\n * The idea behind IO-wait account is to account the idle time that we could\n * have spend running if it were not for IO. That is, if we were to improve the\n * storage performance, we'd have a proportional reduction in IO-wait time.\n *\n * This all works nicely on UP, where, when a task blocks on IO, we account\n * idle time as IO-wait, because if the storage were faster, it could've been\n * running and we'd not be idle.\n *\n * This has been extended to SMP, by doing the same for each CPU. This however\n * is broken.\n *\n * Imagine for instance the case where two tasks block on one CPU, only the one\n * CPU will have IO-wait accounted, while the other has regular idle. Even\n * though, if the storage were faster, both could've ran at the same time,\n * utilising both CPUs.\n *\n * This means, that when looking globally, the current IO-wait accounting on\n * SMP is a lower bound, by reason of under accounting.\n *\n * Worse, since the numbers are provided per CPU, they are sometimes\n * interpreted per CPU, and that is nonsensical. A blocked task isn't strictly\n * associated with any one particular CPU, it can wake to another CPU than it\n * blocked on. This means the per CPU IO-wait number is meaningless.\n *\n * Task CPU affinities can make all that even more 'interesting'.\n */\n\nunsigned long nr_iowait(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += nr_iowait_cpu(i);\n\n\treturn sum;\n}\n\n#ifdef CONFIG_SMP\n\n/*\n * sched_exec - execve() is a valuable balancing opportunity, because at\n * this point the task has the smallest effective memory and cache footprint.\n */\nvoid sched_exec(void)\n{\n\tstruct task_struct *p = current;\n\tunsigned long flags;\n\tint dest_cpu;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0);\n\tif (dest_cpu == smp_processor_id())\n\t\tgoto unlock;\n\n\tif (likely(cpu_active(dest_cpu))) {\n\t\tstruct migration_arg arg = { p, dest_cpu };\n\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\t\tstop_one_cpu(task_cpu(p), migration_cpu_stop, &arg);\n\t\treturn;\n\t}\nunlock:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}\n\n#endif\n\nDEFINE_PER_CPU(struct kernel_stat, kstat);\nDEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);\n\nEXPORT_PER_CPU_SYMBOL(kstat);\nEXPORT_PER_CPU_SYMBOL(kernel_cpustat);\n\n/*\n * The function fair_sched_class.update_curr accesses the struct curr\n * and its field curr->exec_start; when called from task_sched_runtime(),\n * we observe a high rate of cache misses in practice.\n * Prefetching this data results in improved performance.\n */\nstatic inline void prefetch_curr_exec_start(struct task_struct *p)\n{\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tstruct sched_entity *curr = (&p->se)->cfs_rq->curr;\n#else\n\tstruct sched_entity *curr = (&task_rq(p)->cfs)->curr;\n#endif\n\tprefetch(curr);\n\tprefetch(&curr->exec_start);\n}\n\n/*\n * Return accounted runtime for the task.\n * In case the task is currently running, return the runtime plus current's\n * pending runtime that have not been accounted yet.\n */\nunsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}\n\n/*\n * This function gets called by the timer code, with HZ frequency.\n * We call it with interrupts disabled.\n */\nvoid scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq->curr;\n\tstruct rq_flags rf;\n\n\tsched_clock_tick();\n\n\trq_lock(rq, &rf);\n\n\tupdate_rq_clock(rq);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\tcpu_load_update_active(rq);\n\tcalc_global_load_tick(rq);\n\tpsi_task_tick(rq);\n\n\trq_unlock(rq, &rf);\n\n\tperf_event_task_tick();\n\n#ifdef CONFIG_SMP\n\trq->idle_balance = idle_cpu(cpu);\n\ttrigger_load_balance(rq);\n#endif\n}\n\n#ifdef CONFIG_NO_HZ_FULL\n\nstruct tick_work {\n\tint\t\t\tcpu;\n\tstruct delayed_work\twork;\n};\n\nstatic struct tick_work __percpu *tick_work_cpu;\n\nstatic void sched_tick_remote(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct tick_work *twork = container_of(dwork, struct tick_work, work);\n\tint cpu = twork->cpu;\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr;\n\tstruct rq_flags rf;\n\tu64 delta;\n\n\t/*\n\t * Handle the tick only if it appears the remote CPU is running in full\n\t * dynticks mode. The check is racy by nature, but missing a tick or\n\t * having one too much is no big deal because the scheduler tick updates\n\t * statistics and checks timeslices in a time-independent way, regardless\n\t * of when exactly it is running.\n\t */\n\tif (idle_cpu(cpu) || !tick_nohz_tick_stopped_cpu(cpu))\n\t\tgoto out_requeue;\n\n\trq_lock_irq(rq, &rf);\n\tcurr = rq->curr;\n\tif (is_idle_task(curr))\n\t\tgoto out_unlock;\n\n\tupdate_rq_clock(rq);\n\tdelta = rq_clock_task(rq) - curr->se.exec_start;\n\n\t/*\n\t * Make sure the next tick runs within a reasonable\n\t * amount of time.\n\t */\n\tWARN_ON_ONCE(delta > (u64)NSEC_PER_SEC * 3);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\nout_unlock:\n\trq_unlock_irq(rq, &rf);\n\nout_requeue:\n\t/*\n\t * Run the remote tick once per second (1Hz). This arbitrary\n\t * frequency is large enough to avoid overload but short enough\n\t * to keep scheduler internal stats reasonably up to date.\n\t */\n\tqueue_delayed_work(system_unbound_wq, dwork, HZ);\n}\n\nstatic void sched_tick_start(int cpu)\n{\n\tstruct tick_work *twork;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TICK))\n\t\treturn;\n\n\tWARN_ON_ONCE(!tick_work_cpu);\n\n\ttwork = per_cpu_ptr(tick_work_cpu, cpu);\n\ttwork->cpu = cpu;\n\tINIT_DELAYED_WORK(&twork->work, sched_tick_remote);\n\tqueue_delayed_work(system_unbound_wq, &twork->work, HZ);\n}\n\n#ifdef CONFIG_HOTPLUG_CPU\nstatic void sched_tick_stop(int cpu)\n{\n\tstruct tick_work *twork;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TICK))\n\t\treturn;\n\n\tWARN_ON_ONCE(!tick_work_cpu);\n\n\ttwork = per_cpu_ptr(tick_work_cpu, cpu);\n\tcancel_delayed_work_sync(&twork->work);\n}\n#endif /* CONFIG_HOTPLUG_CPU */\n\nint __init sched_tick_offload_init(void)\n{\n\ttick_work_cpu = alloc_percpu(struct tick_work);\n\tBUG_ON(!tick_work_cpu);\n\n\treturn 0;\n}\n\n#else /* !CONFIG_NO_HZ_FULL */\nstatic inline void sched_tick_start(int cpu) { }\nstatic inline void sched_tick_stop(int cpu) { }\n#endif\n\n#if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \\\n\t\t\t\tdefined(CONFIG_TRACE_PREEMPT_TOGGLE))\n/*\n * If the value passed in is equal to the current preempt count\n * then we just disabled preemption. Start timing the latency.\n */\nstatic inline void preempt_latency_start(int val)\n{\n\tif (preempt_count() == val) {\n\t\tunsigned long ip = get_lock_parent_ip();\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = ip;\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, ip);\n\t}\n}\n\nvoid preempt_count_add(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))\n\t\treturn;\n#endif\n\t__preempt_count_add(val);\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Spinlock count overflowing soon?\n\t */\n\tDEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >=\n\t\t\t\tPREEMPT_MASK - 10);\n#endif\n\tpreempt_latency_start(val);\n}\nEXPORT_SYMBOL(preempt_count_add);\nNOKPROBE_SYMBOL(preempt_count_add);\n\n/*\n * If the value passed in equals to the current preempt count\n * then we just enabled preemption. Stop timing the latency.\n */\nstatic inline void preempt_latency_stop(int val)\n{\n\tif (preempt_count() == val)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n}\n\nvoid preempt_count_sub(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(val > preempt_count()))\n\t\treturn;\n\t/*\n\t * Is the spinlock portion underflowing?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&\n\t\t\t!(preempt_count() & PREEMPT_MASK)))\n\t\treturn;\n#endif\n\n\tpreempt_latency_stop(val);\n\t__preempt_count_sub(val);\n}\nEXPORT_SYMBOL(preempt_count_sub);\nNOKPROBE_SYMBOL(preempt_count_sub);\n\n#else\nstatic inline void preempt_latency_start(int val) { }\nstatic inline void preempt_latency_stop(int val) { }\n#endif\n\nstatic inline unsigned long get_preempt_disable_ip(struct task_struct *p)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\treturn p->preempt_disable_ip;\n#else\n\treturn 0;\n#endif\n}\n\n/*\n * Print scheduling while atomic bug:\n */\nstatic noinline void __schedule_bug(struct task_struct *prev)\n{\n\t/* Save this before calling printk(), since that will clobber it */\n\tunsigned long preempt_disable_ip = get_preempt_disable_ip(current);\n\n\tif (oops_in_progress)\n\t\treturn;\n\n\tprintk(KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->comm, prev->pid, preempt_count());\n\n\tdebug_show_held_locks(prev);\n\tprint_modules();\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(prev);\n\tif (IS_ENABLED(CONFIG_DEBUG_PREEMPT)\n\t    && in_atomic_preempt_off()) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\tif (panic_on_warn)\n\t\tpanic(\"scheduling while atomic\\n\");\n\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}\n\n/*\n * Various schedule()-time debugging checks and statistics:\n */\nstatic inline void schedule_debug(struct task_struct *prev)\n{\n#ifdef CONFIG_SCHED_STACK_END_CHECK\n\tif (task_stack_end_corrupted(prev))\n\t\tpanic(\"corrupted stack end detected inside scheduler\\n\");\n#endif\n\n\tif (unlikely(in_atomic_preempt_off())) {\n\t\t__schedule_bug(prev);\n\t\tpreempt_count_set(PREEMPT_DISABLED);\n\t}\n\trcu_sleep_check();\n\n\tprofile_hit(SCHED_PROFILING, __builtin_return_address(0));\n\n\tschedstat_inc(this_rq()->sched_count);\n}\n\n/*\n * Pick up the highest-prio task:\n */\nstatic inline struct task_struct *\npick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tconst struct sched_class *class;\n\tstruct task_struct *p;\n\n\t/*\n\t * Optimization: we know that if all tasks are in the fair class we can\n\t * call that function directly, but only if the @prev task wasn't of a\n\t * higher scheduling class, because otherwise those loose the\n\t * opportunity to pull in more work from other CPUs.\n\t */\n\tif (likely((prev->sched_class == &idle_sched_class ||\n\t\t    prev->sched_class == &fair_sched_class) &&\n\t\t   rq->nr_running == rq->cfs.h_nr_running)) {\n\n\t\tp = fair_sched_class.pick_next_task(rq, prev, rf);\n\t\tif (unlikely(p == RETRY_TASK))\n\t\t\tgoto again;\n\n\t\t/* Assumes fair_sched_class->next == idle_sched_class */\n\t\tif (unlikely(!p))\n\t\t\tp = idle_sched_class.pick_next_task(rq, prev, rf);\n\n\t\treturn p;\n\t}\n\nagain:\n\tfor_each_class(class) {\n\t\tp = class->pick_next_task(rq, prev, rf);\n\t\tif (p) {\n\t\t\tif (unlikely(p == RETRY_TASK))\n\t\t\t\tgoto again;\n\t\t\treturn p;\n\t\t}\n\t}\n\n\t/* The idle class should always have a runnable task: */\n\tBUG();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nunsigned long long nr_context_switches(void)\n{\n\tint i;\n\tunsigned long long sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned long nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}\n\n/*\n * IO-wait accounting, and how its mostly bollocks (on SMP).\n *\n * The idea behind IO-wait account is to account the idle time that we could\n * have spend running if it were not for IO. That is, if we were to improve the\n * storage performance, we'd have a proportional reduction in IO-wait time.\n *\n * This all works nicely on UP, where, when a task blocks on IO, we account\n * idle time as IO-wait, because if the storage were faster, it could've been\n * running and we'd not be idle.\n *\n * This has been extended to SMP, by doing the same for each CPU. This however\n * is broken.\n *\n * Imagine for instance the case where two tasks block on one CPU, only the one\n * CPU will have IO-wait accounted, while the other has regular idle. Even\n * though, if the storage were faster, both could've ran at the same time,\n * utilising both CPUs.\n *\n * This means, that when looking globally, the current IO-wait accounting on\n * SMP is a lower bound, by reason of under accounting.\n *\n * Worse, since the numbers are provided per CPU, they are sometimes\n * interpreted per CPU, and that is nonsensical. A blocked task isn't strictly\n * associated with any one particular CPU, it can wake to another CPU than it\n * blocked on. This means the per CPU IO-wait number is meaningless.\n *\n * Task CPU affinities can make all that even more 'interesting'.\n */\n\nunsigned long nr_iowait(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += nr_iowait_cpu(i);\n\n\treturn sum;\n}\n\n#ifdef CONFIG_SMP\n\n/*\n * sched_exec - execve() is a valuable balancing opportunity, because at\n * this point the task has the smallest effective memory and cache footprint.\n */\nvoid sched_exec(void)\n{\n\tstruct task_struct *p = current;\n\tunsigned long flags;\n\tint dest_cpu;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, 0);\n\tif (dest_cpu == smp_processor_id())\n\t\tgoto unlock;\n\n\tif (likely(cpu_active(dest_cpu))) {\n\t\tstruct migration_arg arg = { p, dest_cpu };\n\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\t\tstop_one_cpu(task_cpu(p), migration_cpu_stop, &arg);\n\t\treturn;\n\t}\nunlock:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}\n\n#endif\n\nDEFINE_PER_CPU(struct kernel_stat, kstat);\nDEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);\n\nEXPORT_PER_CPU_SYMBOL(kstat);\nEXPORT_PER_CPU_SYMBOL(kernel_cpustat);\n\n/*\n * The function fair_sched_class.update_curr accesses the struct curr\n * and its field curr->exec_start; when called from task_sched_runtime(),\n * we observe a high rate of cache misses in practice.\n * Prefetching this data results in improved performance.\n */\nstatic inline void prefetch_curr_exec_start(struct task_struct *p)\n{\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tstruct sched_entity *curr = (&p->se)->cfs_rq->curr;\n#else\n\tstruct sched_entity *curr = (&task_rq(p)->cfs)->curr;\n#endif\n\tprefetch(curr);\n\tprefetch(&curr->exec_start);\n}\n\n/*\n * Return accounted runtime for the task.\n * In case the task is currently running, return the runtime plus current's\n * pending runtime that have not been accounted yet.\n */\nunsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}\n\n/*\n * This function gets called by the timer code, with HZ frequency.\n * We call it with interrupts disabled.\n */\nvoid scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq->curr;\n\tstruct rq_flags rf;\n\n\tsched_clock_tick();\n\n\trq_lock(rq, &rf);\n\n\tupdate_rq_clock(rq);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\tcpu_load_update_active(rq);\n\tcalc_global_load_tick(rq);\n\tpsi_task_tick(rq);\n\n\trq_unlock(rq, &rf);\n\n\tperf_event_task_tick();\n\n#ifdef CONFIG_SMP\n\trq->idle_balance = idle_cpu(cpu);\n\ttrigger_load_balance(rq);\n#endif\n}\n\n#ifdef CONFIG_NO_HZ_FULL\n\nstruct tick_work {\n\tint\t\t\tcpu;\n\tstruct delayed_work\twork;\n};\n\nstatic struct tick_work __percpu *tick_work_cpu;\n\nstatic void sched_tick_remote(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct tick_work *twork = container_of(dwork, struct tick_work, work);\n\tint cpu = twork->cpu;\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr;\n\tstruct rq_flags rf;\n\tu64 delta;\n\n\t/*\n\t * Handle the tick only if it appears the remote CPU is running in full\n\t * dynticks mode. The check is racy by nature, but missing a tick or\n\t * having one too much is no big deal because the scheduler tick updates\n\t * statistics and checks timeslices in a time-independent way, regardless\n\t * of when exactly it is running.\n\t */\n\tif (idle_cpu(cpu) || !tick_nohz_tick_stopped_cpu(cpu))\n\t\tgoto out_requeue;\n\n\trq_lock_irq(rq, &rf);\n\tcurr = rq->curr;\n\tif (is_idle_task(curr))\n\t\tgoto out_unlock;\n\n\tupdate_rq_clock(rq);\n\tdelta = rq_clock_task(rq) - curr->se.exec_start;\n\n\t/*\n\t * Make sure the next tick runs within a reasonable\n\t * amount of time.\n\t */\n\tWARN_ON_ONCE(delta > (u64)NSEC_PER_SEC * 3);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\nout_unlock:\n\trq_unlock_irq(rq, &rf);\n\nout_requeue:\n\t/*\n\t * Run the remote tick once per second (1Hz). This arbitrary\n\t * frequency is large enough to avoid overload but short enough\n\t * to keep scheduler internal stats reasonably up to date.\n\t */\n\tqueue_delayed_work(system_unbound_wq, dwork, HZ);\n}\n\nstatic void sched_tick_start(int cpu)\n{\n\tstruct tick_work *twork;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TICK))\n\t\treturn;\n\n\tWARN_ON_ONCE(!tick_work_cpu);\n\n\ttwork = per_cpu_ptr(tick_work_cpu, cpu);\n\ttwork->cpu = cpu;\n\tINIT_DELAYED_WORK(&twork->work, sched_tick_remote);\n\tqueue_delayed_work(system_unbound_wq, &twork->work, HZ);\n}\n\n#ifdef CONFIG_HOTPLUG_CPU\nstatic void sched_tick_stop(int cpu)\n{\n\tstruct tick_work *twork;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TICK))\n\t\treturn;\n\n\tWARN_ON_ONCE(!tick_work_cpu);\n\n\ttwork = per_cpu_ptr(tick_work_cpu, cpu);\n\tcancel_delayed_work_sync(&twork->work);\n}\n#endif /* CONFIG_HOTPLUG_CPU */\n\nint __init sched_tick_offload_init(void)\n{\n\ttick_work_cpu = alloc_percpu(struct tick_work);\n\tBUG_ON(!tick_work_cpu);\n\n\treturn 0;\n}\n\n#else /* !CONFIG_NO_HZ_FULL */\nstatic inline void sched_tick_start(int cpu) { }\nstatic inline void sched_tick_stop(int cpu) { }\n#endif\n\n#if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \\\n\t\t\t\tdefined(CONFIG_TRACE_PREEMPT_TOGGLE))\n/*\n * If the value passed in is equal to the current preempt count\n * then we just disabled preemption. Start timing the latency.\n */\nstatic inline void preempt_latency_start(int val)\n{\n\tif (preempt_count() == val) {\n\t\tunsigned long ip = get_lock_parent_ip();\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = ip;\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, ip);\n\t}\n}\n\nvoid preempt_count_add(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))\n\t\treturn;\n#endif\n\t__preempt_count_add(val);\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Spinlock count overflowing soon?\n\t */\n\tDEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >=\n\t\t\t\tPREEMPT_MASK - 10);\n#endif\n\tpreempt_latency_start(val);\n}\nEXPORT_SYMBOL(preempt_count_add);\nNOKPROBE_SYMBOL(preempt_count_add);\n\n/*\n * If the value passed in equals to the current preempt count\n * then we just enabled preemption. Stop timing the latency.\n */\nstatic inline void preempt_latency_stop(int val)\n{\n\tif (preempt_count() == val)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n}\n\nvoid preempt_count_sub(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(val > preempt_count()))\n\t\treturn;\n\t/*\n\t * Is the spinlock portion underflowing?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&\n\t\t\t!(preempt_count() & PREEMPT_MASK)))\n\t\treturn;\n#endif\n\n\tpreempt_latency_stop(val);\n\t__preempt_count_sub(val);\n}\nEXPORT_SYMBOL(preempt_count_sub);\nNOKPROBE_SYMBOL(preempt_count_sub);\n\n#else\nstatic inline void preempt_latency_start(int val) { }\nstatic inline void preempt_latency_stop(int val) { }\n#endif\n\nstatic inline unsigned long get_preempt_disable_ip(struct task_struct *p)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\treturn p->preempt_disable_ip;\n#else\n\treturn 0;\n#endif\n}\n\n/*\n * Print scheduling while atomic bug:\n */\nstatic noinline void __schedule_bug(struct task_struct *prev)\n{\n\t/* Save this before calling printk(), since that will clobber it */\n\tunsigned long preempt_disable_ip = get_preempt_disable_ip(current);\n\n\tif (oops_in_progress)\n\t\treturn;\n\n\tprintk(KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->comm, prev->pid, preempt_count());\n\n\tdebug_show_held_locks(prev);\n\tprint_modules();\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(prev);\n\tif (IS_ENABLED(CONFIG_DEBUG_PREEMPT)\n\t    && in_atomic_preempt_off()) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\tif (panic_on_warn)\n\t\tpanic(\"scheduling while atomic\\n\");\n\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}\n\n/*\n * Various schedule()-time debugging checks and statistics:\n */\nstatic inline void schedule_debug(struct task_struct *prev)\n{\n#ifdef CONFIG_SCHED_STACK_END_CHECK\n\tif (task_stack_end_corrupted(prev))\n\t\tpanic(\"corrupted stack end detected inside scheduler\\n\");\n#endif\n\n\tif (unlikely(in_atomic_preempt_off())) {\n\t\t__schedule_bug(prev);\n\t\tpreempt_count_set(PREEMPT_DISABLED);\n\t}\n\trcu_sleep_check();\n\n\tprofile_hit(SCHED_PROFILING, __builtin_return_address(0));\n\n\tschedstat_inc(this_rq()->sched_count);\n}\n\n/*\n * Pick up the highest-prio task:\n */\nstatic inline struct task_struct *\npick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tconst struct sched_class *class;\n\tstruct task_struct *p;\n\n\t/*\n\t * Optimization: we know that if all tasks are in the fair class we can\n\t * call that function directly, but only if the @prev task wasn't of a\n\t * higher scheduling class, because otherwise those loose the\n\t * opportunity to pull in more work from other CPUs.\n\t */\n\tif (likely((prev->sched_class == &idle_sched_class ||\n\t\t    prev->sched_class == &fair_sched_class) &&\n\t\t   rq->nr_running == rq->cfs.h_nr_running)) {\n\n\t\tp = fair_sched_class.pick_next_task(rq, prev, rf);\n\t\tif (unlikely(p == RETRY_TASK))\n\t\t\tgoto again;\n\n\t\t/* Assumes fair_sched_class->next == idle_sched_class */\n\t\tif (unlikely(!p))\n\t\t\tp = idle_sched_class.pick_next_task(rq, prev, rf);\n\n\t\treturn p;\n\t}\n\nagain:\n\tfor_each_class(class) {\n\t\tp = class->pick_next_task(rq, prev, rf);\n\t\tif (p) {\n\t\t\tif (unlikely(p == RETRY_TASK))\n\t\t\t\tgoto again;\n\t\t\treturn p;\n\t\t}\n\t}\n\n\t/* The idle class should always have a runnable task: */\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "num_online_cpus() != 1"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_scheduler_active;\n\nvoid rcu_scheduler_starting(void)\n{\n\tWARN_ON(num_online_cpus() != 1);\n\tWARN_ON(nr_context_switches() > 0);\n\trcu_test_sync_prims();\n\trcu_scheduler_active = RCU_SCHEDULER_INIT;\n\trcu_test_sync_prims();\n}"
  },
  {
    "function_name": "rcu_spawn_gp_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3463-3501",
    "snippet": "static int __init rcu_spawn_gp_kthread(void)\n{\n\tunsigned long flags;\n\tint kthread_prio_in = kthread_prio;\n\tstruct rcu_node *rnp;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\t/* Force priority into range. */\n\tif (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 2\n\t    && IS_BUILTIN(CONFIG_RCU_TORTURE_TEST))\n\t\tkthread_prio = 2;\n\telse if (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 1)\n\t\tkthread_prio = 1;\n\telse if (kthread_prio < 0)\n\t\tkthread_prio = 0;\n\telse if (kthread_prio > 99)\n\t\tkthread_prio = 99;\n\n\tif (kthread_prio != kthread_prio_in)\n\t\tpr_alert(\"rcu_spawn_gp_kthread(): Limited prio to %d from %d\\n\",\n\t\t\t kthread_prio, kthread_prio_in);\n\n\trcu_scheduler_fully_active = 1;\n\tt = kthread_create(rcu_gp_kthread, NULL, \"%s\", rcu_state.name);\n\tBUG_ON(IS_ERR(t));\n\trnp = rcu_get_root();\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trcu_state.gp_kthread = t;\n\tif (kthread_prio) {\n\t\tsp.sched_priority = kthread_prio;\n\t\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\twake_up_process(t);\n\trcu_spawn_nocb_kthreads();\n\trcu_spawn_boost_kthreads();\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static int rcu_scheduler_fully_active",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static int kthread_prio = IS_ENABLED(CONFIG_RCU_BOOST) ? 1 : 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_spawn_boost_kthreads",
          "args": [],
          "line": 3499
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_boost_kthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1508-1510",
          "snippet": "static void __init rcu_spawn_boost_kthreads(void)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_spawn_boost_kthreads(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_spawn_nocb_kthreads",
          "args": [],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_nocb_kthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2641-2643",
          "snippet": "static void __init rcu_spawn_nocb_kthreads(void)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_spawn_nocb_kthreads(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "t"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_setscheduler_nocheck",
          "args": [
            "t",
            "SCHED_FIFO",
            "&sp"
          ],
          "line": 3494
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setscheduler_nocheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4416-4420",
          "snippet": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 3489
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(t)"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "rcu_gp_kthread",
            "NULL",
            "\"%s\"",
            "rcu_state.name"
          ],
          "line": 3487
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "716-727",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu_spawn_gp_kthread(): Limited prio to %d from %d\\n\"",
            "kthread_prio",
            "kthread_prio_in"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_BOOST"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BUILTIN",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_BOOST"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic int rcu_scheduler_fully_active;\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic int kthread_prio = IS_ENABLED(CONFIG_RCU_BOOST) ? 1 : 0;\n\nstatic int __init rcu_spawn_gp_kthread(void)\n{\n\tunsigned long flags;\n\tint kthread_prio_in = kthread_prio;\n\tstruct rcu_node *rnp;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\t/* Force priority into range. */\n\tif (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 2\n\t    && IS_BUILTIN(CONFIG_RCU_TORTURE_TEST))\n\t\tkthread_prio = 2;\n\telse if (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 1)\n\t\tkthread_prio = 1;\n\telse if (kthread_prio < 0)\n\t\tkthread_prio = 0;\n\telse if (kthread_prio > 99)\n\t\tkthread_prio = 99;\n\n\tif (kthread_prio != kthread_prio_in)\n\t\tpr_alert(\"rcu_spawn_gp_kthread(): Limited prio to %d from %d\\n\",\n\t\t\t kthread_prio, kthread_prio_in);\n\n\trcu_scheduler_fully_active = 1;\n\tt = kthread_create(rcu_gp_kthread, NULL, \"%s\", rcu_state.name);\n\tBUG_ON(IS_ERR(t));\n\trnp = rcu_get_root();\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trcu_state.gp_kthread = t;\n\tif (kthread_prio) {\n\t\tsp.sched_priority = kthread_prio;\n\t\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\t}\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\twake_up_process(t);\n\trcu_spawn_nocb_kthreads();\n\trcu_spawn_boost_kthreads();\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_pm_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3440-3458",
    "snippet": "static int rcu_pm_notify(struct notifier_block *self,\n\t\t\t unsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\tif (nr_cpu_ids <= 256) /* Expediting bad for large systems. */\n\t\t\trcu_expedite_gp();\n\t\tbreak;\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\tif (nr_cpu_ids <= 256) /* Expediting bad for large systems. */\n\t\t\trcu_unexpedite_gp();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_unexpedite_gp",
          "args": [],
          "line": 3452
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_unexpedite_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "178-181",
          "snippet": "void rcu_unexpedite_gp(void)\n{\n\tatomic_dec(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_unexpedite_gp(void)\n{\n\tatomic_dec(&rcu_expedited_nesting);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_expedite_gp",
          "args": [],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_expedite_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "163-166",
          "snippet": "void rcu_expedite_gp(void)\n{\n\tatomic_inc(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_expedite_gp(void)\n{\n\tatomic_inc(&rcu_expedited_nesting);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_pm_notify(struct notifier_block *self,\n\t\t\t unsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\tif (nr_cpu_ids <= 256) /* Expediting bad for large systems. */\n\t\t\trcu_expedite_gp();\n\t\tbreak;\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\tif (nr_cpu_ids <= 256) /* Expediting bad for large systems. */\n\t\t\trcu_unexpedite_gp();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "rcutree_migrate_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3401-3433",
    "snippet": "void rcutree_migrate_callbacks(int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *my_rdp;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tbool needwake;\n\n\tif (rcu_is_nocb_cpu(cpu) || rcu_segcblist_empty(&rdp->cblist))\n\t\treturn;  /* No callbacks to migrate. */\n\n\tlocal_irq_save(flags);\n\tmy_rdp = this_cpu_ptr(&rcu_data);\n\tif (rcu_nocb_adopt_orphan_cbs(my_rdp, rdp, flags)) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\t/* Leverage recent GPs and set GP for new callbacks. */\n\tneedwake = rcu_advance_cbs(rnp_root, rdp) ||\n\t\t   rcu_advance_cbs(rnp_root, my_rdp);\n\trcu_segcblist_merge(&my_rdp->cblist, &rdp->cblist);\n\tWARN_ON_ONCE(rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist));\n\traw_spin_unlock_irqrestore_rcu_node(rnp_root, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\tWARN_ONCE(rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist),\n\t\t  \"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\",\n\t\t  cpu, rcu_segcblist_n_cbs(&rdp->cblist),\n\t\t  rcu_segcblist_first_cb(&rdp->cblist));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist)",
            "\"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\"",
            "cpu",
            "rcu_segcblist_n_cbs(&rdp->cblist)",
            "rcu_segcblist_first_cb(&rdp->cblist)"
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_first_cb",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3432
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_first_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "112-117",
          "snippet": "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp)\n{\n\tif (rcu_segcblist_is_enabled(rsclp))\n\t\treturn rsclp->head;\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp)\n{\n\tif (rcu_segcblist_is_enabled(rsclp))\n\t\treturn rsclp->head;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-59",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3429
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1551-1558",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp_root",
            "flags"
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist)"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_merge",
          "args": [
            "&my_rdp->cblist",
            "&rdp->cblist"
          ],
          "line": 3422
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "413-428",
          "snippet": "void rcu_segcblist_merge(struct rcu_segcblist *dst_rsclp,\n\t\t\t struct rcu_segcblist *src_rsclp)\n{\n\tstruct rcu_cblist donecbs;\n\tstruct rcu_cblist pendcbs;\n\n\trcu_cblist_init(&donecbs);\n\trcu_cblist_init(&pendcbs);\n\trcu_segcblist_extract_count(src_rsclp, &donecbs);\n\trcu_segcblist_extract_done_cbs(src_rsclp, &donecbs);\n\trcu_segcblist_extract_pend_cbs(src_rsclp, &pendcbs);\n\trcu_segcblist_insert_count(dst_rsclp, &donecbs);\n\trcu_segcblist_insert_done_cbs(dst_rsclp, &donecbs);\n\trcu_segcblist_insert_pend_cbs(dst_rsclp, &pendcbs);\n\trcu_segcblist_init(src_rsclp);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_merge(struct rcu_segcblist *dst_rsclp,\n\t\t\t struct rcu_segcblist *src_rsclp)\n{\n\tstruct rcu_cblist donecbs;\n\tstruct rcu_cblist pendcbs;\n\n\trcu_cblist_init(&donecbs);\n\trcu_cblist_init(&pendcbs);\n\trcu_segcblist_extract_count(src_rsclp, &donecbs);\n\trcu_segcblist_extract_done_cbs(src_rsclp, &donecbs);\n\trcu_segcblist_extract_pend_cbs(src_rsclp, &pendcbs);\n\trcu_segcblist_insert_count(dst_rsclp, &donecbs);\n\trcu_segcblist_insert_done_cbs(dst_rsclp, &donecbs);\n\trcu_segcblist_insert_pend_cbs(dst_rsclp, &pendcbs);\n\trcu_segcblist_init(src_rsclp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_advance_cbs",
          "args": [
            "rnp_root",
            "my_rdp"
          ],
          "line": 3421
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_advance_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1642-1658",
          "snippet": "static bool rcu_advance_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL sublist.\n\t */\n\trcu_segcblist_advance(&rdp->cblist, rnp->gp_seq);\n\n\t/* Classify any remaining callbacks. */\n\treturn rcu_accelerate_cbs(rnp, rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_advance_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL sublist.\n\t */\n\trcu_segcblist_advance(&rdp->cblist, rnp->gp_seq);\n\n\t/* Classify any remaining callbacks. */\n\treturn rcu_accelerate_cbs(rnp, rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp_root"
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_adopt_orphan_cbs",
          "args": [
            "my_rdp",
            "rdp",
            "flags"
          ],
          "line": 3414
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_adopt_orphan_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2617-2622",
          "snippet": "static bool __maybe_unused rcu_nocb_adopt_orphan_cbs(struct rcu_data *my_rdp,\n\t\t\t\t\t\t     struct rcu_data *rdp,\n\t\t\t\t\t\t     unsigned long flags)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool __maybe_unused rcu_nocb_adopt_orphan_cbs(struct rcu_data *my_rdp,\n\t\t\t\t\t\t     struct rcu_data *rdp,\n\t\t\t\t\t\t     unsigned long flags)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 3413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 3412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_nocb_cpu",
          "args": [
            "cpu"
          ],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_nocb_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1913-1918",
          "snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nbool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 3406
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcutree_migrate_callbacks(int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *my_rdp;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tbool needwake;\n\n\tif (rcu_is_nocb_cpu(cpu) || rcu_segcblist_empty(&rdp->cblist))\n\t\treturn;  /* No callbacks to migrate. */\n\n\tlocal_irq_save(flags);\n\tmy_rdp = this_cpu_ptr(&rcu_data);\n\tif (rcu_nocb_adopt_orphan_cbs(my_rdp, rdp, flags)) {\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\t/* Leverage recent GPs and set GP for new callbacks. */\n\tneedwake = rcu_advance_cbs(rnp_root, rdp) ||\n\t\t   rcu_advance_cbs(rnp_root, my_rdp);\n\trcu_segcblist_merge(&my_rdp->cblist, &rdp->cblist);\n\tWARN_ON_ONCE(rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist));\n\traw_spin_unlock_irqrestore_rcu_node(rnp_root, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\tWARN_ONCE(rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist),\n\t\t  \"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\",\n\t\t  cpu, rcu_segcblist_n_cbs(&rdp->cblist),\n\t\t  rcu_segcblist_first_cb(&rdp->cblist));\n}"
  },
  {
    "function_name": "rcu_report_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3365-3394",
    "snippet": "void rcu_report_dead(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\t/* QS for any half-done expedited grace period. */\n\tpreempt_disable();\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n\tpreempt_enable();\n\trcu_preempt_deferred_qs(current);\n\n\t/* Remove outgoing CPU from mask in the leaf rcu_node structure. */\n\tmask = rdp->grpmask;\n\traw_spin_lock(&rcu_state.ofl_lock);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags); /* Enforce GP memory-order guarantee. */\n\trdp->rcu_ofl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_ofl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on outgoing CPU? */\n\t\t/* Report quiescent state -before- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t}\n\trnp->qsmaskinitnext &= ~mask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\traw_spin_unlock(&rcu_state.ofl_lock);\n\n\tper_cpu(rcu_cpu_started, cpu) = 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
      "static DEFINE_PER_CPU(int, rcu_cpu_started);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "rcu_cpu_started",
            "cpu"
          ],
          "line": 3393
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rcu_state.ofl_lock"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp",
            "rnp->gp_seq",
            "flags"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2133-2188",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rcu_state.ofl_lock"
          ],
          "line": 3380
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "current"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1038-1038",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t) { }",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t) { }"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_exp_rdp",
          "args": [
            "this_cpu_ptr(&rcu_data)"
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_exp_rdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "261-265",
          "snippet": "static void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp)\n{\n\tWRITE_ONCE(rdp->deferred_qs, false);\n\trcu_report_exp_cpu_mult(rdp->mynode, rdp->grpmask, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3373
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic DEFINE_PER_CPU(int, rcu_cpu_started);\n\nvoid rcu_report_dead(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\t/* QS for any half-done expedited grace period. */\n\tpreempt_disable();\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n\tpreempt_enable();\n\trcu_preempt_deferred_qs(current);\n\n\t/* Remove outgoing CPU from mask in the leaf rcu_node structure. */\n\tmask = rdp->grpmask;\n\traw_spin_lock(&rcu_state.ofl_lock);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags); /* Enforce GP memory-order guarantee. */\n\trdp->rcu_ofl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_ofl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on outgoing CPU? */\n\t\t/* Report quiescent state -before- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t}\n\trnp->qsmaskinitnext &= ~mask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\traw_spin_unlock(&rcu_state.ofl_lock);\n\n\tper_cpu(rcu_cpu_started, cpu) = 0;\n}"
  },
  {
    "function_name": "rcu_cpu_starting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3319-3354",
    "snippet": "void rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tint nbits;\n\tunsigned long oldmask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tif (per_cpu(rcu_cpu_started, cpu))\n\t\treturn;\n\n\tper_cpu(rcu_cpu_started, cpu) = 1;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->qsmaskinitnext |= mask;\n\toldmask = rnp->expmaskinitnext;\n\trnp->expmaskinitnext |= mask;\n\toldmask ^= rnp->expmaskinitnext;\n\tnbits = bitmap_weight(&oldmask, BITS_PER_LONG);\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + nbits); /* ^^^ */\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on incoming CPU? */\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
      "static DEFINE_PER_CPU(int, rcu_cpu_started);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp",
            "rnp->gp_seq",
            "flags"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2133-2188",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gpnum_ovf",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 3344
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gpnum_ovf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "972-980",
          "snippet": "static void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rcu_state.ncpus",
            "rcu_state.ncpus + nbits"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "&oldmask",
            "BITS_PER_LONG"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "rcu_cpu_started",
            "cpu"
          ],
          "line": 3331
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic DEFINE_PER_CPU(int, rcu_cpu_started);\n\nvoid rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tint nbits;\n\tunsigned long oldmask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tif (per_cpu(rcu_cpu_started, cpu))\n\t\treturn;\n\n\tper_cpu(rcu_cpu_started, cpu) = 1;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->qsmaskinitnext |= mask;\n\toldmask = rnp->expmaskinitnext;\n\trnp->expmaskinitnext |= mask;\n\toldmask ^= rnp->expmaskinitnext;\n\tnbits = bitmap_weight(&oldmask, BITS_PER_LONG);\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + nbits); /* ^^^ */\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on incoming CPU? */\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}"
  },
  {
    "function_name": "rcutree_offline_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3288-3304",
    "snippet": "int rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\tif (IS_ENABLED(CONFIG_TREE_SRCU))\n\t\tsrcu_offline_cpu(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_offline_cpu",
          "args": [
            "cpu"
          ],
          "line": 3302
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_offline_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.h",
          "lines": "479-479",
          "snippet": "void srcu_offline_cpu(unsigned int cpu) { }",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcu_node_tree.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/swait.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/threads.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_prepare_kthreads(int cpu);",
            "static void print_cpu_stall_info(int cpu);",
            "static bool rcu_nocb_cpu_needs_barrier(int cpu);",
            "static void rcu_spawn_all_nocb_kthreads(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/stop_machine.h>\n#include <linux/swait.h>\n#include <linux/seqlock.h>\n#include <linux/cpumask.h>\n#include <linux/threads.h>\n#include <linux/rtmutex.h>\n#include <linux/spinlock.h>\n#include <linux/cache.h>\n\nstatic void rcu_prepare_kthreads(int cpu);\nstatic void print_cpu_stall_info(int cpu);\nstatic bool rcu_nocb_cpu_needs_barrier(int cpu);\nstatic void rcu_spawn_all_nocb_kthreads(int cpu);\n\nvoid srcu_offline_cpu(unsigned int cpu) { }"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TREE_SRCU"
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutree_affinity_setting",
          "args": [
            "cpu",
            "cpu"
          ],
          "line": 3300
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_affinity_setting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3253-3258",
          "snippet": "static void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\tif (IS_ENABLED(CONFIG_TREE_SRCU))\n\t\tsrcu_offline_cpu(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcutree_online_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3264-3282",
    "snippet": "int rcutree_online_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask |= rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (IS_ENABLED(CONFIG_TREE_SRCU))\n\t\tsrcu_online_cpu(cpu);\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn 0; /* Too early in boot for scheduler work. */\n\tsync_sched_exp_online_cleanup(cpu);\n\trcutree_affinity_setting(cpu, -1);\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "int rcu_scheduler_active",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcutree_affinity_setting",
          "args": [
            "cpu",
            "-1"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_affinity_setting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3253-3258",
          "snippet": "static void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_sched_exp_online_cleanup",
          "args": [
            "cpu"
          ],
          "line": 3279
        },
        "resolved": true,
        "details": {
          "function_name": "sync_sched_exp_online_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "787-799",
          "snippet": "static void sync_sched_exp_online_cleanup(int cpu)\n{\n\tstruct rcu_data *rdp;\n\tint ret;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask))\n\t\treturn;\n\tret = smp_call_function_single(cpu, sync_sched_exp_handler, NULL, 0);\n\tWARN_ON_ONCE(ret);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu)\n{\n\tstruct rcu_data *rdp;\n\tint ret;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\tif (!(READ_ONCE(rnp->expmask) & rdp->grpmask))\n\t\treturn;\n\tret = smp_call_function_single(cpu, sync_sched_exp_handler, NULL, 0);\n\tWARN_ON_ONCE(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_online_cpu",
          "args": [
            "cpu"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_online_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.h",
          "lines": "478-478",
          "snippet": "void srcu_online_cpu(unsigned int cpu) { }",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcu_node_tree.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/swait.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/threads.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_prepare_kthreads(int cpu);",
            "static void print_cpu_stall_info(int cpu);",
            "static bool rcu_nocb_cpu_needs_barrier(int cpu);",
            "static void rcu_spawn_all_nocb_kthreads(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/stop_machine.h>\n#include <linux/swait.h>\n#include <linux/seqlock.h>\n#include <linux/cpumask.h>\n#include <linux/threads.h>\n#include <linux/rtmutex.h>\n#include <linux/spinlock.h>\n#include <linux/cache.h>\n\nstatic void rcu_prepare_kthreads(int cpu);\nstatic void print_cpu_stall_info(int cpu);\nstatic bool rcu_nocb_cpu_needs_barrier(int cpu);\nstatic void rcu_spawn_all_nocb_kthreads(int cpu);\n\nvoid srcu_online_cpu(unsigned int cpu) { }"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TREE_SRCU"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nint rcu_scheduler_active;\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_online_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask |= rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (IS_ENABLED(CONFIG_TREE_SRCU))\n\t\tsrcu_online_cpu(cpu);\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn 0; /* Too early in boot for scheduler work. */\n\tsync_sched_exp_online_cleanup(cpu);\n\trcutree_affinity_setting(cpu, -1);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcutree_affinity_setting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3253-3258",
    "snippet": "static void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_boost_kthread_setaffinity",
          "args": [
            "rdp->mynode",
            "outgoing"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_boost_kthread_setaffinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1504-1506",
          "snippet": "static void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}"
  },
  {
    "function_name": "rcutree_prepare_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3210-3248",
    "snippet": "int rcutree_prepare_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trdp->qlen_last_fqs_check = 0;\n\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\trdp->blimit = blimit;\n\tif (rcu_segcblist_empty(&rdp->cblist) && /* No early-boot CBs? */\n\t    !init_nocb_callback_list(rdp))\n\t\trcu_segcblist_init(&rdp->cblist);  /* Re-enable callbacks. */\n\trdp->dynticks_nesting = 1;\t/* CPU not up, no tearing. */\n\trcu_dynticks_eqs_online();\n\traw_spin_unlock_rcu_node(rnp);\t\t/* irqs remain disabled. */\n\n\t/*\n\t * Add CPU to leaf rcu_node pending-online bitmask.  Any needed\n\t * propagation up the rcu_node tree will happen at the beginning\n\t * of the next grace period.\n\t */\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\t\t/* irqs already disabled. */\n\trdp->beenonline = true;\t /* We have now been online. */\n\trdp->gp_seq = rnp->gp_seq;\n\trdp->gp_seq_needed = rnp->gp_seq;\n\trdp->cpu_no_qs.b.norm = true;\n\trdp->core_needs_qs = false;\n\trdp->rcu_iw_pending = false;\n\trdp->rcu_iw_gp_seq = rnp->gp_seq - 1;\n\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuonl\"));\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_prepare_kthreads(cpu);\n\trcu_spawn_all_nocb_kthreads(cpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static long blimit = DEFAULT_RCU_BLIMIT;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_spawn_all_nocb_kthreads",
          "args": [
            "cpu"
          ],
          "line": 3245
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_spawn_all_nocb_kthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2637-2639",
          "snippet": "static void rcu_spawn_all_nocb_kthreads(int cpu)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_spawn_all_nocb_kthreads(int cpu)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_prepare_kthreads",
          "args": [
            "cpu"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_prepare_kthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1512-1514",
          "snippet": "static void rcu_prepare_kthreads(int cpu)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_prepare_kthreads(int cpu)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rdp->gp_seq",
            "TPS(\"cpuonl\")"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpuonl\""
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_eqs_online",
          "args": [],
          "line": 3225
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_eqs_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "274-281",
          "snippet": "static void rcu_dynticks_eqs_online(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR)\n\t\treturn;\n\tatomic_add(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_dynticks_eqs_online(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR)\n\t\treturn;\n\tatomic_add(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_init",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3223
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "63-74",
          "snippet": "void rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++)\n\t\trsclp->tails[i] = &rsclp->head;\n\trsclp->len = 0;\n\trsclp->len_lazy = 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++)\n\t\trsclp->tails[i] = &rsclp->head;\n\trsclp->len = 0;\n\trsclp->len_lazy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_nocb_callback_list",
          "args": [
            "rdp"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "init_nocb_callback_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2645-2648",
          "snippet": "static bool init_nocb_callback_list(struct rcu_data *rdp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool init_nocb_callback_list(struct rcu_data *rdp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3221
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_prepare_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trdp->qlen_last_fqs_check = 0;\n\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\trdp->blimit = blimit;\n\tif (rcu_segcblist_empty(&rdp->cblist) && /* No early-boot CBs? */\n\t    !init_nocb_callback_list(rdp))\n\t\trcu_segcblist_init(&rdp->cblist);  /* Re-enable callbacks. */\n\trdp->dynticks_nesting = 1;\t/* CPU not up, no tearing. */\n\trcu_dynticks_eqs_online();\n\traw_spin_unlock_rcu_node(rnp);\t\t/* irqs remain disabled. */\n\n\t/*\n\t * Add CPU to leaf rcu_node pending-online bitmask.  Any needed\n\t * propagation up the rcu_node tree will happen at the beginning\n\t * of the next grace period.\n\t */\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\t\t/* irqs already disabled. */\n\trdp->beenonline = true;\t /* We have now been online. */\n\trdp->gp_seq = rnp->gp_seq;\n\trdp->gp_seq_needed = rnp->gp_seq;\n\trdp->cpu_no_qs.b.norm = true;\n\trdp->core_needs_qs = false;\n\trdp->rcu_iw_pending = false;\n\trdp->rcu_iw_gp_seq = rnp->gp_seq - 1;\n\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuonl\"));\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_prepare_kthreads(cpu);\n\trcu_spawn_all_nocb_kthreads(cpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_boot_init_percpu_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3184-3199",
    "snippet": "static void __init\nrcu_boot_init_percpu_data(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\trdp->grpmask = leaf_node_cpu_bit(rdp->mynode, cpu);\n\tWARN_ON_ONCE(rdp->dynticks_nesting != 1);\n\tWARN_ON_ONCE(rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp)));\n\trdp->rcu_ofl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_ofl_gp_flags = RCU_GP_CLEANED;\n\trdp->rcu_onl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_onl_gp_flags = RCU_GP_CLEANED;\n\trdp->cpu = cpu;\n\trcu_boot_init_nocb_percpu_data(rdp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_boot_init_nocb_percpu_data",
          "args": [
            "rdp"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_boot_init_nocb_percpu_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2624-2626",
          "snippet": "static void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void __init rcu_boot_init_nocb_percpu_data(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp))"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs",
          "args": [
            "rcu_dynticks_snap(rdp)"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "310-313",
          "snippet": "static bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & RCU_DYNTICK_CTRL_CTR);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & RCU_DYNTICK_CTRL_CTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "299-304",
          "snippet": "int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_MASK 0x1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->dynticks_nesting != 1"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rdp->mynode",
            "cpu"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void __init\nrcu_boot_init_percpu_data(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\trdp->grpmask = leaf_node_cpu_bit(rdp->mynode, cpu);\n\tWARN_ON_ONCE(rdp->dynticks_nesting != 1);\n\tWARN_ON_ONCE(rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp)));\n\trdp->rcu_ofl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_ofl_gp_flags = RCU_GP_CLEANED;\n\trdp->rcu_onl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_onl_gp_flags = RCU_GP_CLEANED;\n\trdp->cpu = cpu;\n\trcu_boot_init_nocb_percpu_data(rdp);\n}"
  },
  {
    "function_name": "rcu_init_new_rnp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3159-3179",
    "snippet": "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tlong oldmask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tWARN_ON_ONCE(rnp->wait_blkd_tasks);\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (rnp == NULL)\n\t\t\treturn;\n\t\traw_spin_lock_rcu_node(rnp); /* Interrupts already disabled. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit |= mask;\n\t\traw_spin_unlock_rcu_node(rnp); /* Interrupts remain disabled. */\n\t\tif (oldmask)\n\t\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf);",
      "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->wait_blkd_tasks"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp_leaf"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf);\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tlong oldmask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tWARN_ON_ONCE(rnp->wait_blkd_tasks);\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (rnp == NULL)\n\t\t\treturn;\n\t\traw_spin_lock_rcu_node(rnp); /* Interrupts already disabled. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit |= mask;\n\t\traw_spin_unlock_rcu_node(rnp); /* Interrupts remain disabled. */\n\t\tif (oldmask)\n\t\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "rcu_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3068-3150",
    "snippet": "void rcu_barrier(void)\n{\n\tint cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t   rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to one rather than to zero in order to\n\t * avoid a too-soon return to zero in case of a short grace period\n\t * (or preemption of this task).  Exclude CPU-hotplug operations\n\t * to ensure that no offline CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 1);\n\tget_online_cpus();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tif (!cpu_online(cpu) && !rcu_is_nocb_cpu(cpu))\n\t\t\tcontinue;\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rcu_is_nocb_cpu(cpu)) {\n\t\t\tif (!rcu_nocb_cpu_needs_barrier(cpu)) {\n\t\t\t\trcu_barrier_trace(TPS(\"OfflineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t} else {\n\t\t\t\trcu_barrier_trace(TPS(\"OnlineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t\tsmp_mb__before_atomic();\n\t\t\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t\t\t\t__call_rcu(&rdp->barrier_head,\n\t\t\t\t\t   rcu_barrier_callback, cpu, 0);\n\t\t\t}\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, NULL, 1);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tput_online_cpus();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rcu_state.barrier_mutex"
          ],
          "line": 3149
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_end",
          "args": [
            "&rcu_state.barrier_sequence"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "87-92",
          "snippet": "static inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier_trace",
          "args": [
            "TPS(\"Inc2\")",
            "-1",
            "rcu_state.barrier_sequence"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3020-3024",
          "snippet": "static void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void sync_sched_exp_online_cleanup(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Inc2\""
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&rcu_state.barrier_completion"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&rcu_state.barrier_completion"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1099-1102",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rcu_state.barrier_cpu_count"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"OnlineNQ\""
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "rcu_barrier_func",
            "NULL",
            "1"
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "11-23",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tWARN_ON(cpu != 0);\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"OnlineQ\""
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-59",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__call_rcu",
          "args": [
            "&rdp->barrier_head",
            "rcu_barrier_callback",
            "cpu",
            "0"
          ],
          "line": 3120
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2786-2851",
          "snippet": "static void\n__call_rcu(struct rcu_head *head, rcu_callback_t func, int cpu, bool lazy)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tWARN_ONCE(1, \"__call_rcu(): Double-freed CB %p->%pF()!!!\\n\",\n\t\t\t  head, head->func);\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist)) || cpu != -1) {\n\t\tint offline;\n\n\t\tif (cpu != -1)\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (likely(rdp->mynode)) {\n\t\t\t/* Post-boot, so this should be for a no-CBs CPU. */\n\t\t\toffline = !__call_rcu_nocb(rdp, head, lazy, flags);\n\t\t\tWARN_ON_ONCE(offline);\n\t\t\t/* Offline CPU, _call_rcu() illegal, leak callback.  */\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Very early boot, before rcu_init().  Initialize if needed\n\t\t * and then drop through to queue the callback.\n\t\t */\n\t\tBUG_ON(cpu != -1);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\trcu_segcblist_enqueue(&rdp->cblist, head, lazy);\n\tif (!lazy)\n\t\trcu_idle_count_callbacks_posted();\n\n\tif (__is_kfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\t/* Go handle any RCU core processing required. */\n\t__call_rcu_core(rdp, head, flags);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\n__call_rcu(struct rcu_head *head, rcu_callback_t func, int cpu, bool lazy)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tWARN_ONCE(1, \"__call_rcu(): Double-freed CB %p->%pF()!!!\\n\",\n\t\t\t  head, head->func);\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist)) || cpu != -1) {\n\t\tint offline;\n\n\t\tif (cpu != -1)\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (likely(rdp->mynode)) {\n\t\t\t/* Post-boot, so this should be for a no-CBs CPU. */\n\t\t\toffline = !__call_rcu_nocb(rdp, head, lazy, flags);\n\t\t\tWARN_ON_ONCE(offline);\n\t\t\t/* Offline CPU, _call_rcu() illegal, leak callback.  */\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Very early boot, before rcu_init().  Initialize if needed\n\t\t * and then drop through to queue the callback.\n\t\t */\n\t\tBUG_ON(cpu != -1);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\trcu_segcblist_enqueue(&rdp->cblist, head, lazy);\n\tif (!lazy)\n\t\trcu_idle_count_callbacks_posted();\n\n\tif (__is_kfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\t/* Go handle any RCU core processing required. */\n\t__call_rcu_core(rdp, head, flags);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rcu_state.barrier_cpu_count"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"OnlineNoCB\""
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"OfflineNoCB\""
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_cpu_needs_barrier",
          "args": [
            "cpu"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_cpu_needs_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2592-2596",
          "snippet": "static bool rcu_nocb_cpu_needs_barrier(int cpu)\n{\n\tWARN_ON_ONCE(1); /* Should be dead code. */\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_nocb_cpu_needs_barrier(int cpu)\n{\n\tWARN_ON_ONCE(1); /* Should be dead code. */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_nocb_cpu",
          "args": [
            "cpu"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_nocb_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1913-1918",
          "snippet": "bool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nbool rcu_is_nocb_cpu(int cpu)\n{\n\tif (cpumask_available(rcu_nocb_mask))\n\t\treturn cpumask_test_cpu(cpu, rcu_nocb_mask);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rcu_state.barrier_cpu_count",
            "1"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&rcu_state.barrier_completion"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Inc1\""
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_start",
          "args": [
            "&rcu_state.barrier_sequence"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "73-78",
          "snippet": "static inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"EarlyExit\""
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rcu_state.barrier_sequence",
            "s"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "133-136",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rcu_state.barrier_mutex"
          ],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Begin\""
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.barrier_sequence"
          ],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_barrier(void)\n{\n\tint cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t   rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to one rather than to zero in order to\n\t * avoid a too-soon return to zero in case of a short grace period\n\t * (or preemption of this task).  Exclude CPU-hotplug operations\n\t * to ensure that no offline CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 1);\n\tget_online_cpus();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tif (!cpu_online(cpu) && !rcu_is_nocb_cpu(cpu))\n\t\t\tcontinue;\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rcu_is_nocb_cpu(cpu)) {\n\t\t\tif (!rcu_nocb_cpu_needs_barrier(cpu)) {\n\t\t\t\trcu_barrier_trace(TPS(\"OfflineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t} else {\n\t\t\t\trcu_barrier_trace(TPS(\"OnlineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t\tsmp_mb__before_atomic();\n\t\t\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t\t\t\t__call_rcu(&rdp->barrier_head,\n\t\t\t\t\t   rcu_barrier_callback, cpu, 0);\n\t\t\t}\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, NULL, 1);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tput_online_cpus();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}"
  },
  {
    "function_name": "rcu_barrier_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3044-3058",
    "snippet": "static void rcu_barrier_func(void *unused)\n{\n\tstruct rcu_data *rdp = raw_cpu_ptr(&rcu_data);\n\n\trcu_barrier_trace(TPS(\"IRQ\"), -1, rcu_state.barrier_sequence);\n\trdp->barrier_head.func = rcu_barrier_callback;\n\tdebug_rcu_head_queue(&rdp->barrier_head);\n\tif (rcu_segcblist_entrain(&rdp->cblist, &rdp->barrier_head, 0)) {\n\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t} else {\n\t\tdebug_rcu_head_unqueue(&rdp->barrier_head);\n\t\trcu_barrier_trace(TPS(\"IRQNQ\"), -1,\n\t\t\t\t   rcu_state.barrier_sequence);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_barrier_trace",
          "args": [
            "TPS(\"IRQNQ\")",
            "-1",
            "rcu_state.barrier_sequence"
          ],
          "line": 3055
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3020-3024",
          "snippet": "static void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void sync_sched_exp_online_cleanup(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"IRQNQ\""
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "&rdp->barrier_head"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "214-216",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rcu_state.barrier_cpu_count"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_entrain",
          "args": [
            "&rdp->cblist",
            "&rdp->barrier_head",
            "0"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_entrain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "164-183",
          "snippet": "bool rcu_segcblist_entrain(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp, bool lazy)\n{\n\tint i;\n\n\tif (rcu_segcblist_n_cbs(rsclp) == 0)\n\t\treturn false;\n\tWRITE_ONCE(rsclp->len, rsclp->len + 1);\n\tif (lazy)\n\t\trsclp->len_lazy++;\n\tsmp_mb(); /* Ensure counts are updated before callback is entrained. */\n\trhp->next = NULL;\n\tfor (i = RCU_NEXT_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1])\n\t\t\tbreak;\n\t*rsclp->tails[i] = rhp;\n\tfor (; i <= RCU_NEXT_TAIL; i++)\n\t\trsclp->tails[i] = &rhp->next;\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_entrain(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp, bool lazy)\n{\n\tint i;\n\n\tif (rcu_segcblist_n_cbs(rsclp) == 0)\n\t\treturn false;\n\tWRITE_ONCE(rsclp->len, rsclp->len + 1);\n\tif (lazy)\n\t\trsclp->len_lazy++;\n\tsmp_mb(); /* Ensure counts are updated before callback is entrained. */\n\trhp->next = NULL;\n\tfor (i = RCU_NEXT_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1])\n\t\t\tbreak;\n\t*rsclp->tails[i] = rhp;\n\tfor (; i <= RCU_NEXT_TAIL; i++)\n\t\trsclp->tails[i] = &rhp->next;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_queue",
          "args": [
            "&rdp->barrier_head"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "209-212",
          "snippet": "static inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"IRQ\""
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_barrier_func(void *unused)\n{\n\tstruct rcu_data *rdp = raw_cpu_ptr(&rcu_data);\n\n\trcu_barrier_trace(TPS(\"IRQ\"), -1, rcu_state.barrier_sequence);\n\trdp->barrier_head.func = rcu_barrier_callback;\n\tdebug_rcu_head_queue(&rdp->barrier_head);\n\tif (rcu_segcblist_entrain(&rdp->cblist, &rdp->barrier_head, 0)) {\n\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t} else {\n\t\tdebug_rcu_head_unqueue(&rdp->barrier_head);\n\t\trcu_barrier_trace(TPS(\"IRQNQ\"), -1,\n\t\t\t\t   rcu_state.barrier_sequence);\n\t}\n}"
  },
  {
    "function_name": "rcu_barrier_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3030-3039",
    "snippet": "static void rcu_barrier_callback(struct rcu_head *rhp)\n{\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count)) {\n\t\trcu_barrier_trace(TPS(\"LastCB\"), -1,\n\t\t\t\t   rcu_state.barrier_sequence);\n\t\tcomplete(&rcu_state.barrier_completion);\n\t} else {\n\t\trcu_barrier_trace(TPS(\"CB\"), -1, rcu_state.barrier_sequence);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_barrier_trace",
          "args": [
            "TPS(\"CB\")",
            "-1",
            "rcu_state.barrier_sequence"
          ],
          "line": 3037
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3020-3024",
          "snippet": "static void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void sync_sched_exp_online_cleanup(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CB\""
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&rcu_state.barrier_completion"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1099-1102",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"LastCB\""
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rcu_state.barrier_cpu_count"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_barrier_callback(struct rcu_head *rhp)\n{\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count)) {\n\t\trcu_barrier_trace(TPS(\"LastCB\"), -1,\n\t\t\t\t   rcu_state.barrier_sequence);\n\t\tcomplete(&rcu_state.barrier_completion);\n\t} else {\n\t\trcu_barrier_trace(TPS(\"CB\"), -1, rcu_state.barrier_sequence);\n\t}\n}"
  },
  {
    "function_name": "rcu_barrier_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "3020-3024",
    "snippet": "static void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void sync_sched_exp_online_cleanup(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_barrier",
          "args": [
            "rcu_state.name",
            "s",
            "cpu",
            "atomic_read(&rcu_state.barrier_cpu_count)",
            "done"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rcu_state.barrier_cpu_count"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}"
  },
  {
    "function_name": "rcu_cpu_has_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2999-3014",
    "snippet": "static bool rcu_cpu_has_callbacks(bool *all_lazy)\n{\n\tbool al = true;\n\tbool hc = false;\n\tstruct rcu_data *rdp;\n\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!rcu_segcblist_empty(&rdp->cblist)) {\n\t\thc = true;\n\t\tif (rcu_segcblist_n_nonlazy_cbs(&rdp->cblist))\n\t\t\tal = false;\n\t}\n\tif (all_lazy)\n\t\t*all_lazy = al;\n\treturn hc;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_segcblist_n_nonlazy_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_nonlazy_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "68-71",
          "snippet": "static inline long rcu_segcblist_n_nonlazy_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->len - rsclp->len_lazy;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_nonlazy_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->len - rsclp->len_lazy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_cpu_has_callbacks(bool *all_lazy)\n{\n\tbool al = true;\n\tbool hc = false;\n\tstruct rcu_data *rdp;\n\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!rcu_segcblist_empty(&rdp->cblist)) {\n\t\thc = true;\n\t\tif (rcu_segcblist_n_nonlazy_cbs(&rdp->cblist))\n\t\t\tal = false;\n\t}\n\tif (all_lazy)\n\t\t*all_lazy = al;\n\treturn hc;\n}"
  },
  {
    "function_name": "rcu_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2955-2992",
    "snippet": "static int rcu_pending(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/* Check for CPU stalls, if enabled. */\n\tcheck_cpu_stall(rdp);\n\n\t/* Is this CPU a NO_HZ_FULL CPU that should ignore RCU? */\n\tif (rcu_nohz_full_cpu())\n\t\treturn 0;\n\n\t/* Is the RCU core waiting for a quiescent state from this CPU? */\n\tif (rdp->core_needs_qs && !rdp->cpu_no_qs.b.norm)\n\t\treturn 1;\n\n\t/* Does this CPU have callbacks ready to invoke? */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\treturn 1;\n\n\t/* Has RCU gone idle with this CPU needing another grace period? */\n\tif (!rcu_gp_in_progress() &&\n\t    rcu_segcblist_is_enabled(&rdp->cblist) &&\n\t    !rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\treturn 1;\n\n\t/* Have RCU grace period completed or started?  */\n\tif (rcu_seq_current(&rnp->gp_seq) != rdp->gp_seq ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) /* outside lock */\n\t\treturn 1;\n\n\t/* Does this CPU need a deferred NOCB wakeup? */\n\tif (rcu_nocb_need_deferred_wakeup(rdp))\n\t\treturn 1;\n\n\t/* nothing to do */\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
      "static int rcu_pending(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nocb_need_deferred_wakeup",
          "args": [
            "rdp"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_need_deferred_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2628-2631",
          "snippet": "static int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_nocb_need_deferred_wakeup(struct rcu_data *rdp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(rdp->gpwrap)"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gpwrap"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rnp->gp_seq"
          ],
          "line": 2982
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_restempty",
          "args": [
            "&rdp->cblist",
            "RCU_NEXT_READY_TAIL"
          ],
          "line": 2978
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_restempty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "87-90",
          "snippet": "static inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !*rsclp->tails[seg];\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !*rsclp->tails[seg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_is_enabled",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "77-80",
          "snippet": "static inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn !!rsclp->tails[RCU_NEXT_TAIL];\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn !!rsclp->tails[RCU_NEXT_TAIL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 2976
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "205-208",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "92-96",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != rsclp->tails[RCU_DONE_TAIL];\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != rsclp->tails[RCU_DONE_TAIL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_nohz_full_cpu",
          "args": [],
          "line": 2964
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nohz_full_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2661-2670",
          "snippet": "static bool rcu_nohz_full_cpu(void)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tif (tick_nohz_full_cpu(smp_processor_id()) &&\n\t    (!rcu_gp_in_progress() ||\n\t     ULONG_CMP_LT(jiffies, READ_ONCE(rcu_state.gp_start) + HZ)))\n\t\treturn true;\n#endif /* #ifdef CONFIG_NO_HZ_FULL */\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_nohz_full_cpu(void)\n{\n#ifdef CONFIG_NO_HZ_FULL\n\tif (tick_nohz_full_cpu(smp_processor_id()) &&\n\t    (!rcu_gp_in_progress() ||\n\t     ULONG_CMP_LT(jiffies, READ_ONCE(rcu_state.gp_start) + HZ)))\n\t\treturn true;\n#endif /* #ifdef CONFIG_NO_HZ_FULL */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_cpu_stall",
          "args": [
            "rdp"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "check_cpu_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1356-1417",
          "snippet": "static void check_cpu_stall(struct rcu_data *rdp)\n{\n\tunsigned long gs1;\n\tunsigned long gs2;\n\tunsigned long gps;\n\tunsigned long j;\n\tunsigned long jn;\n\tunsigned long js;\n\tstruct rcu_node *rnp;\n\n\tif ((rcu_cpu_stall_suppress && !rcu_kick_kthreads) ||\n\t    !rcu_gp_in_progress())\n\t\treturn;\n\trcu_stall_kick_kthreads();\n\tj = jiffies;\n\n\t/*\n\t * Lots of memory barriers to reject false positives.\n\t *\n\t * The idea is to pick up rcu_state.gp_seq, then\n\t * rcu_state.jiffies_stall, then rcu_state.gp_start, and finally\n\t * another copy of rcu_state.gp_seq.  These values are updated in\n\t * the opposite order with memory barriers (or equivalent) during\n\t * grace-period initialization and cleanup.  Now, a false positive\n\t * can occur if we get an new value of rcu_state.gp_start and a old\n\t * value of rcu_state.jiffies_stall.  But given the memory barriers,\n\t * the only way that this can happen is if one grace period ends\n\t * and another starts between these two fetches.  This is detected\n\t * by comparing the second fetch of rcu_state.gp_seq with the\n\t * previous fetch from rcu_state.gp_seq.\n\t *\n\t * Given this check, comparisons of jiffies, rcu_state.jiffies_stall,\n\t * and rcu_state.gp_start suffice to forestall false positives.\n\t */\n\tgs1 = READ_ONCE(rcu_state.gp_seq);\n\tsmp_rmb(); /* Pick up ->gp_seq first... */\n\tjs = READ_ONCE(rcu_state.jiffies_stall);\n\tsmp_rmb(); /* ...then ->jiffies_stall before the rest... */\n\tgps = READ_ONCE(rcu_state.gp_start);\n\tsmp_rmb(); /* ...and finally ->gp_start before ->gp_seq again. */\n\tgs2 = READ_ONCE(rcu_state.gp_seq);\n\tif (gs1 != gs2 ||\n\t    ULONG_CMP_LT(j, js) ||\n\t    ULONG_CMP_GE(gps, js))\n\t\treturn; /* No stall or GP completed since entering function. */\n\trnp = rdp->mynode;\n\tjn = jiffies + 3 * rcu_jiffies_till_stall_check() + 3;\n\tif (rcu_gp_in_progress() &&\n\t    (READ_ONCE(rnp->qsmask) & rdp->grpmask) &&\n\t    cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/* We haven't checked in, so go dump stack. */\n\t\tprint_cpu_stall();\n\n\t} else if (rcu_gp_in_progress() &&\n\t\t   ULONG_CMP_GE(j, js + RCU_STALL_RAT_DELAY) &&\n\t\t   cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/* They had a few time units to dump stack, so complain. */\n\t\tprint_other_cpu_stall(gs2);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static bool rcu_kick_kthreads;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_kick_kthreads;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void check_cpu_stall(struct rcu_data *rdp)\n{\n\tunsigned long gs1;\n\tunsigned long gs2;\n\tunsigned long gps;\n\tunsigned long j;\n\tunsigned long jn;\n\tunsigned long js;\n\tstruct rcu_node *rnp;\n\n\tif ((rcu_cpu_stall_suppress && !rcu_kick_kthreads) ||\n\t    !rcu_gp_in_progress())\n\t\treturn;\n\trcu_stall_kick_kthreads();\n\tj = jiffies;\n\n\t/*\n\t * Lots of memory barriers to reject false positives.\n\t *\n\t * The idea is to pick up rcu_state.gp_seq, then\n\t * rcu_state.jiffies_stall, then rcu_state.gp_start, and finally\n\t * another copy of rcu_state.gp_seq.  These values are updated in\n\t * the opposite order with memory barriers (or equivalent) during\n\t * grace-period initialization and cleanup.  Now, a false positive\n\t * can occur if we get an new value of rcu_state.gp_start and a old\n\t * value of rcu_state.jiffies_stall.  But given the memory barriers,\n\t * the only way that this can happen is if one grace period ends\n\t * and another starts between these two fetches.  This is detected\n\t * by comparing the second fetch of rcu_state.gp_seq with the\n\t * previous fetch from rcu_state.gp_seq.\n\t *\n\t * Given this check, comparisons of jiffies, rcu_state.jiffies_stall,\n\t * and rcu_state.gp_start suffice to forestall false positives.\n\t */\n\tgs1 = READ_ONCE(rcu_state.gp_seq);\n\tsmp_rmb(); /* Pick up ->gp_seq first... */\n\tjs = READ_ONCE(rcu_state.jiffies_stall);\n\tsmp_rmb(); /* ...then ->jiffies_stall before the rest... */\n\tgps = READ_ONCE(rcu_state.gp_start);\n\tsmp_rmb(); /* ...and finally ->gp_start before ->gp_seq again. */\n\tgs2 = READ_ONCE(rcu_state.gp_seq);\n\tif (gs1 != gs2 ||\n\t    ULONG_CMP_LT(j, js) ||\n\t    ULONG_CMP_GE(gps, js))\n\t\treturn; /* No stall or GP completed since entering function. */\n\trnp = rdp->mynode;\n\tjn = jiffies + 3 * rcu_jiffies_till_stall_check() + 3;\n\tif (rcu_gp_in_progress() &&\n\t    (READ_ONCE(rnp->qsmask) & rdp->grpmask) &&\n\t    cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/* We haven't checked in, so go dump stack. */\n\t\tprint_cpu_stall();\n\n\t} else if (rcu_gp_in_progress() &&\n\t\t   ULONG_CMP_GE(j, js + RCU_STALL_RAT_DELAY) &&\n\t\t   cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/* They had a few time units to dump stack, so complain. */\n\t\tprint_other_cpu_stall(gs2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(void);\n\nstatic int rcu_pending(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/* Check for CPU stalls, if enabled. */\n\tcheck_cpu_stall(rdp);\n\n\t/* Is this CPU a NO_HZ_FULL CPU that should ignore RCU? */\n\tif (rcu_nohz_full_cpu())\n\t\treturn 0;\n\n\t/* Is the RCU core waiting for a quiescent state from this CPU? */\n\tif (rdp->core_needs_qs && !rdp->cpu_no_qs.b.norm)\n\t\treturn 1;\n\n\t/* Does this CPU have callbacks ready to invoke? */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\treturn 1;\n\n\t/* Has RCU gone idle with this CPU needing another grace period? */\n\tif (!rcu_gp_in_progress() &&\n\t    rcu_segcblist_is_enabled(&rdp->cblist) &&\n\t    !rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\treturn 1;\n\n\t/* Have RCU grace period completed or started?  */\n\tif (rcu_seq_current(&rnp->gp_seq) != rdp->gp_seq ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) /* outside lock */\n\t\treturn 1;\n\n\t/* Does this CPU need a deferred NOCB wakeup? */\n\tif (rcu_nocb_need_deferred_wakeup(rdp))\n\t\treturn 1;\n\n\t/* nothing to do */\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_synchronize_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2939-2945",
    "snippet": "void cond_synchronize_rcu(unsigned long oldstate)\n{\n\tif (!rcu_seq_done(&rcu_state.gp_seq, oldstate))\n\t\tsynchronize_rcu();\n\telse\n\t\tsmp_mb(); /* Ensure GP ends before subsequent accesses. */\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "get_state_synchronize_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2914-2922",
          "snippet": "unsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nunsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&rcu_state.gp_seq",
            "oldstate"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "133-136",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nvoid cond_synchronize_rcu(unsigned long oldstate)\n{\n\tif (!rcu_seq_done(&rcu_state.gp_seq, oldstate))\n\t\tsynchronize_rcu();\n\telse\n\t\tsmp_mb(); /* Ensure GP ends before subsequent accesses. */\n}"
  },
  {
    "function_name": "get_state_synchronize_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2914-2922",
    "snippet": "unsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nunsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}"
  },
  {
    "function_name": "kfree_call_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2901-2904",
    "snippet": "void kfree_call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\t__call_rcu(head, func, -1, 1);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__call_rcu",
          "args": [
            "head",
            "func",
            "-1",
            "1"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2786-2851",
          "snippet": "static void\n__call_rcu(struct rcu_head *head, rcu_callback_t func, int cpu, bool lazy)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tWARN_ONCE(1, \"__call_rcu(): Double-freed CB %p->%pF()!!!\\n\",\n\t\t\t  head, head->func);\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist)) || cpu != -1) {\n\t\tint offline;\n\n\t\tif (cpu != -1)\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (likely(rdp->mynode)) {\n\t\t\t/* Post-boot, so this should be for a no-CBs CPU. */\n\t\t\toffline = !__call_rcu_nocb(rdp, head, lazy, flags);\n\t\t\tWARN_ON_ONCE(offline);\n\t\t\t/* Offline CPU, _call_rcu() illegal, leak callback.  */\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Very early boot, before rcu_init().  Initialize if needed\n\t\t * and then drop through to queue the callback.\n\t\t */\n\t\tBUG_ON(cpu != -1);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\trcu_segcblist_enqueue(&rdp->cblist, head, lazy);\n\tif (!lazy)\n\t\trcu_idle_count_callbacks_posted();\n\n\tif (__is_kfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\t/* Go handle any RCU core processing required. */\n\t__call_rcu_core(rdp, head, flags);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\n__call_rcu(struct rcu_head *head, rcu_callback_t func, int cpu, bool lazy)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tWARN_ONCE(1, \"__call_rcu(): Double-freed CB %p->%pF()!!!\\n\",\n\t\t\t  head, head->func);\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist)) || cpu != -1) {\n\t\tint offline;\n\n\t\tif (cpu != -1)\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (likely(rdp->mynode)) {\n\t\t\t/* Post-boot, so this should be for a no-CBs CPU. */\n\t\t\toffline = !__call_rcu_nocb(rdp, head, lazy, flags);\n\t\t\tWARN_ON_ONCE(offline);\n\t\t\t/* Offline CPU, _call_rcu() illegal, leak callback.  */\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Very early boot, before rcu_init().  Initialize if needed\n\t\t * and then drop through to queue the callback.\n\t\t */\n\t\tBUG_ON(cpu != -1);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\trcu_segcblist_enqueue(&rdp->cblist, head, lazy);\n\tif (!lazy)\n\t\trcu_idle_count_callbacks_posted();\n\n\tif (__is_kfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\t/* Go handle any RCU core processing required. */\n\t__call_rcu_core(rdp, head, flags);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid kfree_call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\t__call_rcu(head, func, -1, 1);\n}"
  },
  {
    "function_name": "call_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2888-2891",
    "snippet": "void call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\t__call_rcu(head, func, -1, 0);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__call_rcu",
          "args": [
            "head",
            "func",
            "-1",
            "0"
          ],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2786-2851",
          "snippet": "static void\n__call_rcu(struct rcu_head *head, rcu_callback_t func, int cpu, bool lazy)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tWARN_ONCE(1, \"__call_rcu(): Double-freed CB %p->%pF()!!!\\n\",\n\t\t\t  head, head->func);\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist)) || cpu != -1) {\n\t\tint offline;\n\n\t\tif (cpu != -1)\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (likely(rdp->mynode)) {\n\t\t\t/* Post-boot, so this should be for a no-CBs CPU. */\n\t\t\toffline = !__call_rcu_nocb(rdp, head, lazy, flags);\n\t\t\tWARN_ON_ONCE(offline);\n\t\t\t/* Offline CPU, _call_rcu() illegal, leak callback.  */\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Very early boot, before rcu_init().  Initialize if needed\n\t\t * and then drop through to queue the callback.\n\t\t */\n\t\tBUG_ON(cpu != -1);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\trcu_segcblist_enqueue(&rdp->cblist, head, lazy);\n\tif (!lazy)\n\t\trcu_idle_count_callbacks_posted();\n\n\tif (__is_kfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\t/* Go handle any RCU core processing required. */\n\t__call_rcu_core(rdp, head, flags);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\n__call_rcu(struct rcu_head *head, rcu_callback_t func, int cpu, bool lazy)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tWARN_ONCE(1, \"__call_rcu(): Double-freed CB %p->%pF()!!!\\n\",\n\t\t\t  head, head->func);\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist)) || cpu != -1) {\n\t\tint offline;\n\n\t\tif (cpu != -1)\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (likely(rdp->mynode)) {\n\t\t\t/* Post-boot, so this should be for a no-CBs CPU. */\n\t\t\toffline = !__call_rcu_nocb(rdp, head, lazy, flags);\n\t\t\tWARN_ON_ONCE(offline);\n\t\t\t/* Offline CPU, _call_rcu() illegal, leak callback.  */\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Very early boot, before rcu_init().  Initialize if needed\n\t\t * and then drop through to queue the callback.\n\t\t */\n\t\tBUG_ON(cpu != -1);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\trcu_segcblist_enqueue(&rdp->cblist, head, lazy);\n\tif (!lazy)\n\t\trcu_idle_count_callbacks_posted();\n\n\tif (__is_kfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\t/* Go handle any RCU core processing required. */\n\t__call_rcu_core(rdp, head, flags);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\t__call_rcu(head, func, -1, 0);\n}"
  },
  {
    "function_name": "__call_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2786-2851",
    "snippet": "static void\n__call_rcu(struct rcu_head *head, rcu_callback_t func, int cpu, bool lazy)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tWARN_ONCE(1, \"__call_rcu(): Double-freed CB %p->%pF()!!!\\n\",\n\t\t\t  head, head->func);\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist)) || cpu != -1) {\n\t\tint offline;\n\n\t\tif (cpu != -1)\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (likely(rdp->mynode)) {\n\t\t\t/* Post-boot, so this should be for a no-CBs CPU. */\n\t\t\toffline = !__call_rcu_nocb(rdp, head, lazy, flags);\n\t\t\tWARN_ON_ONCE(offline);\n\t\t\t/* Offline CPU, _call_rcu() illegal, leak callback.  */\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Very early boot, before rcu_init().  Initialize if needed\n\t\t * and then drop through to queue the callback.\n\t\t */\n\t\tBUG_ON(cpu != -1);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\trcu_segcblist_enqueue(&rdp->cblist, head, lazy);\n\tif (!lazy)\n\t\trcu_idle_count_callbacks_posted();\n\n\tif (__is_kfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\t/* Go handle any RCU core processing required. */\n\t__call_rcu_core(rdp, head, flags);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__call_rcu_core",
          "args": [
            "rdp",
            "head",
            "flags"
          ],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2731-2771",
          "snippet": "static void __call_rcu_core(struct rcu_data *rdp, struct rcu_head *head,\n\t\t\t    unsigned long flags)\n{\n\t/*\n\t * If called from an extended quiescent state, invoke the RCU\n\t * core in order to force a re-evaluation of RCU's idleness.\n\t */\n\tif (!rcu_is_watching())\n\t\tinvoke_rcu_core();\n\n\t/* If interrupts were disabled or CPU offline, don't invoke RCU core. */\n\tif (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Force the grace period if too many callbacks or too long waiting.\n\t * Enforce hysteresis, and don't invoke force_quiescent_state()\n\t * if some other CPU has recently done so.  Also, don't bother\n\t * invoking force_quiescent_state() if the newly enqueued callback\n\t * is the only one waiting for a grace period to complete.\n\t */\n\tif (unlikely(rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark)) {\n\n\t\t/* Are we ignoring a completed grace period? */\n\t\tnote_gp_changes(rdp);\n\n\t\t/* Start a new grace period if one not already started. */\n\t\tif (!rcu_gp_in_progress()) {\n\t\t\trcu_accelerate_cbs_unlocked(rdp->mynode, rdp);\n\t\t} else {\n\t\t\t/* Give the grace period a kick. */\n\t\t\trdp->blimit = LONG_MAX;\n\t\t\tif (rcu_state.n_force_qs == rdp->n_force_qs_snap &&\n\t\t\t    rcu_segcblist_first_pend_cb(&rdp->cblist) != head)\n\t\t\t\tforce_quiescent_state();\n\t\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_core(void);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static long blimit = DEFAULT_RCU_BLIMIT;",
            "static long qhimark = DEFAULT_RCU_QHIMARK;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
            "static void force_quiescent_state(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_core(void);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic void force_quiescent_state(void);\n\nstatic void __call_rcu_core(struct rcu_data *rdp, struct rcu_head *head,\n\t\t\t    unsigned long flags)\n{\n\t/*\n\t * If called from an extended quiescent state, invoke the RCU\n\t * core in order to force a re-evaluation of RCU's idleness.\n\t */\n\tif (!rcu_is_watching())\n\t\tinvoke_rcu_core();\n\n\t/* If interrupts were disabled or CPU offline, don't invoke RCU core. */\n\tif (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Force the grace period if too many callbacks or too long waiting.\n\t * Enforce hysteresis, and don't invoke force_quiescent_state()\n\t * if some other CPU has recently done so.  Also, don't bother\n\t * invoking force_quiescent_state() if the newly enqueued callback\n\t * is the only one waiting for a grace period to complete.\n\t */\n\tif (unlikely(rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark)) {\n\n\t\t/* Are we ignoring a completed grace period? */\n\t\tnote_gp_changes(rdp);\n\n\t\t/* Start a new grace period if one not already started. */\n\t\tif (!rcu_gp_in_progress()) {\n\t\t\trcu_accelerate_cbs_unlocked(rdp->mynode, rdp);\n\t\t} else {\n\t\t\t/* Give the grace period a kick. */\n\t\t\trdp->blimit = LONG_MAX;\n\t\t\tif (rcu_state.n_force_qs == rdp->n_force_qs_snap &&\n\t\t\t    rcu_segcblist_first_pend_cb(&rdp->cblist) != head)\n\t\t\t\tforce_quiescent_state();\n\t\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_callback",
          "args": [
            "rcu_state.name",
            "head",
            "rcu_segcblist_n_lazy_cbs(&rdp->cblist)",
            "rcu_segcblist_n_cbs(&rdp->cblist)"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-59",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_lazy_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_lazy_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "62-65",
          "snippet": "static inline long rcu_segcblist_n_lazy_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->len_lazy;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_lazy_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->len_lazy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_kfree_callback",
          "args": [
            "rcu_state.name",
            "head",
            "(unsigned long)func",
            "rcu_segcblist_n_lazy_cbs(&rdp->cblist)",
            "rcu_segcblist_n_cbs(&rdp->cblist)"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__is_kfree_rcu_offset",
          "args": [
            "(unsigned long)func"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_idle_count_callbacks_posted",
          "args": [],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_idle_count_callbacks_posted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1753-1756",
          "snippet": "static void rcu_idle_count_callbacks_posted(void)\n{\n\t__this_cpu_add(rcu_data.nonlazy_posted, 1);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_idle_count_callbacks_posted(void)\n{\n\t__this_cpu_add(rcu_data.nonlazy_posted, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_enqueue",
          "args": [
            "&rdp->cblist",
            "head",
            "lazy"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "142-152",
          "snippet": "void rcu_segcblist_enqueue(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp, bool lazy)\n{\n\tWRITE_ONCE(rsclp->len, rsclp->len + 1); /* ->len sampled locklessly. */\n\tif (lazy)\n\t\trsclp->len_lazy++;\n\tsmp_mb(); /* Ensure counts are updated before callback is enqueued. */\n\trhp->next = NULL;\n\t*rsclp->tails[RCU_NEXT_TAIL] = rhp;\n\trsclp->tails[RCU_NEXT_TAIL] = &rhp->next;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_enqueue(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp, bool lazy)\n{\n\tWRITE_ONCE(rsclp->len, rsclp->len + 1); /* ->len sampled locklessly. */\n\tif (lazy)\n\t\trsclp->len_lazy++;\n\tsmp_mb(); /* Ensure counts are updated before callback is enqueued. */\n\trhp->next = NULL;\n\t*rsclp->tails[RCU_NEXT_TAIL] = rhp;\n\trsclp->tails[RCU_NEXT_TAIL] = &rhp->next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_init",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "63-74",
          "snippet": "void rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++)\n\t\trsclp->tails[i] = &rsclp->head;\n\trsclp->len = 0;\n\trsclp->len_lazy = 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++)\n\t\trsclp->tails[i] = &rsclp->head;\n\trsclp->len = 0;\n\trsclp->len_lazy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_is_watching()"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "901-909",
          "snippet": "bool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpu != -1"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "offline"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__call_rcu_nocb",
          "args": [
            "rdp",
            "head",
            "lazy",
            "flags"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "__call_rcu_nocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2611-2615",
          "snippet": "static bool __call_rcu_nocb(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t    bool lazy, unsigned long flags)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool __call_rcu_nocb(struct rcu_data *rdp, struct rcu_head *rhp,\n\t\t\t    bool lazy, unsigned long flags)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rdp->mynode"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rcu_segcblist_is_enabled(&rdp->cblist)"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_is_enabled",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "77-80",
          "snippet": "static inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn !!rsclp->tails[RCU_NEXT_TAIL];\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn !!rsclp->tails[RCU_NEXT_TAIL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "head->func",
            "rcu_leak_callback"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"__call_rcu(): Double-freed CB %p->%pF()!!!\\n\"",
            "head",
            "head->func"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_queue",
          "args": [
            "head"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "209-212",
          "snippet": "static inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(unsigned long)head & (sizeof(void *) - 1)"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\n__call_rcu(struct rcu_head *head, rcu_callback_t func, int cpu, bool lazy)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tWARN_ONCE(1, \"__call_rcu(): Double-freed CB %p->%pF()!!!\\n\",\n\t\t\t  head, head->func);\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist)) || cpu != -1) {\n\t\tint offline;\n\n\t\tif (cpu != -1)\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (likely(rdp->mynode)) {\n\t\t\t/* Post-boot, so this should be for a no-CBs CPU. */\n\t\t\toffline = !__call_rcu_nocb(rdp, head, lazy, flags);\n\t\t\tWARN_ON_ONCE(offline);\n\t\t\t/* Offline CPU, _call_rcu() illegal, leak callback.  */\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Very early boot, before rcu_init().  Initialize if needed\n\t\t * and then drop through to queue the callback.\n\t\t */\n\t\tBUG_ON(cpu != -1);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\trcu_segcblist_enqueue(&rdp->cblist, head, lazy);\n\tif (!lazy)\n\t\trcu_idle_count_callbacks_posted();\n\n\tif (__is_kfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\t/* Go handle any RCU core processing required. */\n\t__call_rcu_core(rdp, head, flags);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rcu_leak_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2776-2778",
    "snippet": "static void rcu_leak_callback(struct rcu_head *rhp)\n{\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_leak_callback(struct rcu_head *rhp)\n{\n}"
  },
  {
    "function_name": "__call_rcu_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2731-2771",
    "snippet": "static void __call_rcu_core(struct rcu_data *rdp, struct rcu_head *head,\n\t\t\t    unsigned long flags)\n{\n\t/*\n\t * If called from an extended quiescent state, invoke the RCU\n\t * core in order to force a re-evaluation of RCU's idleness.\n\t */\n\tif (!rcu_is_watching())\n\t\tinvoke_rcu_core();\n\n\t/* If interrupts were disabled or CPU offline, don't invoke RCU core. */\n\tif (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Force the grace period if too many callbacks or too long waiting.\n\t * Enforce hysteresis, and don't invoke force_quiescent_state()\n\t * if some other CPU has recently done so.  Also, don't bother\n\t * invoking force_quiescent_state() if the newly enqueued callback\n\t * is the only one waiting for a grace period to complete.\n\t */\n\tif (unlikely(rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark)) {\n\n\t\t/* Are we ignoring a completed grace period? */\n\t\tnote_gp_changes(rdp);\n\n\t\t/* Start a new grace period if one not already started. */\n\t\tif (!rcu_gp_in_progress()) {\n\t\t\trcu_accelerate_cbs_unlocked(rdp->mynode, rdp);\n\t\t} else {\n\t\t\t/* Give the grace period a kick. */\n\t\t\trdp->blimit = LONG_MAX;\n\t\t\tif (rcu_state.n_force_qs == rdp->n_force_qs_snap &&\n\t\t\t    rcu_segcblist_first_pend_cb(&rdp->cblist) != head)\n\t\t\t\tforce_quiescent_state();\n\t\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_core(void);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static long blimit = DEFAULT_RCU_BLIMIT;",
      "static long qhimark = DEFAULT_RCU_QHIMARK;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
      "static void force_quiescent_state(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-59",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_quiescent_state",
          "args": [],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "force_quiescent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2566-2597",
          "snippet": "static void force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t      !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void force_quiescent_state(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void force_quiescent_state(void);\n\nstatic void force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t      !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_first_pend_cb",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_first_pend_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "126-131",
          "snippet": "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp)\n{\n\tif (rcu_segcblist_is_enabled(rsclp))\n\t\treturn *rsclp->tails[RCU_DONE_TAIL];\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp)\n{\n\tif (rcu_segcblist_is_enabled(rsclp))\n\t\treturn *rsclp->tails[RCU_DONE_TAIL];\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs_unlocked",
          "args": [
            "rdp->mynode",
            "rdp"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1612-1630",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "205-208",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "note_gp_changes",
          "args": [
            "rdp"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "note_gp_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1707-1725",
          "snippet": "static void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2722-2726",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "901-909",
          "snippet": "bool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_core(void);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic void force_quiescent_state(void);\n\nstatic void __call_rcu_core(struct rcu_data *rdp, struct rcu_head *head,\n\t\t\t    unsigned long flags)\n{\n\t/*\n\t * If called from an extended quiescent state, invoke the RCU\n\t * core in order to force a re-evaluation of RCU's idleness.\n\t */\n\tif (!rcu_is_watching())\n\t\tinvoke_rcu_core();\n\n\t/* If interrupts were disabled or CPU offline, don't invoke RCU core. */\n\tif (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Force the grace period if too many callbacks or too long waiting.\n\t * Enforce hysteresis, and don't invoke force_quiescent_state()\n\t * if some other CPU has recently done so.  Also, don't bother\n\t * invoking force_quiescent_state() if the newly enqueued callback\n\t * is the only one waiting for a grace period to complete.\n\t */\n\tif (unlikely(rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark)) {\n\n\t\t/* Are we ignoring a completed grace period? */\n\t\tnote_gp_changes(rdp);\n\n\t\t/* Start a new grace period if one not already started. */\n\t\tif (!rcu_gp_in_progress()) {\n\t\t\trcu_accelerate_cbs_unlocked(rdp->mynode, rdp);\n\t\t} else {\n\t\t\t/* Give the grace period a kick. */\n\t\t\trdp->blimit = LONG_MAX;\n\t\t\tif (rcu_state.n_force_qs == rdp->n_force_qs_snap &&\n\t\t\t    rcu_segcblist_first_pend_cb(&rdp->cblist) != head)\n\t\t\t\tforce_quiescent_state();\n\t\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "invoke_rcu_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2722-2726",
    "snippet": "static void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void invoke_rcu_core(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raise_softirq",
          "args": [
            "RCU_SOFTIRQ"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "449-453",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}"
  },
  {
    "function_name": "invoke_rcu_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2711-2720",
    "snippet": "static void invoke_rcu_callbacks(struct rcu_data *rdp)\n{\n\tif (unlikely(!READ_ONCE(rcu_scheduler_fully_active)))\n\t\treturn;\n\tif (likely(!rcu_state.boost)) {\n\t\trcu_do_batch(rdp);\n\t\treturn;\n\t}\n\tinvoke_rcu_callbacks_kthread();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static int rcu_scheduler_fully_active",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "invoke_rcu_callbacks_kthread",
          "args": [],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_callbacks_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1490-1493",
          "snippet": "static void invoke_rcu_callbacks_kthread(void)\n{\n\tWARN_ON_ONCE(1);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void invoke_rcu_callbacks_kthread(void)\n{\n\tWARN_ON_ONCE(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_do_batch",
          "args": [
            "rdp"
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_do_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2400-2482",
          "snippet": "static void rcu_do_batch(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\tlocal_irq_save(flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tbl = rdp->blimit;\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tlocal_irq_restore(flags);\n\n\t/* Invoke callbacks. */\n\trhp = rcu_cblist_dequeue(&rcl);\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\tdebug_rcu_head_unqueue(rhp);\n\t\tif (__rcu_reclaim(rcu_state.name, rhp))\n\t\t\trcu_cblist_dequeued_lazy(&rcl);\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t * Note: The rcl structure counts down from zero.\n\t\t */\n\t\tif (-rcl.len >= bl &&\n\t\t    (need_resched() ||\n\t\t     (!is_idle_task(current) && !rcu_is_callbacks_kthread())))\n\t\t\tbreak;\n\t}\n\n\tlocal_irq_save(flags);\n\tcount = -rcl.len;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\tsmp_mb(); /* List handling before counting for rcu_barrier(). */\n\trcu_segcblist_insert_count(&rdp->cblist, &rcl);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit == LONG_MAX && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tWARN_ON_ONCE(rcu_segcblist_empty(&rdp->cblist) != (count == 0));\n\n\tlocal_irq_restore(flags);\n\n\t/* Re-invoke RCU core processing if there are callbacks remaining. */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\tinvoke_rcu_core();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_core(void);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static long blimit = DEFAULT_RCU_BLIMIT;",
            "static long qhimark = DEFAULT_RCU_QHIMARK;",
            "static long qlowmark = DEFAULT_RCU_QLOMARK;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_core(void);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic long qlowmark = DEFAULT_RCU_QLOMARK;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_do_batch(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\tlocal_irq_save(flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tbl = rdp->blimit;\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tlocal_irq_restore(flags);\n\n\t/* Invoke callbacks. */\n\trhp = rcu_cblist_dequeue(&rcl);\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\tdebug_rcu_head_unqueue(rhp);\n\t\tif (__rcu_reclaim(rcu_state.name, rhp))\n\t\t\trcu_cblist_dequeued_lazy(&rcl);\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t * Note: The rcl structure counts down from zero.\n\t\t */\n\t\tif (-rcl.len >= bl &&\n\t\t    (need_resched() ||\n\t\t     (!is_idle_task(current) && !rcu_is_callbacks_kthread())))\n\t\t\tbreak;\n\t}\n\n\tlocal_irq_save(flags);\n\tcount = -rcl.len;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\tsmp_mb(); /* List handling before counting for rcu_barrier(). */\n\trcu_segcblist_insert_count(&rdp->cblist, &rcl);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit == LONG_MAX && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tWARN_ON_ONCE(rcu_segcblist_empty(&rdp->cblist) != (count == 0));\n\n\tlocal_irq_restore(flags);\n\n\t/* Re-invoke RCU core processing if there are callbacks remaining. */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\tinvoke_rcu_core();\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!rcu_state.boost"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!READ_ONCE(rcu_scheduler_fully_active)"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_scheduler_fully_active"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic int rcu_scheduler_fully_active;\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp)\n{\n\tif (unlikely(!READ_ONCE(rcu_scheduler_fully_active)))\n\t\treturn;\n\tif (likely(!rcu_state.boost)) {\n\t\trcu_do_batch(rdp);\n\t\treturn;\n\t}\n\tinvoke_rcu_callbacks_kthread();\n}"
  },
  {
    "function_name": "rcu_process_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2662-2702",
    "snippet": "static __latent_entropy void rcu_process_callbacks(struct softirq_action *unused)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = raw_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\ttrace_rcu_utilization(TPS(\"Start RCU core\"));\n\tWARN_ON_ONCE(!rdp->beenonline);\n\n\t/* Report any deferred quiescent states if preemption enabled. */\n\tif (!(preempt_count() & PREEMPT_MASK)) {\n\t\trcu_preempt_deferred_qs(current);\n\t} else if (rcu_preempt_need_deferred_qs(current)) {\n\t\tset_tsk_need_resched(current);\n\t\tset_preempt_need_resched();\n\t}\n\n\t/* Update RCU state based on any recent quiescent states. */\n\trcu_check_quiescent_state(rdp);\n\n\t/* No grace period and unregistered callbacks? */\n\tif (!rcu_gp_in_progress() &&\n\t    rcu_segcblist_is_enabled(&rdp->cblist)) {\n\t\tlocal_irq_save(flags);\n\t\tif (!rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\t\trcu_accelerate_cbs_unlocked(rnp, rdp);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\trcu_check_gp_start_stall(rnp, rdp);\n\n\t/* If there are callbacks ready, invoke them. */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\tinvoke_rcu_callbacks(rdp);\n\n\t/* Do any needed deferred wakeups of rcuo kthreads. */\n\tdo_nocb_deferred_wakeup(rdp);\n\ttrace_rcu_utilization(TPS(\"End RCU core\"));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End RCU core\")"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End RCU core\""
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup",
          "args": [
            "rdp"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2633-2635",
          "snippet": "static void do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "invoke_rcu_callbacks",
          "args": [
            "rdp"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2711-2720",
          "snippet": "static void invoke_rcu_callbacks(struct rcu_data *rdp)\n{\n\tif (unlikely(!READ_ONCE(rcu_scheduler_fully_active)))\n\t\treturn;\n\tif (likely(!rcu_state.boost)) {\n\t\trcu_do_batch(rdp);\n\t\treturn;\n\t}\n\tinvoke_rcu_callbacks_kthread();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static int rcu_scheduler_fully_active",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic int rcu_scheduler_fully_active;\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp)\n{\n\tif (unlikely(!READ_ONCE(rcu_scheduler_fully_active)))\n\t\treturn;\n\tif (likely(!rcu_state.boost)) {\n\t\trcu_do_batch(rdp);\n\t\treturn;\n\t}\n\tinvoke_rcu_callbacks_kthread();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "92-96",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != rsclp->tails[RCU_DONE_TAIL];\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != rsclp->tails[RCU_DONE_TAIL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_check_gp_start_stall",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_gp_start_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2603-2655",
          "snippet": "static void\nrcu_check_gp_start_stall(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tconst unsigned long gpssdelay = rcu_jiffies_till_stall_check() * HZ;\n\tunsigned long flags;\n\tunsigned long j;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tstatic atomic_t warned = ATOMIC_INIT(0);\n\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU) || rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed))\n\t\treturn;\n\tj = jiffies; /* Expensive access, and in common case don't get here. */\n\tif (time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned))\n\t\treturn;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\t/* Hold onto the leaf lock to make others see warned==1. */\n\n\tif (rnp_root != rnp)\n\t\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed) ||\n\t    time_before(j, rcu_state.gp_req_activity + gpssdelay) ||\n\t    time_before(j, rcu_state.gp_activity + gpssdelay) ||\n\t    atomic_xchg(&warned, 1)) {\n\t\traw_spin_unlock_rcu_node(rnp_root); /* irqs remain disabled. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tpr_alert(\"%s: g%ld->%ld gar:%lu ga:%lu f%#x gs:%d %s->state:%#lx\\n\",\n\t\t __func__, (long)READ_ONCE(rcu_state.gp_seq),\n\t\t (long)READ_ONCE(rnp_root->gp_seq_needed),\n\t\t j - rcu_state.gp_req_activity, j - rcu_state.gp_activity,\n\t\t rcu_state.gp_flags, rcu_state.gp_state, rcu_state.name,\n\t\t rcu_state.gp_kthread ? rcu_state.gp_kthread->state : 0x1ffffL);\n\tWARN_ON(1);\n\tif (rnp_root != rnp)\n\t\traw_spin_unlock_rcu_node(rnp_root);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\nrcu_check_gp_start_stall(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tconst unsigned long gpssdelay = rcu_jiffies_till_stall_check() * HZ;\n\tunsigned long flags;\n\tunsigned long j;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tstatic atomic_t warned = ATOMIC_INIT(0);\n\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU) || rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed))\n\t\treturn;\n\tj = jiffies; /* Expensive access, and in common case don't get here. */\n\tif (time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned))\n\t\treturn;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\t/* Hold onto the leaf lock to make others see warned==1. */\n\n\tif (rnp_root != rnp)\n\t\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed) ||\n\t    time_before(j, rcu_state.gp_req_activity + gpssdelay) ||\n\t    time_before(j, rcu_state.gp_activity + gpssdelay) ||\n\t    atomic_xchg(&warned, 1)) {\n\t\traw_spin_unlock_rcu_node(rnp_root); /* irqs remain disabled. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tpr_alert(\"%s: g%ld->%ld gar:%lu ga:%lu f%#x gs:%d %s->state:%#lx\\n\",\n\t\t __func__, (long)READ_ONCE(rcu_state.gp_seq),\n\t\t (long)READ_ONCE(rnp_root->gp_seq_needed),\n\t\t j - rcu_state.gp_req_activity, j - rcu_state.gp_activity,\n\t\t rcu_state.gp_flags, rcu_state.gp_state, rcu_state.name,\n\t\t rcu_state.gp_kthread ? rcu_state.gp_kthread->state : 0x1ffffL);\n\tWARN_ON(1);\n\tif (rnp_root != rnp)\n\t\traw_spin_unlock_rcu_node(rnp_root);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs_unlocked",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1612-1630",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_restempty",
          "args": [
            "&rdp->cblist",
            "RCU_NEXT_READY_TAIL"
          ],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_restempty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "87-90",
          "snippet": "static inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !*rsclp->tails[seg];\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !*rsclp->tails[seg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_is_enabled",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_is_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "77-80",
          "snippet": "static inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn !!rsclp->tails[RCU_NEXT_TAIL];\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_is_enabled(struct rcu_segcblist *rsclp)\n{\n\treturn !!rsclp->tails[RCU_NEXT_TAIL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "205-208",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_check_quiescent_state",
          "args": [
            "rdp"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_quiescent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2284-2309",
          "snippet": "static void\nrcu_check_quiescent_state(struct rcu_data *rdp)\n{\n\t/* Check for grace-period ends and beginnings. */\n\tnote_gp_changes(rdp);\n\n\t/*\n\t * Does this CPU still need to do its part for current grace period?\n\t * If no, return and let the other CPUs do their part as well.\n\t */\n\tif (!rdp->core_needs_qs)\n\t\treturn;\n\n\t/*\n\t * Was there a quiescent state since the beginning of the grace\n\t * period? If no, then exit and wait for the next call.\n\t */\n\tif (rdp->cpu_no_qs.b.norm)\n\t\treturn;\n\n\t/*\n\t * Tell RCU we are done (but rcu_report_qs_rdp() will be the\n\t * judge of that).\n\t */\n\trcu_report_qs_rdp(rdp->cpu, rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\nrcu_check_quiescent_state(struct rcu_data *rdp)\n{\n\t/* Check for grace-period ends and beginnings. */\n\tnote_gp_changes(rdp);\n\n\t/*\n\t * Does this CPU still need to do its part for current grace period?\n\t * If no, return and let the other CPUs do their part as well.\n\t */\n\tif (!rdp->core_needs_qs)\n\t\treturn;\n\n\t/*\n\t * Was there a quiescent state since the beginning of the grace\n\t * period? If no, then exit and wait for the next call.\n\t */\n\tif (rdp->cpu_no_qs.b.norm)\n\t\treturn;\n\n\t/*\n\t * Tell RCU we are done (but rcu_report_qs_rdp() will be the\n\t * judge of that).\n\t */\n\trcu_report_qs_rdp(rdp->cpu, rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "current"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_need_deferred_qs",
          "args": [
            "current"
          ],
          "line": 2676
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_need_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1034-1037",
          "snippet": "static bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_need_deferred_qs(struct task_struct *t)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "current"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1038-1038",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t) { }",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t) { }"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rdp->beenonline"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start RCU core\")"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start RCU core\""
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic __latent_entropy void rcu_process_callbacks(struct softirq_action *unused)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = raw_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\ttrace_rcu_utilization(TPS(\"Start RCU core\"));\n\tWARN_ON_ONCE(!rdp->beenonline);\n\n\t/* Report any deferred quiescent states if preemption enabled. */\n\tif (!(preempt_count() & PREEMPT_MASK)) {\n\t\trcu_preempt_deferred_qs(current);\n\t} else if (rcu_preempt_need_deferred_qs(current)) {\n\t\tset_tsk_need_resched(current);\n\t\tset_preempt_need_resched();\n\t}\n\n\t/* Update RCU state based on any recent quiescent states. */\n\trcu_check_quiescent_state(rdp);\n\n\t/* No grace period and unregistered callbacks? */\n\tif (!rcu_gp_in_progress() &&\n\t    rcu_segcblist_is_enabled(&rdp->cblist)) {\n\t\tlocal_irq_save(flags);\n\t\tif (!rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\t\trcu_accelerate_cbs_unlocked(rnp, rdp);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\trcu_check_gp_start_stall(rnp, rdp);\n\n\t/* If there are callbacks ready, invoke them. */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\tinvoke_rcu_callbacks(rdp);\n\n\t/* Do any needed deferred wakeups of rcuo kthreads. */\n\tdo_nocb_deferred_wakeup(rdp);\n\ttrace_rcu_utilization(TPS(\"End RCU core\"));\n}"
  },
  {
    "function_name": "rcu_check_gp_start_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2603-2655",
    "snippet": "static void\nrcu_check_gp_start_stall(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tconst unsigned long gpssdelay = rcu_jiffies_till_stall_check() * HZ;\n\tunsigned long flags;\n\tunsigned long j;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tstatic atomic_t warned = ATOMIC_INIT(0);\n\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU) || rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed))\n\t\treturn;\n\tj = jiffies; /* Expensive access, and in common case don't get here. */\n\tif (time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned))\n\t\treturn;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\t/* Hold onto the leaf lock to make others see warned==1. */\n\n\tif (rnp_root != rnp)\n\t\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed) ||\n\t    time_before(j, rcu_state.gp_req_activity + gpssdelay) ||\n\t    time_before(j, rcu_state.gp_activity + gpssdelay) ||\n\t    atomic_xchg(&warned, 1)) {\n\t\traw_spin_unlock_rcu_node(rnp_root); /* irqs remain disabled. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tpr_alert(\"%s: g%ld->%ld gar:%lu ga:%lu f%#x gs:%d %s->state:%#lx\\n\",\n\t\t __func__, (long)READ_ONCE(rcu_state.gp_seq),\n\t\t (long)READ_ONCE(rnp_root->gp_seq_needed),\n\t\t j - rcu_state.gp_req_activity, j - rcu_state.gp_activity,\n\t\t rcu_state.gp_flags, rcu_state.gp_state, rcu_state.name,\n\t\t rcu_state.gp_kthread ? rcu_state.gp_kthread->state : 0x1ffffL);\n\tWARN_ON(1);\n\tif (rnp_root != rnp)\n\t\traw_spin_unlock_rcu_node(rnp_root);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp_root"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: g%ld->%ld gar:%lu ga:%lu f%#x gs:%d %s->state:%#lx\\n\"",
            "__func__",
            "(long)READ_ONCE(rcu_state.gp_seq)",
            "(long)READ_ONCE(rnp_root->gp_seq_needed)",
            "j - rcu_state.gp_req_activity",
            "j - rcu_state.gp_activity",
            "rcu_state.gp_flags",
            "rcu_state.gp_state",
            "rcu_state.name",
            "rcu_state.gp_kthread ? rcu_state.gp_kthread->state : 0x1ffffL"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp_root->gp_seq_needed"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp_root"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&warned",
            "1"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "rcu_state.gp_activity + gpssdelay"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "rcu_state.gp_req_activity + gpssdelay"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rnp_root->gp_seq",
            "rnp_root->gp_seq_needed"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "205-208",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp_root"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&warned"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_activity) + gpssdelay"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_activity"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_req_activity) + gpssdelay"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_req_activity"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rnp_root->gp_seq",
            "rnp_root->gp_seq_needed"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&warned"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_activity) + gpssdelay"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_activity"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "j",
            "READ_ONCE(rcu_state.gp_req_activity) + gpssdelay"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_req_activity"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rnp_root->gp_seq",
            "rnp_root->gp_seq_needed"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PROVE_RCU"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_INIT",
          "args": [
            "0"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "454-470",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t       0",
            "#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_STALL_DELAY_DELTA\t       0\n#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\nrcu_check_gp_start_stall(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tconst unsigned long gpssdelay = rcu_jiffies_till_stall_check() * HZ;\n\tunsigned long flags;\n\tunsigned long j;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tstatic atomic_t warned = ATOMIC_INIT(0);\n\n\tif (!IS_ENABLED(CONFIG_PROVE_RCU) || rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed))\n\t\treturn;\n\tj = jiffies; /* Expensive access, and in common case don't get here. */\n\tif (time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned))\n\t\treturn;\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_req_activity) + gpssdelay) ||\n\t    time_before(j, READ_ONCE(rcu_state.gp_activity) + gpssdelay) ||\n\t    atomic_read(&warned)) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\t/* Hold onto the leaf lock to make others see warned==1. */\n\n\tif (rnp_root != rnp)\n\t\traw_spin_lock_rcu_node(rnp_root); /* irqs already disabled. */\n\tj = jiffies;\n\tif (rcu_gp_in_progress() ||\n\t    ULONG_CMP_GE(rnp_root->gp_seq, rnp_root->gp_seq_needed) ||\n\t    time_before(j, rcu_state.gp_req_activity + gpssdelay) ||\n\t    time_before(j, rcu_state.gp_activity + gpssdelay) ||\n\t    atomic_xchg(&warned, 1)) {\n\t\traw_spin_unlock_rcu_node(rnp_root); /* irqs remain disabled. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tpr_alert(\"%s: g%ld->%ld gar:%lu ga:%lu f%#x gs:%d %s->state:%#lx\\n\",\n\t\t __func__, (long)READ_ONCE(rcu_state.gp_seq),\n\t\t (long)READ_ONCE(rnp_root->gp_seq_needed),\n\t\t j - rcu_state.gp_req_activity, j - rcu_state.gp_activity,\n\t\t rcu_state.gp_flags, rcu_state.gp_state, rcu_state.name,\n\t\t rcu_state.gp_kthread ? rcu_state.gp_kthread->state : 0x1ffffL);\n\tWARN_ON(1);\n\tif (rnp_root != rnp)\n\t\traw_spin_unlock_rcu_node(rnp_root);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}"
  },
  {
    "function_name": "force_quiescent_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2566-2597",
    "snippet": "static void force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t      !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void force_quiescent_state(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1551-1558",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp_old",
            "flags"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp_old",
            "flags"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rnp_old->fqslock"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp_old",
            "flags"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock",
          "args": [
            "&rnp->fqslock"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "134-137",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.mynode"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void force_quiescent_state(void);\n\nstatic void force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t      !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}"
  },
  {
    "function_name": "force_qs_rnp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2519-2560",
    "snippet": "static void force_qs_rnp(int (*f)(struct rcu_data *rdp))\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\tcond_resched_tasks_rcu_qs();\n\t\tmask = 0;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->qsmask == 0) {\n\t\t\tif (!IS_ENABLED(CONFIG_PREEMPT) ||\n\t\t\t    rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\t\t/*\n\t\t\t\t * No point in scanning bits because they\n\t\t\t\t * are all zero.  But we might need to\n\t\t\t\t * priority-boost blocked readers.\n\t\t\t\t */\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\t\t/* rcu_initiate_boost() releases rnp->lock */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\tunsigned long bit = leaf_node_cpu_bit(rnp, cpu);\n\t\t\tif ((rnp->qsmask & bit) != 0) {\n\t\t\t\tif (f(per_cpu_ptr(&rcu_data, cpu)))\n\t\t\t\t\tmask |= bit;\n\t\t\t}\n\t\t}\n\t\tif (mask != 0) {\n\t\t\t/* Idle/offline CPUs, report (releases rnp->lock). */\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t} else {\n\t\t\t/* Nothing to do here, so just drop the lock. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp",
            "rnp->gp_seq",
            "flags"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2133-2188",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "per_cpu_ptr(&rcu_data, cpu)"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "rcutree_offline_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3288-3304",
          "snippet": "int rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\tif (IS_ENABLED(CONFIG_TREE_SRCU))\n\t\tsrcu_offline_cpu(cpu);\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\tif (IS_ENABLED(CONFIG_TREE_SRCU))\n\t\tsrcu_offline_cpu(cpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_initiate_boost",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_initiate_boost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1484-1488",
          "snippet": "static void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_initiate_boost(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp))\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\tcond_resched_tasks_rcu_qs();\n\t\tmask = 0;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->qsmask == 0) {\n\t\t\tif (!IS_ENABLED(CONFIG_PREEMPT) ||\n\t\t\t    rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\t\t/*\n\t\t\t\t * No point in scanning bits because they\n\t\t\t\t * are all zero.  But we might need to\n\t\t\t\t * priority-boost blocked readers.\n\t\t\t\t */\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\t\t/* rcu_initiate_boost() releases rnp->lock */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\tunsigned long bit = leaf_node_cpu_bit(rnp, cpu);\n\t\t\tif ((rnp->qsmask & bit) != 0) {\n\t\t\t\tif (f(per_cpu_ptr(&rcu_data, cpu)))\n\t\t\t\t\tmask |= bit;\n\t\t\t}\n\t\t}\n\t\tif (mask != 0) {\n\t\t\t/* Idle/offline CPUs, report (releases rnp->lock). */\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t} else {\n\t\t\t/* Nothing to do here, so just drop the lock. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rcu_check_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2492-2510",
    "snippet": "void rcu_check_callbacks(int user)\n{\n\ttrace_rcu_utilization(TPS(\"Start scheduler-tick\"));\n\traw_cpu_inc(rcu_data.ticks_this_gp);\n\t/* The load-acquire pairs with the store-release setting to true. */\n\tif (smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\t/* Idle and userspace execution already are quiescent states. */\n\t\tif (!rcu_is_cpu_rrupt_from_idle() && !user) {\n\t\t\tset_tsk_need_resched(current);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\t__this_cpu_write(rcu_data.rcu_urgent_qs, false);\n\t}\n\trcu_flavor_check_callbacks(user);\n\tif (rcu_pending())\n\t\tinvoke_rcu_core();\n\n\ttrace_rcu_utilization(TPS(\"End scheduler-tick\"));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_core(void);",
      "static int rcu_pending(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"End scheduler-tick\")"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End scheduler-tick\""
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2722-2726",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_pending",
          "args": [],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2955-2992",
          "snippet": "static int rcu_pending(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/* Check for CPU stalls, if enabled. */\n\tcheck_cpu_stall(rdp);\n\n\t/* Is this CPU a NO_HZ_FULL CPU that should ignore RCU? */\n\tif (rcu_nohz_full_cpu())\n\t\treturn 0;\n\n\t/* Is the RCU core waiting for a quiescent state from this CPU? */\n\tif (rdp->core_needs_qs && !rdp->cpu_no_qs.b.norm)\n\t\treturn 1;\n\n\t/* Does this CPU have callbacks ready to invoke? */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\treturn 1;\n\n\t/* Has RCU gone idle with this CPU needing another grace period? */\n\tif (!rcu_gp_in_progress() &&\n\t    rcu_segcblist_is_enabled(&rdp->cblist) &&\n\t    !rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\treturn 1;\n\n\t/* Have RCU grace period completed or started?  */\n\tif (rcu_seq_current(&rnp->gp_seq) != rdp->gp_seq ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) /* outside lock */\n\t\treturn 1;\n\n\t/* Does this CPU need a deferred NOCB wakeup? */\n\tif (rcu_nocb_need_deferred_wakeup(rdp))\n\t\treturn 1;\n\n\t/* nothing to do */\n\treturn 0;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));",
            "static int rcu_pending(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(void);\n\nstatic int rcu_pending(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/* Check for CPU stalls, if enabled. */\n\tcheck_cpu_stall(rdp);\n\n\t/* Is this CPU a NO_HZ_FULL CPU that should ignore RCU? */\n\tif (rcu_nohz_full_cpu())\n\t\treturn 0;\n\n\t/* Is the RCU core waiting for a quiescent state from this CPU? */\n\tif (rdp->core_needs_qs && !rdp->cpu_no_qs.b.norm)\n\t\treturn 1;\n\n\t/* Does this CPU have callbacks ready to invoke? */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\treturn 1;\n\n\t/* Has RCU gone idle with this CPU needing another grace period? */\n\tif (!rcu_gp_in_progress() &&\n\t    rcu_segcblist_is_enabled(&rdp->cblist) &&\n\t    !rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\treturn 1;\n\n\t/* Have RCU grace period completed or started?  */\n\tif (rcu_seq_current(&rnp->gp_seq) != rdp->gp_seq ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) /* outside lock */\n\t\treturn 1;\n\n\t/* Does this CPU need a deferred NOCB wakeup? */\n\tif (rcu_nocb_need_deferred_wakeup(rdp))\n\t\treturn 1;\n\n\t/* nothing to do */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_flavor_check_callbacks",
          "args": [
            "user"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_flavor_check_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1085-1103",
          "snippet": "static void rcu_flavor_check_callbacks(int user)\n{\n\tif (user || rcu_is_cpu_rrupt_from_idle()) {\n\n\t\t/*\n\t\t * Get here if this CPU took its interrupt from user\n\t\t * mode or from the idle loop, and if this is not a\n\t\t * nested interrupt.  In this case, the CPU is in\n\t\t * a quiescent state, so note it.\n\t\t *\n\t\t * No memory barrier is required here because rcu_qs()\n\t\t * references only CPU-local variables that other CPUs\n\t\t * neither access nor modify, at least not while the\n\t\t * corresponding CPU is online.\n\t\t */\n\n\t\trcu_qs();\n\t}\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_flavor_check_callbacks(int user)\n{\n\tif (user || rcu_is_cpu_rrupt_from_idle()) {\n\n\t\t/*\n\t\t * Get here if this CPU took its interrupt from user\n\t\t * mode or from the idle loop, and if this is not a\n\t\t * nested interrupt.  In this case, the CPU is in\n\t\t * a quiescent state, so note it.\n\t\t *\n\t\t * No memory barrier is required here because rcu_qs()\n\t\t * references only CPU-local variables that other CPUs\n\t\t * neither access nor modify, at least not while the\n\t\t * corresponding CPU is online.\n\t\t */\n\n\t\trcu_qs();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "rcu_data.rcu_urgent_qs",
            "false"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "current"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_cpu_rrupt_from_idle",
          "args": [],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_cpu_rrupt_from_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "377-381",
          "snippet": "static int rcu_is_cpu_rrupt_from_idle(void)\n{\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) <= 0 &&\n\t       __this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 1;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\n\nstatic int rcu_is_cpu_rrupt_from_idle(void)\n{\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) <= 0 &&\n\t       __this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "this_cpu_ptr(&rcu_data.rcu_urgent_qs)"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data.rcu_urgent_qs"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_inc",
          "args": [
            "rcu_data.ticks_this_gp"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_utilization",
          "args": [
            "TPS(\"Start scheduler-tick\")"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start scheduler-tick\""
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_core(void);\nstatic int rcu_pending(void);\n\nvoid rcu_check_callbacks(int user)\n{\n\ttrace_rcu_utilization(TPS(\"Start scheduler-tick\"));\n\traw_cpu_inc(rcu_data.ticks_this_gp);\n\t/* The load-acquire pairs with the store-release setting to true. */\n\tif (smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\t/* Idle and userspace execution already are quiescent states. */\n\t\tif (!rcu_is_cpu_rrupt_from_idle() && !user) {\n\t\t\tset_tsk_need_resched(current);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\t__this_cpu_write(rcu_data.rcu_urgent_qs, false);\n\t}\n\trcu_flavor_check_callbacks(user);\n\tif (rcu_pending())\n\t\tinvoke_rcu_core();\n\n\ttrace_rcu_utilization(TPS(\"End scheduler-tick\"));\n}"
  },
  {
    "function_name": "rcu_do_batch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2400-2482",
    "snippet": "static void rcu_do_batch(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\tlocal_irq_save(flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tbl = rdp->blimit;\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tlocal_irq_restore(flags);\n\n\t/* Invoke callbacks. */\n\trhp = rcu_cblist_dequeue(&rcl);\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\tdebug_rcu_head_unqueue(rhp);\n\t\tif (__rcu_reclaim(rcu_state.name, rhp))\n\t\t\trcu_cblist_dequeued_lazy(&rcl);\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t * Note: The rcl structure counts down from zero.\n\t\t */\n\t\tif (-rcl.len >= bl &&\n\t\t    (need_resched() ||\n\t\t     (!is_idle_task(current) && !rcu_is_callbacks_kthread())))\n\t\t\tbreak;\n\t}\n\n\tlocal_irq_save(flags);\n\tcount = -rcl.len;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\tsmp_mb(); /* List handling before counting for rcu_barrier(). */\n\trcu_segcblist_insert_count(&rdp->cblist, &rcl);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit == LONG_MAX && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tWARN_ON_ONCE(rcu_segcblist_empty(&rdp->cblist) != (count == 0));\n\n\tlocal_irq_restore(flags);\n\n\t/* Re-invoke RCU core processing if there are callbacks remaining. */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\tinvoke_rcu_core();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_core(void);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static long blimit = DEFAULT_RCU_BLIMIT;",
      "static long qhimark = DEFAULT_RCU_QHIMARK;",
      "static long qlowmark = DEFAULT_RCU_QLOMARK;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "invoke_rcu_core",
          "args": [],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_rcu_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2722-2726",
          "snippet": "static void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void invoke_rcu_core(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void invoke_rcu_core(void);\n\nstatic void invoke_rcu_core(void)\n{\n\tif (cpu_online(smp_processor_id()))\n\t\traise_softirq(RCU_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "92-96",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != rsclp->tails[RCU_DONE_TAIL];\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != rsclp->tails[RCU_DONE_TAIL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_segcblist_empty(&rdp->cblist) != (count == 0)"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "56-59",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn READ_ONCE(rsclp->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_insert_count",
          "args": [
            "&rdp->cblist",
            "&rcl"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_insert_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "249-257",
          "snippet": "void rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp)\n{\n\trsclp->len_lazy += rclp->len_lazy;\n\t/* ->len sampled locklessly. */\n\tWRITE_ONCE(rsclp->len, rsclp->len + rclp->len);\n\trclp->len_lazy = 0;\n\trclp->len = 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp)\n{\n\trsclp->len_lazy += rclp->len_lazy;\n\t/* ->len sampled locklessly. */\n\tWRITE_ONCE(rsclp->len, rsclp->len + rclp->len);\n\trclp->len_lazy = 0;\n\trclp->len = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_insert_done_cbs",
          "args": [
            "&rdp->cblist",
            "&rcl"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_insert_done_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "263-279",
          "snippet": "void rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rclp->head)\n\t\treturn; /* No callbacks to move. */\n\t*rclp->tail = rsclp->head;\n\trsclp->head = rclp->head;\n\tfor (i = RCU_DONE_TAIL; i < RCU_CBLIST_NSEGS; i++)\n\t\tif (&rsclp->head == rsclp->tails[i])\n\t\t\trsclp->tails[i] = rclp->tail;\n\t\telse\n\t\t\tbreak;\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rclp->head)\n\t\treturn; /* No callbacks to move. */\n\t*rclp->tail = rsclp->head;\n\trsclp->head = rclp->head;\n\tfor (i = RCU_DONE_TAIL; i < RCU_CBLIST_NSEGS; i++)\n\t\tif (&rsclp->head == rsclp->tails[i])\n\t\t\trsclp->tails[i] = rclp->tail;\n\t\telse\n\t\t\tbreak;\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_batch_end",
          "args": [
            "rcu_state.name",
            "count",
            "!!rcl.head",
            "need_resched()",
            "is_idle_task(current)",
            "rcu_is_callbacks_kthread()"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_callbacks_kthread",
          "args": [],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_callbacks_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1495-1498",
          "snippet": "static bool rcu_is_callbacks_kthread(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_is_callbacks_kthread(void)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cblist_dequeued_lazy",
          "args": [
            "&rcl"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_dequeued_lazy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "29-32",
          "snippet": "static inline void rcu_cblist_dequeued_lazy(struct rcu_cblist *rclp)\n{\n\trclp->len_lazy--;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_cblist_init(struct rcu_cblist *rclp);",
            "struct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_count(struct rcu_segcblist *rsclp,\n\t\t\t\t struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);",
            "void rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_cblist_init(struct rcu_cblist *rclp);\nstruct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_count(struct rcu_segcblist *rsclp,\n\t\t\t\t struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\nvoid rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp);\n\nstatic inline void rcu_cblist_dequeued_lazy(struct rcu_cblist *rclp)\n{\n\trclp->len_lazy--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rcu_reclaim",
          "args": [
            "rcu_state.name",
            "rhp"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "225-244",
          "snippet": "static inline bool __rcu_reclaim(const char *rn, struct rcu_head *head)\n{\n\trcu_callback_t f;\n\tunsigned long offset = (unsigned long)head->func;\n\n\trcu_lock_acquire(&rcu_callback_map);\n\tif (__is_kfree_rcu_offset(offset)) {\n\t\tRCU_TRACE(trace_rcu_invoke_kfree_callback(rn, head, offset);)\n\t\tkfree((void *)head - offset);\n\t\trcu_lock_release(&rcu_callback_map);\n\t\treturn true;\n\t} else {\n\t\tRCU_TRACE(trace_rcu_invoke_callback(rn, head);)\n\t\tf = head->func;\n\t\tWRITE_ONCE(head->func, (rcu_callback_t)0L);\n\t\tf(head);\n\t\trcu_lock_release(&rcu_callback_map);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool __rcu_reclaim(const char *rn, struct rcu_head *head)\n{\n\trcu_callback_t f;\n\tunsigned long offset = (unsigned long)head->func;\n\n\trcu_lock_acquire(&rcu_callback_map);\n\tif (__is_kfree_rcu_offset(offset)) {\n\t\tRCU_TRACE(trace_rcu_invoke_kfree_callback(rn, head, offset);)\n\t\tkfree((void *)head - offset);\n\t\trcu_lock_release(&rcu_callback_map);\n\t\treturn true;\n\t} else {\n\t\tRCU_TRACE(trace_rcu_invoke_callback(rn, head);)\n\t\tf = head->func;\n\t\tWRITE_ONCE(head->func, (rcu_callback_t)0L);\n\t\tf(head);\n\t\trcu_lock_release(&rcu_callback_map);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "rhp"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "214-216",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_extract_done_cbs",
          "args": [
            "&rdp->cblist",
            "&rcl"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_extract_done_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "208-222",
          "snippet": "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rcu_segcblist_ready_cbs(rsclp))\n\t\treturn; /* Nothing to do. */\n\t*rclp->tail = rsclp->head;\n\trsclp->head = *rsclp->tails[RCU_DONE_TAIL];\n\t*rsclp->tails[RCU_DONE_TAIL] = NULL;\n\trclp->tail = rsclp->tails[RCU_DONE_TAIL];\n\tfor (i = RCU_CBLIST_NSEGS - 1; i >= RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] == rsclp->tails[RCU_DONE_TAIL])\n\t\t\trsclp->tails[i] = &rsclp->head;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rcu_segcblist_ready_cbs(rsclp))\n\t\treturn; /* Nothing to do. */\n\t*rclp->tail = rsclp->head;\n\trsclp->head = *rsclp->tails[RCU_DONE_TAIL];\n\t*rsclp->tails[RCU_DONE_TAIL] = NULL;\n\trclp->tail = rsclp->tails[RCU_DONE_TAIL];\n\tfor (i = RCU_CBLIST_NSEGS - 1; i >= RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] == rsclp->tails[RCU_DONE_TAIL])\n\t\t\trsclp->tails[i] = &rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_batch_start",
          "args": [
            "rcu_state.name",
            "rcu_segcblist_n_lazy_cbs(&rdp->cblist)",
            "rcu_segcblist_n_cbs(&rdp->cblist)",
            "bl"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_lazy_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_lazy_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "62-65",
          "snippet": "static inline long rcu_segcblist_n_lazy_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->len_lazy;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_lazy_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rsclp->len_lazy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu_is_offline(smp_processor_id())"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "smp_processor_id()"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_batch_end",
          "args": [
            "rcu_state.name",
            "0",
            "!rcu_segcblist_empty(&rdp->cblist)",
            "need_resched()",
            "is_idle_task(current)",
            "rcu_is_callbacks_kthread()"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_batch_start",
          "args": [
            "rcu_state.name",
            "rcu_segcblist_n_lazy_cbs(&rdp->cblist)",
            "rcu_segcblist_n_cbs(&rdp->cblist)",
            "0"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_CBLIST_INITIALIZER",
          "args": [
            "rcl"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_core(void);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic long blimit = DEFAULT_RCU_BLIMIT;\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\nstatic long qlowmark = DEFAULT_RCU_QLOMARK;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_do_batch(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\tlocal_irq_save(flags);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tbl = rdp->blimit;\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_lazy_cbs(&rdp->cblist),\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tlocal_irq_restore(flags);\n\n\t/* Invoke callbacks. */\n\trhp = rcu_cblist_dequeue(&rcl);\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\tdebug_rcu_head_unqueue(rhp);\n\t\tif (__rcu_reclaim(rcu_state.name, rhp))\n\t\t\trcu_cblist_dequeued_lazy(&rcl);\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t * Note: The rcl structure counts down from zero.\n\t\t */\n\t\tif (-rcl.len >= bl &&\n\t\t    (need_resched() ||\n\t\t     (!is_idle_task(current) && !rcu_is_callbacks_kthread())))\n\t\t\tbreak;\n\t}\n\n\tlocal_irq_save(flags);\n\tcount = -rcl.len;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\tsmp_mb(); /* List handling before counting for rcu_barrier(). */\n\trcu_segcblist_insert_count(&rdp->cblist, &rcl);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit == LONG_MAX && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tWARN_ON_ONCE(rcu_segcblist_empty(&rdp->cblist) != (count == 0));\n\n\tlocal_irq_restore(flags);\n\n\t/* Re-invoke RCU core processing if there are callbacks remaining. */\n\tif (rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\tinvoke_rcu_core();\n}"
  },
  {
    "function_name": "rcutree_dead_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2381-2394",
    "snippet": "int rcutree_dead_cpu(unsigned int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn 0;\n\n\t/* Adjust any no-longer-needed kthreads. */\n\trcu_boost_kthread_setaffinity(rnp, -1);\n\t/* Do any needed no-CB deferred wakeups from this CPU. */\n\tdo_nocb_deferred_wakeup(per_cpu_ptr(&rcu_data, cpu));\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup",
          "args": [
            "per_cpu_ptr(&rcu_data, cpu)"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2633-2635",
          "snippet": "static void do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_boost_kthread_setaffinity",
          "args": [
            "rnp",
            "-1"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_boost_kthread_setaffinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1504-1506",
          "snippet": "static void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HOTPLUG_CPU"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_dead_cpu(unsigned int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn 0;\n\n\t/* Adjust any no-longer-needed kthreads. */\n\trcu_boost_kthread_setaffinity(rnp, -1);\n\t/* Do any needed no-CB deferred wakeups from this CPU. */\n\tdo_nocb_deferred_wakeup(per_cpu_ptr(&rcu_data, cpu));\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_cleanup_dead_rnp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2347-2373",
    "snippet": "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU) ||\n\t    WARN_ON_ONCE(rnp_leaf->qsmaskinit) ||\n\t    WARN_ON_ONCE(rcu_preempt_has_tasks(rnp_leaf)))\n\t\treturn;\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (!rnp)\n\t\t\tbreak;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\trnp->qsmaskinit &= ~mask;\n\t\t/* Between grace periods, so better already be zero! */\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tif (rnp->qsmaskinit) {\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\t\t/* irqs remain disabled. */\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf);",
      "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_preempt_has_tasks(rnp_leaf)"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_has_tasks",
          "args": [
            "rnp_leaf"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_has_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1025-1028",
          "snippet": "static bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp_leaf->qsmaskinit"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HOTPLUG_CPU"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp_leaf"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf);\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);\n\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU) ||\n\t    WARN_ON_ONCE(rnp_leaf->qsmaskinit) ||\n\t    WARN_ON_ONCE(rcu_preempt_has_tasks(rnp_leaf)))\n\t\treturn;\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (!rnp)\n\t\t\tbreak;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\trnp->qsmaskinit &= ~mask;\n\t\t/* Between grace periods, so better already be zero! */\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tif (rnp->qsmaskinit) {\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\t\t/* irqs remain disabled. */\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n}"
  },
  {
    "function_name": "rcutree_dying_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2315-2328",
    "snippet": "int rcutree_dying_cpu(unsigned int cpu)\n{\n\tRCU_TRACE(bool blkd;)\n\tRCU_TRACE(struct rcu_data *rdp = this_cpu_ptr(&rcu_data);)\n\tRCU_TRACE(struct rcu_node *rnp = rdp->mynode;)\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn 0;\n\n\tRCU_TRACE(blkd = !!(rnp->qsmask & rdp->grpmask);)\n\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq,\n\t\t\t       blkd ? TPS(\"cpuofl\") : TPS(\"cpuofl-bgp\"));\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rnp->gp_seq",
            "blkd ? TPS(\"cpuofl\") : TPS(\"cpuofl-bgp\")"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpuofl-bgp\""
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpuofl\""
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_TRACE",
          "args": [
            "blkd = !!(rnp->qsmask & rdp->grpmask);"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HOTPLUG_CPU"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcutree_dying_cpu(unsigned int cpu)\n{\n\tRCU_TRACE(bool blkd;)\n\tRCU_TRACE(struct rcu_data *rdp = this_cpu_ptr(&rcu_data);)\n\tRCU_TRACE(struct rcu_node *rnp = rdp->mynode;)\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn 0;\n\n\tRCU_TRACE(blkd = !!(rnp->qsmask & rdp->grpmask);)\n\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq,\n\t\t\t       blkd ? TPS(\"cpuofl\") : TPS(\"cpuofl-bgp\"));\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_check_quiescent_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2284-2309",
    "snippet": "static void\nrcu_check_quiescent_state(struct rcu_data *rdp)\n{\n\t/* Check for grace-period ends and beginnings. */\n\tnote_gp_changes(rdp);\n\n\t/*\n\t * Does this CPU still need to do its part for current grace period?\n\t * If no, return and let the other CPUs do their part as well.\n\t */\n\tif (!rdp->core_needs_qs)\n\t\treturn;\n\n\t/*\n\t * Was there a quiescent state since the beginning of the grace\n\t * period? If no, then exit and wait for the next call.\n\t */\n\tif (rdp->cpu_no_qs.b.norm)\n\t\treturn;\n\n\t/*\n\t * Tell RCU we are done (but rcu_report_qs_rdp() will be the\n\t * judge of that).\n\t */\n\trcu_report_qs_rdp(rdp->cpu, rdp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_qs_rdp",
          "args": [
            "rdp->cpu",
            "rdp"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rdp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2236-2276",
          "snippet": "static void\nrcu_report_qs_rdp(int cpu, struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (rdp->cpu_no_qs.b.norm || rdp->gp_seq != rnp->gp_seq ||\n\t    rdp->gpwrap) {\n\n\t\t/*\n\t\t * The grace period in which this quiescent state was\n\t\t * recorded has ended, so don't report it upwards.\n\t\t * We will instead need a new quiescent state that lies\n\t\t * within the current grace period.\n\t\t */\n\t\trdp->cpu_no_qs.b.norm = true;\t/* need qs for new gp. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tmask = rdp->grpmask;\n\tif ((rnp->qsmask & mask) == 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t} else {\n\t\trdp->core_needs_qs = false;\n\n\t\t/*\n\t\t * This GP can't end until cpu checks in, so all of our\n\t\t * callbacks can be processed during the next GP.\n\t\t */\n\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t/* ^^^ Released rnp->lock */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\nrcu_report_qs_rdp(int cpu, struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (rdp->cpu_no_qs.b.norm || rdp->gp_seq != rnp->gp_seq ||\n\t    rdp->gpwrap) {\n\n\t\t/*\n\t\t * The grace period in which this quiescent state was\n\t\t * recorded has ended, so don't report it upwards.\n\t\t * We will instead need a new quiescent state that lies\n\t\t * within the current grace period.\n\t\t */\n\t\trdp->cpu_no_qs.b.norm = true;\t/* need qs for new gp. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tmask = rdp->grpmask;\n\tif ((rnp->qsmask & mask) == 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t} else {\n\t\trdp->core_needs_qs = false;\n\n\t\t/*\n\t\t * This GP can't end until cpu checks in, so all of our\n\t\t * callbacks can be processed during the next GP.\n\t\t */\n\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t/* ^^^ Released rnp->lock */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "note_gp_changes",
          "args": [
            "rdp"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "note_gp_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1707-1725",
          "snippet": "static void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\nrcu_check_quiescent_state(struct rcu_data *rdp)\n{\n\t/* Check for grace-period ends and beginnings. */\n\tnote_gp_changes(rdp);\n\n\t/*\n\t * Does this CPU still need to do its part for current grace period?\n\t * If no, return and let the other CPUs do their part as well.\n\t */\n\tif (!rdp->core_needs_qs)\n\t\treturn;\n\n\t/*\n\t * Was there a quiescent state since the beginning of the grace\n\t * period? If no, then exit and wait for the next call.\n\t */\n\tif (rdp->cpu_no_qs.b.norm)\n\t\treturn;\n\n\t/*\n\t * Tell RCU we are done (but rcu_report_qs_rdp() will be the\n\t * judge of that).\n\t */\n\trcu_report_qs_rdp(rdp->cpu, rdp);\n}"
  },
  {
    "function_name": "rcu_report_qs_rdp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2236-2276",
    "snippet": "static void\nrcu_report_qs_rdp(int cpu, struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (rdp->cpu_no_qs.b.norm || rdp->gp_seq != rnp->gp_seq ||\n\t    rdp->gpwrap) {\n\n\t\t/*\n\t\t * The grace period in which this quiescent state was\n\t\t * recorded has ended, so don't report it upwards.\n\t\t * We will instead need a new quiescent state that lies\n\t\t * within the current grace period.\n\t\t */\n\t\trdp->cpu_no_qs.b.norm = true;\t/* need qs for new gp. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tmask = rdp->grpmask;\n\tif ((rnp->qsmask & mask) == 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t} else {\n\t\trdp->core_needs_qs = false;\n\n\t\t/*\n\t\t * This GP can't end until cpu checks in, so all of our\n\t\t * callbacks can be processed during the next GP.\n\t\t */\n\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t/* ^^^ Released rnp->lock */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1551-1558",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp",
            "rnp->gp_seq",
            "flags"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2133-2188",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1612-1630",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void\nrcu_report_qs_rdp(int cpu, struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (rdp->cpu_no_qs.b.norm || rdp->gp_seq != rnp->gp_seq ||\n\t    rdp->gpwrap) {\n\n\t\t/*\n\t\t * The grace period in which this quiescent state was\n\t\t * recorded has ended, so don't report it upwards.\n\t\t * We will instead need a new quiescent state that lies\n\t\t * within the current grace period.\n\t\t */\n\t\trdp->cpu_no_qs.b.norm = true;\t/* need qs for new gp. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tmask = rdp->grpmask;\n\tif ((rnp->qsmask & mask) == 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t} else {\n\t\trdp->core_needs_qs = false;\n\n\t\t/*\n\t\t * This GP can't end until cpu checks in, so all of our\n\t\t * callbacks can be processed during the next GP.\n\t\t */\n\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t/* ^^^ Released rnp->lock */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}"
  },
  {
    "function_name": "rcu_report_unblock_qs_rnp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2197-2230",
    "snippet": "static void __maybe_unused\nrcu_report_unblock_qs_rnp(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long gps;\n\tunsigned long mask;\n\tstruct rcu_node *rnp_p;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_PREEMPT)) ||\n\t    WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)) ||\n\t    rnp->qsmask != 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;  /* Still need more quiescent states! */\n\t}\n\n\trnp->completedqs = rnp->gp_seq;\n\trnp_p = rnp->parent;\n\tif (rnp_p == NULL) {\n\t\t/*\n\t\t * Only one rcu_node structure in the tree, so don't\n\t\t * try to report up to its nonexistent parent!\n\t\t */\n\t\trcu_report_qs_rsp(flags);\n\t\treturn;\n\t}\n\n\t/* Report up the rest of the hierarchy, tracking current ->gp_seq. */\n\tgps = rnp->gp_seq;\n\tmask = rnp->grpmask;\n\traw_spin_unlock_rcu_node(rnp);\t/* irqs remain disabled. */\n\traw_spin_lock_rcu_node(rnp_p);\t/* irqs already disabled. */\n\trcu_report_qs_rnp(mask, rnp_p, gps, flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void __maybe_unused"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp_p",
            "gps",
            "flags"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2133-2188",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp_p"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rsp",
          "args": [
            "flags"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2108-2117",
          "snippet": "static void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_preempt_blocked_readers_cgp(rnp)"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!IS_ENABLED(CONFIG_PREEMPT)"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void __maybe_unused;\n\nstatic void __maybe_unused\nrcu_report_unblock_qs_rnp(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long gps;\n\tunsigned long mask;\n\tstruct rcu_node *rnp_p;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_PREEMPT)) ||\n\t    WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)) ||\n\t    rnp->qsmask != 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;  /* Still need more quiescent states! */\n\t}\n\n\trnp->completedqs = rnp->gp_seq;\n\trnp_p = rnp->parent;\n\tif (rnp_p == NULL) {\n\t\t/*\n\t\t * Only one rcu_node structure in the tree, so don't\n\t\t * try to report up to its nonexistent parent!\n\t\t */\n\t\trcu_report_qs_rsp(flags);\n\t\treturn;\n\t}\n\n\t/* Report up the rest of the hierarchy, tracking current ->gp_seq. */\n\tgps = rnp->gp_seq;\n\tmask = rnp->grpmask;\n\traw_spin_unlock_rcu_node(rnp);\t/* irqs remain disabled. */\n\traw_spin_lock_rcu_node(rnp_p);\t/* irqs already disabled. */\n\trcu_report_qs_rnp(mask, rnp_p, gps, flags);\n}"
  },
  {
    "function_name": "rcu_report_qs_rnp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2133-2188",
    "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_report_qs_rsp",
          "args": [
            "flags"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2108-2117",
          "snippet": "static void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_quiescent_state_report",
          "args": [
            "rcu_state.name",
            "rnp->gp_seq",
            "mask",
            "rnp->qsmask",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "!!rnp->gp_tasks"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp)"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "oldmask"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rnp->lock"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
  },
  {
    "function_name": "rcu_report_qs_rsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2108-2117",
    "snippet": "static void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1551-1558",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rcu_get_root()",
            "flags"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_gp_in_progress()"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "205-208",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rcu_get_root()"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "rcu_get_root()->lock"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}"
  },
  {
    "function_name": "rcu_gp_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "2063-2097",
    "snippet": "static int __noreturn rcu_gp_kthread(void *unused)\n{\n\trcu_bind_gp_kthread();\n\tfor (;;) {\n\n\t\t/* Handle grace-period start. */\n\t\tfor (;;) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"reqwait\"));\n\t\t\trcu_state.gp_state = RCU_GP_WAIT_GPS;\n\t\t\tswait_event_idle_exclusive(rcu_state.gp_wq,\n\t\t\t\t\t READ_ONCE(rcu_state.gp_flags) &\n\t\t\t\t\t RCU_GP_FLAG_INIT);\n\t\t\trcu_state.gp_state = RCU_GP_DONE_GPS;\n\t\t\t/* Locking provides needed memory barrier. */\n\t\t\tif (rcu_gp_init())\n\t\t\t\tbreak;\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"reqwaitsig\"));\n\t\t}\n\n\t\t/* Handle quiescent-state forcing. */\n\t\trcu_gp_fqs_loop();\n\n\t\t/* Handle grace-period end. */\n\t\trcu_state.gp_state = RCU_GP_CLEANUP;\n\t\trcu_gp_cleanup();\n\t\trcu_state.gp_state = RCU_GP_CLEANED;\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_cleanup",
          "args": [],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1978-2058",
          "snippet": "static void rcu_gp_cleanup(void)\n{\n\tunsigned long gp_duration;\n\tbool needgp = false;\n\tunsigned long new_gp_seq;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tstruct swait_queue_head *sq;\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tgp_duration = jiffies - rcu_state.gp_start;\n\tif (gp_duration > rcu_state.gp_max)\n\t\trcu_state.gp_max = gp_duration;\n\n\t/*\n\t * We know the grace period is complete, but to everyone else\n\t * it appears to still be ongoing.  But it is also the case\n\t * that to everyone else it looks like there is nothing that\n\t * they can do to advance the grace period.  It is therefore\n\t * safe for us to drop the lock in order to mark the grace\n\t * period as completed in all of the rcu_node structures.\n\t */\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Propagate new ->gp_seq value to rcu_node structures so that\n\t * other CPUs don't have to wait until the start of the next grace\n\t * period to process their callbacks.  This also avoids some nasty\n\t * RCU grace-period initialization races by forcing the end of\n\t * the current grace period to be completely recorded in all of\n\t * the rcu_node structures before the beginning of the next grace\n\t * period is recorded in any of the rcu_node structures.\n\t */\n\tnew_gp_seq = rcu_state.gp_seq;\n\trcu_seq_end(&new_gp_seq);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\t\tdump_blkd_tasks(rnp, 10);\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tWRITE_ONCE(rnp->gp_seq, new_gp_seq);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\tif (rnp == rdp->mynode)\n\t\t\tneedgp = __note_gp_changes(rnp, rdp) || needgp;\n\t\t/* smp_mb() provided by prior unlock-lock pair. */\n\t\tneedgp = rcu_future_gp_cleanup(rnp) || needgp;\n\t\tsq = rcu_nocb_gp_get(rnp);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\trcu_nocb_gp_cleanup(sq);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\trcu_gp_slow(gp_cleanup_delay);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irq_rcu_node(rnp); /* GP before ->gp_seq update. */\n\n\t/* Declare grace period done. */\n\trcu_seq_end(&rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"end\"));\n\trcu_state.gp_state = RCU_GP_IDLE;\n\t/* Check for GP requests since above loop. */\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!needgp && ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq_needed,\n\t\t\t\t  TPS(\"CleanupMore\"));\n\t\tneedgp = true;\n\t}\n\t/* Advance CBs to reduce false positives below. */\n\tif (!rcu_accelerate_cbs(rnp, rdp) && needgp) {\n\t\tWRITE_ONCE(rcu_state.gp_flags, RCU_GP_FLAG_INIT);\n\t\trcu_state.gp_req_activity = jiffies;\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t       TPS(\"newreq\"));\n\t} else {\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   rcu_state.gp_flags & RCU_GP_FLAG_INIT);\n\t}\n\traw_spin_unlock_irq_rcu_node(rnp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static int gp_cleanup_delay;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic int gp_cleanup_delay;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gp_cleanup(void)\n{\n\tunsigned long gp_duration;\n\tbool needgp = false;\n\tunsigned long new_gp_seq;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tstruct swait_queue_head *sq;\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tgp_duration = jiffies - rcu_state.gp_start;\n\tif (gp_duration > rcu_state.gp_max)\n\t\trcu_state.gp_max = gp_duration;\n\n\t/*\n\t * We know the grace period is complete, but to everyone else\n\t * it appears to still be ongoing.  But it is also the case\n\t * that to everyone else it looks like there is nothing that\n\t * they can do to advance the grace period.  It is therefore\n\t * safe for us to drop the lock in order to mark the grace\n\t * period as completed in all of the rcu_node structures.\n\t */\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Propagate new ->gp_seq value to rcu_node structures so that\n\t * other CPUs don't have to wait until the start of the next grace\n\t * period to process their callbacks.  This also avoids some nasty\n\t * RCU grace-period initialization races by forcing the end of\n\t * the current grace period to be completely recorded in all of\n\t * the rcu_node structures before the beginning of the next grace\n\t * period is recorded in any of the rcu_node structures.\n\t */\n\tnew_gp_seq = rcu_state.gp_seq;\n\trcu_seq_end(&new_gp_seq);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\t\tdump_blkd_tasks(rnp, 10);\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tWRITE_ONCE(rnp->gp_seq, new_gp_seq);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\tif (rnp == rdp->mynode)\n\t\t\tneedgp = __note_gp_changes(rnp, rdp) || needgp;\n\t\t/* smp_mb() provided by prior unlock-lock pair. */\n\t\tneedgp = rcu_future_gp_cleanup(rnp) || needgp;\n\t\tsq = rcu_nocb_gp_get(rnp);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\trcu_nocb_gp_cleanup(sq);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\trcu_gp_slow(gp_cleanup_delay);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irq_rcu_node(rnp); /* GP before ->gp_seq update. */\n\n\t/* Declare grace period done. */\n\trcu_seq_end(&rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"end\"));\n\trcu_state.gp_state = RCU_GP_IDLE;\n\t/* Check for GP requests since above loop. */\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!needgp && ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq_needed,\n\t\t\t\t  TPS(\"CleanupMore\"));\n\t\tneedgp = true;\n\t}\n\t/* Advance CBs to reduce false positives below. */\n\tif (!rcu_accelerate_cbs(rnp, rdp) && needgp) {\n\t\tWRITE_ONCE(rcu_state.gp_flags, RCU_GP_FLAG_INIT);\n\t\trcu_state.gp_req_activity = jiffies;\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t       TPS(\"newreq\"));\n\t} else {\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   rcu_state.gp_flags & RCU_GP_FLAG_INIT);\n\t}\n\traw_spin_unlock_irq_rcu_node(rnp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_fqs_loop",
          "args": [],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_fqs_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1913-1973",
          "snippet": "static void rcu_gp_fqs_loop(void)\n{\n\tbool first_gp_fqs;\n\tint gf;\n\tunsigned long j;\n\tint ret;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tfirst_gp_fqs = true;\n\tj = READ_ONCE(jiffies_till_first_fqs);\n\tret = 0;\n\tfor (;;) {\n\t\tif (!ret) {\n\t\t\trcu_state.jiffies_force_qs = jiffies + j;\n\t\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads,\n\t\t\t\t   jiffies + 3 * j);\n\t\t}\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t       TPS(\"fqswait\"));\n\t\trcu_state.gp_state = RCU_GP_WAIT_FQS;\n\t\tret = swait_event_idle_timeout_exclusive(\n\t\t\t\trcu_state.gp_wq, rcu_gp_fqs_check_wake(&gf), j);\n\t\trcu_state.gp_state = RCU_GP_DOING_FQS;\n\t\t/* Locking provides needed memory barriers. */\n\t\t/* If grace period done, leave loop. */\n\t\tif (!READ_ONCE(rnp->qsmask) &&\n\t\t    !rcu_preempt_blocked_readers_cgp(rnp))\n\t\t\tbreak;\n\t\t/* If time for quiescent-state forcing, do it. */\n\t\tif (ULONG_CMP_GE(jiffies, rcu_state.jiffies_force_qs) ||\n\t\t    (gf & RCU_GP_FLAG_FQS)) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqsstart\"));\n\t\t\trcu_gp_fqs(first_gp_fqs);\n\t\t\tfirst_gp_fqs = false;\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqsend\"));\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tret = 0; /* Force full wait till next FQS. */\n\t\t\tj = READ_ONCE(jiffies_till_next_fqs);\n\t\t} else {\n\t\t\t/* Deal with stray signal. */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqswaitsig\"));\n\t\t\tret = 1; /* Keep old FQS timing. */\n\t\t\tj = jiffies;\n\t\t\tif (time_after(jiffies, rcu_state.jiffies_force_qs))\n\t\t\t\tj = 1;\n\t\t\telse\n\t\t\t\tj = rcu_state.jiffies_force_qs - j;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static ulong jiffies_till_first_fqs = ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic ulong jiffies_till_first_fqs = ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\n\nstatic void rcu_gp_fqs_loop(void)\n{\n\tbool first_gp_fqs;\n\tint gf;\n\tunsigned long j;\n\tint ret;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tfirst_gp_fqs = true;\n\tj = READ_ONCE(jiffies_till_first_fqs);\n\tret = 0;\n\tfor (;;) {\n\t\tif (!ret) {\n\t\t\trcu_state.jiffies_force_qs = jiffies + j;\n\t\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads,\n\t\t\t\t   jiffies + 3 * j);\n\t\t}\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t       TPS(\"fqswait\"));\n\t\trcu_state.gp_state = RCU_GP_WAIT_FQS;\n\t\tret = swait_event_idle_timeout_exclusive(\n\t\t\t\trcu_state.gp_wq, rcu_gp_fqs_check_wake(&gf), j);\n\t\trcu_state.gp_state = RCU_GP_DOING_FQS;\n\t\t/* Locking provides needed memory barriers. */\n\t\t/* If grace period done, leave loop. */\n\t\tif (!READ_ONCE(rnp->qsmask) &&\n\t\t    !rcu_preempt_blocked_readers_cgp(rnp))\n\t\t\tbreak;\n\t\t/* If time for quiescent-state forcing, do it. */\n\t\tif (ULONG_CMP_GE(jiffies, rcu_state.jiffies_force_qs) ||\n\t\t    (gf & RCU_GP_FLAG_FQS)) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqsstart\"));\n\t\t\trcu_gp_fqs(first_gp_fqs);\n\t\t\tfirst_gp_fqs = false;\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqsend\"));\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tret = 0; /* Force full wait till next FQS. */\n\t\t\tj = READ_ONCE(jiffies_till_next_fqs);\n\t\t} else {\n\t\t\t/* Deal with stray signal. */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqswaitsig\"));\n\t\t\tret = 1; /* Keep old FQS timing. */\n\t\t\tj = jiffies;\n\t\t\tif (time_after(jiffies, rcu_state.jiffies_force_qs))\n\t\t\t\tj = 1;\n\t\t\telse\n\t\t\t\tj = rcu_state.jiffies_force_qs - j;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "READ_ONCE(rcu_state.gp_seq)",
            "TPS(\"reqwaitsig\")"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"reqwaitsig\""
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_init",
          "args": [],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1738-1863",
          "snippet": "static bool rcu_gp_init(void)\n{\n\tunsigned long flags;\n\tunsigned long oldmask;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tif (!READ_ONCE(rcu_state.gp_flags)) {\n\t\t/* Spurious wakeup, tell caller to go back to sleep.  */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags, 0); /* Clear all flags: New GP. */\n\n\tif (WARN_ON_ONCE(rcu_gp_in_progress())) {\n\t\t/*\n\t\t * Grace period already in progress, don't start another.\n\t\t * Not supposed to be able to happen.\n\t\t */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\n\t/* Advance to a new grace period and initialize state. */\n\trecord_gp_stall_check_time();\n\t/* Record GP times before starting GP, hence rcu_seq_start(). */\n\trcu_seq_start(&rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"start\"));\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Apply per-leaf buffered online and offline operations to the\n\t * rcu_node tree.  Note that this new grace period need not wait\n\t * for subsequent online CPUs, and that quiescent-state forcing\n\t * will handle subsequent offline CPUs.\n\t */\n\trcu_state.gp_state = RCU_GP_ONOFF;\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock(&rcu_state.ofl_lock);\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (rnp->qsmaskinit == rnp->qsmaskinitnext &&\n\t\t    !rnp->wait_blkd_tasks) {\n\t\t\t/* Nothing to do on this leaf rcu_node structure. */\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record old state, apply changes to ->qsmaskinit field. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit = rnp->qsmaskinitnext;\n\n\t\t/* If zero-ness of ->qsmaskinit changed, propagate up tree. */\n\t\tif (!oldmask != !rnp->qsmaskinit) {\n\t\t\tif (!oldmask) { /* First online CPU for rcu_node. */\n\t\t\t\tif (!rnp->wait_blkd_tasks) /* Ever offline? */\n\t\t\t\t\trcu_init_new_rnp(rnp);\n\t\t\t} else if (rcu_preempt_has_tasks(rnp)) {\n\t\t\t\trnp->wait_blkd_tasks = true; /* blocked tasks */\n\t\t\t} else { /* Last offline CPU and can propagate. */\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If all waited-on tasks from prior grace period are\n\t\t * done, and if all this rcu_node structure's CPUs are\n\t\t * still offline, propagate up the rcu_node tree and\n\t\t * clear ->wait_blkd_tasks.  Otherwise, if one of this\n\t\t * rcu_node structure's CPUs has since come back online,\n\t\t * simply clear ->wait_blkd_tasks.\n\t\t */\n\t\tif (rnp->wait_blkd_tasks &&\n\t\t    (!rcu_preempt_has_tasks(rnp) || rnp->qsmaskinit)) {\n\t\t\trnp->wait_blkd_tasks = false;\n\t\t\tif (!rnp->qsmaskinit)\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t}\n\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t}\n\trcu_gp_slow(gp_preinit_delay); /* Races with CPU hotplug. */\n\n\t/*\n\t * Set the quiescent-state-needed bits in all the rcu_node\n\t * structures for all currently online CPUs in breadth-first\n\t * order, starting from the root rcu_node structure, relying on the\n\t * layout of the tree within the rcu_state.node[] array.  Note that\n\t * other CPUs will access only the leaves of the hierarchy, thus\n\t * seeing that no grace period is in progress, at least until the\n\t * corresponding leaf node has been initialized.\n\t *\n\t * The grace period cannot complete until the initialization\n\t * process finishes, because this kthread handles both.\n\t */\n\trcu_state.gp_state = RCU_GP_INIT;\n\trcu_for_each_node_breadth_first(rnp) {\n\t\trcu_gp_slow(gp_init_delay);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_preempt_check_blocked_tasks(rnp);\n\t\trnp->qsmask = rnp->qsmaskinit;\n\t\tWRITE_ONCE(rnp->gp_seq, rcu_state.gp_seq);\n\t\tif (rnp == rdp->mynode)\n\t\t\t(void)__note_gp_changes(rnp, rdp);\n\t\trcu_preempt_boost_start_gp(rnp);\n\t\ttrace_rcu_grace_period_init(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t    rnp->level, rnp->grplo,\n\t\t\t\t\t    rnp->grphi, rnp->qsmask);\n\t\t/* Quiescent states for tasks on any now-offline CPUs. */\n\t\tmask = rnp->qsmask & ~rnp->qsmaskinitnext;\n\t\trnp->rcu_gp_init_mask = mask;\n\t\tif ((mask || rnp->wait_blkd_tasks) && rcu_is_leaf_node(rnp))\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\telse\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static int gp_preinit_delay;",
            "static int gp_init_delay;",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic int gp_preinit_delay;\nstatic int gp_init_delay;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_gp_init(void)\n{\n\tunsigned long flags;\n\tunsigned long oldmask;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tif (!READ_ONCE(rcu_state.gp_flags)) {\n\t\t/* Spurious wakeup, tell caller to go back to sleep.  */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags, 0); /* Clear all flags: New GP. */\n\n\tif (WARN_ON_ONCE(rcu_gp_in_progress())) {\n\t\t/*\n\t\t * Grace period already in progress, don't start another.\n\t\t * Not supposed to be able to happen.\n\t\t */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\n\t/* Advance to a new grace period and initialize state. */\n\trecord_gp_stall_check_time();\n\t/* Record GP times before starting GP, hence rcu_seq_start(). */\n\trcu_seq_start(&rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"start\"));\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Apply per-leaf buffered online and offline operations to the\n\t * rcu_node tree.  Note that this new grace period need not wait\n\t * for subsequent online CPUs, and that quiescent-state forcing\n\t * will handle subsequent offline CPUs.\n\t */\n\trcu_state.gp_state = RCU_GP_ONOFF;\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock(&rcu_state.ofl_lock);\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (rnp->qsmaskinit == rnp->qsmaskinitnext &&\n\t\t    !rnp->wait_blkd_tasks) {\n\t\t\t/* Nothing to do on this leaf rcu_node structure. */\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record old state, apply changes to ->qsmaskinit field. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit = rnp->qsmaskinitnext;\n\n\t\t/* If zero-ness of ->qsmaskinit changed, propagate up tree. */\n\t\tif (!oldmask != !rnp->qsmaskinit) {\n\t\t\tif (!oldmask) { /* First online CPU for rcu_node. */\n\t\t\t\tif (!rnp->wait_blkd_tasks) /* Ever offline? */\n\t\t\t\t\trcu_init_new_rnp(rnp);\n\t\t\t} else if (rcu_preempt_has_tasks(rnp)) {\n\t\t\t\trnp->wait_blkd_tasks = true; /* blocked tasks */\n\t\t\t} else { /* Last offline CPU and can propagate. */\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If all waited-on tasks from prior grace period are\n\t\t * done, and if all this rcu_node structure's CPUs are\n\t\t * still offline, propagate up the rcu_node tree and\n\t\t * clear ->wait_blkd_tasks.  Otherwise, if one of this\n\t\t * rcu_node structure's CPUs has since come back online,\n\t\t * simply clear ->wait_blkd_tasks.\n\t\t */\n\t\tif (rnp->wait_blkd_tasks &&\n\t\t    (!rcu_preempt_has_tasks(rnp) || rnp->qsmaskinit)) {\n\t\t\trnp->wait_blkd_tasks = false;\n\t\t\tif (!rnp->qsmaskinit)\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t}\n\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t}\n\trcu_gp_slow(gp_preinit_delay); /* Races with CPU hotplug. */\n\n\t/*\n\t * Set the quiescent-state-needed bits in all the rcu_node\n\t * structures for all currently online CPUs in breadth-first\n\t * order, starting from the root rcu_node structure, relying on the\n\t * layout of the tree within the rcu_state.node[] array.  Note that\n\t * other CPUs will access only the leaves of the hierarchy, thus\n\t * seeing that no grace period is in progress, at least until the\n\t * corresponding leaf node has been initialized.\n\t *\n\t * The grace period cannot complete until the initialization\n\t * process finishes, because this kthread handles both.\n\t */\n\trcu_state.gp_state = RCU_GP_INIT;\n\trcu_for_each_node_breadth_first(rnp) {\n\t\trcu_gp_slow(gp_init_delay);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_preempt_check_blocked_tasks(rnp);\n\t\trnp->qsmask = rnp->qsmaskinit;\n\t\tWRITE_ONCE(rnp->gp_seq, rcu_state.gp_seq);\n\t\tif (rnp == rdp->mynode)\n\t\t\t(void)__note_gp_changes(rnp, rdp);\n\t\trcu_preempt_boost_start_gp(rnp);\n\t\ttrace_rcu_grace_period_init(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t    rnp->level, rnp->grplo,\n\t\t\t\t\t    rnp->grphi, rnp->qsmask);\n\t\t/* Quiescent states for tasks on any now-offline CPUs. */\n\t\tmask = rnp->qsmask & ~rnp->qsmaskinitnext;\n\t\trnp->rcu_gp_init_mask = mask;\n\t\tif ((mask || rnp->wait_blkd_tasks) && rcu_is_leaf_node(rnp))\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\telse\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swait_event_idle_exclusive",
          "args": [
            "rcu_state.gp_wq",
            "READ_ONCE(rcu_state.gp_flags) &\n\t\t\t\t\t RCU_GP_FLAG_INIT"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "READ_ONCE(rcu_state.gp_seq)",
            "TPS(\"reqwait\")"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"reqwait\""
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_bind_gp_kthread",
          "args": [],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_bind_gp_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2675-2680",
          "snippet": "static void rcu_bind_gp_kthread(void)\n{\n\tif (!tick_nohz_full_enabled())\n\t\treturn;\n\thousekeeping_affine(current, HK_FLAG_RCU);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_bind_gp_kthread(void)\n{\n\tif (!tick_nohz_full_enabled())\n\t\treturn;\n\thousekeeping_affine(current, HK_FLAG_RCU);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int __noreturn rcu_gp_kthread(void *unused)\n{\n\trcu_bind_gp_kthread();\n\tfor (;;) {\n\n\t\t/* Handle grace-period start. */\n\t\tfor (;;) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"reqwait\"));\n\t\t\trcu_state.gp_state = RCU_GP_WAIT_GPS;\n\t\t\tswait_event_idle_exclusive(rcu_state.gp_wq,\n\t\t\t\t\t READ_ONCE(rcu_state.gp_flags) &\n\t\t\t\t\t RCU_GP_FLAG_INIT);\n\t\t\trcu_state.gp_state = RCU_GP_DONE_GPS;\n\t\t\t/* Locking provides needed memory barrier. */\n\t\t\tif (rcu_gp_init())\n\t\t\t\tbreak;\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"reqwaitsig\"));\n\t\t}\n\n\t\t/* Handle quiescent-state forcing. */\n\t\trcu_gp_fqs_loop();\n\n\t\t/* Handle grace-period end. */\n\t\trcu_state.gp_state = RCU_GP_CLEANUP;\n\t\trcu_gp_cleanup();\n\t\trcu_state.gp_state = RCU_GP_CLEANED;\n\t}\n}"
  },
  {
    "function_name": "rcu_gp_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1978-2058",
    "snippet": "static void rcu_gp_cleanup(void)\n{\n\tunsigned long gp_duration;\n\tbool needgp = false;\n\tunsigned long new_gp_seq;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tstruct swait_queue_head *sq;\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tgp_duration = jiffies - rcu_state.gp_start;\n\tif (gp_duration > rcu_state.gp_max)\n\t\trcu_state.gp_max = gp_duration;\n\n\t/*\n\t * We know the grace period is complete, but to everyone else\n\t * it appears to still be ongoing.  But it is also the case\n\t * that to everyone else it looks like there is nothing that\n\t * they can do to advance the grace period.  It is therefore\n\t * safe for us to drop the lock in order to mark the grace\n\t * period as completed in all of the rcu_node structures.\n\t */\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Propagate new ->gp_seq value to rcu_node structures so that\n\t * other CPUs don't have to wait until the start of the next grace\n\t * period to process their callbacks.  This also avoids some nasty\n\t * RCU grace-period initialization races by forcing the end of\n\t * the current grace period to be completely recorded in all of\n\t * the rcu_node structures before the beginning of the next grace\n\t * period is recorded in any of the rcu_node structures.\n\t */\n\tnew_gp_seq = rcu_state.gp_seq;\n\trcu_seq_end(&new_gp_seq);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\t\tdump_blkd_tasks(rnp, 10);\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tWRITE_ONCE(rnp->gp_seq, new_gp_seq);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\tif (rnp == rdp->mynode)\n\t\t\tneedgp = __note_gp_changes(rnp, rdp) || needgp;\n\t\t/* smp_mb() provided by prior unlock-lock pair. */\n\t\tneedgp = rcu_future_gp_cleanup(rnp) || needgp;\n\t\tsq = rcu_nocb_gp_get(rnp);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\trcu_nocb_gp_cleanup(sq);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\trcu_gp_slow(gp_cleanup_delay);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irq_rcu_node(rnp); /* GP before ->gp_seq update. */\n\n\t/* Declare grace period done. */\n\trcu_seq_end(&rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"end\"));\n\trcu_state.gp_state = RCU_GP_IDLE;\n\t/* Check for GP requests since above loop. */\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!needgp && ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq_needed,\n\t\t\t\t  TPS(\"CleanupMore\"));\n\t\tneedgp = true;\n\t}\n\t/* Advance CBs to reduce false positives below. */\n\tif (!rcu_accelerate_cbs(rnp, rdp) && needgp) {\n\t\tWRITE_ONCE(rcu_state.gp_flags, RCU_GP_FLAG_INIT);\n\t\trcu_state.gp_req_activity = jiffies;\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t       TPS(\"newreq\"));\n\t} else {\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   rcu_state.gp_flags & RCU_GP_FLAG_INIT);\n\t}\n\traw_spin_unlock_irq_rcu_node(rnp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static int gp_cleanup_delay;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "rcu_state.gp_flags & RCU_GP_FLAG_INIT"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "READ_ONCE(rcu_state.gp_seq)",
            "TPS(\"newreq\")"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"newreq\""
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "RCU_GP_FLAG_INIT"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1612-1630",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_this_gp",
          "args": [
            "rnp",
            "rdp",
            "rnp->gp_seq_needed",
            "TPS(\"CleanupMore\")"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "trace_rcu_this_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1434-1439",
          "snippet": "static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, rnp->gp_seq, gp_seq_req,\n\t\t\t\t      rnp->level, rnp->grplo, rnp->grphi, s);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, rnp->gp_seq, gp_seq_req,\n\t\t\t\t      rnp->level, rnp->grplo, rnp->grphi, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CleanupMore\""
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rnp->gp_seq",
            "rnp->gp_seq_needed"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"end\")"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"end\""
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_end",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "87-92",
          "snippet": "static inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_slow",
          "args": [
            "gp_cleanup_delay"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1727-1733",
          "snippet": "static void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_uninterruptible(delay);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays. */"
          ],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "int rcu_num_nodes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays. */\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_num_nodes;\n\nstatic void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_uninterruptible(delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_gp_cleanup",
          "args": [
            "sq"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_gp_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2598-2600",
          "snippet": "static void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_nocb_gp_cleanup(struct swait_queue_head *sq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_nocb_gp_get",
          "args": [
            "rnp"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nocb_gp_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2602-2605",
          "snippet": "static struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic struct swait_queue_head *rcu_nocb_gp_get(struct rcu_node *rnp)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_future_gp_cleanup",
          "args": [
            "rnp"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_future_gp_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1532-1543",
          "snippet": "static bool rcu_future_gp_cleanup(struct rcu_node *rnp)\n{\n\tbool needmore;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tneedmore = ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed);\n\tif (!needmore)\n\t\trnp->gp_seq_needed = rnp->gp_seq; /* Avoid counter wrap. */\n\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq,\n\t\t\t  needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\"));\n\treturn needmore;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_future_gp_cleanup(struct rcu_node *rnp)\n{\n\tbool needmore;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tneedmore = ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed);\n\tif (!needmore)\n\t\trnp->gp_seq_needed = rnp->gp_seq; /* Avoid counter wrap. */\n\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq,\n\t\t\t  needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\"));\n\treturn needmore;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__note_gp_changes",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "__note_gp_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1666-1705",
          "snippet": "static bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret;\n\tbool need_gp;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance callbacks. */\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent callbacks. */\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_gp = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_gp;\n\t\trdp->core_needs_qs = need_gp;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_GE(rnp->gp_seq_needed, rdp->gp_seq_needed) || rdp->gpwrap)\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret;\n\tbool need_gp;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance callbacks. */\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent callbacks. */\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_gp = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_gp;\n\t\trdp->core_needs_qs = need_gp;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_GE(rnp->gp_seq_needed, rdp->gp_seq_needed) || rdp->gpwrap)\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->gp_seq",
            "new_gp_seq"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_blkd_tasks",
          "args": [
            "rnp",
            "10"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "dump_blkd_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1132-1136",
          "snippet": "static void\ndump_blkd_tasks(struct rcu_node *rnp, int ncheck)\n{\n\tWARN_ON_ONCE(!list_empty(&rnp->blkd_tasks));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void\ndump_blkd_tasks(struct rcu_node *rnp, int ncheck)\n{\n\tWARN_ON_ONCE(!list_empty(&rnp->blkd_tasks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_preempt_blocked_readers_cgp(rnp)"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic int gp_cleanup_delay;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gp_cleanup(void)\n{\n\tunsigned long gp_duration;\n\tbool needgp = false;\n\tunsigned long new_gp_seq;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tstruct swait_queue_head *sq;\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tgp_duration = jiffies - rcu_state.gp_start;\n\tif (gp_duration > rcu_state.gp_max)\n\t\trcu_state.gp_max = gp_duration;\n\n\t/*\n\t * We know the grace period is complete, but to everyone else\n\t * it appears to still be ongoing.  But it is also the case\n\t * that to everyone else it looks like there is nothing that\n\t * they can do to advance the grace period.  It is therefore\n\t * safe for us to drop the lock in order to mark the grace\n\t * period as completed in all of the rcu_node structures.\n\t */\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Propagate new ->gp_seq value to rcu_node structures so that\n\t * other CPUs don't have to wait until the start of the next grace\n\t * period to process their callbacks.  This also avoids some nasty\n\t * RCU grace-period initialization races by forcing the end of\n\t * the current grace period to be completely recorded in all of\n\t * the rcu_node structures before the beginning of the next grace\n\t * period is recorded in any of the rcu_node structures.\n\t */\n\tnew_gp_seq = rcu_state.gp_seq;\n\trcu_seq_end(&new_gp_seq);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\t\tdump_blkd_tasks(rnp, 10);\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tWRITE_ONCE(rnp->gp_seq, new_gp_seq);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\tif (rnp == rdp->mynode)\n\t\t\tneedgp = __note_gp_changes(rnp, rdp) || needgp;\n\t\t/* smp_mb() provided by prior unlock-lock pair. */\n\t\tneedgp = rcu_future_gp_cleanup(rnp) || needgp;\n\t\tsq = rcu_nocb_gp_get(rnp);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\trcu_nocb_gp_cleanup(sq);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\trcu_gp_slow(gp_cleanup_delay);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irq_rcu_node(rnp); /* GP before ->gp_seq update. */\n\n\t/* Declare grace period done. */\n\trcu_seq_end(&rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"end\"));\n\trcu_state.gp_state = RCU_GP_IDLE;\n\t/* Check for GP requests since above loop. */\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!needgp && ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq_needed,\n\t\t\t\t  TPS(\"CleanupMore\"));\n\t\tneedgp = true;\n\t}\n\t/* Advance CBs to reduce false positives below. */\n\tif (!rcu_accelerate_cbs(rnp, rdp) && needgp) {\n\t\tWRITE_ONCE(rcu_state.gp_flags, RCU_GP_FLAG_INIT);\n\t\trcu_state.gp_req_activity = jiffies;\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t       TPS(\"newreq\"));\n\t} else {\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   rcu_state.gp_flags & RCU_GP_FLAG_INIT);\n\t}\n\traw_spin_unlock_irq_rcu_node(rnp);\n}"
  },
  {
    "function_name": "rcu_gp_fqs_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1913-1973",
    "snippet": "static void rcu_gp_fqs_loop(void)\n{\n\tbool first_gp_fqs;\n\tint gf;\n\tunsigned long j;\n\tint ret;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tfirst_gp_fqs = true;\n\tj = READ_ONCE(jiffies_till_first_fqs);\n\tret = 0;\n\tfor (;;) {\n\t\tif (!ret) {\n\t\t\trcu_state.jiffies_force_qs = jiffies + j;\n\t\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads,\n\t\t\t\t   jiffies + 3 * j);\n\t\t}\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t       TPS(\"fqswait\"));\n\t\trcu_state.gp_state = RCU_GP_WAIT_FQS;\n\t\tret = swait_event_idle_timeout_exclusive(\n\t\t\t\trcu_state.gp_wq, rcu_gp_fqs_check_wake(&gf), j);\n\t\trcu_state.gp_state = RCU_GP_DOING_FQS;\n\t\t/* Locking provides needed memory barriers. */\n\t\t/* If grace period done, leave loop. */\n\t\tif (!READ_ONCE(rnp->qsmask) &&\n\t\t    !rcu_preempt_blocked_readers_cgp(rnp))\n\t\t\tbreak;\n\t\t/* If time for quiescent-state forcing, do it. */\n\t\tif (ULONG_CMP_GE(jiffies, rcu_state.jiffies_force_qs) ||\n\t\t    (gf & RCU_GP_FLAG_FQS)) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqsstart\"));\n\t\t\trcu_gp_fqs(first_gp_fqs);\n\t\t\tfirst_gp_fqs = false;\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqsend\"));\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tret = 0; /* Force full wait till next FQS. */\n\t\t\tj = READ_ONCE(jiffies_till_next_fqs);\n\t\t} else {\n\t\t\t/* Deal with stray signal. */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqswaitsig\"));\n\t\t\tret = 1; /* Keep old FQS timing. */\n\t\t\tj = jiffies;\n\t\t\tif (time_after(jiffies, rcu_state.jiffies_force_qs))\n\t\t\t\tj = 1;\n\t\t\telse\n\t\t\t\tj = rcu_state.jiffies_force_qs - j;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static ulong jiffies_till_first_fqs = ULONG_MAX;",
      "static ulong jiffies_till_next_fqs = ULONG_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.jiffies_force_qs"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "READ_ONCE(rcu_state.gp_seq)",
            "TPS(\"fqswaitsig\")"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"fqswaitsig\""
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_next_fqs"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "READ_ONCE(rcu_state.gp_seq)",
            "TPS(\"fqsend\")"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"fqsend\""
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_fqs",
          "args": [
            "first_gp_fqs"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_fqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1888-1908",
          "snippet": "static void rcu_gp_fqs(bool first_time)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\trcu_state.n_force_qs++;\n\tif (first_time) {\n\t\t/* Collect dyntick-idle snapshots. */\n\t\tforce_qs_rnp(dyntick_save_progress_counter);\n\t} else {\n\t\t/* Handle dyntick-idle and offline CPUs. */\n\t\tforce_qs_rnp(rcu_implicit_dynticks_qs);\n\t}\n\t/* Clear flag to prevent immediate re-entry. */\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_fqs(bool first_time)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\trcu_state.n_force_qs++;\n\tif (first_time) {\n\t\t/* Collect dyntick-idle snapshots. */\n\t\tforce_qs_rnp(dyntick_save_progress_counter);\n\t} else {\n\t\t/* Handle dyntick-idle and offline CPUs. */\n\t\tforce_qs_rnp(rcu_implicit_dynticks_qs);\n\t}\n\t/* Clear flag to prevent immediate re-entry. */\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "READ_ONCE(rcu_state.gp_seq)",
            "TPS(\"fqsstart\")"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"fqsstart\""
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "jiffies",
            "rcu_state.jiffies_force_qs"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_idle_timeout_exclusive",
          "args": [
            "rcu_state.gp_wq",
            "rcu_gp_fqs_check_wake(&gf)",
            "j"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_fqs_check_wake",
          "args": [
            "&gf"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_fqs_check_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1869-1883",
          "snippet": "static bool rcu_gp_fqs_check_wake(int *gfp)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Someone like call_rcu() requested a force-quiescent-state scan. */\n\t*gfp = READ_ONCE(rcu_state.gp_flags);\n\tif (*gfp & RCU_GP_FLAG_FQS)\n\t\treturn true;\n\n\t/* The current grace period has completed. */\n\tif (!READ_ONCE(rnp->qsmask) && !rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic bool rcu_gp_fqs_check_wake(int *gfp)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Someone like call_rcu() requested a force-quiescent-state scan. */\n\t*gfp = READ_ONCE(rcu_state.gp_flags);\n\tif (*gfp & RCU_GP_FLAG_FQS)\n\t\treturn true;\n\n\t/* The current grace period has completed. */\n\tif (!READ_ONCE(rnp->qsmask) && !rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "READ_ONCE(rcu_state.gp_seq)",
            "TPS(\"fqswait\")"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"fqswait\""
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_kick_kthreads",
            "jiffies + 3 * j"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_first_fqs"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic ulong jiffies_till_first_fqs = ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\n\nstatic void rcu_gp_fqs_loop(void)\n{\n\tbool first_gp_fqs;\n\tint gf;\n\tunsigned long j;\n\tint ret;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tfirst_gp_fqs = true;\n\tj = READ_ONCE(jiffies_till_first_fqs);\n\tret = 0;\n\tfor (;;) {\n\t\tif (!ret) {\n\t\t\trcu_state.jiffies_force_qs = jiffies + j;\n\t\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads,\n\t\t\t\t   jiffies + 3 * j);\n\t\t}\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t       TPS(\"fqswait\"));\n\t\trcu_state.gp_state = RCU_GP_WAIT_FQS;\n\t\tret = swait_event_idle_timeout_exclusive(\n\t\t\t\trcu_state.gp_wq, rcu_gp_fqs_check_wake(&gf), j);\n\t\trcu_state.gp_state = RCU_GP_DOING_FQS;\n\t\t/* Locking provides needed memory barriers. */\n\t\t/* If grace period done, leave loop. */\n\t\tif (!READ_ONCE(rnp->qsmask) &&\n\t\t    !rcu_preempt_blocked_readers_cgp(rnp))\n\t\t\tbreak;\n\t\t/* If time for quiescent-state forcing, do it. */\n\t\tif (ULONG_CMP_GE(jiffies, rcu_state.jiffies_force_qs) ||\n\t\t    (gf & RCU_GP_FLAG_FQS)) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqsstart\"));\n\t\t\trcu_gp_fqs(first_gp_fqs);\n\t\t\tfirst_gp_fqs = false;\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqsend\"));\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tret = 0; /* Force full wait till next FQS. */\n\t\t\tj = READ_ONCE(jiffies_till_next_fqs);\n\t\t} else {\n\t\t\t/* Deal with stray signal. */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t\t       READ_ONCE(rcu_state.gp_seq),\n\t\t\t\t\t       TPS(\"fqswaitsig\"));\n\t\t\tret = 1; /* Keep old FQS timing. */\n\t\t\tj = jiffies;\n\t\t\tif (time_after(jiffies, rcu_state.jiffies_force_qs))\n\t\t\t\tj = 1;\n\t\t\telse\n\t\t\t\tj = rcu_state.jiffies_force_qs - j;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rcu_gp_fqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1888-1908",
    "snippet": "static void rcu_gp_fqs(bool first_time)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\trcu_state.n_force_qs++;\n\tif (first_time) {\n\t\t/* Collect dyntick-idle snapshots. */\n\t\tforce_qs_rnp(dyntick_save_progress_counter);\n\t} else {\n\t\t/* Handle dyntick-idle and offline CPUs. */\n\t\tforce_qs_rnp(rcu_implicit_dynticks_qs);\n\t}\n\t/* Clear flag to prevent immediate re-entry. */\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_qs_rnp",
          "args": [
            "rcu_implicit_dynticks_qs"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "force_qs_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2519-2560",
          "snippet": "static void force_qs_rnp(int (*f)(struct rcu_data *rdp))\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\tcond_resched_tasks_rcu_qs();\n\t\tmask = 0;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->qsmask == 0) {\n\t\t\tif (!IS_ENABLED(CONFIG_PREEMPT) ||\n\t\t\t    rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\t\t/*\n\t\t\t\t * No point in scanning bits because they\n\t\t\t\t * are all zero.  But we might need to\n\t\t\t\t * priority-boost blocked readers.\n\t\t\t\t */\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\t\t/* rcu_initiate_boost() releases rnp->lock */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\tunsigned long bit = leaf_node_cpu_bit(rnp, cpu);\n\t\t\tif ((rnp->qsmask & bit) != 0) {\n\t\t\t\tif (f(per_cpu_ptr(&rcu_data, cpu)))\n\t\t\t\t\tmask |= bit;\n\t\t\t}\n\t\t}\n\t\tif (mask != 0) {\n\t\t\t/* Idle/offline CPUs, report (releases rnp->lock). */\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t} else {\n\t\t\t/* Nothing to do here, so just drop the lock. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp))\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\tcond_resched_tasks_rcu_qs();\n\t\tmask = 0;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tif (rnp->qsmask == 0) {\n\t\t\tif (!IS_ENABLED(CONFIG_PREEMPT) ||\n\t\t\t    rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\t\t/*\n\t\t\t\t * No point in scanning bits because they\n\t\t\t\t * are all zero.  But we might need to\n\t\t\t\t * priority-boost blocked readers.\n\t\t\t\t */\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\t\t/* rcu_initiate_boost() releases rnp->lock */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\tunsigned long bit = leaf_node_cpu_bit(rnp, cpu);\n\t\t\tif ((rnp->qsmask & bit) != 0) {\n\t\t\t\tif (f(per_cpu_ptr(&rcu_data, cpu)))\n\t\t\t\t\tmask |= bit;\n\t\t\t}\n\t\t}\n\t\tif (mask != 0) {\n\t\t\t/* Idle/offline CPUs, report (releases rnp->lock). */\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t} else {\n\t\t\t/* Nothing to do here, so just drop the lock. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_fqs(bool first_time)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\trcu_state.n_force_qs++;\n\tif (first_time) {\n\t\t/* Collect dyntick-idle snapshots. */\n\t\tforce_qs_rnp(dyntick_save_progress_counter);\n\t} else {\n\t\t/* Handle dyntick-idle and offline CPUs. */\n\t\tforce_qs_rnp(rcu_implicit_dynticks_qs);\n\t}\n\t/* Clear flag to prevent immediate re-entry. */\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t}\n}"
  },
  {
    "function_name": "rcu_gp_fqs_check_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1869-1883",
    "snippet": "static bool rcu_gp_fqs_check_wake(int *gfp)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Someone like call_rcu() requested a force-quiescent-state scan. */\n\t*gfp = READ_ONCE(rcu_state.gp_flags);\n\tif (*gfp & RCU_GP_FLAG_FQS)\n\t\treturn true;\n\n\t/* The current grace period has completed. */\n\tif (!READ_ONCE(rnp->qsmask) && !rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_preempt_blocked_readers_cgp",
          "args": [
            "rnp"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_blocked_readers_cgp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1017-1020",
          "snippet": "static int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_preempt_blocked_readers_cgp(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic bool rcu_gp_fqs_check_wake(int *gfp)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Someone like call_rcu() requested a force-quiescent-state scan. */\n\t*gfp = READ_ONCE(rcu_state.gp_flags);\n\tif (*gfp & RCU_GP_FLAG_FQS)\n\t\treturn true;\n\n\t/* The current grace period has completed. */\n\tif (!READ_ONCE(rnp->qsmask) && !rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_gp_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1738-1863",
    "snippet": "static bool rcu_gp_init(void)\n{\n\tunsigned long flags;\n\tunsigned long oldmask;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tif (!READ_ONCE(rcu_state.gp_flags)) {\n\t\t/* Spurious wakeup, tell caller to go back to sleep.  */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags, 0); /* Clear all flags: New GP. */\n\n\tif (WARN_ON_ONCE(rcu_gp_in_progress())) {\n\t\t/*\n\t\t * Grace period already in progress, don't start another.\n\t\t * Not supposed to be able to happen.\n\t\t */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\n\t/* Advance to a new grace period and initialize state. */\n\trecord_gp_stall_check_time();\n\t/* Record GP times before starting GP, hence rcu_seq_start(). */\n\trcu_seq_start(&rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"start\"));\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Apply per-leaf buffered online and offline operations to the\n\t * rcu_node tree.  Note that this new grace period need not wait\n\t * for subsequent online CPUs, and that quiescent-state forcing\n\t * will handle subsequent offline CPUs.\n\t */\n\trcu_state.gp_state = RCU_GP_ONOFF;\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock(&rcu_state.ofl_lock);\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (rnp->qsmaskinit == rnp->qsmaskinitnext &&\n\t\t    !rnp->wait_blkd_tasks) {\n\t\t\t/* Nothing to do on this leaf rcu_node structure. */\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record old state, apply changes to ->qsmaskinit field. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit = rnp->qsmaskinitnext;\n\n\t\t/* If zero-ness of ->qsmaskinit changed, propagate up tree. */\n\t\tif (!oldmask != !rnp->qsmaskinit) {\n\t\t\tif (!oldmask) { /* First online CPU for rcu_node. */\n\t\t\t\tif (!rnp->wait_blkd_tasks) /* Ever offline? */\n\t\t\t\t\trcu_init_new_rnp(rnp);\n\t\t\t} else if (rcu_preempt_has_tasks(rnp)) {\n\t\t\t\trnp->wait_blkd_tasks = true; /* blocked tasks */\n\t\t\t} else { /* Last offline CPU and can propagate. */\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If all waited-on tasks from prior grace period are\n\t\t * done, and if all this rcu_node structure's CPUs are\n\t\t * still offline, propagate up the rcu_node tree and\n\t\t * clear ->wait_blkd_tasks.  Otherwise, if one of this\n\t\t * rcu_node structure's CPUs has since come back online,\n\t\t * simply clear ->wait_blkd_tasks.\n\t\t */\n\t\tif (rnp->wait_blkd_tasks &&\n\t\t    (!rcu_preempt_has_tasks(rnp) || rnp->qsmaskinit)) {\n\t\t\trnp->wait_blkd_tasks = false;\n\t\t\tif (!rnp->qsmaskinit)\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t}\n\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t}\n\trcu_gp_slow(gp_preinit_delay); /* Races with CPU hotplug. */\n\n\t/*\n\t * Set the quiescent-state-needed bits in all the rcu_node\n\t * structures for all currently online CPUs in breadth-first\n\t * order, starting from the root rcu_node structure, relying on the\n\t * layout of the tree within the rcu_state.node[] array.  Note that\n\t * other CPUs will access only the leaves of the hierarchy, thus\n\t * seeing that no grace period is in progress, at least until the\n\t * corresponding leaf node has been initialized.\n\t *\n\t * The grace period cannot complete until the initialization\n\t * process finishes, because this kthread handles both.\n\t */\n\trcu_state.gp_state = RCU_GP_INIT;\n\trcu_for_each_node_breadth_first(rnp) {\n\t\trcu_gp_slow(gp_init_delay);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_preempt_check_blocked_tasks(rnp);\n\t\trnp->qsmask = rnp->qsmaskinit;\n\t\tWRITE_ONCE(rnp->gp_seq, rcu_state.gp_seq);\n\t\tif (rnp == rdp->mynode)\n\t\t\t(void)__note_gp_changes(rnp, rdp);\n\t\trcu_preempt_boost_start_gp(rnp);\n\t\ttrace_rcu_grace_period_init(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t    rnp->level, rnp->grplo,\n\t\t\t\t\t    rnp->grphi, rnp->qsmask);\n\t\t/* Quiescent states for tasks on any now-offline CPUs. */\n\t\tmask = rnp->qsmask & ~rnp->qsmaskinitnext;\n\t\trnp->rcu_gp_init_mask = mask;\n\t\tif ((mask || rnp->wait_blkd_tasks) && rcu_is_leaf_node(rnp))\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\telse\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static int gp_preinit_delay;",
      "static int gp_init_delay;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_report_qs_rnp",
          "args": [
            "mask",
            "rnp",
            "rnp->gp_seq",
            "flags"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_report_qs_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2133-2188",
          "snippet": "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\trnp->qsmask &= ~mask;\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = rnp_c->qsmask;\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period_init",
          "args": [
            "rcu_state.name",
            "rnp->gp_seq",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "rnp->qsmask"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_boost_start_gp",
          "args": [
            "rnp"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_boost_start_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1500-1502",
          "snippet": "static void rcu_preempt_boost_start_gp(struct rcu_node *rnp)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_boost_start_gp(struct rcu_node *rnp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__note_gp_changes",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "__note_gp_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1666-1705",
          "snippet": "static bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret;\n\tbool need_gp;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance callbacks. */\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent callbacks. */\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_gp = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_gp;\n\t\trdp->core_needs_qs = need_gp;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_GE(rnp->gp_seq_needed, rdp->gp_seq_needed) || rdp->gpwrap)\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret;\n\tbool need_gp;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance callbacks. */\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent callbacks. */\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_gp = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_gp;\n\t\trdp->core_needs_qs = need_gp;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_GE(rnp->gp_seq_needed, rdp->gp_seq_needed) || rdp->gpwrap)\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rnp->gp_seq",
            "rcu_state.gp_seq"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_check_blocked_tasks",
          "args": [
            "rnp"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_check_blocked_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1072-1075",
          "snippet": "static void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp)\n{\n\tWARN_ON_ONCE(rnp->qsmask);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_check_blocked_tasks(struct rcu_node *rnp)\n{\n\tWARN_ON_ONCE(rnp->qsmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_slow",
          "args": [
            "gp_init_delay"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1727-1733",
          "snippet": "static void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_uninterruptible(delay);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays. */"
          ],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "int rcu_num_nodes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays. */\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_num_nodes;\n\nstatic void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_uninterruptible(delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rcu_state.ofl_lock"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cleanup_dead_rnp",
          "args": [
            "rnp"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cleanup_dead_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2347-2373",
          "snippet": "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU) ||\n\t    WARN_ON_ONCE(rnp_leaf->qsmaskinit) ||\n\t    WARN_ON_ONCE(rcu_preempt_has_tasks(rnp_leaf)))\n\t\treturn;\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (!rnp)\n\t\t\tbreak;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\trnp->qsmaskinit &= ~mask;\n\t\t/* Between grace periods, so better already be zero! */\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tif (rnp->qsmaskinit) {\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\t\t/* irqs remain disabled. */\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf);",
            "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf);\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);\n\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU) ||\n\t    WARN_ON_ONCE(rnp_leaf->qsmaskinit) ||\n\t    WARN_ON_ONCE(rcu_preempt_has_tasks(rnp_leaf)))\n\t\treturn;\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (!rnp)\n\t\t\tbreak;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\trnp->qsmaskinit &= ~mask;\n\t\t/* Between grace periods, so better already be zero! */\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tif (rnp->qsmaskinit) {\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\t\t/* irqs remain disabled. */\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_preempt_has_tasks",
          "args": [
            "rnp"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_has_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1025-1028",
          "snippet": "static bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic bool rcu_preempt_has_tasks(struct rcu_node *rnp)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_init_new_rnp",
          "args": [
            "rnp"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_new_rnp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3159-3179",
          "snippet": "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tlong oldmask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tWARN_ON_ONCE(rnp->wait_blkd_tasks);\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (rnp == NULL)\n\t\t\treturn;\n\t\traw_spin_lock_rcu_node(rnp); /* Interrupts already disabled. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit |= mask;\n\t\traw_spin_unlock_rcu_node(rnp); /* Interrupts remain disabled. */\n\t\tif (oldmask)\n\t\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_init_new_rnp(struct rcu_node *rnp_leaf);",
            "static void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf);\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);\n\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tlong oldmask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tWARN_ON_ONCE(rnp->wait_blkd_tasks);\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (rnp == NULL)\n\t\t\treturn;\n\t\traw_spin_lock_rcu_node(rnp); /* Interrupts already disabled. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit |= mask;\n\t\traw_spin_unlock_rcu_node(rnp); /* Interrupts remain disabled. */\n\t\tif (oldmask)\n\t\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rcu_state.ofl_lock"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rcu_state.gp_seq",
            "TPS(\"start\")"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"start\""
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_start",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "73-78",
          "snippet": "static inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_gp_stall_check_time",
          "args": [],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "record_gp_stall_check_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1132-1143",
          "snippet": "static void record_gp_stall_check_time(void)\n{\n\tunsigned long j = jiffies;\n\tunsigned long j1;\n\n\trcu_state.gp_start = j;\n\tj1 = rcu_jiffies_till_stall_check();\n\t/* Record ->gp_start before ->jiffies_stall. */\n\tsmp_store_release(&rcu_state.jiffies_stall, j + j1); /* ^^^ */\n\trcu_state.jiffies_resched = j + j1 / 2;\n\trcu_state.n_force_qs_gpstart = READ_ONCE(rcu_state.n_force_qs);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void record_gp_stall_check_time(void)\n{\n\tunsigned long j = jiffies;\n\tunsigned long j1;\n\n\trcu_state.gp_start = j;\n\tj1 = rcu_jiffies_till_stall_check();\n\t/* Record ->gp_start before ->jiffies_stall. */\n\tsmp_store_release(&rcu_state.jiffies_stall, j + j1); /* ^^^ */\n\trcu_state.jiffies_resched = j + j1 / 2;\n\trcu_state.n_force_qs_gpstart = READ_ONCE(rcu_state.n_force_qs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_gp_in_progress()"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "205-208",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "0"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_activity",
            "jiffies"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic int gp_preinit_delay;\nstatic int gp_init_delay;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_gp_init(void)\n{\n\tunsigned long flags;\n\tunsigned long oldmask;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tif (!READ_ONCE(rcu_state.gp_flags)) {\n\t\t/* Spurious wakeup, tell caller to go back to sleep.  */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags, 0); /* Clear all flags: New GP. */\n\n\tif (WARN_ON_ONCE(rcu_gp_in_progress())) {\n\t\t/*\n\t\t * Grace period already in progress, don't start another.\n\t\t * Not supposed to be able to happen.\n\t\t */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\n\t/* Advance to a new grace period and initialize state. */\n\trecord_gp_stall_check_time();\n\t/* Record GP times before starting GP, hence rcu_seq_start(). */\n\trcu_seq_start(&rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"start\"));\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Apply per-leaf buffered online and offline operations to the\n\t * rcu_node tree.  Note that this new grace period need not wait\n\t * for subsequent online CPUs, and that quiescent-state forcing\n\t * will handle subsequent offline CPUs.\n\t */\n\trcu_state.gp_state = RCU_GP_ONOFF;\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock(&rcu_state.ofl_lock);\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (rnp->qsmaskinit == rnp->qsmaskinitnext &&\n\t\t    !rnp->wait_blkd_tasks) {\n\t\t\t/* Nothing to do on this leaf rcu_node structure. */\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record old state, apply changes to ->qsmaskinit field. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit = rnp->qsmaskinitnext;\n\n\t\t/* If zero-ness of ->qsmaskinit changed, propagate up tree. */\n\t\tif (!oldmask != !rnp->qsmaskinit) {\n\t\t\tif (!oldmask) { /* First online CPU for rcu_node. */\n\t\t\t\tif (!rnp->wait_blkd_tasks) /* Ever offline? */\n\t\t\t\t\trcu_init_new_rnp(rnp);\n\t\t\t} else if (rcu_preempt_has_tasks(rnp)) {\n\t\t\t\trnp->wait_blkd_tasks = true; /* blocked tasks */\n\t\t\t} else { /* Last offline CPU and can propagate. */\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If all waited-on tasks from prior grace period are\n\t\t * done, and if all this rcu_node structure's CPUs are\n\t\t * still offline, propagate up the rcu_node tree and\n\t\t * clear ->wait_blkd_tasks.  Otherwise, if one of this\n\t\t * rcu_node structure's CPUs has since come back online,\n\t\t * simply clear ->wait_blkd_tasks.\n\t\t */\n\t\tif (rnp->wait_blkd_tasks &&\n\t\t    (!rcu_preempt_has_tasks(rnp) || rnp->qsmaskinit)) {\n\t\t\trnp->wait_blkd_tasks = false;\n\t\t\tif (!rnp->qsmaskinit)\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t}\n\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t}\n\trcu_gp_slow(gp_preinit_delay); /* Races with CPU hotplug. */\n\n\t/*\n\t * Set the quiescent-state-needed bits in all the rcu_node\n\t * structures for all currently online CPUs in breadth-first\n\t * order, starting from the root rcu_node structure, relying on the\n\t * layout of the tree within the rcu_state.node[] array.  Note that\n\t * other CPUs will access only the leaves of the hierarchy, thus\n\t * seeing that no grace period is in progress, at least until the\n\t * corresponding leaf node has been initialized.\n\t *\n\t * The grace period cannot complete until the initialization\n\t * process finishes, because this kthread handles both.\n\t */\n\trcu_state.gp_state = RCU_GP_INIT;\n\trcu_for_each_node_breadth_first(rnp) {\n\t\trcu_gp_slow(gp_init_delay);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_preempt_check_blocked_tasks(rnp);\n\t\trnp->qsmask = rnp->qsmaskinit;\n\t\tWRITE_ONCE(rnp->gp_seq, rcu_state.gp_seq);\n\t\tif (rnp == rdp->mynode)\n\t\t\t(void)__note_gp_changes(rnp, rdp);\n\t\trcu_preempt_boost_start_gp(rnp);\n\t\ttrace_rcu_grace_period_init(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t    rnp->level, rnp->grplo,\n\t\t\t\t\t    rnp->grphi, rnp->qsmask);\n\t\t/* Quiescent states for tasks on any now-offline CPUs. */\n\t\tmask = rnp->qsmask & ~rnp->qsmaskinitnext;\n\t\trnp->rcu_gp_init_mask = mask;\n\t\tif ((mask || rnp->wait_blkd_tasks) && rcu_is_leaf_node(rnp))\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\telse\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "rcu_gp_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1727-1733",
    "snippet": "static void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_uninterruptible(delay);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays. */"
    ],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "int rcu_num_nodes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "delay"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1835-1839",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "48-51",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays. */\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nint rcu_num_nodes;\n\nstatic void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_uninterruptible(delay);\n}"
  },
  {
    "function_name": "note_gp_changes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1707-1725",
    "snippet": "static void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1551-1558",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__note_gp_changes",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "__note_gp_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1666-1705",
          "snippet": "static bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret;\n\tbool need_gp;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance callbacks. */\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent callbacks. */\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_gp = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_gp;\n\t\trdp->core_needs_qs = need_gp;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_GE(rnp->gp_seq_needed, rdp->gp_seq_needed) || rdp->gpwrap)\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret;\n\tbool need_gp;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance callbacks. */\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent callbacks. */\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_gp = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_gp;\n\t\trdp->core_needs_qs = need_gp;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_GE(rnp->gp_seq_needed, rdp->gp_seq_needed) || rdp->gpwrap)\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_trylock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(rdp->gpwrap)"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gpwrap"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rnp->gp_seq"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
  },
  {
    "function_name": "__note_gp_changes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1666-1705",
    "snippet": "static bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret;\n\tbool need_gp;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance callbacks. */\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent callbacks. */\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_gp = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_gp;\n\t\trdp->core_needs_qs = need_gp;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_GE(rnp->gp_seq_needed, rdp->gp_seq_needed) || rdp->gpwrap)\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gpnum_ovf",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gpnum_ovf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "972-980",
          "snippet": "static void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->gpwrap",
            "false"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rnp->gp_seq_needed",
            "rdp->gp_seq_needed"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_cpu_stall_ticks",
          "args": [
            "rdp"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "zero_cpu_stall_ticks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1846-1851",
          "snippet": "static void zero_cpu_stall_ticks(struct rcu_data *rdp)\n{\n\trdp->ticks_this_gp = 0;\n\trdp->softirq_snap = kstat_softirqs_cpu(RCU_SOFTIRQ, smp_processor_id());\n\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void zero_cpu_stall_ticks(struct rcu_data *rdp)\n{\n\trdp->ticks_this_gp = 0;\n\trdp->softirq_snap = kstat_softirqs_cpu(RCU_SOFTIRQ, smp_processor_id());\n\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rnp->gp_seq",
            "TPS(\"cpustart\")"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpustart\""
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(rdp->gpwrap)"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gpwrap"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_new_gp",
          "args": [
            "rdp->gp_seq",
            "rnp->gp_seq"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_new_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "149-153",
          "snippet": "static inline bool rcu_seq_new_gp(unsigned long old, unsigned long new)\n{\n\treturn ULONG_CMP_LT((old + RCU_SEQ_STATE_MASK) & ~RCU_SEQ_STATE_MASK,\n\t\t\t    new);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline bool rcu_seq_new_gp(unsigned long old, unsigned long new)\n{\n\treturn ULONG_CMP_LT((old + RCU_SEQ_STATE_MASK) & ~RCU_SEQ_STATE_MASK,\n\t\t\t    new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1612-1630",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rdp->gp_seq",
            "TPS(\"cpuend\")"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"cpuend\""
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_advance_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_advance_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1642-1658",
          "snippet": "static bool rcu_advance_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL sublist.\n\t */\n\trcu_segcblist_advance(&rdp->cblist, rnp->gp_seq);\n\n\t/* Classify any remaining callbacks. */\n\treturn rcu_accelerate_cbs(rnp, rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_advance_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL sublist.\n\t */\n\trcu_segcblist_advance(&rdp->cblist, rnp->gp_seq);\n\n\t/* Classify any remaining callbacks. */\n\treturn rcu_accelerate_cbs(rnp, rdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(rdp->gpwrap)"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->gpwrap"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_completed_gp",
          "args": [
            "rdp->gp_seq",
            "rnp->gp_seq"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_completed_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "141-144",
          "snippet": "static inline bool rcu_seq_completed_gp(unsigned long old, unsigned long new)\n{\n\treturn ULONG_CMP_LT(old, new & ~RCU_SEQ_STATE_MASK);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline bool rcu_seq_completed_gp(unsigned long old, unsigned long new)\n{\n\treturn ULONG_CMP_LT(old, new & ~RCU_SEQ_STATE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret;\n\tbool need_gp;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance callbacks. */\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent callbacks. */\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_gp = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_gp;\n\t\trdp->core_needs_qs = need_gp;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_GE(rnp->gp_seq_needed, rdp->gp_seq_needed) || rdp->gpwrap)\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_advance_cbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1642-1658",
    "snippet": "static bool rcu_advance_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL sublist.\n\t */\n\trcu_segcblist_advance(&rdp->cblist, rnp->gp_seq);\n\n\t/* Classify any remaining callbacks. */\n\treturn rcu_accelerate_cbs(rnp, rdp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1612-1630",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_advance",
          "args": [
            "&rdp->cblist",
            "rnp->gp_seq"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_advance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "300-338",
          "snippet": "void rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\trsclp->tails[RCU_DONE_TAIL] = rsclp->tails[i];\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\trsclp->tails[j] = rsclp->tails[RCU_DONE_TAIL];\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\trsclp->tails[j] = rsclp->tails[i];\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\trsclp->tails[RCU_DONE_TAIL] = rsclp->tails[i];\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\trsclp->tails[j] = rsclp->tails[RCU_DONE_TAIL];\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\trsclp->tails[j] = rsclp->tails[i];\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_pend_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_pend_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "102-106",
          "snippet": "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_advance_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL sublist.\n\t */\n\trcu_segcblist_advance(&rdp->cblist, rnp->gp_seq);\n\n\t/* Classify any remaining callbacks. */\n\treturn rcu_accelerate_cbs(rnp, rdp);\n}"
  },
  {
    "function_name": "rcu_accelerate_cbs_unlocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1612-1630",
    "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gp_kthread_wake",
          "args": [],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_kthread_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1551-1558",
          "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_accelerate_cbs",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_accelerate_cbs_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1612-1630",
          "snippet": "static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_accelerate",
          "args": [
            "&rdp->cblist",
            "c"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_accelerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "355-404",
          "snippet": "bool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t */\n\tif (++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\trsclp->tails[i] = rsclp->tails[RCU_NEXT_TAIL];\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t */\n\tif (++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\trsclp->tails[i] = rsclp->tails[RCU_NEXT_TAIL];\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rdp->gp_seq_needed",
            "c"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\tlockdep_assert_irqs_disabled();\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!rdp->gpwrap && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}"
  },
  {
    "function_name": "rcu_accelerate_cbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1572-1603",
    "snippet": "static bool rcu_accelerate_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tunsigned long gp_seq_req;\n\tbool ret = false;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Callbacks are often registered with incomplete grace-period\n\t * information.  Something about the fact that getting exact\n\t * information requires acquiring a global lock...  RCU therefore\n\t * makes a conservative estimate of the grace period number at which\n\t * a given callback will become ready to invoke.\tThe following\n\t * code checks this estimate and improves it when possible, thus\n\t * accelerating callback invocation to an earlier grace-period\n\t * number.\n\t */\n\tgp_seq_req = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (rcu_segcblist_accelerate(&rdp->cblist, gp_seq_req))\n\t\tret = rcu_start_this_gp(rnp, rdp, gp_seq_req);\n\n\t/* Trace depending on how much we were able to accelerate. */\n\tif (rcu_segcblist_restempty(&rdp->cblist, RCU_WAIT_TAIL))\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"AccWaitCB\"));\n\telse\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"AccReadyCB\"));\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rdp->gp_seq",
            "TPS(\"AccReadyCB\")"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"AccReadyCB\""
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "rdp->gp_seq",
            "TPS(\"AccWaitCB\")"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"AccWaitCB\""
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_restempty",
          "args": [
            "&rdp->cblist",
            "RCU_WAIT_TAIL"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_restempty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "87-90",
          "snippet": "static inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !*rsclp->tails[seg];\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_restempty(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn !*rsclp->tails[seg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_start_this_gp",
          "args": [
            "rnp",
            "rdp",
            "gp_seq_req"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_start_this_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1457-1526",
          "snippet": "static bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\trnp->gp_seq_needed = gp_seq_req;\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\trcu_state.gp_req_activity = jiffies;\n\tif (!rcu_state.gp_kthread) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, READ_ONCE(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\trnp_start->gp_seq_needed = rnp->gp_seq_needed;\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\trnp->gp_seq_needed = gp_seq_req;\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\trcu_state.gp_req_activity = jiffies;\n\tif (!rcu_state.gp_kthread) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, READ_ONCE(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\trnp_start->gp_seq_needed = rnp->gp_seq_needed;\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_accelerate",
          "args": [
            "&rdp->cblist",
            "gp_seq_req"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_accelerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "355-404",
          "snippet": "bool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t */\n\tif (++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\trsclp->tails[i] = rsclp->tails[RCU_NEXT_TAIL];\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t */\n\tif (++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\trsclp->tails[i] = rsclp->tails[RCU_NEXT_TAIL];\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "105-112",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_pend_cbs",
          "args": [
            "&rdp->cblist"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_pend_cbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "102-106",
          "snippet": "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_accelerate_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tunsigned long gp_seq_req;\n\tbool ret = false;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Callbacks are often registered with incomplete grace-period\n\t * information.  Something about the fact that getting exact\n\t * information requires acquiring a global lock...  RCU therefore\n\t * makes a conservative estimate of the grace period number at which\n\t * a given callback will become ready to invoke.\tThe following\n\t * code checks this estimate and improves it when possible, thus\n\t * accelerating callback invocation to an earlier grace-period\n\t * number.\n\t */\n\tgp_seq_req = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (rcu_segcblist_accelerate(&rdp->cblist, gp_seq_req))\n\t\tret = rcu_start_this_gp(rnp, rdp, gp_seq_req);\n\n\t/* Trace depending on how much we were able to accelerate. */\n\tif (rcu_segcblist_restempty(&rdp->cblist, RCU_WAIT_TAIL))\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"AccWaitCB\"));\n\telse\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"AccReadyCB\"));\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_gp_kthread_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1551-1558",
    "snippet": "static void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swake_up_one",
          "args": [
            "&rcu_state.gp_wq"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/swait.c",
          "lines": "35-42",
          "snippet": "void swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void rcu_gp_kthread_wake(void)\n{\n\tif (current == rcu_state.gp_kthread ||\n\t    !READ_ONCE(rcu_state.gp_flags) ||\n\t    !rcu_state.gp_kthread)\n\t\treturn;\n\tswake_up_one(&rcu_state.gp_wq);\n}"
  },
  {
    "function_name": "rcu_future_gp_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1532-1543",
    "snippet": "static bool rcu_future_gp_cleanup(struct rcu_node *rnp)\n{\n\tbool needmore;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tneedmore = ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed);\n\tif (!needmore)\n\t\trnp->gp_seq_needed = rnp->gp_seq; /* Avoid counter wrap. */\n\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq,\n\t\t\t  needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\"));\n\treturn needmore;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_this_gp",
          "args": [
            "rnp",
            "rdp",
            "rnp->gp_seq",
            "needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\")"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "trace_rcu_this_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1434-1439",
          "snippet": "static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, rnp->gp_seq, gp_seq_req,\n\t\t\t\t      rnp->level, rnp->grplo, rnp->grphi, s);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, rnp->gp_seq, gp_seq_req,\n\t\t\t\t      rnp->level, rnp->grplo, rnp->grphi, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Cleanup\""
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"CleanupMore\""
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rnp->gp_seq",
            "rnp->gp_seq_needed"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_future_gp_cleanup(struct rcu_node *rnp)\n{\n\tbool needmore;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tneedmore = ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed);\n\tif (!needmore)\n\t\trnp->gp_seq_needed = rnp->gp_seq; /* Avoid counter wrap. */\n\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq,\n\t\t\t  needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\"));\n\treturn needmore;\n}"
  },
  {
    "function_name": "rcu_start_this_gp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1457-1526",
    "snippet": "static bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\trnp->gp_seq_needed = gp_seq_req;\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\trcu_state.gp_req_activity = jiffies;\n\tif (!rcu_state.gp_kthread) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, READ_ONCE(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\trnp_start->gp_seq_needed = rnp->gp_seq_needed;\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "gp_seq_req",
            "rnp->gp_seq_needed"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_grace_period",
          "args": [
            "rcu_state.name",
            "READ_ONCE(rcu_state.gp_seq)",
            "TPS(\"newreq\")"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"newreq\""
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_this_gp",
          "args": [
            "rnp",
            "rdp",
            "gp_seq_req",
            "TPS(\"NoGPkthread\")"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "trace_rcu_this_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1434-1439",
          "snippet": "static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, rnp->gp_seq, gp_seq_req,\n\t\t\t\t      rnp->level, rnp->grplo, rnp->grphi, s);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, rnp->gp_seq, gp_seq_req,\n\t\t\t\t      rnp->level, rnp->grplo, rnp->grphi, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"NoGPkthread\""
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.gp_flags",
            "rcu_state.gp_flags | RCU_GP_FLAG_INIT"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Startedroot\""
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Startedleafroot\""
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "205-208",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Startedleaf\""
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "rcu_seq_current(&rnp->gp_seq)"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "57-60",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rnp->gp_seq"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Prestarted\""
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_started",
          "args": [
            "&rnp->gp_seq",
            "gp_seq_req"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_started",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "124-127",
          "snippet": "static inline bool rcu_seq_started(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_LT((s - 1) & ~RCU_SEQ_STATE_MASK, READ_ONCE(*sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline bool rcu_seq_started(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_LT((s - 1) & ~RCU_SEQ_STATE_MASK, READ_ONCE(*sp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rnp->gp_seq_needed",
            "gp_seq_req"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Startleaf\""
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp_start"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\trnp->gp_seq_needed = gp_seq_req;\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\trcu_state.gp_req_activity = jiffies;\n\tif (!rcu_state.gp_kthread) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, READ_ONCE(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\trnp_start->gp_seq_needed = rnp->gp_seq_needed;\n\t\trdp->gp_seq_needed = rnp->gp_seq_needed;\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_rcu_this_gp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1434-1439",
    "snippet": "static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, rnp->gp_seq, gp_seq_req,\n\t\t\t\t      rnp->level, rnp->grplo, rnp->grphi, s);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_rcu_future_grace_period",
          "args": [
            "rcu_state.name",
            "rnp->gp_seq",
            "gp_seq_req",
            "rnp->level",
            "rnp->grplo",
            "rnp->grphi",
            "s"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, rnp->gp_seq, gp_seq_req,\n\t\t\t\t      rnp->level, rnp->grplo, rnp->grphi, s);\n}"
  },
  {
    "function_name": "rcu_cpu_stall_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1428-1431",
    "snippet": "void rcu_cpu_stall_reset(void)\n{\n\tWRITE_ONCE(rcu_state.jiffies_stall, jiffies + ULONG_MAX / 2);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_stall",
            "jiffies + ULONG_MAX / 2"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nvoid rcu_cpu_stall_reset(void)\n{\n\tWRITE_ONCE(rcu_state.jiffies_stall, jiffies + ULONG_MAX / 2);\n}"
  },
  {
    "function_name": "check_cpu_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1356-1417",
    "snippet": "static void check_cpu_stall(struct rcu_data *rdp)\n{\n\tunsigned long gs1;\n\tunsigned long gs2;\n\tunsigned long gps;\n\tunsigned long j;\n\tunsigned long jn;\n\tunsigned long js;\n\tstruct rcu_node *rnp;\n\n\tif ((rcu_cpu_stall_suppress && !rcu_kick_kthreads) ||\n\t    !rcu_gp_in_progress())\n\t\treturn;\n\trcu_stall_kick_kthreads();\n\tj = jiffies;\n\n\t/*\n\t * Lots of memory barriers to reject false positives.\n\t *\n\t * The idea is to pick up rcu_state.gp_seq, then\n\t * rcu_state.jiffies_stall, then rcu_state.gp_start, and finally\n\t * another copy of rcu_state.gp_seq.  These values are updated in\n\t * the opposite order with memory barriers (or equivalent) during\n\t * grace-period initialization and cleanup.  Now, a false positive\n\t * can occur if we get an new value of rcu_state.gp_start and a old\n\t * value of rcu_state.jiffies_stall.  But given the memory barriers,\n\t * the only way that this can happen is if one grace period ends\n\t * and another starts between these two fetches.  This is detected\n\t * by comparing the second fetch of rcu_state.gp_seq with the\n\t * previous fetch from rcu_state.gp_seq.\n\t *\n\t * Given this check, comparisons of jiffies, rcu_state.jiffies_stall,\n\t * and rcu_state.gp_start suffice to forestall false positives.\n\t */\n\tgs1 = READ_ONCE(rcu_state.gp_seq);\n\tsmp_rmb(); /* Pick up ->gp_seq first... */\n\tjs = READ_ONCE(rcu_state.jiffies_stall);\n\tsmp_rmb(); /* ...then ->jiffies_stall before the rest... */\n\tgps = READ_ONCE(rcu_state.gp_start);\n\tsmp_rmb(); /* ...and finally ->gp_start before ->gp_seq again. */\n\tgs2 = READ_ONCE(rcu_state.gp_seq);\n\tif (gs1 != gs2 ||\n\t    ULONG_CMP_LT(j, js) ||\n\t    ULONG_CMP_GE(gps, js))\n\t\treturn; /* No stall or GP completed since entering function. */\n\trnp = rdp->mynode;\n\tjn = jiffies + 3 * rcu_jiffies_till_stall_check() + 3;\n\tif (rcu_gp_in_progress() &&\n\t    (READ_ONCE(rnp->qsmask) & rdp->grpmask) &&\n\t    cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/* We haven't checked in, so go dump stack. */\n\t\tprint_cpu_stall();\n\n\t} else if (rcu_gp_in_progress() &&\n\t\t   ULONG_CMP_GE(j, js + RCU_STALL_RAT_DELAY) &&\n\t\t   cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/* They had a few time units to dump stack, so complain. */\n\t\tprint_other_cpu_stall(gs2);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static bool rcu_kick_kthreads;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_other_cpu_stall",
          "args": [
            "gs2"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "print_other_cpu_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1228-1299",
          "snippet": "static void print_other_cpu_stall(unsigned long gp_seq)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpa;\n\tunsigned long j;\n\tint ndetected = 0;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_cpu_stall_suppress)\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on our buddy...\n\t * See Documentation/RCU/stallwarn.txt for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\tpr_err(\"INFO: %s detected stalls on CPUs/tasks:\", rcu_state.name);\n\tprint_cpu_stall_info_begin();\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tndetected += rcu_print_task_stall(rnp);\n\t\tif (rnp->qsmask != 0) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\t\tprint_cpu_stall_info(cpu);\n\t\t\t\t\tndetected++;\n\t\t\t\t}\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\n\tprint_cpu_stall_info_end();\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_segcblist_n_cbs(&per_cpu_ptr(&rcu_data,\n\t\t\t\t\t\t\t    cpu)->cblist);\n\tpr_cont(\"(detected by %d, t=%ld jiffies, g=%ld, q=%lu)\\n\",\n\t       smp_processor_id(), (long)(jiffies - rcu_state.gp_start),\n\t       (long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\tif (ndetected) {\n\t\trcu_dump_cpu_stacks();\n\n\t\t/* Complain about tasks blocking the grace period. */\n\t\trcu_print_detail_task_stall();\n\t} else {\n\t\tif (rcu_seq_current(&rcu_state.gp_seq) != gp_seq) {\n\t\t\tpr_err(\"INFO: Stall ended before state dump start\\n\");\n\t\t} else {\n\t\t\tj = jiffies;\n\t\t\tgpa = READ_ONCE(rcu_state.gp_activity);\n\t\t\tpr_err(\"All QSes seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\",\n\t\t\t       rcu_state.name, j - gpa, j, gpa,\n\t\t\t       READ_ONCE(jiffies_till_next_fqs),\n\t\t\t       rcu_get_root()->qsmask);\n\t\t\t/* In this case, the current CPU might be at fault. */\n\t\t\tsched_show_task(current);\n\t\t}\n\t}\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\n\trcu_check_gp_kthread_starvation();\n\n\tpanic_on_rcu_stall();\n\n\tforce_quiescent_state();  /* Kick them all. */\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;",
            "static void force_quiescent_state(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic void force_quiescent_state(void);\n\nstatic void print_other_cpu_stall(unsigned long gp_seq)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpa;\n\tunsigned long j;\n\tint ndetected = 0;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_cpu_stall_suppress)\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on our buddy...\n\t * See Documentation/RCU/stallwarn.txt for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\tpr_err(\"INFO: %s detected stalls on CPUs/tasks:\", rcu_state.name);\n\tprint_cpu_stall_info_begin();\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tndetected += rcu_print_task_stall(rnp);\n\t\tif (rnp->qsmask != 0) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\t\tprint_cpu_stall_info(cpu);\n\t\t\t\t\tndetected++;\n\t\t\t\t}\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\n\tprint_cpu_stall_info_end();\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_segcblist_n_cbs(&per_cpu_ptr(&rcu_data,\n\t\t\t\t\t\t\t    cpu)->cblist);\n\tpr_cont(\"(detected by %d, t=%ld jiffies, g=%ld, q=%lu)\\n\",\n\t       smp_processor_id(), (long)(jiffies - rcu_state.gp_start),\n\t       (long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\tif (ndetected) {\n\t\trcu_dump_cpu_stacks();\n\n\t\t/* Complain about tasks blocking the grace period. */\n\t\trcu_print_detail_task_stall();\n\t} else {\n\t\tif (rcu_seq_current(&rcu_state.gp_seq) != gp_seq) {\n\t\t\tpr_err(\"INFO: Stall ended before state dump start\\n\");\n\t\t} else {\n\t\t\tj = jiffies;\n\t\t\tgpa = READ_ONCE(rcu_state.gp_activity);\n\t\t\tpr_err(\"All QSes seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\",\n\t\t\t       rcu_state.name, j - gpa, j, gpa,\n\t\t\t       READ_ONCE(jiffies_till_next_fqs),\n\t\t\t       rcu_get_root()->qsmask);\n\t\t\t/* In this case, the current CPU might be at fault. */\n\t\t\tsched_show_task(current);\n\t\t}\n\t}\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\n\trcu_check_gp_kthread_starvation();\n\n\tpanic_on_rcu_stall();\n\n\tforce_quiescent_state();  /* Kick them all. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&rcu_state.jiffies_stall",
            "js",
            "jn"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "j",
            "js + RCU_STALL_RAT_DELAY"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "205-208",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cpu_stall",
          "args": [],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1301-1354",
          "snippet": "static void print_cpu_stall(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_cpu_stall_suppress)\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on ourselves...\n\t * See Documentation/RCU/stallwarn.txt for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\tpr_err(\"INFO: %s self-detected stall on CPU\", rcu_state.name);\n\tprint_cpu_stall_info_begin();\n\traw_spin_lock_irqsave_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info(smp_processor_id());\n\traw_spin_unlock_irqrestore_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info_end();\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_segcblist_n_cbs(&per_cpu_ptr(&rcu_data,\n\t\t\t\t\t\t\t    cpu)->cblist);\n\tpr_cont(\" (t=%lu jiffies g=%ld q=%lu)\\n\",\n\t\tjiffies - rcu_state.gp_start,\n\t\t(long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\n\trcu_check_gp_kthread_starvation();\n\n\trcu_dump_cpu_stacks();\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\tpanic_on_rcu_stall();\n\n\t/*\n\t * Attempt to revive the RCU machinery by forcing a context switch.\n\t *\n\t * A context switch would normally allow the RCU state machine to make\n\t * progress and it could be we're stuck in kernel space without context\n\t * switches for an entirely unreasonable amount of time.\n\t */\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void print_cpu_stall(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_cpu_stall_suppress)\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on ourselves...\n\t * See Documentation/RCU/stallwarn.txt for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\tpr_err(\"INFO: %s self-detected stall on CPU\", rcu_state.name);\n\tprint_cpu_stall_info_begin();\n\traw_spin_lock_irqsave_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info(smp_processor_id());\n\traw_spin_unlock_irqrestore_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info_end();\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_segcblist_n_cbs(&per_cpu_ptr(&rcu_data,\n\t\t\t\t\t\t\t    cpu)->cblist);\n\tpr_cont(\" (t=%lu jiffies g=%ld q=%lu)\\n\",\n\t\tjiffies - rcu_state.gp_start,\n\t\t(long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\n\trcu_check_gp_kthread_starvation();\n\n\trcu_dump_cpu_stacks();\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\tpanic_on_rcu_stall();\n\n\t/*\n\t * Attempt to revive the RCU machinery by forcing a context switch.\n\t *\n\t * A context switch would normally allow the RCU state machine to make\n\t * progress and it could be we're stuck in kernel space without context\n\t * switches for an entirely unreasonable amount of time.\n\t */\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&rcu_state.jiffies_stall",
            "js",
            "jn"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmask"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "454-470",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t       0",
            "#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_STALL_DELAY_DELTA\t       0\n#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "gps",
            "js"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "j",
            "js"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_start"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.jiffies_stall"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_stall_kick_kthreads",
          "args": [],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_kick_kthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1205-1220",
          "snippet": "static void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!rcu_kick_kthreads)\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static bool rcu_kick_kthreads;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic bool rcu_kick_kthreads;\n\nstatic void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!rcu_kick_kthreads)\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic bool rcu_kick_kthreads;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void check_cpu_stall(struct rcu_data *rdp)\n{\n\tunsigned long gs1;\n\tunsigned long gs2;\n\tunsigned long gps;\n\tunsigned long j;\n\tunsigned long jn;\n\tunsigned long js;\n\tstruct rcu_node *rnp;\n\n\tif ((rcu_cpu_stall_suppress && !rcu_kick_kthreads) ||\n\t    !rcu_gp_in_progress())\n\t\treturn;\n\trcu_stall_kick_kthreads();\n\tj = jiffies;\n\n\t/*\n\t * Lots of memory barriers to reject false positives.\n\t *\n\t * The idea is to pick up rcu_state.gp_seq, then\n\t * rcu_state.jiffies_stall, then rcu_state.gp_start, and finally\n\t * another copy of rcu_state.gp_seq.  These values are updated in\n\t * the opposite order with memory barriers (or equivalent) during\n\t * grace-period initialization and cleanup.  Now, a false positive\n\t * can occur if we get an new value of rcu_state.gp_start and a old\n\t * value of rcu_state.jiffies_stall.  But given the memory barriers,\n\t * the only way that this can happen is if one grace period ends\n\t * and another starts between these two fetches.  This is detected\n\t * by comparing the second fetch of rcu_state.gp_seq with the\n\t * previous fetch from rcu_state.gp_seq.\n\t *\n\t * Given this check, comparisons of jiffies, rcu_state.jiffies_stall,\n\t * and rcu_state.gp_start suffice to forestall false positives.\n\t */\n\tgs1 = READ_ONCE(rcu_state.gp_seq);\n\tsmp_rmb(); /* Pick up ->gp_seq first... */\n\tjs = READ_ONCE(rcu_state.jiffies_stall);\n\tsmp_rmb(); /* ...then ->jiffies_stall before the rest... */\n\tgps = READ_ONCE(rcu_state.gp_start);\n\tsmp_rmb(); /* ...and finally ->gp_start before ->gp_seq again. */\n\tgs2 = READ_ONCE(rcu_state.gp_seq);\n\tif (gs1 != gs2 ||\n\t    ULONG_CMP_LT(j, js) ||\n\t    ULONG_CMP_GE(gps, js))\n\t\treturn; /* No stall or GP completed since entering function. */\n\trnp = rdp->mynode;\n\tjn = jiffies + 3 * rcu_jiffies_till_stall_check() + 3;\n\tif (rcu_gp_in_progress() &&\n\t    (READ_ONCE(rnp->qsmask) & rdp->grpmask) &&\n\t    cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/* We haven't checked in, so go dump stack. */\n\t\tprint_cpu_stall();\n\n\t} else if (rcu_gp_in_progress() &&\n\t\t   ULONG_CMP_GE(j, js + RCU_STALL_RAT_DELAY) &&\n\t\t   cmpxchg(&rcu_state.jiffies_stall, js, jn) == js) {\n\n\t\t/* They had a few time units to dump stack, so complain. */\n\t\tprint_other_cpu_stall(gs2);\n\t}\n}"
  },
  {
    "function_name": "print_cpu_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1301-1354",
    "snippet": "static void print_cpu_stall(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_cpu_stall_suppress)\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on ourselves...\n\t * See Documentation/RCU/stallwarn.txt for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\tpr_err(\"INFO: %s self-detected stall on CPU\", rcu_state.name);\n\tprint_cpu_stall_info_begin();\n\traw_spin_lock_irqsave_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info(smp_processor_id());\n\traw_spin_unlock_irqrestore_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info_end();\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_segcblist_n_cbs(&per_cpu_ptr(&rcu_data,\n\t\t\t\t\t\t\t    cpu)->cblist);\n\tpr_cont(\" (t=%lu jiffies g=%ld q=%lu)\\n\",\n\t\tjiffies - rcu_state.gp_start,\n\t\t(long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\n\trcu_check_gp_kthread_starvation();\n\n\trcu_dump_cpu_stacks();\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\tpanic_on_rcu_stall();\n\n\t/*\n\t * Attempt to revive the RCU machinery by forcing a context switch.\n\t *\n\t * A context switch would normally allow the RCU state machine to make\n\t * progress and it could be we're stuck in kernel space without context\n\t * switches for an entirely unreasonable amount of time.\n\t */\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_preempt_need_resched",
          "args": [],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "current"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic_on_rcu_stall",
          "args": [],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "panic_on_rcu_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1222-1226",
          "snippet": "static void panic_on_rcu_stall(void)\n{\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_rcu_stall"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint sysctl_panic_on_rcu_stall;\n\nstatic void panic_on_rcu_stall(void)\n{\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_stall",
            "jiffies + 3 * rcu_jiffies_till_stall_check() + 3"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "454-470",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t       0",
            "#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_STALL_DELAY_DELTA\t       0\n#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "jiffies",
            "READ_ONCE(rcu_state.jiffies_stall)"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.jiffies_stall"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dump_cpu_stacks",
          "args": [],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dump_cpu_stacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1185-1199",
          "snippet": "static void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu))\n\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void sync_sched_exp_online_cleanup(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu))\n\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_check_gp_kthread_starvation",
          "args": [],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_gp_kthread_starvation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1158-1177",
          "snippet": "static void rcu_check_gp_kthread_starvation(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tj = jiffies - READ_ONCE(rcu_state.gp_activity);\n\tif (j > 2 * HZ) {\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#lx ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       rcu_state.gp_flags,\n\t\t       gp_state_getname(rcu_state.gp_state), rcu_state.gp_state,\n\t\t       gpk ? gpk->state : ~0, gpk ? task_cpu(gpk) : -1);\n\t\tif (gpk) {\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void sync_sched_exp_online_cleanup(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_check_gp_kthread_starvation(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tj = jiffies - READ_ONCE(rcu_state.gp_activity);\n\tif (j > 2 * HZ) {\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#lx ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       rcu_state.gp_flags,\n\t\t       gp_state_getname(rcu_state.gp_state), rcu_state.gp_state,\n\t\t       gpk ? gpk->state : ~0, gpk ? task_cpu(gpk) : -1);\n\t\tif (gpk) {\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" (t=%lu jiffies g=%ld q=%lu)\\n\"",
            "jiffies - rcu_state.gp_start",
            "(long)rcu_seq_current(&rcu_state.gp_seq)",
            "totqlen"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cpu_stall_info_end",
          "args": [],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall_info_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1840-1843",
          "snippet": "static void print_cpu_stall_info_end(void)\n{\n\tpr_err(\"\\t\");\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_info_end(void)\n{\n\tpr_err(\"\\t\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rdp->mynode",
            "flags"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cpu_stall_info",
          "args": [
            "smp_processor_id()"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1800-1837",
          "snippet": "static void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tchar fast_no_hz[72];\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tprint_cpu_stall_fast_no_hz(fast_no_hz, cpu);\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       READ_ONCE(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       fast_no_hz);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tchar fast_no_hz[72];\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tprint_cpu_stall_fast_no_hz(fast_no_hz, cpu);\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       READ_ONCE(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       fast_no_hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rdp->mynode",
            "flags"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cpu_stall_info_begin",
          "args": [],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall_info_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1784-1787",
          "snippet": "static void print_cpu_stall_info_begin(void)\n{\n\tpr_cont(\"\\n\");\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_info_begin(void)\n{\n\tpr_cont(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: %s self-detected stall on CPU\"",
            "rcu_state.name"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_stall_kick_kthreads",
          "args": [],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_kick_kthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1205-1220",
          "snippet": "static void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!rcu_kick_kthreads)\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static bool rcu_kick_kthreads;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic bool rcu_kick_kthreads;\n\nstatic void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!rcu_kick_kthreads)\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void print_cpu_stall(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_cpu_stall_suppress)\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on ourselves...\n\t * See Documentation/RCU/stallwarn.txt for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\tpr_err(\"INFO: %s self-detected stall on CPU\", rcu_state.name);\n\tprint_cpu_stall_info_begin();\n\traw_spin_lock_irqsave_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info(smp_processor_id());\n\traw_spin_unlock_irqrestore_rcu_node(rdp->mynode, flags);\n\tprint_cpu_stall_info_end();\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_segcblist_n_cbs(&per_cpu_ptr(&rcu_data,\n\t\t\t\t\t\t\t    cpu)->cblist);\n\tpr_cont(\" (t=%lu jiffies g=%ld q=%lu)\\n\",\n\t\tjiffies - rcu_state.gp_start,\n\t\t(long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\n\trcu_check_gp_kthread_starvation();\n\n\trcu_dump_cpu_stacks();\n\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\tpanic_on_rcu_stall();\n\n\t/*\n\t * Attempt to revive the RCU machinery by forcing a context switch.\n\t *\n\t * A context switch would normally allow the RCU state machine to make\n\t * progress and it could be we're stuck in kernel space without context\n\t * switches for an entirely unreasonable amount of time.\n\t */\n\tset_tsk_need_resched(current);\n\tset_preempt_need_resched();\n}"
  },
  {
    "function_name": "print_other_cpu_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1228-1299",
    "snippet": "static void print_other_cpu_stall(unsigned long gp_seq)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpa;\n\tunsigned long j;\n\tint ndetected = 0;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_cpu_stall_suppress)\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on our buddy...\n\t * See Documentation/RCU/stallwarn.txt for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\tpr_err(\"INFO: %s detected stalls on CPUs/tasks:\", rcu_state.name);\n\tprint_cpu_stall_info_begin();\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tndetected += rcu_print_task_stall(rnp);\n\t\tif (rnp->qsmask != 0) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\t\tprint_cpu_stall_info(cpu);\n\t\t\t\t\tndetected++;\n\t\t\t\t}\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\n\tprint_cpu_stall_info_end();\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_segcblist_n_cbs(&per_cpu_ptr(&rcu_data,\n\t\t\t\t\t\t\t    cpu)->cblist);\n\tpr_cont(\"(detected by %d, t=%ld jiffies, g=%ld, q=%lu)\\n\",\n\t       smp_processor_id(), (long)(jiffies - rcu_state.gp_start),\n\t       (long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\tif (ndetected) {\n\t\trcu_dump_cpu_stacks();\n\n\t\t/* Complain about tasks blocking the grace period. */\n\t\trcu_print_detail_task_stall();\n\t} else {\n\t\tif (rcu_seq_current(&rcu_state.gp_seq) != gp_seq) {\n\t\t\tpr_err(\"INFO: Stall ended before state dump start\\n\");\n\t\t} else {\n\t\t\tj = jiffies;\n\t\t\tgpa = READ_ONCE(rcu_state.gp_activity);\n\t\t\tpr_err(\"All QSes seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\",\n\t\t\t       rcu_state.name, j - gpa, j, gpa,\n\t\t\t       READ_ONCE(jiffies_till_next_fqs),\n\t\t\t       rcu_get_root()->qsmask);\n\t\t\t/* In this case, the current CPU might be at fault. */\n\t\t\tsched_show_task(current);\n\t\t}\n\t}\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\n\trcu_check_gp_kthread_starvation();\n\n\tpanic_on_rcu_stall();\n\n\tforce_quiescent_state();  /* Kick them all. */\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static ulong jiffies_till_next_fqs = ULONG_MAX;",
      "static void force_quiescent_state(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_quiescent_state",
          "args": [],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "force_quiescent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2566-2597",
          "snippet": "static void force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t      !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void force_quiescent_state(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void force_quiescent_state(void);\n\nstatic void force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t      !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic_on_rcu_stall",
          "args": [],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "panic_on_rcu_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1222-1226",
          "snippet": "static void panic_on_rcu_stall(void)\n{\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_rcu_stall"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint sysctl_panic_on_rcu_stall;\n\nstatic void panic_on_rcu_stall(void)\n{\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_check_gp_kthread_starvation",
          "args": [],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_gp_kthread_starvation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1158-1177",
          "snippet": "static void rcu_check_gp_kthread_starvation(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tj = jiffies - READ_ONCE(rcu_state.gp_activity);\n\tif (j > 2 * HZ) {\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#lx ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       rcu_state.gp_flags,\n\t\t       gp_state_getname(rcu_state.gp_state), rcu_state.gp_state,\n\t\t       gpk ? gpk->state : ~0, gpk ? task_cpu(gpk) : -1);\n\t\tif (gpk) {\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void sync_sched_exp_online_cleanup(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_check_gp_kthread_starvation(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tj = jiffies - READ_ONCE(rcu_state.gp_activity);\n\tif (j > 2 * HZ) {\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#lx ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       rcu_state.gp_flags,\n\t\t       gp_state_getname(rcu_state.gp_state), rcu_state.gp_state,\n\t\t       gpk ? gpk->state : ~0, gpk ? task_cpu(gpk) : -1);\n\t\tif (gpk) {\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_stall",
            "jiffies + 3 * rcu_jiffies_till_stall_check() + 3"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "454-470",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t       0",
            "#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_STALL_DELAY_DELTA\t       0\n#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "jiffies",
            "READ_ONCE(rcu_state.jiffies_stall)"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.jiffies_stall"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "current"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5268-5295",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"All QSes seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\"",
            "rcu_state.name",
            "j - gpa",
            "j",
            "gpa",
            "READ_ONCE(jiffies_till_next_fqs)",
            "rcu_get_root()->qsmask"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_root",
          "args": [],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "557-560",
          "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_next_fqs"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_activity"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: Stall ended before state dump start\\n\""
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_print_detail_task_stall",
          "args": [],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_print_detail_task_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1044-1046",
          "snippet": "static void rcu_print_detail_task_stall(void)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_print_detail_task_stall(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dump_cpu_stacks",
          "args": [],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dump_cpu_stacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1185-1199",
          "snippet": "static void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu))\n\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void sync_sched_exp_online_cleanup(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu))\n\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"(detected by %d, t=%ld jiffies, g=%ld, q=%lu)\\n\"",
            "smp_processor_id()",
            "(long)(jiffies - rcu_state.gp_start)",
            "(long)rcu_seq_current(&rcu_state.gp_seq)",
            "totqlen"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cpu_stall_info_end",
          "args": [],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall_info_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1840-1843",
          "snippet": "static void print_cpu_stall_info_end(void)\n{\n\tpr_err(\"\\t\");\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_info_end(void)\n{\n\tpr_err(\"\\t\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cpu_stall_info",
          "args": [
            "cpu"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1800-1837",
          "snippet": "static void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tchar fast_no_hz[72];\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tprint_cpu_stall_fast_no_hz(fast_no_hz, cpu);\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       READ_ONCE(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       fast_no_hz);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_info(int cpu)\n{\n\tunsigned long delta;\n\tchar fast_no_hz[72];\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tchar *ticks_title;\n\tunsigned long ticks_value;\n\n\t/*\n\t * We could be printing a lot while holding a spinlock.  Avoid\n\t * triggering hard lockup.\n\t */\n\ttouch_nmi_watchdog();\n\n\tticks_value = rcu_seq_ctr(rcu_state.gp_seq - rdp->gp_seq);\n\tif (ticks_value) {\n\t\tticks_title = \"GPs behind\";\n\t} else {\n\t\tticks_title = \"ticks this GP\";\n\t\tticks_value = rdp->ticks_this_gp;\n\t}\n\tprint_cpu_stall_fast_no_hz(fast_no_hz, cpu);\n\tdelta = rcu_seq_ctr(rdp->mynode->gp_seq - rdp->rcu_iw_gp_seq);\n\tpr_err(\"\\t%d-%c%c%c%c: (%lu %s) idle=%03x/%ld/%#lx softirq=%u/%u fqs=%ld %s\\n\",\n\t       cpu,\n\t       \"O.\"[!!cpu_online(cpu)],\n\t       \"o.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinit)],\n\t       \"N.\"[!!(rdp->grpmask & rdp->mynode->qsmaskinitnext)],\n\t       !IS_ENABLED(CONFIG_IRQ_WORK) ? '?' :\n\t\t\trdp->rcu_iw_pending ? (int)min(delta, 9UL) + '0' :\n\t\t\t\t\"!.\"[!delta],\n\t       ticks_value, ticks_title,\n\t       rcu_dynticks_snap(rdp) & 0xfff,\n\t       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,\n\t       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),\n\t       READ_ONCE(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,\n\t       fast_no_hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_print_task_stall",
          "args": [
            "rnp"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_print_task_stall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1052-1055",
          "snippet": "static int rcu_print_task_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic int rcu_print_task_stall(struct rcu_node *rnp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cpu_stall_info_begin",
          "args": [],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu_stall_info_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1784-1787",
          "snippet": "static void print_cpu_stall_info_begin(void)\n{\n\tpr_cont(\"\\n\");\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void print_cpu_stall_info_begin(void)\n{\n\tpr_cont(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: %s detected stalls on CPUs/tasks:\"",
            "rcu_state.name"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_stall_kick_kthreads",
          "args": [],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_stall_kick_kthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1205-1220",
          "snippet": "static void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!rcu_kick_kthreads)\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static bool rcu_kick_kthreads;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic bool rcu_kick_kthreads;\n\nstatic void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!rcu_kick_kthreads)\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic void force_quiescent_state(void);\n\nstatic void print_other_cpu_stall(unsigned long gp_seq)\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpa;\n\tunsigned long j;\n\tint ndetected = 0;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tlong totqlen = 0;\n\n\t/* Kick and suppress, if so configured. */\n\trcu_stall_kick_kthreads();\n\tif (rcu_cpu_stall_suppress)\n\t\treturn;\n\n\t/*\n\t * OK, time to rat on our buddy...\n\t * See Documentation/RCU/stallwarn.txt for info on how to debug\n\t * RCU CPU stall warnings.\n\t */\n\tpr_err(\"INFO: %s detected stalls on CPUs/tasks:\", rcu_state.name);\n\tprint_cpu_stall_info_begin();\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tndetected += rcu_print_task_stall(rnp);\n\t\tif (rnp->qsmask != 0) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu)) {\n\t\t\t\t\tprint_cpu_stall_info(cpu);\n\t\t\t\t\tndetected++;\n\t\t\t\t}\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\n\tprint_cpu_stall_info_end();\n\tfor_each_possible_cpu(cpu)\n\t\ttotqlen += rcu_segcblist_n_cbs(&per_cpu_ptr(&rcu_data,\n\t\t\t\t\t\t\t    cpu)->cblist);\n\tpr_cont(\"(detected by %d, t=%ld jiffies, g=%ld, q=%lu)\\n\",\n\t       smp_processor_id(), (long)(jiffies - rcu_state.gp_start),\n\t       (long)rcu_seq_current(&rcu_state.gp_seq), totqlen);\n\tif (ndetected) {\n\t\trcu_dump_cpu_stacks();\n\n\t\t/* Complain about tasks blocking the grace period. */\n\t\trcu_print_detail_task_stall();\n\t} else {\n\t\tif (rcu_seq_current(&rcu_state.gp_seq) != gp_seq) {\n\t\t\tpr_err(\"INFO: Stall ended before state dump start\\n\");\n\t\t} else {\n\t\t\tj = jiffies;\n\t\t\tgpa = READ_ONCE(rcu_state.gp_activity);\n\t\t\tpr_err(\"All QSes seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\",\n\t\t\t       rcu_state.name, j - gpa, j, gpa,\n\t\t\t       READ_ONCE(jiffies_till_next_fqs),\n\t\t\t       rcu_get_root()->qsmask);\n\t\t\t/* In this case, the current CPU might be at fault. */\n\t\t\tsched_show_task(current);\n\t\t}\n\t}\n\t/* Rewrite if needed in case of slow consoles. */\n\tif (ULONG_CMP_GE(jiffies, READ_ONCE(rcu_state.jiffies_stall)))\n\t\tWRITE_ONCE(rcu_state.jiffies_stall,\n\t\t\t   jiffies + 3 * rcu_jiffies_till_stall_check() + 3);\n\n\trcu_check_gp_kthread_starvation();\n\n\tpanic_on_rcu_stall();\n\n\tforce_quiescent_state();  /* Kick them all. */\n}"
  },
  {
    "function_name": "panic_on_rcu_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1222-1226",
    "snippet": "static void panic_on_rcu_stall(void)\n{\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_panic_on_rcu_stall"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"RCU Stall\\n\""
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_panic_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "181-185",
          "snippet": "static int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint sysctl_panic_on_rcu_stall;\n\nstatic void panic_on_rcu_stall(void)\n{\n\tif (sysctl_panic_on_rcu_stall)\n\t\tpanic(\"RCU Stall\\n\");\n}"
  },
  {
    "function_name": "rcu_stall_kick_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1205-1220",
    "snippet": "static void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!rcu_kick_kthreads)\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static bool rcu_kick_kthreads;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_state.jiffies_kick_kthreads",
            "j + HZ"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "rcu_state.gp_kthread"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Kicking %s grace-period kthread\\n\"",
            "rcu_state.name"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_in_progress",
          "args": [],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_in_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "205-208",
          "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "j"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.jiffies_kick_kthreads"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic bool rcu_kick_kthreads;\n\nstatic void rcu_stall_kick_kthreads(void)\n{\n\tunsigned long j;\n\n\tif (!rcu_kick_kthreads)\n\t\treturn;\n\tj = READ_ONCE(rcu_state.jiffies_kick_kthreads);\n\tif (time_after(jiffies, j) && rcu_state.gp_kthread &&\n\t    (rcu_gp_in_progress() || READ_ONCE(rcu_state.gp_flags))) {\n\t\tWARN_ONCE(1, \"Kicking %s grace-period kthread\\n\",\n\t\t\t  rcu_state.name);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t\twake_up_process(rcu_state.gp_kthread);\n\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads, j + HZ);\n\t}\n}"
  },
  {
    "function_name": "rcu_dump_cpu_stacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1185-1199",
    "snippet": "static void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu))\n\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
      "static void sync_sched_exp_online_cleanup(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_cpu_task",
          "args": [
            "cpu"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cpu_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "7007-7011",
          "snippet": "void dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_single_cpu_backtrace",
          "args": [
            "cpu"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_node_cpu_bit",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave_rcu_node",
          "args": [
            "rnp",
            "flags"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_dump_cpu_stacks(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\tstruct rcu_node *rnp;\n\n\trcu_for_each_leaf_node(rnp) {\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu)\n\t\t\tif (rnp->qsmask & leaf_node_cpu_bit(rnp, cpu))\n\t\t\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\t\t\tdump_cpu_task(cpu);\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n}"
  },
  {
    "function_name": "rcu_check_gp_kthread_starvation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1158-1177",
    "snippet": "static void rcu_check_gp_kthread_starvation(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tj = jiffies - READ_ONCE(rcu_state.gp_activity);\n\tif (j > 2 * HZ) {\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#lx ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       rcu_state.gp_flags,\n\t\t       gp_state_getname(rcu_state.gp_state), rcu_state.gp_state,\n\t\t       gpk ? gpk->state : ~0, gpk ? task_cpu(gpk) : -1);\n\t\tif (gpk) {\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void sync_sched_exp_online_cleanup(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "gpk"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "gpk"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5268-5295",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"RCU grace-period kthread stack dump:\\n\""
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#lx ->cpu=%d\\n\"",
            "rcu_state.name",
            "j",
            "(long)rcu_seq_current(&rcu_state.gp_seq)",
            "rcu_state.gp_flags",
            "gp_state_getname(rcu_state.gp_state)",
            "rcu_state.gp_state",
            "gpk ? gpk->state : ~0",
            "gpk ? task_cpu(gpk) : -1"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "gpk"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gp_state_getname",
          "args": [
            "rcu_state.gp_state"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "gp_state_getname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "1148-1153",
          "snippet": "static const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_activity"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nstatic void rcu_check_gp_kthread_starvation(void)\n{\n\tstruct task_struct *gpk = rcu_state.gp_kthread;\n\tunsigned long j;\n\n\tj = jiffies - READ_ONCE(rcu_state.gp_activity);\n\tif (j > 2 * HZ) {\n\t\tpr_err(\"%s kthread starved for %ld jiffies! g%ld f%#x %s(%d) ->state=%#lx ->cpu=%d\\n\",\n\t\t       rcu_state.name, j,\n\t\t       (long)rcu_seq_current(&rcu_state.gp_seq),\n\t\t       rcu_state.gp_flags,\n\t\t       gp_state_getname(rcu_state.gp_state), rcu_state.gp_state,\n\t\t       gpk ? gpk->state : ~0, gpk ? task_cpu(gpk) : -1);\n\t\tif (gpk) {\n\t\t\tpr_err(\"RCU grace-period kthread stack dump:\\n\");\n\t\t\tsched_show_task(gpk);\n\t\t\twake_up_process(gpk);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "gp_state_getname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1148-1153",
    "snippet": "static const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "gp_state_names"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic const char *gp_state_getname(short gs)\n{\n\tif (gs < 0 || gs >= ARRAY_SIZE(gp_state_names))\n\t\treturn \"???\";\n\treturn gp_state_names[gs];\n}"
  },
  {
    "function_name": "record_gp_stall_check_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1132-1143",
    "snippet": "static void record_gp_stall_check_time(void)\n{\n\tunsigned long j = jiffies;\n\tunsigned long j1;\n\n\trcu_state.gp_start = j;\n\tj1 = rcu_jiffies_till_stall_check();\n\t/* Record ->gp_start before ->jiffies_stall. */\n\tsmp_store_release(&rcu_state.jiffies_stall, j + j1); /* ^^^ */\n\trcu_state.jiffies_resched = j + j1 / 2;\n\trcu_state.n_force_qs_gpstart = READ_ONCE(rcu_state.n_force_qs);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.n_force_qs"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rcu_state.jiffies_stall",
            "j + j1"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_jiffies_till_stall_check",
          "args": [],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_jiffies_till_stall_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "454-470",
          "snippet": "int rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_STALL_DELAY_DELTA\t       0",
            "#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_STALL_DELAY_DELTA\t       0\n#define RCU_STALL_DELAY_DELTA\t       (5 * HZ)\n\nint rcu_jiffies_till_stall_check(void)\n{\n\tint till_stall_check = READ_ONCE(rcu_cpu_stall_timeout);\n\n\t/*\n\t * Limit check must be consistent with the Kconfig limits\n\t * for CONFIG_RCU_CPU_STALL_TIMEOUT.\n\t */\n\tif (till_stall_check < 3) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 3);\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check > 300) {\n\t\tWRITE_ONCE(rcu_cpu_stall_timeout, 300);\n\t\ttill_stall_check = 300;\n\t}\n\treturn till_stall_check * HZ + RCU_STALL_DELAY_DELTA;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic void record_gp_stall_check_time(void)\n{\n\tunsigned long j = jiffies;\n\tunsigned long j1;\n\n\trcu_state.gp_start = j;\n\tj1 = rcu_jiffies_till_stall_check();\n\t/* Record ->gp_start before ->jiffies_stall. */\n\tsmp_store_release(&rcu_state.jiffies_stall, j + j1); /* ^^^ */\n\trcu_state.jiffies_resched = j + j1 / 2;\n\trcu_state.n_force_qs_gpstart = READ_ONCE(rcu_state.n_force_qs);\n}"
  },
  {
    "function_name": "rcu_implicit_dynticks_qs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1025-1130",
    "snippet": "static int rcu_implicit_dynticks_qs(struct rcu_data *rdp)\n{\n\tunsigned long jtsq;\n\tbool *rnhqp;\n\tbool *ruqp;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/*\n\t * If the CPU passed through or entered a dynticks idle phase with\n\t * no active irq/NMI handlers, then we can safely pretend that the CPU\n\t * already acknowledged the request to pass through a quiescent\n\t * state.  Either way, that CPU cannot possibly be in an RCU\n\t * read-side critical section that started before the beginning\n\t * of the current RCU grace period.\n\t */\n\tif (rcu_dynticks_in_eqs_since(rdp, rdp->dynticks_snap)) {\n\t\ttrace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS(\"dti\"));\n\t\trcu_gpnum_ovf(rnp, rdp);\n\t\treturn 1;\n\t}\n\n\t/* If waiting too long on an offline CPU, complain. */\n\tif (!(rdp->grpmask & rcu_rnp_online_cpus(rnp)) &&\n\t    time_after(jiffies, rcu_state.gp_start + HZ)) {\n\t\tbool onl;\n\t\tstruct rcu_node *rnp1;\n\n\t\tWARN_ON(1);  /* Offline CPUs are supposed to report QS! */\n\t\tpr_info(\"%s: grp: %d-%d level: %d ->gp_seq %ld ->completedqs %ld\\n\",\n\t\t\t__func__, rnp->grplo, rnp->grphi, rnp->level,\n\t\t\t(long)rnp->gp_seq, (long)rnp->completedqs);\n\t\tfor (rnp1 = rnp; rnp1; rnp1 = rnp1->parent)\n\t\t\tpr_info(\"%s: %d:%d ->qsmask %#lx ->qsmaskinit %#lx ->qsmaskinitnext %#lx ->rcu_gp_init_mask %#lx\\n\",\n\t\t\t\t__func__, rnp1->grplo, rnp1->grphi, rnp1->qsmask, rnp1->qsmaskinit, rnp1->qsmaskinitnext, rnp1->rcu_gp_init_mask);\n\t\tonl = !!(rdp->grpmask & rcu_rnp_online_cpus(rnp));\n\t\tpr_info(\"%s %d: %c online: %ld(%d) offline: %ld(%d)\\n\",\n\t\t\t__func__, rdp->cpu, \".o\"[onl],\n\t\t\t(long)rdp->rcu_onl_gp_seq, rdp->rcu_onl_gp_flags,\n\t\t\t(long)rdp->rcu_ofl_gp_seq, rdp->rcu_ofl_gp_flags);\n\t\treturn 1; /* Break things loose after complaining. */\n\t}\n\n\t/*\n\t * A CPU running for an extended time within the kernel can\n\t * delay RCU grace periods: (1) At age jiffies_to_sched_qs,\n\t * set .rcu_urgent_qs, (2) At age 2*jiffies_to_sched_qs, set\n\t * both .rcu_need_heavy_qs and .rcu_urgent_qs.  Note that the\n\t * unsynchronized assignments to the per-CPU rcu_need_heavy_qs\n\t * variable are safe because the assignments are repeated if this\n\t * CPU failed to pass through a quiescent state.  This code\n\t * also checks .jiffies_resched in case jiffies_to_sched_qs\n\t * is set way high.\n\t */\n\tjtsq = READ_ONCE(jiffies_to_sched_qs);\n\truqp = per_cpu_ptr(&rcu_data.rcu_urgent_qs, rdp->cpu);\n\trnhqp = &per_cpu(rcu_data.rcu_need_heavy_qs, rdp->cpu);\n\tif (!READ_ONCE(*rnhqp) &&\n\t    (time_after(jiffies, rcu_state.gp_start + jtsq * 2) ||\n\t     time_after(jiffies, rcu_state.jiffies_resched))) {\n\t\tWRITE_ONCE(*rnhqp, true);\n\t\t/* Store rcu_need_heavy_qs before rcu_urgent_qs. */\n\t\tsmp_store_release(ruqp, true);\n\t} else if (time_after(jiffies, rcu_state.gp_start + jtsq)) {\n\t\tWRITE_ONCE(*ruqp, true);\n\t}\n\n\t/*\n\t * NO_HZ_FULL CPUs can run in-kernel without rcu_check_callbacks!\n\t * The above code handles this, but only for straight cond_resched().\n\t * And some in-kernel loops check need_resched() before calling\n\t * cond_resched(), which defeats the above code for CPUs that are\n\t * running in-kernel with scheduling-clock interrupts disabled.\n\t * So hit them over the head with the resched_cpu() hammer!\n\t */\n\tif (tick_nohz_full_cpu(rdp->cpu) &&\n\t\t   time_after(jiffies,\n\t\t\t      READ_ONCE(rdp->last_fqs_resched) + jtsq * 3)) {\n\t\tresched_cpu(rdp->cpu);\n\t\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n\t}\n\n\t/*\n\t * If more than halfway to RCU CPU stall-warning time, invoke\n\t * resched_cpu() more frequently to try to loosen things up a bit.\n\t * Also check to see if the CPU is getting hammered with interrupts,\n\t * but only once per grace period, just to keep the IPIs down to\n\t * a dull roar.\n\t */\n\tif (time_after(jiffies, rcu_state.jiffies_resched)) {\n\t\tif (time_after(jiffies,\n\t\t\t       READ_ONCE(rdp->last_fqs_resched) + jtsq)) {\n\t\t\tresched_cpu(rdp->cpu);\n\t\t\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_IRQ_WORK) &&\n\t\t    !rdp->rcu_iw_pending && rdp->rcu_iw_gp_seq != rnp->gp_seq &&\n\t\t    (rnp->ffmask & rdp->grpmask)) {\n\t\t\tinit_irq_work(&rdp->rcu_iw, rcu_iw_handler);\n\t\t\trdp->rcu_iw_pending = true;\n\t\t\trdp->rcu_iw_gp_seq = rnp->gp_seq;\n\t\t\tirq_work_queue_on(&rdp->rcu_iw, rdp->cpu);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static ulong jiffies_to_sched_qs;",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue_on",
          "args": [
            "&rdp->rcu_iw",
            "rdp->cpu"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "65-87",
          "snippet": "bool irq_work_queue_on(struct irq_work *work, int cpu)\n{\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(cpu));\n\n#ifdef CONFIG_SMP\n\n\t/* Arch remote IPI send/receive backend aren't NMI safe */\n\tWARN_ON_ONCE(in_nmi());\n\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\tif (llist_add(&work->llnode, &per_cpu(raised_list, cpu)))\n\t\tarch_send_call_function_single_ipi(cpu);\n\n#else /* #ifdef CONFIG_SMP */\n\tirq_work_queue(work);\n#endif /* #else #ifdef CONFIG_SMP */\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\n\nbool irq_work_queue_on(struct irq_work *work, int cpu)\n{\n\t/* All work should have been flushed before going offline */\n\tWARN_ON_ONCE(cpu_is_offline(cpu));\n\n#ifdef CONFIG_SMP\n\n\t/* Arch remote IPI send/receive backend aren't NMI safe */\n\tWARN_ON_ONCE(in_nmi());\n\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\tif (llist_add(&work->llnode, &per_cpu(raised_list, cpu)))\n\t\tarch_send_call_function_single_ipi(cpu);\n\n#else /* #ifdef CONFIG_SMP */\n\tirq_work_queue(work);\n#endif /* #else #ifdef CONFIG_SMP */\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&rdp->rcu_iw",
            "rcu_iw_handler"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IRQ_WORK"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->last_fqs_resched",
            "jiffies"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resched_cpu",
          "args": [
            "rdp->cpu"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "resched_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "476-485",
          "snippet": "void resched_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\tif (cpu_online(cpu) || cpu == smp_processor_id())\n\t\tresched_curr(rq);\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\tif (cpu_online(cpu) || cpu == smp_processor_id())\n\t\tresched_curr(rq);\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "READ_ONCE(rdp->last_fqs_resched) + jtsq"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->last_fqs_resched"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.jiffies_resched"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->last_fqs_resched",
            "jiffies"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "READ_ONCE(rdp->last_fqs_resched) + jtsq * 3"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rdp->last_fqs_resched"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "rdp->cpu"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*ruqp",
            "true"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.gp_start + jtsq"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "ruqp",
            "true"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*rnhqp",
            "true"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.jiffies_resched"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.gp_start + jtsq * 2"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*rnhqp"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "rcu_data.rcu_need_heavy_qs",
            "rdp->cpu"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data.rcu_urgent_qs",
            "rdp->cpu"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_to_sched_qs"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s %d: %c online: %ld(%d) offline: %ld(%d)\\n\"",
            "__func__",
            "rdp->cpu",
            "\".o\"[onl]",
            "(long)rdp->rcu_onl_gp_seq",
            "rdp->rcu_onl_gp_flags",
            "(long)rdp->rcu_ofl_gp_seq",
            "rdp->rcu_ofl_gp_flags"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rnp_online_cpus",
          "args": [
            "rnp"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rnp_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "195-198",
          "snippet": "unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nunsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: %d:%d ->qsmask %#lx ->qsmaskinit %#lx ->qsmaskinitnext %#lx ->rcu_gp_init_mask %#lx\\n\"",
            "__func__",
            "rnp1->grplo",
            "rnp1->grphi",
            "rnp1->qsmask",
            "rnp1->qsmaskinit",
            "rnp1->qsmaskinitnext",
            "rnp1->rcu_gp_init_mask"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: grp: %d-%d level: %d ->gp_seq %ld ->completedqs %ld\\n\"",
            "__func__",
            "rnp->grplo",
            "rnp->grphi",
            "rnp->level",
            "(long)rnp->gp_seq",
            "(long)rnp->completedqs"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "rcu_state.gp_start + HZ"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gpnum_ovf",
          "args": [
            "rnp",
            "rdp"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gpnum_ovf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "972-980",
          "snippet": "static void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_fqs",
          "args": [
            "rcu_state.name",
            "rdp->gp_seq",
            "rdp->cpu",
            "TPS(\"dti\")"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"dti\""
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs_since",
          "args": [
            "rdp",
            "rdp->dynticks_snap"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs_since",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "320-323",
          "snippet": "static bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic ulong jiffies_to_sched_qs;\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int rcu_implicit_dynticks_qs(struct rcu_data *rdp)\n{\n\tunsigned long jtsq;\n\tbool *rnhqp;\n\tbool *ruqp;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/*\n\t * If the CPU passed through or entered a dynticks idle phase with\n\t * no active irq/NMI handlers, then we can safely pretend that the CPU\n\t * already acknowledged the request to pass through a quiescent\n\t * state.  Either way, that CPU cannot possibly be in an RCU\n\t * read-side critical section that started before the beginning\n\t * of the current RCU grace period.\n\t */\n\tif (rcu_dynticks_in_eqs_since(rdp, rdp->dynticks_snap)) {\n\t\ttrace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS(\"dti\"));\n\t\trcu_gpnum_ovf(rnp, rdp);\n\t\treturn 1;\n\t}\n\n\t/* If waiting too long on an offline CPU, complain. */\n\tif (!(rdp->grpmask & rcu_rnp_online_cpus(rnp)) &&\n\t    time_after(jiffies, rcu_state.gp_start + HZ)) {\n\t\tbool onl;\n\t\tstruct rcu_node *rnp1;\n\n\t\tWARN_ON(1);  /* Offline CPUs are supposed to report QS! */\n\t\tpr_info(\"%s: grp: %d-%d level: %d ->gp_seq %ld ->completedqs %ld\\n\",\n\t\t\t__func__, rnp->grplo, rnp->grphi, rnp->level,\n\t\t\t(long)rnp->gp_seq, (long)rnp->completedqs);\n\t\tfor (rnp1 = rnp; rnp1; rnp1 = rnp1->parent)\n\t\t\tpr_info(\"%s: %d:%d ->qsmask %#lx ->qsmaskinit %#lx ->qsmaskinitnext %#lx ->rcu_gp_init_mask %#lx\\n\",\n\t\t\t\t__func__, rnp1->grplo, rnp1->grphi, rnp1->qsmask, rnp1->qsmaskinit, rnp1->qsmaskinitnext, rnp1->rcu_gp_init_mask);\n\t\tonl = !!(rdp->grpmask & rcu_rnp_online_cpus(rnp));\n\t\tpr_info(\"%s %d: %c online: %ld(%d) offline: %ld(%d)\\n\",\n\t\t\t__func__, rdp->cpu, \".o\"[onl],\n\t\t\t(long)rdp->rcu_onl_gp_seq, rdp->rcu_onl_gp_flags,\n\t\t\t(long)rdp->rcu_ofl_gp_seq, rdp->rcu_ofl_gp_flags);\n\t\treturn 1; /* Break things loose after complaining. */\n\t}\n\n\t/*\n\t * A CPU running for an extended time within the kernel can\n\t * delay RCU grace periods: (1) At age jiffies_to_sched_qs,\n\t * set .rcu_urgent_qs, (2) At age 2*jiffies_to_sched_qs, set\n\t * both .rcu_need_heavy_qs and .rcu_urgent_qs.  Note that the\n\t * unsynchronized assignments to the per-CPU rcu_need_heavy_qs\n\t * variable are safe because the assignments are repeated if this\n\t * CPU failed to pass through a quiescent state.  This code\n\t * also checks .jiffies_resched in case jiffies_to_sched_qs\n\t * is set way high.\n\t */\n\tjtsq = READ_ONCE(jiffies_to_sched_qs);\n\truqp = per_cpu_ptr(&rcu_data.rcu_urgent_qs, rdp->cpu);\n\trnhqp = &per_cpu(rcu_data.rcu_need_heavy_qs, rdp->cpu);\n\tif (!READ_ONCE(*rnhqp) &&\n\t    (time_after(jiffies, rcu_state.gp_start + jtsq * 2) ||\n\t     time_after(jiffies, rcu_state.jiffies_resched))) {\n\t\tWRITE_ONCE(*rnhqp, true);\n\t\t/* Store rcu_need_heavy_qs before rcu_urgent_qs. */\n\t\tsmp_store_release(ruqp, true);\n\t} else if (time_after(jiffies, rcu_state.gp_start + jtsq)) {\n\t\tWRITE_ONCE(*ruqp, true);\n\t}\n\n\t/*\n\t * NO_HZ_FULL CPUs can run in-kernel without rcu_check_callbacks!\n\t * The above code handles this, but only for straight cond_resched().\n\t * And some in-kernel loops check need_resched() before calling\n\t * cond_resched(), which defeats the above code for CPUs that are\n\t * running in-kernel with scheduling-clock interrupts disabled.\n\t * So hit them over the head with the resched_cpu() hammer!\n\t */\n\tif (tick_nohz_full_cpu(rdp->cpu) &&\n\t\t   time_after(jiffies,\n\t\t\t      READ_ONCE(rdp->last_fqs_resched) + jtsq * 3)) {\n\t\tresched_cpu(rdp->cpu);\n\t\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n\t}\n\n\t/*\n\t * If more than halfway to RCU CPU stall-warning time, invoke\n\t * resched_cpu() more frequently to try to loosen things up a bit.\n\t * Also check to see if the CPU is getting hammered with interrupts,\n\t * but only once per grace period, just to keep the IPIs down to\n\t * a dull roar.\n\t */\n\tif (time_after(jiffies, rcu_state.jiffies_resched)) {\n\t\tif (time_after(jiffies,\n\t\t\t       READ_ONCE(rdp->last_fqs_resched) + jtsq)) {\n\t\t\tresched_cpu(rdp->cpu);\n\t\t\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_IRQ_WORK) &&\n\t\t    !rdp->rcu_iw_pending && rdp->rcu_iw_gp_seq != rnp->gp_seq &&\n\t\t    (rnp->ffmask & rdp->grpmask)) {\n\t\t\tinit_irq_work(&rdp->rcu_iw, rcu_iw_handler);\n\t\t\trdp->rcu_iw_pending = true;\n\t\t\trdp->rcu_iw_gp_seq = rnp->gp_seq;\n\t\t\tirq_work_queue_on(&rdp->rcu_iw, rdp->cpu);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_iw_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "1004-1017",
    "snippet": "static void rcu_iw_handler(struct irq_work *iwp)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = container_of(iwp, struct rcu_data, rcu_iw);\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\n\tif (!WARN_ON_ONCE(!rdp->rcu_iw_pending)) {\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq;\n\t\trdp->rcu_iw_pending = false;\n\t}\n\traw_spin_unlock_rcu_node(rnp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rdp->rcu_iw_pending"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "iwp",
            "structrcu_data",
            "rcu_iw"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_iw_handler(struct irq_work *iwp)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = container_of(iwp, struct rcu_data, rcu_iw);\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\n\tif (!WARN_ON_ONCE(!rdp->rcu_iw_pending)) {\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq;\n\t\trdp->rcu_iw_pending = false;\n\t}\n\traw_spin_unlock_rcu_node(rnp);\n}"
  },
  {
    "function_name": "dyntick_save_progress_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "987-996",
    "snippet": "static int dyntick_save_progress_counter(struct rcu_data *rdp)\n{\n\trdp->dynticks_snap = rcu_dynticks_snap(rdp);\n\tif (rcu_dynticks_in_eqs(rdp->dynticks_snap)) {\n\t\ttrace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS(\"dti\"));\n\t\trcu_gpnum_ovf(rdp->mynode, rdp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_gpnum_ovf",
          "args": [
            "rdp->mynode",
            "rdp"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gpnum_ovf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "972-980",
          "snippet": "static void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_rcu_fqs",
          "args": [
            "rcu_state.name",
            "rdp->gp_seq",
            "rdp->cpu",
            "TPS(\"dti\")"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"dti\""
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_in_eqs",
          "args": [
            "rdp->dynticks_snap"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_in_eqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "310-313",
          "snippet": "static bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & RCU_DYNTICK_CTRL_CTR);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & RCU_DYNTICK_CTRL_CTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "299-304",
          "snippet": "int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_MASK 0x1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic int dyntick_save_progress_counter(struct rcu_data *rdp)\n{\n\trdp->dynticks_snap = rcu_dynticks_snap(rdp);\n\tif (rcu_dynticks_in_eqs(rdp->dynticks_snap)) {\n\t\ttrace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS(\"dti\"));\n\t\trcu_gpnum_ovf(rdp->mynode, rdp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_gpnum_ovf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "972-980",
    "snippet": "static void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rdp->rcu_iw_gp_seq + ULONG_MAX / 4",
            "rnp->gp_seq"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->gpwrap",
            "true"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4",
            "rnp->gp_seq"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rdp->gp_seq"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_lockdep_assert_held_rcu_node",
          "args": [
            "rnp"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}"
  },
  {
    "function_name": "rcu_lockdep_current_cpu_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "945-960",
    "snippet": "bool rcu_lockdep_current_cpu_online(void)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool ret = false;\n\n\tif (in_nmi() || !rcu_scheduler_fully_active)\n\t\treturn true;\n\tpreempt_disable();\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (rdp->grpmask & rcu_rnp_online_cpus(rnp))\n\t\tret = true;\n\tpreempt_enable();\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static int rcu_scheduler_fully_active",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_rnp_online_cpus",
          "args": [
            "rnp"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_rnp_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "195-198",
          "snippet": "unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nunsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic int rcu_scheduler_fully_active;\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_lockdep_current_cpu_online(void)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool ret = false;\n\n\tif (in_nmi() || !rcu_scheduler_fully_active)\n\t\treturn true;\n\tpreempt_disable();\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (rdp->grpmask & rcu_rnp_online_cpus(rnp))\n\t\tret = true;\n\tpreempt_enable();\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_request_urgent_qs_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "919-928",
    "snippet": "void rcu_request_urgent_qs_task(struct task_struct *t)\n{\n\tint cpu;\n\n\tbarrier();\n\tcpu = task_cpu(t);\n\tif (!task_curr(t))\n\t\treturn; /* This task is not running on that CPU. */\n\tsmp_store_release(per_cpu_ptr(&rcu_data.rcu_urgent_qs, cpu), true);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void sync_sched_exp_online_cleanup(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "per_cpu_ptr(&rcu_data.rcu_urgent_qs, cpu)",
            "true"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data.rcu_urgent_qs",
            "cpu"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_curr",
          "args": [
            "t"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "task_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "816-819",
          "snippet": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "t"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3068-3150",
          "snippet": "void rcu_barrier(void)\n{\n\tint cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t   rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to one rather than to zero in order to\n\t * avoid a too-soon return to zero in case of a short grace period\n\t * (or preemption of this task).  Exclude CPU-hotplug operations\n\t * to ensure that no offline CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 1);\n\tget_online_cpus();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tif (!cpu_online(cpu) && !rcu_is_nocb_cpu(cpu))\n\t\t\tcontinue;\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rcu_is_nocb_cpu(cpu)) {\n\t\t\tif (!rcu_nocb_cpu_needs_barrier(cpu)) {\n\t\t\t\trcu_barrier_trace(TPS(\"OfflineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t} else {\n\t\t\t\trcu_barrier_trace(TPS(\"OnlineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t\tsmp_mb__before_atomic();\n\t\t\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t\t\t\t__call_rcu(&rdp->barrier_head,\n\t\t\t\t\t   rcu_barrier_callback, cpu, 0);\n\t\t\t}\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, NULL, 1);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tput_online_cpus();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_barrier(void)\n{\n\tint cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t   rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to one rather than to zero in order to\n\t * avoid a too-soon return to zero in case of a short grace period\n\t * (or preemption of this task).  Exclude CPU-hotplug operations\n\t * to ensure that no offline CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 1);\n\tget_online_cpus();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tif (!cpu_online(cpu) && !rcu_is_nocb_cpu(cpu))\n\t\t\tcontinue;\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rcu_is_nocb_cpu(cpu)) {\n\t\t\tif (!rcu_nocb_cpu_needs_barrier(cpu)) {\n\t\t\t\trcu_barrier_trace(TPS(\"OfflineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t} else {\n\t\t\t\trcu_barrier_trace(TPS(\"OnlineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t\tsmp_mb__before_atomic();\n\t\t\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t\t\t\t__call_rcu(&rdp->barrier_head,\n\t\t\t\t\t   rcu_barrier_callback, cpu, 0);\n\t\t\t}\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, NULL, 1);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tput_online_cpus();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void sync_sched_exp_online_cleanup(int cpu);\n\nvoid rcu_request_urgent_qs_task(struct task_struct *t)\n{\n\tint cpu;\n\n\tbarrier();\n\tcpu = task_cpu(t);\n\tif (!task_curr(t))\n\t\treturn; /* This task is not running on that CPU. */\n\tsmp_store_release(per_cpu_ptr(&rcu_data.rcu_urgent_qs, cpu), true);\n}"
  },
  {
    "function_name": "rcu_is_watching",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "901-909",
    "snippet": "bool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_curr_cpu_in_eqs",
          "args": [],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_curr_cpu_in_eqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "288-293",
          "snippet": "bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool notrace rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
  },
  {
    "function_name": "rcu_irq_enter_irqson",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "884-891",
    "snippet": "void rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_irq_enter",
          "args": [],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_irq_enter_irqson",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "884-891",
          "snippet": "void rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rcu_irq_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "872-876",
    "snippet": "void rcu_irq_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_enter_common(true);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nmi_enter_common",
          "args": [
            "true"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nmi_enter_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "806-840",
          "snippet": "static __always_inline void rcu_nmi_enter_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tlong incby = 2;\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (irq)\n\t\t\trcu_dynticks_task_exit();\n\n\t\trcu_dynticks_eqs_exit();\n\n\t\tif (irq)\n\t\t\trcu_cleanup_after_idle();\n\n\t\tincby = 1;\n\t}\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic __always_inline void rcu_nmi_enter_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tlong incby = 2;\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (irq)\n\t\t\trcu_dynticks_task_exit();\n\n\t\trcu_dynticks_eqs_exit();\n\n\t\tif (irq)\n\t\t\trcu_cleanup_after_idle();\n\n\t\tincby = 1;\n\t}\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_irq_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_enter_common(true);\n}"
  },
  {
    "function_name": "rcu_nmi_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "845-848",
    "snippet": "void rcu_nmi_enter(void)\n{\n\trcu_nmi_enter_common(false);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nmi_enter_common",
          "args": [
            "false"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nmi_enter_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "806-840",
          "snippet": "static __always_inline void rcu_nmi_enter_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tlong incby = 2;\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (irq)\n\t\t\trcu_dynticks_task_exit();\n\n\t\trcu_dynticks_eqs_exit();\n\n\t\tif (irq)\n\t\t\trcu_cleanup_after_idle();\n\n\t\tincby = 1;\n\t}\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic __always_inline void rcu_nmi_enter_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tlong incby = 2;\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (irq)\n\t\t\trcu_dynticks_task_exit();\n\n\t\trcu_dynticks_eqs_exit();\n\n\t\tif (irq)\n\t\t\trcu_cleanup_after_idle();\n\n\t\tincby = 1;\n\t}\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_nmi_enter(void)\n{\n\trcu_nmi_enter_common(false);\n}"
  },
  {
    "function_name": "rcu_nmi_enter_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "806-840",
    "snippet": "static __always_inline void rcu_nmi_enter_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tlong incby = 2;\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (irq)\n\t\t\trcu_dynticks_task_exit();\n\n\t\trcu_dynticks_eqs_exit();\n\n\t\tif (irq)\n\t\t\trcu_cleanup_after_idle();\n\n\t\tincby = 1;\n\t}\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "3068-3150",
          "snippet": "void rcu_barrier(void)\n{\n\tint cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t   rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to one rather than to zero in order to\n\t * avoid a too-soon return to zero in case of a short grace period\n\t * (or preemption of this task).  Exclude CPU-hotplug operations\n\t * to ensure that no offline CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 1);\n\tget_online_cpus();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tif (!cpu_online(cpu) && !rcu_is_nocb_cpu(cpu))\n\t\t\tcontinue;\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rcu_is_nocb_cpu(cpu)) {\n\t\t\tif (!rcu_nocb_cpu_needs_barrier(cpu)) {\n\t\t\t\trcu_barrier_trace(TPS(\"OfflineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t} else {\n\t\t\t\trcu_barrier_trace(TPS(\"OnlineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t\tsmp_mb__before_atomic();\n\t\t\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t\t\t\t__call_rcu(&rdp->barrier_head,\n\t\t\t\t\t   rcu_barrier_callback, cpu, 0);\n\t\t\t}\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, NULL, 1);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tput_online_cpus();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid rcu_barrier(void)\n{\n\tint cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t   rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to one rather than to zero in order to\n\t * avoid a too-soon return to zero in case of a short grace period\n\t * (or preemption of this task).  Exclude CPU-hotplug operations\n\t * to ensure that no offline CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 1);\n\tget_online_cpus();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tif (!cpu_online(cpu) && !rcu_is_nocb_cpu(cpu))\n\t\t\tcontinue;\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (rcu_is_nocb_cpu(cpu)) {\n\t\t\tif (!rcu_nocb_cpu_needs_barrier(cpu)) {\n\t\t\t\trcu_barrier_trace(TPS(\"OfflineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t} else {\n\t\t\t\trcu_barrier_trace(TPS(\"OnlineNoCB\"), cpu,\n\t\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\t\tsmp_mb__before_atomic();\n\t\t\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t\t\t\t__call_rcu(&rdp->barrier_head,\n\t\t\t\t\t   rcu_barrier_callback, cpu, 0);\n\t\t\t}\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, NULL, 1);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t   rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tput_online_cpus();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting",
            "/* Prevent store tearing. */rdp->dynticks_nmi_nesting + incby"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_dyntick",
          "args": [
            "incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\")",
            "rdp->dynticks_nmi_nesting",
            "rdp->dynticks_nmi_nesting + incby",
            "rdp->dynticks"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"++=\""
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Endirq\""
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cleanup_after_idle",
          "args": [],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cleanup_after_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1736-1743",
          "snippet": "static void rcu_cleanup_after_idle(void)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\tif (rcu_try_advance_all_cbs())\n\t\tinvoke_rcu_core();\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_cleanup_after_idle(void)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\tif (rcu_try_advance_all_cbs())\n\t\tinvoke_rcu_core();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_eqs_exit",
          "args": [],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_eqs_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "243-262",
          "snippet": "static void rcu_dynticks_eqs_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     !(seq & RCU_DYNTICK_CTRL_CTR));\n\tif (seq & RCU_DYNTICK_CTRL_MASK) {\n\t\tatomic_andnot(RCU_DYNTICK_CTRL_MASK, &rdp->dynticks);\n\t\tsmp_mb__after_atomic(); /* _exit after clearing mask. */\n\t\t/* Prefer duplicate flushes to losing a flush. */\n\t\trcu_eqs_special_exit();\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)",
            "#define RCU_DYNTICK_CTRL_MASK 0x1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_dynticks_eqs_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     !(seq & RCU_DYNTICK_CTRL_CTR));\n\tif (seq & RCU_DYNTICK_CTRL_MASK) {\n\t\tatomic_andnot(RCU_DYNTICK_CTRL_MASK, &rdp->dynticks);\n\t\tsmp_mb__after_atomic(); /* _exit after clearing mask. */\n\t\t/* Prefer duplicate flushes to losing a flush. */\n\t\trcu_eqs_special_exit();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_task_exit",
          "args": [],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_task_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2691-2696",
          "snippet": "static void rcu_dynticks_task_exit(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, -1);\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_dynticks_task_exit(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, -1);\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_curr_cpu_in_eqs",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_curr_cpu_in_eqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "288-293",
          "snippet": "bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting < 0"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic __always_inline void rcu_nmi_enter_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tlong incby = 2;\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (irq)\n\t\t\trcu_dynticks_task_exit();\n\n\t\trcu_dynticks_eqs_exit();\n\n\t\tif (irq)\n\t\t\trcu_cleanup_after_idle();\n\n\t\tincby = 1;\n\t}\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}"
  },
  {
    "function_name": "rcu_user_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "787-790",
    "snippet": "void rcu_user_exit(void)\n{\n\trcu_eqs_exit(1);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_eqs_exit",
          "args": [
            "1"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_eqs_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "736-757",
          "snippet": "static void rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\trcu_dynticks_eqs_exit();\n\trcu_cleanup_after_idle();\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\trcu_dynticks_eqs_exit();\n\trcu_cleanup_after_idle();\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_user_exit(void)\n{\n\trcu_eqs_exit(1);\n}"
  },
  {
    "function_name": "rcu_idle_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "768-775",
    "snippet": "void rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_eqs_exit",
          "args": [
            "false"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_eqs_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "736-757",
          "snippet": "static void rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\trcu_dynticks_eqs_exit();\n\trcu_cleanup_after_idle();\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\trcu_dynticks_eqs_exit();\n\trcu_cleanup_after_idle();\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rcu_eqs_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "736-757",
    "snippet": "static void rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\trcu_dynticks_eqs_exit();\n\trcu_cleanup_after_idle();\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting",
            "DYNTICK_IRQ_NONIDLE"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nesting",
            "1"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current)"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_dyntick",
          "args": [
            "TPS(\"End\")",
            "rdp->dynticks_nesting",
            "1",
            "rdp->dynticks"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"End\""
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cleanup_after_idle",
          "args": [],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cleanup_after_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1736-1743",
          "snippet": "static void rcu_cleanup_after_idle(void)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\tif (rcu_try_advance_all_cbs())\n\t\tinvoke_rcu_core();\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_cleanup_after_idle(void)\n{\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\tif (rcu_try_advance_all_cbs())\n\t\tinvoke_rcu_core();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_eqs_exit",
          "args": [],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_eqs_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "243-262",
          "snippet": "static void rcu_dynticks_eqs_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     !(seq & RCU_DYNTICK_CTRL_CTR));\n\tif (seq & RCU_DYNTICK_CTRL_MASK) {\n\t\tatomic_andnot(RCU_DYNTICK_CTRL_MASK, &rdp->dynticks);\n\t\tsmp_mb__after_atomic(); /* _exit after clearing mask. */\n\t\t/* Prefer duplicate flushes to losing a flush. */\n\t\trcu_eqs_special_exit();\n\t}\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)",
            "#define RCU_DYNTICK_CTRL_MASK 0x1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_dynticks_eqs_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     !(seq & RCU_DYNTICK_CTRL_CTR));\n\tif (seq & RCU_DYNTICK_CTRL_MASK) {\n\t\tatomic_andnot(RCU_DYNTICK_CTRL_MASK, &rdp->dynticks);\n\t\tsmp_mb__after_atomic(); /* _exit after clearing mask. */\n\t\t/* Prefer duplicate flushes to losing a flush. */\n\t\trcu_eqs_special_exit();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_task_exit",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_task_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2691-2696",
          "snippet": "static void rcu_dynticks_task_exit(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, -1);\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_dynticks_task_exit(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, -1);\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\trcu_dynticks_eqs_exit();\n\trcu_cleanup_after_idle();\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n}"
  },
  {
    "function_name": "rcu_irq_exit_irqson",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "719-726",
    "snippet": "void rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_irq_exit",
          "args": [],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_irq_exit_irqson",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "719-726",
          "snippet": "void rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rcu_irq_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "707-711",
    "snippet": "void rcu_irq_exit(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_exit_common(true);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nmi_exit_common",
          "args": [
            "true"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nmi_exit_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "640-674",
          "snippet": "static __always_inline void rcu_nmi_exit_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2, rdp->dynticks);\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\tif (irq)\n\t\trcu_prepare_for_idle();\n\n\trcu_dynticks_eqs_enter();\n\n\tif (irq)\n\t\trcu_dynticks_task_enter();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic __always_inline void rcu_nmi_exit_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2, rdp->dynticks);\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\tif (irq)\n\t\trcu_prepare_for_idle();\n\n\trcu_dynticks_eqs_enter();\n\n\tif (irq)\n\t\trcu_dynticks_task_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_irq_exit(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_exit_common(true);\n}"
  },
  {
    "function_name": "rcu_nmi_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "683-686",
    "snippet": "void rcu_nmi_exit(void)\n{\n\trcu_nmi_exit_common(false);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_nmi_exit_common",
          "args": [
            "false"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_nmi_exit_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "640-674",
          "snippet": "static __always_inline void rcu_nmi_exit_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2, rdp->dynticks);\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\tif (irq)\n\t\trcu_prepare_for_idle();\n\n\trcu_dynticks_eqs_enter();\n\n\tif (irq)\n\t\trcu_dynticks_task_enter();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic __always_inline void rcu_nmi_exit_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2, rdp->dynticks);\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\tif (irq)\n\t\trcu_prepare_for_idle();\n\n\trcu_dynticks_eqs_enter();\n\n\tif (irq)\n\t\trcu_dynticks_task_enter();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_nmi_exit(void)\n{\n\trcu_nmi_exit_common(false);\n}"
  },
  {
    "function_name": "rcu_nmi_exit_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "640-674",
    "snippet": "static __always_inline void rcu_nmi_exit_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2, rdp->dynticks);\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\tif (irq)\n\t\trcu_prepare_for_idle();\n\n\trcu_dynticks_eqs_enter();\n\n\tif (irq)\n\t\trcu_dynticks_task_enter();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dynticks_task_enter",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_task_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2683-2688",
          "snippet": "static void rcu_dynticks_task_enter(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_dynticks_task_enter(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_eqs_enter",
          "args": [],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_eqs_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "220-237",
          "snippet": "static void rcu_dynticks_eqs_enter(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\t/* Better be in an extended quiescent state! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_CTR));\n\t/* Better not have special action (TLB flush) pending! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_MASK));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)",
            "#define RCU_DYNTICK_CTRL_MASK 0x1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_dynticks_eqs_enter(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\t/* Better be in an extended quiescent state! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_CTR));\n\t/* Better not have special action (TLB flush) pending! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_prepare_for_idle",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_prepare_for_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1679-1729",
          "snippet": "static void rcu_prepare_for_idle(void)\n{\n\tbool needwake;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp;\n\tint tne;\n\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\n\t/* Handle nohz enablement switches conservatively. */\n\ttne = READ_ONCE(tick_nohz_active);\n\tif (tne != rdp->tick_nohz_enabled_snap) {\n\t\tif (rcu_cpu_has_callbacks(NULL))\n\t\t\tinvoke_rcu_core(); /* force nohz to see update. */\n\t\trdp->tick_nohz_enabled_snap = tne;\n\t\treturn;\n\t}\n\tif (!tne)\n\t\treturn;\n\n\t/*\n\t * If a non-lazy callback arrived at a CPU having only lazy\n\t * callbacks, invoke RCU core for the side-effect of recalculating\n\t * idle duration on re-entry to idle.\n\t */\n\tif (rdp->all_lazy &&\n\t    rdp->nonlazy_posted != rdp->nonlazy_posted_snap) {\n\t\trdp->all_lazy = false;\n\t\trdp->nonlazy_posted_snap = rdp->nonlazy_posted;\n\t\tinvoke_rcu_core();\n\t\treturn;\n\t}\n\n\t/*\n\t * If we have not yet accelerated this jiffy, accelerate all\n\t * callbacks on this CPU.\n\t */\n\tif (rdp->last_accelerate == jiffies)\n\t\treturn;\n\trdp->last_accelerate = jiffies;\n\tif (rcu_segcblist_pend_cbs(&rdp->cblist)) {\n\t\trnp = rdp->mynode;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_prepare_for_idle(void)\n{\n\tbool needwake;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp;\n\tint tne;\n\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\n\t/* Handle nohz enablement switches conservatively. */\n\ttne = READ_ONCE(tick_nohz_active);\n\tif (tne != rdp->tick_nohz_enabled_snap) {\n\t\tif (rcu_cpu_has_callbacks(NULL))\n\t\t\tinvoke_rcu_core(); /* force nohz to see update. */\n\t\trdp->tick_nohz_enabled_snap = tne;\n\t\treturn;\n\t}\n\tif (!tne)\n\t\treturn;\n\n\t/*\n\t * If a non-lazy callback arrived at a CPU having only lazy\n\t * callbacks, invoke RCU core for the side-effect of recalculating\n\t * idle duration on re-entry to idle.\n\t */\n\tif (rdp->all_lazy &&\n\t    rdp->nonlazy_posted != rdp->nonlazy_posted_snap) {\n\t\trdp->all_lazy = false;\n\t\trdp->nonlazy_posted_snap = rdp->nonlazy_posted;\n\t\tinvoke_rcu_core();\n\t\treturn;\n\t}\n\n\t/*\n\t * If we have not yet accelerated this jiffy, accelerate all\n\t * callbacks on this CPU.\n\t */\n\tif (rdp->last_accelerate == jiffies)\n\t\treturn;\n\trdp->last_accelerate = jiffies;\n\tif (rcu_segcblist_pend_cbs(&rdp->cblist)) {\n\t\trnp = rdp->mynode;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting",
            "0"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_dyntick",
          "args": [
            "TPS(\"Startirq\")",
            "rdp->dynticks_nmi_nesting",
            "0",
            "rdp->dynticks"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Startirq\""
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting",
            "/* No store tearing. */rdp->dynticks_nmi_nesting - 2"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_dyntick",
          "args": [
            "TPS(\"--=\")",
            "rdp->dynticks_nmi_nesting",
            "rdp->dynticks_nmi_nesting - 2",
            "rdp->dynticks"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"--=\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_dynticks_curr_cpu_in_eqs()"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_curr_cpu_in_eqs",
          "args": [],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_curr_cpu_in_eqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "288-293",
          "snippet": "bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting <= 0"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic __always_inline void rcu_nmi_exit_common(bool irq)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2, rdp->dynticks);\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, rdp->dynticks);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\tif (irq)\n\t\trcu_prepare_for_idle();\n\n\trcu_dynticks_eqs_enter();\n\n\tif (irq)\n\t\trcu_dynticks_task_enter();\n}"
  },
  {
    "function_name": "rcu_user_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "624-628",
    "snippet": "void rcu_user_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(true);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_eqs_enter",
          "args": [
            "true"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_eqs_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "570-593",
          "snippet": "static void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trdp = this_cpu_ptr(&rcu_data);\n\tdo_nocb_deferred_wakeup(rdp);\n\trcu_prepare_for_idle();\n\trcu_preempt_deferred_qs(current);\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\trcu_dynticks_eqs_enter();\n\trcu_dynticks_task_enter();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trdp = this_cpu_ptr(&rcu_data);\n\tdo_nocb_deferred_wakeup(rdp);\n\trcu_prepare_for_idle();\n\trcu_preempt_deferred_qs(current);\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\trcu_dynticks_eqs_enter();\n\trcu_dynticks_task_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_user_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(true);\n}"
  },
  {
    "function_name": "rcu_idle_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "606-610",
    "snippet": "void rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_eqs_enter",
          "args": [
            "false"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_eqs_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "570-593",
          "snippet": "static void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trdp = this_cpu_ptr(&rcu_data);\n\tdo_nocb_deferred_wakeup(rdp);\n\trcu_prepare_for_idle();\n\trcu_preempt_deferred_qs(current);\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\trcu_dynticks_eqs_enter();\n\trcu_dynticks_task_enter();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trdp = this_cpu_ptr(&rcu_data);\n\tdo_nocb_deferred_wakeup(rdp);\n\trcu_prepare_for_idle();\n\trcu_preempt_deferred_qs(current);\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\trcu_dynticks_eqs_enter();\n\trcu_dynticks_task_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}"
  },
  {
    "function_name": "rcu_eqs_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "570-593",
    "snippet": "static void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trdp = this_cpu_ptr(&rcu_data);\n\tdo_nocb_deferred_wakeup(rdp);\n\trcu_prepare_for_idle();\n\trcu_preempt_deferred_qs(current);\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\trcu_dynticks_eqs_enter();\n\trcu_dynticks_task_enter();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dynticks_task_enter",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_task_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2683-2688",
          "snippet": "static void rcu_dynticks_task_enter(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_dynticks_task_enter(void)\n{\n#if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL)\n\tWRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());\n#endif /* #if defined(CONFIG_TASKS_RCU) && defined(CONFIG_NO_HZ_FULL) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dynticks_eqs_enter",
          "args": [],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_eqs_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "220-237",
          "snippet": "static void rcu_dynticks_eqs_enter(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\t/* Better be in an extended quiescent state! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_CTR));\n\t/* Better not have special action (TLB flush) pending! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_MASK));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)",
            "#define RCU_DYNTICK_CTRL_MASK 0x1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_dynticks_eqs_enter(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\t/* Better be in an extended quiescent state! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_CTR));\n\t/* Better not have special action (TLB flush) pending! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nesting",
            "0"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "current"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1038-1038",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t) { }",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t) { }"
        }
      },
      {
        "call_info": {
          "callee": "rcu_prepare_for_idle",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_prepare_for_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1679-1729",
          "snippet": "static void rcu_prepare_for_idle(void)\n{\n\tbool needwake;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp;\n\tint tne;\n\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\n\t/* Handle nohz enablement switches conservatively. */\n\ttne = READ_ONCE(tick_nohz_active);\n\tif (tne != rdp->tick_nohz_enabled_snap) {\n\t\tif (rcu_cpu_has_callbacks(NULL))\n\t\t\tinvoke_rcu_core(); /* force nohz to see update. */\n\t\trdp->tick_nohz_enabled_snap = tne;\n\t\treturn;\n\t}\n\tif (!tne)\n\t\treturn;\n\n\t/*\n\t * If a non-lazy callback arrived at a CPU having only lazy\n\t * callbacks, invoke RCU core for the side-effect of recalculating\n\t * idle duration on re-entry to idle.\n\t */\n\tif (rdp->all_lazy &&\n\t    rdp->nonlazy_posted != rdp->nonlazy_posted_snap) {\n\t\trdp->all_lazy = false;\n\t\trdp->nonlazy_posted_snap = rdp->nonlazy_posted;\n\t\tinvoke_rcu_core();\n\t\treturn;\n\t}\n\n\t/*\n\t * If we have not yet accelerated this jiffy, accelerate all\n\t * callbacks on this CPU.\n\t */\n\tif (rdp->last_accelerate == jiffies)\n\t\treturn;\n\trdp->last_accelerate = jiffies;\n\tif (rcu_segcblist_pend_cbs(&rdp->cblist)) {\n\t\trnp = rdp->mynode;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_prepare_for_idle(void)\n{\n\tbool needwake;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp;\n\tint tne;\n\n\tlockdep_assert_irqs_disabled();\n\tif (rcu_is_nocb_cpu(smp_processor_id()))\n\t\treturn;\n\n\t/* Handle nohz enablement switches conservatively. */\n\ttne = READ_ONCE(tick_nohz_active);\n\tif (tne != rdp->tick_nohz_enabled_snap) {\n\t\tif (rcu_cpu_has_callbacks(NULL))\n\t\t\tinvoke_rcu_core(); /* force nohz to see update. */\n\t\trdp->tick_nohz_enabled_snap = tne;\n\t\treturn;\n\t}\n\tif (!tne)\n\t\treturn;\n\n\t/*\n\t * If a non-lazy callback arrived at a CPU having only lazy\n\t * callbacks, invoke RCU core for the side-effect of recalculating\n\t * idle duration on re-entry to idle.\n\t */\n\tif (rdp->all_lazy &&\n\t    rdp->nonlazy_posted != rdp->nonlazy_posted_snap) {\n\t\trdp->all_lazy = false;\n\t\trdp->nonlazy_posted_snap = rdp->nonlazy_posted;\n\t\tinvoke_rcu_core();\n\t\treturn;\n\t}\n\n\t/*\n\t * If we have not yet accelerated this jiffy, accelerate all\n\t * callbacks on this CPU.\n\t */\n\tif (rdp->last_accelerate == jiffies)\n\t\treturn;\n\trdp->last_accelerate = jiffies;\n\tif (rcu_segcblist_pend_cbs(&rdp->cblist)) {\n\t\trnp = rdp->mynode;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_nocb_deferred_wakeup",
          "args": [
            "rdp"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "do_nocb_deferred_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "2633-2635",
          "snippet": "static void do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void do_nocb_deferred_wakeup(struct rcu_data *rdp)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current)"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "current"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rcu_dyntick",
          "args": [
            "TPS(\"Start\")",
            "rdp->dynticks_nesting",
            "0",
            "rdp->dynticks"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"Start\""
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting",
            "0"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\trdp = this_cpu_ptr(&rcu_data);\n\tdo_nocb_deferred_wakeup(rdp);\n\trcu_prepare_for_idle();\n\trcu_preempt_deferred_qs(current);\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\trcu_dynticks_eqs_enter();\n\trcu_dynticks_task_enter();\n}"
  },
  {
    "function_name": "rcu_get_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "557-560",
    "snippet": "static struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}"
  },
  {
    "function_name": "rcutorture_get_gp_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "538-551",
    "snippet": "void rcutorture_get_gp_data(enum rcutorture_type test_type, int *flags,\n\t\t\t    unsigned long *gp_seq)\n{\n\tswitch (test_type) {\n\tcase RCU_FLAVOR:\n\tcase RCU_BH_FLAVOR:\n\tcase RCU_SCHED_FLAVOR:\n\t\t*flags = READ_ONCE(rcu_state.gp_flags);\n\t\t*gp_seq = rcu_seq_current(&rcu_state.gp_seq);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_flags"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcutorture_get_gp_data(enum rcutorture_type test_type, int *flags,\n\t\t\t    unsigned long *gp_seq)\n{\n\tswitch (test_type) {\n\tcase RCU_FLAVOR:\n\tcase RCU_BH_FLAVOR:\n\tcase RCU_SCHED_FLAVOR:\n\t\t*flags = READ_ONCE(rcu_state.gp_flags);\n\t\t*gp_seq = rcu_seq_current(&rcu_state.gp_seq);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "show_rcu_gp_kthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "505-532",
    "snippet": "void show_rcu_gp_kthreads(void)\n{\n\tint cpu;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"%s: wait state: %d ->state: %#lx\\n\", rcu_state.name,\n\t\trcu_state.gp_state, rcu_state.gp_kthread->state);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_GE(rcu_state.gp_seq, rnp->gp_seq_needed))\n\t\t\tcontinue;\n\t\tpr_info(\"\\trcu_node %d:%d ->gp_seq %lu ->gp_seq_needed %lu\\n\",\n\t\t\trnp->grplo, rnp->grphi, rnp->gp_seq,\n\t\t\trnp->gp_seq_needed);\n\t\tif (!rcu_is_leaf_node(rnp))\n\t\t\tcontinue;\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (rdp->gpwrap ||\n\t\t\t    ULONG_CMP_GE(rcu_state.gp_seq,\n\t\t\t\t\t rdp->gp_seq_needed))\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"\\tcpu %d ->gp_seq_needed %lu\\n\",\n\t\t\t\tcpu, rdp->gp_seq_needed);\n\t\t}\n\t}\n\t/* sched_show_task(rcu_state.gp_kthread); */\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tcpu %d ->gp_seq_needed %lu\\n\"",
            "cpu",
            "rdp->gp_seq_needed"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rcu_state.gp_seq",
            "rdp->gp_seq_needed"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&rcu_data",
            "cpu"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_leaf_node_possible_cpu",
          "args": [
            "rnp",
            "cpu"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_leaf_node",
          "args": [
            "rnp"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\trcu_node %d:%d ->gp_seq %lu ->gp_seq_needed %lu\\n\"",
            "rnp->grplo",
            "rnp->grphi",
            "rnp->gp_seq",
            "rnp->gp_seq_needed"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "rcu_state.gp_seq",
            "rnp->gp_seq_needed"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: wait state: %d ->state: %#lx\\n\"",
            "rcu_state.name",
            "rcu_state.gp_state",
            "rcu_state.gp_kthread->state"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nvoid show_rcu_gp_kthreads(void)\n{\n\tint cpu;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"%s: wait state: %d ->state: %#lx\\n\", rcu_state.name,\n\t\trcu_state.gp_state, rcu_state.gp_kthread->state);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (ULONG_CMP_GE(rcu_state.gp_seq, rnp->gp_seq_needed))\n\t\t\tcontinue;\n\t\tpr_info(\"\\trcu_node %d:%d ->gp_seq %lu ->gp_seq_needed %lu\\n\",\n\t\t\trnp->grplo, rnp->grphi, rnp->gp_seq,\n\t\t\trnp->gp_seq_needed);\n\t\tif (!rcu_is_leaf_node(rnp))\n\t\t\tcontinue;\n\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (rdp->gpwrap ||\n\t\t\t    ULONG_CMP_GE(rcu_state.gp_seq,\n\t\t\t\t\t rdp->gp_seq_needed))\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"\\tcpu %d ->gp_seq_needed %lu\\n\",\n\t\t\t\tcpu, rdp->gp_seq_needed);\n\t\t}\n\t}\n\t/* sched_show_task(rcu_state.gp_kthread); */\n}"
  },
  {
    "function_name": "rcu_force_quiescent_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "496-499",
    "snippet": "void rcu_force_quiescent_state(void)\n{\n\tforce_quiescent_state();\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void force_quiescent_state(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_quiescent_state",
          "args": [],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "force_quiescent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2566-2597",
          "snippet": "static void force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t      !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};",
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);",
            "static void force_quiescent_state(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void force_quiescent_state(void);\n\nstatic void force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t      !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void force_quiescent_state(void);\n\nvoid rcu_force_quiescent_state(void)\n{\n\tforce_quiescent_state();\n}"
  },
  {
    "function_name": "rcu_exp_batches_completed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "487-490",
    "snippet": "unsigned long rcu_exp_batches_completed(void)\n{\n\treturn rcu_state.expedited_sequence;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nunsigned long rcu_exp_batches_completed(void)\n{\n\treturn rcu_state.expedited_sequence;\n}"
  },
  {
    "function_name": "rcu_get_gp_seq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "475-478",
    "snippet": "unsigned long rcu_get_gp_seq(void)\n{\n\treturn READ_ONCE(rcu_state.gp_seq);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_state.gp_seq"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nunsigned long rcu_get_gp_seq(void)\n{\n\treturn READ_ONCE(rcu_state.gp_seq);\n}"
  },
  {
    "function_name": "param_set_next_fqs_jiffies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "442-452",
    "snippet": "static int param_set_next_fqs_jiffies(const char *val, const struct kernel_param *kp)\n{\n\tulong j;\n\tint ret = kstrtoul(val, 0, &j);\n\n\tif (!ret) {\n\t\tWRITE_ONCE(*(ulong *)kp->arg, (j > HZ) ? HZ : (j ?: 1));\n\t\tadjust_jiffies_till_sched_qs();\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjust_jiffies_till_sched_qs",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_jiffies_till_sched_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "413-428",
          "snippet": "static void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong jiffies_till_first_fqs = ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;",
            "static ulong jiffies_till_sched_qs = ULONG_MAX;",
            "static ulong jiffies_to_sched_qs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ulong jiffies_till_first_fqs = ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\nstatic ulong jiffies_to_sched_qs;\n\nstatic void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(ulong *)kp->arg",
            "(j > HZ) ? HZ : (j ?: 1)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "val",
            "0",
            "&j"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int param_set_next_fqs_jiffies(const char *val, const struct kernel_param *kp)\n{\n\tulong j;\n\tint ret = kstrtoul(val, 0, &j);\n\n\tif (!ret) {\n\t\tWRITE_ONCE(*(ulong *)kp->arg, (j > HZ) ? HZ : (j ?: 1));\n\t\tadjust_jiffies_till_sched_qs();\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "param_set_first_fqs_jiffies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "430-440",
    "snippet": "static int param_set_first_fqs_jiffies(const char *val, const struct kernel_param *kp)\n{\n\tulong j;\n\tint ret = kstrtoul(val, 0, &j);\n\n\tif (!ret) {\n\t\tWRITE_ONCE(*(ulong *)kp->arg, (j > HZ) ? HZ : j);\n\t\tadjust_jiffies_till_sched_qs();\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjust_jiffies_till_sched_qs",
          "args": [],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_jiffies_till_sched_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "413-428",
          "snippet": "static void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong jiffies_till_first_fqs = ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;",
            "static ulong jiffies_till_sched_qs = ULONG_MAX;",
            "static ulong jiffies_to_sched_qs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ulong jiffies_till_first_fqs = ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\nstatic ulong jiffies_to_sched_qs;\n\nstatic void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(ulong *)kp->arg",
            "(j > HZ) ? HZ : j"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "val",
            "0",
            "&j"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int param_set_first_fqs_jiffies(const char *val, const struct kernel_param *kp)\n{\n\tulong j;\n\tint ret = kstrtoul(val, 0, &j);\n\n\tif (!ret) {\n\t\tWRITE_ONCE(*(ulong *)kp->arg, (j > HZ) ? HZ : j);\n\t\tadjust_jiffies_till_sched_qs();\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "adjust_jiffies_till_sched_qs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "413-428",
    "snippet": "static void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ulong jiffies_till_first_fqs = ULONG_MAX;",
      "static ulong jiffies_till_next_fqs = ULONG_MAX;",
      "static ulong jiffies_till_sched_qs = ULONG_MAX;",
      "static ulong jiffies_to_sched_qs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "jiffies_to_sched_qs",
            "j"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\"",
            "j"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_next_fqs"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies_till_first_fqs"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "jiffies_to_sched_qs",
            "jiffies_till_sched_qs"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ulong jiffies_till_first_fqs = ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\nstatic ulong jiffies_to_sched_qs;\n\nstatic void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}"
  },
  {
    "function_name": "rcu_is_cpu_rrupt_from_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "377-381",
    "snippet": "static int rcu_is_cpu_rrupt_from_idle(void)\n{\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) <= 0 &&\n\t       __this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 1;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.dynticks_nmi_nesting"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "rcu_data.dynticks_nesting"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\n\nstatic int rcu_is_cpu_rrupt_from_idle(void)\n{\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) <= 0 &&\n\t       __this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 1;\n}"
  },
  {
    "function_name": "rcu_eqs_special_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "332-345",
    "snippet": "bool rcu_eqs_special_set(int cpu)\n{\n\tint old;\n\tint new;\n\tstruct rcu_data *rdp = &per_cpu(rcu_data, cpu);\n\n\tdo {\n\t\told = atomic_read(&rdp->dynticks);\n\t\tif (old & RCU_DYNTICK_CTRL_CTR)\n\t\t\treturn false;\n\t\tnew = old | RCU_DYNTICK_CTRL_MASK;\n\t} while (atomic_cmpxchg(&rdp->dynticks, old, new) != old);\n\treturn true;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)",
      "#define RCU_DYNTICK_CTRL_MASK 0x1"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void sync_sched_exp_online_cleanup(int cpu);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&rdp->dynticks",
            "old",
            "new"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "rcu_data",
            "cpu"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_eqs_special_set(int cpu)\n{\n\tint old;\n\tint new;\n\tstruct rcu_data *rdp = &per_cpu(rcu_data, cpu);\n\n\tdo {\n\t\told = atomic_read(&rdp->dynticks);\n\t\tif (old & RCU_DYNTICK_CTRL_CTR)\n\t\t\treturn false;\n\t\tnew = old | RCU_DYNTICK_CTRL_MASK;\n\t} while (atomic_cmpxchg(&rdp->dynticks, old, new) != old);\n\treturn true;\n}"
  },
  {
    "function_name": "rcu_dynticks_in_eqs_since",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "320-323",
    "snippet": "static bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dynticks_snap",
          "args": [
            "rdp"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_dynticks_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "299-304",
          "snippet": "int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_DYNTICK_CTRL_MASK 0x1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
            "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
            "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}"
  },
  {
    "function_name": "rcu_dynticks_in_eqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "310-313",
    "snippet": "static bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & RCU_DYNTICK_CTRL_CTR);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & RCU_DYNTICK_CTRL_CTR);\n}"
  },
  {
    "function_name": "rcu_dynticks_snap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "299-304",
    "snippet": "int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_DYNTICK_CTRL_MASK 0x1"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "0",
            "&rdp->dynticks"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nint rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}"
  },
  {
    "function_name": "rcu_dynticks_curr_cpu_in_eqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "288-293",
    "snippet": "bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nbool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}"
  },
  {
    "function_name": "rcu_dynticks_eqs_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "274-281",
    "snippet": "static void rcu_dynticks_eqs_online(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR)\n\t\treturn;\n\tatomic_add(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "RCU_DYNTICK_CTRL_CTR",
            "&rdp->dynticks"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rdp->dynticks"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_dynticks_eqs_online(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR)\n\t\treturn;\n\tatomic_add(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n}"
  },
  {
    "function_name": "rcu_dynticks_eqs_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "243-262",
    "snippet": "static void rcu_dynticks_eqs_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     !(seq & RCU_DYNTICK_CTRL_CTR));\n\tif (seq & RCU_DYNTICK_CTRL_MASK) {\n\t\tatomic_andnot(RCU_DYNTICK_CTRL_MASK, &rdp->dynticks);\n\t\tsmp_mb__after_atomic(); /* _exit after clearing mask. */\n\t\t/* Prefer duplicate flushes to losing a flush. */\n\t\trcu_eqs_special_exit();\n\t}\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)",
      "#define RCU_DYNTICK_CTRL_MASK 0x1"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_eqs_special_exit",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_andnot",
          "args": [
            "RCU_DYNTICK_CTRL_MASK",
            "&rdp->dynticks"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     !(seq & RCU_DYNTICK_CTRL_CTR)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "RCU_DYNTICK_CTRL_CTR",
            "&rdp->dynticks"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_dynticks_eqs_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     !(seq & RCU_DYNTICK_CTRL_CTR));\n\tif (seq & RCU_DYNTICK_CTRL_MASK) {\n\t\tatomic_andnot(RCU_DYNTICK_CTRL_MASK, &rdp->dynticks);\n\t\tsmp_mb__after_atomic(); /* _exit after clearing mask. */\n\t\t/* Prefer duplicate flushes to losing a flush. */\n\t\trcu_eqs_special_exit();\n\t}\n}"
  },
  {
    "function_name": "rcu_dynticks_eqs_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "220-237",
    "snippet": "static void rcu_dynticks_eqs_enter(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\t/* Better be in an extended quiescent state! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_CTR));\n\t/* Better not have special action (TLB flush) pending! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_MASK));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)",
      "#define RCU_DYNTICK_CTRL_MASK 0x1"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
      "static void invoke_rcu_callbacks(struct rcu_data *rdp);",
      "static void rcu_report_exp_rdp(struct rcu_data *rdp);",
      "static void force_qs_rnp(int (*f)(struct rcu_data *rdp));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_MASK)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_CTR)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_EQS_DEBUG"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "RCU_DYNTICK_CTRL_CTR",
            "&rdp->dynticks"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_data"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n#define RCU_DYNTICK_CTRL_MASK 0x1\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_callbacks(struct rcu_data *rdp);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\n\nstatic void rcu_dynticks_eqs_enter(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\tseq = atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\t/* Better be in an extended quiescent state! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_CTR));\n\t/* Better not have special action (TLB flush) pending! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_MASK));\n}"
  },
  {
    "function_name": "rcu_softirq_qs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "210-214",
    "snippet": "void rcu_softirq_qs(void)\n{\n\trcu_qs();\n\trcu_preempt_deferred_qs(current);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_preempt_deferred_qs",
          "args": [
            "current"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_preempt_deferred_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "1038-1038",
          "snippet": "static void rcu_preempt_deferred_qs(struct task_struct *t) { }",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_preempt_deferred_qs(struct task_struct *t) { }"
        }
      },
      {
        "call_info": {
          "callee": "rcu_qs",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_qs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "940-952",
          "snippet": "static void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nstatic void rcu_qs(void)\n{\n\tRCU_LOCKDEP_WARN(preemptible(), \"rcu_qs() invoked with preemption enabled!!!\");\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.s))\n\t\treturn;\n\ttrace_rcu_grace_period(TPS(\"rcu_sched\"),\n\t\t\t       __this_cpu_read(rcu_data.gp_seq), TPS(\"cpuqs\"));\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.norm, false);\n\tif (!__this_cpu_read(rcu_data.cpu_no_qs.b.exp))\n\t\treturn;\n\t__this_cpu_write(rcu_data.cpu_no_qs.b.exp, false);\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_softirq_qs(void)\n{\n\trcu_qs();\n\trcu_preempt_deferred_qs(current);\n}"
  },
  {
    "function_name": "rcu_gp_in_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "205-208",
    "snippet": "static int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "rcu_seq_current(&rcu_state.gp_seq)"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "57-60",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&rcu_state.gp_seq"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstruct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}"
  },
  {
    "function_name": "rcu_rnp_online_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "195-198",
    "snippet": "unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rnp->qsmaskinitnext"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nunsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}"
  },
  {
    "function_name": "rcu_get_gp_kthreads_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
    "lines": "172-175",
    "snippet": "int rcu_get_gp_kthreads_prio(void)\n{\n\treturn kthread_prio;\n}",
    "includes": [
      "#include \"tree_plugin.h\"",
      "#include \"tree_exp.h\"",
      "#include \"rcu.h\"",
      "#include \"tree.h\"",
      "#include <linux/tick.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/suspend.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/random.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/delay.h>",
      "#include <linux/prefetch.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/kthread.h>",
      "#include <linux/wait.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/time.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kthread_prio = IS_ENABLED(CONFIG_RCU_BOOST) ? 1 : 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int kthread_prio = IS_ENABLED(CONFIG_RCU_BOOST) ? 1 : 0;\n\nint rcu_get_gp_kthreads_prio(void)\n{\n\treturn kthread_prio;\n}"
  }
]