[
  {
    "function_name": "tick_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "533-537",
    "snippet": "void __init tick_init(void)\n{\n\ttick_broadcast_init();\n\ttick_nohz_init();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_init",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "410-446",
          "snippet": "void __init tick_nohz_init(void)\n{\n\tint cpu, ret;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\t/*\n\t * Full dynticks uses irq work to drive the tick rescheduling on safe\n\t * locking contexts. But then we need irq work to raise its own\n\t * interrupts to avoid circular dependency on the tick\n\t */\n\tif (!arch_irq_work_has_interrupt()) {\n\t\tpr_warn(\"NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\tcpu = smp_processor_id();\n\n\tif (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {\n\t\tpr_warn(\"NO_HZ: Clearing %d from nohz_full range for timekeeping\\n\",\n\t\t\tcpu);\n\t\tcpumask_clear_cpu(cpu, tick_nohz_full_mask);\n\t}\n\n\tfor_each_cpu(cpu, tick_nohz_full_mask)\n\t\tcontext_tracking_cpu_set(cpu);\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"kernel/nohz:predown\", NULL,\n\t\t\t\t\ttick_nohz_cpu_down);\n\tWARN_ON(ret < 0);\n\tpr_info(\"NO_HZ: Full dynticks CPUs: %*pbl.\\n\",\n\t\tcpumask_pr_args(tick_nohz_full_mask));\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init tick_nohz_init(void)\n{\n\tint cpu, ret;\n\n\tif (!tick_nohz_full_running)\n\t\treturn;\n\n\t/*\n\t * Full dynticks uses irq work to drive the tick rescheduling on safe\n\t * locking contexts. But then we need irq work to raise its own\n\t * interrupts to avoid circular dependency on the tick\n\t */\n\tif (!arch_irq_work_has_interrupt()) {\n\t\tpr_warn(\"NO_HZ: Can't run full dynticks because arch doesn't support irq work self-IPIs\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\tcpu = smp_processor_id();\n\n\tif (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {\n\t\tpr_warn(\"NO_HZ: Clearing %d from nohz_full range for timekeeping\\n\",\n\t\t\tcpu);\n\t\tcpumask_clear_cpu(cpu, tick_nohz_full_mask);\n\t}\n\n\tfor_each_cpu(cpu, tick_nohz_full_mask)\n\t\tcontext_tracking_cpu_set(cpu);\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"kernel/nohz:predown\", NULL,\n\t\t\t\t\ttick_nohz_cpu_down);\n\tWARN_ON(ret < 0);\n\tpr_info(\"NO_HZ: Full dynticks CPUs: %*pbl.\\n\",\n\t\tcpumask_pr_args(tick_nohz_full_mask));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_init",
          "args": [],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_init_sysfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "741-741",
          "snippet": "static inline int tick_broadcast_init_sysfs(void) { return 0; }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic inline int tick_broadcast_init_sysfs(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init tick_init(void)\n{\n\ttick_broadcast_init();\n\ttick_nohz_init();\n}"
  },
  {
    "function_name": "tick_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "511-527",
    "snippet": "void tick_unfreeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\tif (tick_freeze_depth == num_online_cpus()) {\n\t\ttimekeeping_resume();\n\t\tsystem_state = SYSTEM_RUNNING;\n\t\ttrace_suspend_resume(TPS(\"timekeeping_freeze\"),\n\t\t\t\t     smp_processor_id(), false);\n\t} else {\n\t\ttick_resume_local();\n\t}\n\n\ttick_freeze_depth--;\n\n\traw_spin_unlock(&tick_freeze_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_freeze_lock"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_resume_local",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "429-441",
          "snippet": "void tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"timekeeping_freeze\")",
            "smp_processor_id()",
            "false"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"timekeeping_freeze\""
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_resume",
          "args": [],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1677-1735",
          "snippet": "void timekeeping_resume(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock = tk->tkr_mono.clock;\n\tunsigned long flags;\n\tstruct timespec64 ts_new, ts_delta;\n\tu64 cycle_now, nsec;\n\tbool inject_sleeptime = false;\n\n\tread_persistent_clock64(&ts_new);\n\n\tclockevents_resume();\n\tclocksource_resume();\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t/*\n\t * After system resumes, we need to calculate the suspended time and\n\t * compensate it for the OS time. There are 3 sources that could be\n\t * used: Nonstop clocksource during suspend, persistent clock and rtc\n\t * device.\n\t *\n\t * One specific platform may have 1 or 2 or all of them, and the\n\t * preference will be:\n\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc\n\t * The less preferred source will only be tried if there is no better\n\t * usable source. The rtc part is handled separately in rtc core code.\n\t */\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);\n\tif (nsec > 0) {\n\t\tts_delta = ns_to_timespec64(nsec);\n\t\tinject_sleeptime = true;\n\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {\n\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);\n\t\tinject_sleeptime = true;\n\t}\n\n\tif (inject_sleeptime) {\n\t\tsuspend_timing_needed = false;\n\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);\n\t}\n\n\t/* Re-base the last cycle value */\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->ntp_error = 0;\n\ttimekeeping_suspended = 0;\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttouch_softlockup_watchdog();\n\n\ttick_resume();\n\thrtimers_resume();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)"
          ],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
            "static bool suspend_timing_needed;",
            "static struct timespec64 timekeeping_suspend_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic bool suspend_timing_needed;\nstatic struct timespec64 timekeeping_suspend_time;\n\nvoid timekeeping_resume(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock = tk->tkr_mono.clock;\n\tunsigned long flags;\n\tstruct timespec64 ts_new, ts_delta;\n\tu64 cycle_now, nsec;\n\tbool inject_sleeptime = false;\n\n\tread_persistent_clock64(&ts_new);\n\n\tclockevents_resume();\n\tclocksource_resume();\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t/*\n\t * After system resumes, we need to calculate the suspended time and\n\t * compensate it for the OS time. There are 3 sources that could be\n\t * used: Nonstop clocksource during suspend, persistent clock and rtc\n\t * device.\n\t *\n\t * One specific platform may have 1 or 2 or all of them, and the\n\t * preference will be:\n\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc\n\t * The less preferred source will only be tried if there is no better\n\t * usable source. The rtc part is handled separately in rtc core code.\n\t */\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);\n\tif (nsec > 0) {\n\t\tts_delta = ns_to_timespec64(nsec);\n\t\tinject_sleeptime = true;\n\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {\n\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);\n\t\tinject_sleeptime = true;\n\t}\n\n\tif (inject_sleeptime) {\n\t\tsuspend_timing_needed = false;\n\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);\n\t}\n\n\t/* Re-base the last cycle value */\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->ntp_error = 0;\n\ttimekeeping_suspended = 0;\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttouch_softlockup_watchdog();\n\n\ttick_resume();\n\thrtimers_resume();\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_freeze_lock"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_unfreeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\tif (tick_freeze_depth == num_online_cpus()) {\n\t\ttimekeeping_resume();\n\t\tsystem_state = SYSTEM_RUNNING;\n\t\ttrace_suspend_resume(TPS(\"timekeeping_freeze\"),\n\t\t\t\t     smp_processor_id(), false);\n\t} else {\n\t\ttick_resume_local();\n\t}\n\n\ttick_freeze_depth--;\n\n\traw_spin_unlock(&tick_freeze_lock);\n}"
  },
  {
    "function_name": "tick_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "485-500",
    "snippet": "void tick_freeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\ttick_freeze_depth++;\n\tif (tick_freeze_depth == num_online_cpus()) {\n\t\ttrace_suspend_resume(TPS(\"timekeeping_freeze\"),\n\t\t\t\t     smp_processor_id(), true);\n\t\tsystem_state = SYSTEM_SUSPEND;\n\t\ttimekeeping_suspend();\n\t} else {\n\t\ttick_suspend_local();\n\t}\n\n\traw_spin_unlock(&tick_freeze_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&tick_freeze_lock"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_suspend_local",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "tick_suspend_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "415-420",
          "snippet": "void tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_suspend",
          "args": [],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1737-1804",
          "snippet": "int timekeeping_suspend(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64\t\tdelta, delta_delta;\n\tstatic struct timespec64\told_delta;\n\tstruct clocksource *curr_clock;\n\tu64 cycle_now;\n\n\tread_persistent_clock64(&timekeeping_suspend_time);\n\n\t/*\n\t * On some systems the persistent_clock can not be detected at\n\t * timekeeping_init by its return value, so if we see a valid\n\t * value returned, update the persistent_clock_exists flag.\n\t */\n\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)\n\t\tpersistent_clock_exists = true;\n\n\tsuspend_timing_needed = true;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\ttimekeeping_forward_now(tk);\n\ttimekeeping_suspended = 1;\n\n\t/*\n\t * Since we've called forward_now, cycle_last stores the value\n\t * just read from the current clocksource. Save this to potentially\n\t * use in suspend timing.\n\t */\n\tcurr_clock = tk->tkr_mono.clock;\n\tcycle_now = tk->tkr_mono.cycle_last;\n\tclocksource_start_suspend_timing(curr_clock, cycle_now);\n\n\tif (persistent_clock_exists) {\n\t\t/*\n\t\t * To avoid drift caused by repeated suspend/resumes,\n\t\t * which each can add ~1 second drift error,\n\t\t * try to compensate so the difference in system time\n\t\t * and persistent_clock time stays close to constant.\n\t\t */\n\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);\n\t\tdelta_delta = timespec64_sub(delta, old_delta);\n\t\tif (abs(delta_delta.tv_sec) >= 2) {\n\t\t\t/*\n\t\t\t * if delta_delta is too large, assume time correction\n\t\t\t * has occurred and set old_delta to the current delta.\n\t\t\t */\n\t\t\told_delta = delta;\n\t\t} else {\n\t\t\t/* Otherwise try to adjust old_system to compensate */\n\t\t\ttimekeeping_suspend_time =\n\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);\n\t\t}\n\t}\n\n\ttimekeeping_update(tk, TK_MIRROR);\n\thalt_fast_timekeeper(tk);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttick_suspend();\n\tclocksource_suspend();\n\tclockevents_suspend();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_MIRROR\t\t(1 << 1)"
          ],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
            "static bool suspend_timing_needed;",
            "static bool persistent_clock_exists;",
            "static struct timespec64 timekeeping_suspend_time;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic bool suspend_timing_needed;\nstatic bool persistent_clock_exists;\nstatic struct timespec64 timekeeping_suspend_time;\n\nint timekeeping_suspend(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64\t\tdelta, delta_delta;\n\tstatic struct timespec64\told_delta;\n\tstruct clocksource *curr_clock;\n\tu64 cycle_now;\n\n\tread_persistent_clock64(&timekeeping_suspend_time);\n\n\t/*\n\t * On some systems the persistent_clock can not be detected at\n\t * timekeeping_init by its return value, so if we see a valid\n\t * value returned, update the persistent_clock_exists flag.\n\t */\n\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)\n\t\tpersistent_clock_exists = true;\n\n\tsuspend_timing_needed = true;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\ttimekeeping_forward_now(tk);\n\ttimekeeping_suspended = 1;\n\n\t/*\n\t * Since we've called forward_now, cycle_last stores the value\n\t * just read from the current clocksource. Save this to potentially\n\t * use in suspend timing.\n\t */\n\tcurr_clock = tk->tkr_mono.clock;\n\tcycle_now = tk->tkr_mono.cycle_last;\n\tclocksource_start_suspend_timing(curr_clock, cycle_now);\n\n\tif (persistent_clock_exists) {\n\t\t/*\n\t\t * To avoid drift caused by repeated suspend/resumes,\n\t\t * which each can add ~1 second drift error,\n\t\t * try to compensate so the difference in system time\n\t\t * and persistent_clock time stays close to constant.\n\t\t */\n\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);\n\t\tdelta_delta = timespec64_sub(delta, old_delta);\n\t\tif (abs(delta_delta.tv_sec) >= 2) {\n\t\t\t/*\n\t\t\t * if delta_delta is too large, assume time correction\n\t\t\t * has occurred and set old_delta to the current delta.\n\t\t\t */\n\t\t\told_delta = delta;\n\t\t} else {\n\t\t\t/* Otherwise try to adjust old_system to compensate */\n\t\t\ttimekeeping_suspend_time =\n\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);\n\t\t}\n\t}\n\n\ttimekeeping_update(tk, TK_MIRROR);\n\thalt_fast_timekeeper(tk);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttick_suspend();\n\tclocksource_suspend();\n\tclockevents_suspend();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"timekeeping_freeze\")",
            "smp_processor_id()",
            "true"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"timekeeping_freeze\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&tick_freeze_lock"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_freeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\ttick_freeze_depth++;\n\tif (tick_freeze_depth == num_online_cpus()) {\n\t\ttrace_suspend_resume(TPS(\"timekeeping_freeze\"),\n\t\t\t\t     smp_processor_id(), true);\n\t\tsystem_state = SYSTEM_SUSPEND;\n\t\ttimekeeping_suspend();\n\t} else {\n\t\ttick_suspend_local();\n\t}\n\n\traw_spin_unlock(&tick_freeze_lock);\n}"
  },
  {
    "function_name": "tick_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "466-470",
    "snippet": "void tick_resume(void)\n{\n\ttick_resume_broadcast();\n\ttick_resume_local();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_resume_local",
          "args": [],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "429-441",
          "snippet": "void tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_resume_broadcast",
          "args": [],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_broadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "492-516",
          "snippet": "void tick_resume_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc) {\n\t\tclockevents_tick_resume(bc);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\tbreak;\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_resume_broadcast_oneshot(bc);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static cpumask_var_t tick_broadcast_mask",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_resume_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\n\tif (bc) {\n\t\tclockevents_tick_resume(bc);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_broadcast_start_periodic(bc);\n\t\t\tbreak;\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\tif (!cpumask_empty(tick_broadcast_mask))\n\t\t\t\ttick_resume_broadcast_oneshot(bc);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume(void)\n{\n\ttick_resume_broadcast();\n\ttick_resume_local();\n}"
  },
  {
    "function_name": "tick_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "452-456",
    "snippet": "void tick_suspend(void)\n{\n\ttick_suspend_local();\n\ttick_suspend_broadcast();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_suspend_broadcast",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "tick_suspend_broadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "462-474",
          "snippet": "void tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_suspend_local",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "tick_suspend_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "415-420",
          "snippet": "void tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_suspend(void)\n{\n\ttick_suspend_local();\n\ttick_suspend_broadcast();\n}"
  },
  {
    "function_name": "tick_resume_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "429-441",
    "snippet": "void tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_resume_oneshot",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "54-60",
          "snippet": "void tick_resume_oneshot(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(dev, ktime_get(), true);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume_oneshot(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(dev, ktime_get(), true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_setup_periodic",
          "args": [
            "td->evtdev",
            "0"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_periodic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "144-172",
          "snippet": "void tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;",
            "ktime_t tick_period;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nktime_t tick_period;\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_tick_resume",
          "args": [
            "td->evtdev"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_tick_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "189-197",
          "snippet": "int clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_resume_check_broadcast",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_check_broadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "484-490",
          "snippet": "bool tick_resume_check_broadcast(void)\n{\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT)\n\t\treturn false;\n\telse\n\t\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\n\nbool tick_resume_check_broadcast(void)\n{\n\tif (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT)\n\t\treturn false;\n\telse\n\t\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n}"
  },
  {
    "function_name": "tick_suspend_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "415-420",
    "snippet": "void tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "td->evtdev"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "179-183",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}"
  },
  {
    "function_name": "tick_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "389-405",
    "snippet": "void tick_shutdown(unsigned int cpu)\n{\n\tstruct tick_device *td = &per_cpu(tick_cpu_device, cpu);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttd->mode = TICKDEV_MODE_PERIODIC;\n\tif (dev) {\n\t\t/*\n\t\t * Prevent that the clock events layer tries to call\n\t\t * the set mode function!\n\t\t */\n\t\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\t\tclockevents_exchange_device(dev, NULL);\n\t\tdev->event_handler = clockevents_handle_noop;\n\t\ttd->evtdev = NULL;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_exchange_device",
          "args": [
            "dev",
            "NULL"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_exchange_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "579-597",
          "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_del(&old->list);\n\t\tlist_add(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_del(&old->list);\n\t\tlist_add(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_set_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_DETACHED"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-internal.h",
          "lines": "45-49",
          "snippet": "static inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_shutdown(unsigned int cpu)\n{\n\tstruct tick_device *td = &per_cpu(tick_cpu_device, cpu);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttd->mode = TICKDEV_MODE_PERIODIC;\n\tif (dev) {\n\t\t/*\n\t\t * Prevent that the clock events layer tries to call\n\t\t * the set mode function!\n\t\t */\n\t\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\t\tclockevents_exchange_device(dev, NULL);\n\t\tdev->event_handler = clockevents_handle_noop;\n\t\ttd->evtdev = NULL;\n\t}\n}"
  },
  {
    "function_name": "tick_handover_do_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "372-380",
    "snippet": "void tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id()) {\n\t\tint cpu = cpumask_first(cpu_online_mask);\n\n\t\ttick_do_timer_cpu = (cpu < nr_cpu_ids) ? cpu :\n\t\t\tTICK_DO_TIMER_NONE;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int tick_do_timer_cpu"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_do_timer_cpu;\n\nvoid tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id()) {\n\t\tint cpu = cpumask_first(cpu_online_mask);\n\n\t\ttick_do_timer_cpu = (cpu < nr_cpu_ids) ? cpu :\n\t\t\tTICK_DO_TIMER_NONE;\n\t}\n}"
  },
  {
    "function_name": "tick_broadcast_oneshot_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "354-362",
    "snippet": "int tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tif (!(td->evtdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 0;\n\n\treturn __tick_broadcast_oneshot_control(state);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tick_broadcast_oneshot_control",
          "args": [
            "state"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "__tick_broadcast_oneshot_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "995-1003",
          "snippet": "int __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (!bc || (bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint __tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\tif (!bc || (bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tif (!(td->evtdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 0;\n\n\treturn __tick_broadcast_oneshot_control(state);\n}"
  },
  {
    "function_name": "tick_check_new_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "300-341",
    "snippet": "void tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\t/* cpu local device ? */\n\tif (!tick_check_percpu(curdev, newdev, cpu))\n\t\tgoto out_bc;\n\n\t/* Preference decision */\n\tif (!tick_check_preferred(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_install_broadcast_device",
          "args": [
            "newdev"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "tick_install_broadcast_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "92-118",
          "snippet": "void tick_install_broadcast_device(struct clock_event_device *dev)\n{\n\tstruct clock_event_device *cur = tick_broadcast_device.evtdev;\n\n\tif (!tick_check_broadcast_device(cur, dev))\n\t\treturn;\n\n\tif (!try_module_get(dev->owner))\n\t\treturn;\n\n\tclockevents_exchange_device(cur, dev);\n\tif (cur)\n\t\tcur->event_handler = clockevents_handle_noop;\n\ttick_broadcast_device.evtdev = dev;\n\tif (!cpumask_empty(tick_broadcast_mask))\n\t\ttick_broadcast_start_periodic(dev);\n\t/*\n\t * Inform all cpus about this. We might be in a situation\n\t * where we did not switch to oneshot mode because the per cpu\n\t * devices are affected by CLOCK_EVT_FEAT_C3STOP and the lack\n\t * of a oneshot capable broadcast device. Without that\n\t * notification the systems stays stuck in periodic mode\n\t * forever.\n\t */\n\tif (dev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_clock_notify();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\n\nvoid tick_install_broadcast_device(struct clock_event_device *dev)\n{\n\tstruct clock_event_device *cur = tick_broadcast_device.evtdev;\n\n\tif (!tick_check_broadcast_device(cur, dev))\n\t\treturn;\n\n\tif (!try_module_get(dev->owner))\n\t\treturn;\n\n\tclockevents_exchange_device(cur, dev);\n\tif (cur)\n\t\tcur->event_handler = clockevents_handle_noop;\n\ttick_broadcast_device.evtdev = dev;\n\tif (!cpumask_empty(tick_broadcast_mask))\n\t\ttick_broadcast_start_periodic(dev);\n\t/*\n\t * Inform all cpus about this. We might be in a situation\n\t * where we did not switch to oneshot mode because the per cpu\n\t * devices are affected by CLOCK_EVT_FEAT_C3STOP and the lack\n\t * of a oneshot capable broadcast device. Without that\n\t * notification the systems stays stuck in periodic mode\n\t * forever.\n\t */\n\tif (dev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_clock_notify();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_oneshot_notify",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1356-1361",
          "snippet": "void tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_setup_device",
          "args": [
            "td",
            "newdev",
            "cpu",
            "cpumask_of(cpu)"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "177-234",
          "snippet": "static void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\tif (!tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_cpu = cpu;\n\t\t\telse\n\t\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t\ttick_next_period = ktime_get();\n\t\t\ttick_period = NSEC_PER_SEC / HZ;\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;",
            "ktime_t tick_period;",
            "int tick_do_timer_cpu"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nktime_t tick_period;\nint tick_do_timer_cpu;\n\nstatic void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\tif (!tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_cpu = cpu;\n\t\t\telse\n\t\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t\ttick_next_period = ktime_get();\n\t\t\ttick_period = NSEC_PER_SEC / HZ;\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_exchange_device",
          "args": [
            "curdev",
            "newdev"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_exchange_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "579-597",
          "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_del(&old->list);\n\t\tlist_add(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_del(&old->list);\n\t\tlist_add(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "curdev"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "179-183",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_is_broadcast_device",
          "args": [
            "curdev"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "tick_is_broadcast_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "123-126",
          "snippet": "int tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "newdev->owner"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1113-1129",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_preferred",
          "args": [
            "curdev",
            "newdev"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_preferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "263-281",
          "snippet": "static bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t/* Prefer oneshot capable device */\n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Use the higher rated one, but prefer a CPU local device with a lower\n\t * rating than a non-CPU local device\n\t */\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t/* Prefer oneshot capable device */\n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Use the higher rated one, but prefer a CPU local device with a lower\n\t * rating than a non-CPU local device\n\t */\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_percpu",
          "args": [
            "curdev",
            "newdev",
            "cpu"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "247-261",
          "snippet": "static bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t/* Check if irq affinity can be set */\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t/* Prefer an existing cpu local device */\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t/* Check if irq affinity can be set */\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t/* Prefer an existing cpu local device */\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\t/* cpu local device ? */\n\tif (!tick_check_percpu(curdev, newdev, cpu))\n\t\tgoto out_bc;\n\n\t/* Preference decision */\n\tif (!tick_check_preferred(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev);\n}"
  },
  {
    "function_name": "tick_check_replacement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "287-294",
    "snippet": "bool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_check_preferred",
          "args": [
            "curdev",
            "newdev"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_preferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "263-281",
          "snippet": "static bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t/* Prefer oneshot capable device */\n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Use the higher rated one, but prefer a CPU local device with a lower\n\t * rating than a non-CPU local device\n\t */\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t/* Prefer oneshot capable device */\n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Use the higher rated one, but prefer a CPU local device with a lower\n\t * rating than a non-CPU local device\n\t */\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_percpu",
          "args": [
            "curdev",
            "newdev",
            "smp_processor_id()"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "247-261",
          "snippet": "static bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t/* Check if irq affinity can be set */\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t/* Prefer an existing cpu local device */\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t/* Check if irq affinity can be set */\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t/* Prefer an existing cpu local device */\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nbool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}"
  },
  {
    "function_name": "tick_check_preferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "263-281",
    "snippet": "static bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t/* Prefer oneshot capable device */\n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Use the higher rated one, but prefer a CPU local device with a lower\n\t * rating than a non-CPU local device\n\t */\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "curdev->cpumask",
            "newdev->cpumask"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_oneshot_mode_active",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_mode_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "110-120",
          "snippet": "int tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t/* Prefer oneshot capable device */\n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * Use the higher rated one, but prefer a CPU local device with a lower\n\t * rating than a non-CPU local device\n\t */\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}"
  },
  {
    "function_name": "tick_check_percpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "247-261",
    "snippet": "static bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t/* Check if irq affinity can be set */\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t/* Prefer an existing cpu local device */\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "curdev->cpumask",
            "cpumask_of(cpu)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_can_set_affinity",
          "args": [
            "newdev->irq"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "irq_can_set_affinity_usr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "145-151",
          "snippet": "bool irq_can_set_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn __irq_can_set_affinity(desc) &&\n\t\t!irqd_affinity_is_managed(&desc->irq_data);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool irq_can_set_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn __irq_can_set_affinity(desc) &&\n\t\t!irqd_affinity_is_managed(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "newdev->cpumask",
            "cpumask_of(cpu)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "newdev->cpumask"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t/* Check if irq affinity can be set */\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t/* Prefer an existing cpu local device */\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "tick_install_replacement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "236-245",
    "snippet": "void tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_oneshot_notify",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1356-1361",
          "snippet": "void tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_oneshot_notify(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tset_bit(0, &ts->check_clocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_setup_device",
          "args": [
            "td",
            "newdev",
            "cpu",
            "cpumask_of(cpu)"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "177-234",
          "snippet": "static void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\tif (!tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_cpu = cpu;\n\t\t\telse\n\t\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t\ttick_next_period = ktime_get();\n\t\t\ttick_period = NSEC_PER_SEC / HZ;\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;",
            "ktime_t tick_period;",
            "int tick_do_timer_cpu"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nktime_t tick_period;\nint tick_do_timer_cpu;\n\nstatic void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\tif (!tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_cpu = cpu;\n\t\t\telse\n\t\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t\ttick_next_period = ktime_get();\n\t\t\ttick_period = NSEC_PER_SEC / HZ;\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_exchange_device",
          "args": [
            "td->evtdev",
            "newdev"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_exchange_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "579-597",
          "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_del(&old->list);\n\t\tlist_add(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_del(&old->list);\n\t\tlist_add(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&tick_cpu_device"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n}"
  },
  {
    "function_name": "tick_setup_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "177-234",
    "snippet": "static void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\tif (!tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_cpu = cpu;\n\t\t\telse\n\t\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t\ttick_next_period = ktime_get();\n\t\t\ttick_period = NSEC_PER_SEC / HZ;\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ktime_t tick_next_period;",
      "ktime_t tick_period;",
      "int tick_do_timer_cpu"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_setup_oneshot",
          "args": [
            "newdev",
            "handler",
            "next_event"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "65-72",
          "snippet": "void tick_setup_oneshot(struct clock_event_device *newdev,\n\t\t\tvoid (*handler)(struct clock_event_device *),\n\t\t\tktime_t next_event)\n{\n\tnewdev->event_handler = handler;\n\tclockevents_switch_state(newdev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(newdev, next_event, true);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_setup_oneshot(struct clock_event_device *newdev,\n\t\t\tvoid (*handler)(struct clock_event_device *),\n\t\t\tktime_t next_event)\n{\n\tnewdev->event_handler = handler;\n\tclockevents_switch_state(newdev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(newdev, next_event, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_setup_periodic",
          "args": [
            "newdev",
            "0"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "tick_setup_periodic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "144-172",
          "snippet": "void tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;",
            "ktime_t tick_period;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nktime_t tick_period;\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_device_uses_broadcast",
          "args": [
            "newdev",
            "cpu"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "tick_device_uses_broadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "161-240",
          "snippet": "int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Devices might be registered with both periodic and oneshot\n\t * mode disabled. This signals, that the device needs to be\n\t * operated from the broadcast device and is a placeholder for\n\t * the cpu local device.\n\t */\n\tif (!tick_device_is_functional(dev)) {\n\t\tdev->event_handler = tick_handle_periodic;\n\t\ttick_device_setup_broadcast_func(dev);\n\t\tcpumask_set_cpu(cpu, tick_broadcast_mask);\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_broadcast_start_periodic(bc);\n\t\telse\n\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\tret = 1;\n\t} else {\n\t\t/*\n\t\t * Clear the broadcast bit for this cpu if the\n\t\t * device is not power state affected.\n\t\t */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\t\telse\n\t\t\ttick_device_setup_broadcast_func(dev);\n\n\t\t/*\n\t\t * Clear the broadcast bit if the CPU is not in\n\t\t * periodic broadcast on state.\n\t\t */\n\t\tif (!cpumask_test_cpu(cpu, tick_broadcast_on))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\t/*\n\t\t\t * If the system is in oneshot mode we can\n\t\t\t * unconditionally clear the oneshot mask bit,\n\t\t\t * because the CPU is running and therefore\n\t\t\t * not in an idle state which causes the power\n\t\t\t * state affected device to stop. Let the\n\t\t\t * caller initialize the device.\n\t\t\t */\n\t\t\ttick_broadcast_clear_oneshot(cpu);\n\t\t\tret = 0;\n\t\t\tbreak;\n\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\t/*\n\t\t\t * If the system is in periodic mode, check\n\t\t\t * whether the broadcast device can be\n\t\t\t * switched off now.\n\t\t\t */\n\t\t\tif (cpumask_empty(tick_broadcast_mask) && bc)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t\t/*\n\t\t\t * If we kept the cpu in the broadcast mask,\n\t\t\t * tell the caller to leave the per cpu device\n\t\t\t * in shutdown state. The periodic interrupt\n\t\t\t * is delivered by the broadcast device, if\n\t\t\t * the broadcast device exists and is not\n\t\t\t * hrtimer based.\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\t\t\tret = cpumask_test_cpu(cpu, tick_broadcast_mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static cpumask_var_t tick_broadcast_mask",
            "static cpumask_var_t tick_broadcast_on",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nint tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\t/*\n\t * Devices might be registered with both periodic and oneshot\n\t * mode disabled. This signals, that the device needs to be\n\t * operated from the broadcast device and is a placeholder for\n\t * the cpu local device.\n\t */\n\tif (!tick_device_is_functional(dev)) {\n\t\tdev->event_handler = tick_handle_periodic;\n\t\ttick_device_setup_broadcast_func(dev);\n\t\tcpumask_set_cpu(cpu, tick_broadcast_mask);\n\t\tif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_broadcast_start_periodic(bc);\n\t\telse\n\t\t\ttick_broadcast_setup_oneshot(bc);\n\t\tret = 1;\n\t} else {\n\t\t/*\n\t\t * Clear the broadcast bit for this cpu if the\n\t\t * device is not power state affected.\n\t\t */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\t\telse\n\t\t\ttick_device_setup_broadcast_func(dev);\n\n\t\t/*\n\t\t * Clear the broadcast bit if the CPU is not in\n\t\t * periodic broadcast on state.\n\t\t */\n\t\tif (!cpumask_test_cpu(cpu, tick_broadcast_on))\n\t\t\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\n\t\tswitch (tick_broadcast_device.mode) {\n\t\tcase TICKDEV_MODE_ONESHOT:\n\t\t\t/*\n\t\t\t * If the system is in oneshot mode we can\n\t\t\t * unconditionally clear the oneshot mask bit,\n\t\t\t * because the CPU is running and therefore\n\t\t\t * not in an idle state which causes the power\n\t\t\t * state affected device to stop. Let the\n\t\t\t * caller initialize the device.\n\t\t\t */\n\t\t\ttick_broadcast_clear_oneshot(cpu);\n\t\t\tret = 0;\n\t\t\tbreak;\n\n\t\tcase TICKDEV_MODE_PERIODIC:\n\t\t\t/*\n\t\t\t * If the system is in periodic mode, check\n\t\t\t * whether the broadcast device can be\n\t\t\t * switched off now.\n\t\t\t */\n\t\t\tif (cpumask_empty(tick_broadcast_mask) && bc)\n\t\t\t\tclockevents_shutdown(bc);\n\t\t\t/*\n\t\t\t * If we kept the cpu in the broadcast mask,\n\t\t\t * tell the caller to leave the per cpu device\n\t\t\t * in shutdown state. The periodic interrupt\n\t\t\t * is delivered by the broadcast device, if\n\t\t\t * the broadcast device exists and is not\n\t\t\t * hrtimer based.\n\t\t\t */\n\t\t\tif (bc && !(bc->features & CLOCK_EVT_FEAT_HRTIMER))\n\t\t\t\tret = cpumask_test_cpu(cpu, tick_broadcast_mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_affinity",
          "args": [
            "newdev->irq",
            "cpumask"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_affinity_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "334-363",
          "snippet": "int\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify)\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify)\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "newdev->cpumask",
            "cpumask"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "cpu"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nktime_t tick_period;\nint tick_do_timer_cpu;\n\nstatic void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t/*\n\t * First device setup ?\n\t */\n\tif (!td->evtdev) {\n\t\t/*\n\t\t * If no cpu took the do_timer update, assign it to\n\t\t * this cpu:\n\t\t */\n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\tif (!tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_cpu = cpu;\n\t\t\telse\n\t\t\t\ttick_do_timer_cpu = TICK_DO_TIMER_NONE;\n\t\t\ttick_next_period = ktime_get();\n\t\t\ttick_period = NSEC_PER_SEC / HZ;\n\t\t}\n\n\t\t/*\n\t\t * Startup in periodic mode first.\n\t\t */\n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t/*\n\t * When the device is not per cpu, pin the interrupt to the\n\t * current cpu:\n\t */\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t/*\n\t * When global broadcasting is active, check if the current\n\t * device is registered as a placeholder for broadcast mode.\n\t * This allows us to handle this x86 misfeature in a generic\n\t * way. This function also returns !=0 when we keep the\n\t * current active broadcast state for this CPU.\n\t */\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}"
  },
  {
    "function_name": "tick_setup_periodic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "144-172",
    "snippet": "void tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ktime_t tick_next_period;",
      "ktime_t tick_period;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "next",
            "tick_period"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "dev",
            "next",
            "false"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "311-347",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_ONESHOT"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "153-173",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (unlikely(!dev->mult)) {\n\t\t\t\tdev->mult = 1;\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&jiffies_lock",
            "seq"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&jiffies_lock"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_broadcast_oneshot_active",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_oneshot_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "979-982",
          "snippet": "int tick_broadcast_oneshot_active(void)\n{\n\treturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_broadcast_oneshot_active(void)\n{\n\treturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_device_is_functional",
          "args": [
            "dev"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "tick_device_is_functional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-internal.h",
          "lines": "35-38",
          "snippet": "static inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_set_periodic_handler",
          "args": [
            "dev",
            "broadcast"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "tick_set_periodic_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "430-436",
          "snippet": "void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)\n{\n\tif (!broadcast)\n\t\tdev->event_handler = tick_handle_periodic;\n\telse\n\t\tdev->event_handler = tick_handle_periodic_broadcast;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)\n{\n\tif (!broadcast)\n\t\tdev->event_handler = tick_handle_periodic;\n\telse\n\t\tdev->event_handler = tick_handle_periodic_broadcast;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nktime_t tick_period;\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t/* Broadcast setup ? */\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "tick_handle_periodic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "99-139",
    "snippet": "void tick_handle_periodic(struct clock_event_device *dev)\n{\n\tint cpu = smp_processor_id();\n\tktime_t next = dev->next_event;\n\n\ttick_periodic(cpu);\n\n#if defined(CONFIG_HIGH_RES_TIMERS) || defined(CONFIG_NO_HZ_COMMON)\n\t/*\n\t * The cpu might have transitioned to HIGHRES or NOHZ mode via\n\t * update_process_times() -> run_local_timers() ->\n\t * hrtimer_run_queues().\n\t */\n\tif (dev->event_handler != tick_handle_periodic)\n\t\treturn;\n#endif\n\n\tif (!clockevent_state_oneshot(dev))\n\t\treturn;\n\tfor (;;) {\n\t\t/*\n\t\t * Setup the next period for devices, which do not have\n\t\t * periodic mode:\n\t\t */\n\t\tnext = ktime_add(next, tick_period);\n\n\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\treturn;\n\t\t/*\n\t\t * Have to be careful here. If we're in oneshot mode,\n\t\t * before we call tick_periodic() in a loop, we need\n\t\t * to be sure we're using a real hardware clocksource.\n\t\t * Otherwise we could get trapped in an infinite\n\t\t * loop, as the tick_periodic() increments jiffies,\n\t\t * which then will increment time, possibly causing\n\t\t * the loop to trigger again and again.\n\t\t */\n\t\tif (timekeeping_valid_for_hres())\n\t\t\ttick_periodic(cpu);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ktime_t tick_period;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_periodic",
          "args": [
            "cpu"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "tick_periodic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "79-94",
          "snippet": "static void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\twrite_seqlock(&jiffies_lock);\n\n\t\t/* Keep track of the next tick event */\n\t\ttick_next_period = ktime_add(tick_next_period, tick_period);\n\n\t\tdo_timer(1);\n\t\twrite_sequnlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "ktime_t tick_next_period;",
            "ktime_t tick_period;",
            "int tick_do_timer_cpu"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nktime_t tick_period;\nint tick_do_timer_cpu;\n\nstatic void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\twrite_seqlock(&jiffies_lock);\n\n\t\t/* Keep track of the next tick event */\n\t\ttick_next_period = ktime_add(tick_next_period, tick_period);\n\n\t\tdo_timer(1);\n\t\twrite_sequnlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_valid_for_hres",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_valid_for_hres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1434-1448",
          "snippet": "int timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "dev",
            "next",
            "false"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "311-347",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (unlikely(expires < 0)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ETIME;\n\t}\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "next",
            "tick_period"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_period;\n\nvoid tick_handle_periodic(struct clock_event_device *dev)\n{\n\tint cpu = smp_processor_id();\n\tktime_t next = dev->next_event;\n\n\ttick_periodic(cpu);\n\n#if defined(CONFIG_HIGH_RES_TIMERS) || defined(CONFIG_NO_HZ_COMMON)\n\t/*\n\t * The cpu might have transitioned to HIGHRES or NOHZ mode via\n\t * update_process_times() -> run_local_timers() ->\n\t * hrtimer_run_queues().\n\t */\n\tif (dev->event_handler != tick_handle_periodic)\n\t\treturn;\n#endif\n\n\tif (!clockevent_state_oneshot(dev))\n\t\treturn;\n\tfor (;;) {\n\t\t/*\n\t\t * Setup the next period for devices, which do not have\n\t\t * periodic mode:\n\t\t */\n\t\tnext = ktime_add(next, tick_period);\n\n\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\treturn;\n\t\t/*\n\t\t * Have to be careful here. If we're in oneshot mode,\n\t\t * before we call tick_periodic() in a loop, we need\n\t\t * to be sure we're using a real hardware clocksource.\n\t\t * Otherwise we could get trapped in an infinite\n\t\t * loop, as the tick_periodic() increments jiffies,\n\t\t * which then will increment time, possibly causing\n\t\t * the loop to trigger again and again.\n\t\t */\n\t\tif (timekeeping_valid_for_hres())\n\t\t\ttick_periodic(cpu);\n\t}\n}"
  },
  {
    "function_name": "tick_periodic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "79-94",
    "snippet": "static void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\twrite_seqlock(&jiffies_lock);\n\n\t\t/* Keep track of the next tick event */\n\t\ttick_next_period = ktime_add(tick_next_period, tick_period);\n\n\t\tdo_timer(1);\n\t\twrite_sequnlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ktime_t tick_next_period;",
      "ktime_t tick_period;",
      "int tick_do_timer_cpu"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_tick",
          "args": [
            "CPU_PROFILING"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "profile_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/profile.c",
          "lines": "401-408",
          "snippet": "void profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && prof_cpu_mask != NULL &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t prof_cpu_mask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t prof_cpu_mask;\n\nvoid profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && prof_cpu_mask != NULL &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_process_times",
          "args": [
            "user_mode(get_irq_regs())"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "update_process_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1629-1644",
          "snippet": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_check_callbacks(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers(p);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_check_callbacks(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "get_irq_regs()"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_wall_time",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "update_wall_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2136-2139",
          "snippet": "void update_wall_time(void)\n{\n\ttimekeeping_advance(TK_ADV_TICK);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid update_wall_time(void)\n{\n\ttimekeeping_advance(TK_ADV_TICK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_timer",
          "args": [
            "1"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "do_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2195-2199",
          "snippet": "void do_timer(unsigned long ticks)\n{\n\tjiffies_64 += ticks;\n\tcalc_global_load(ticks);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid do_timer(unsigned long ticks)\n{\n\tjiffies_64 += ticks;\n\tcalc_global_load(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tick_next_period",
            "tick_period"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nktime_t tick_next_period;\nktime_t tick_period;\nint tick_do_timer_cpu;\n\nstatic void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\twrite_seqlock(&jiffies_lock);\n\n\t\t/* Keep track of the next tick event */\n\t\ttick_next_period = ktime_add(tick_next_period, tick_period);\n\n\t\tdo_timer(1);\n\t\twrite_sequnlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}"
  },
  {
    "function_name": "tick_is_oneshot_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "65-74",
    "snippet": "int tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn 0;\n\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_broadcast_oneshot_available",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_oneshot_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "987-992",
          "snippet": "bool tick_broadcast_oneshot_available(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\treturn bc ? bc->features & CLOCK_EVT_FEAT_ONESHOT : false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nbool tick_broadcast_oneshot_available(void)\n{\n\tstruct clock_event_device *bc = tick_broadcast_device.evtdev;\n\n\treturn bc ? bc->features & CLOCK_EVT_FEAT_ONESHOT : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "tick_cpu_device.evtdev"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn 0;\n\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}"
  },
  {
    "function_name": "tick_get_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
    "lines": "57-60",
    "snippet": "struct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <asm/irq_regs.h>",
      "#include <trace/events/power.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}"
  }
]