[
  {
    "function_name": "rcu_torture_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "2080-2280",
    "snippet": "static int __init\nrcu_torture_init(void)\n{\n\tlong i;\n\tint cpu;\n\tint firsterr = 0;\n\tstatic struct rcu_torture_ops *torture_ops[] = {\n\t\t&rcu_ops, &rcu_busted_ops, &srcu_ops, &srcud_ops,\n\t\t&busted_srcud_ops, &tasks_ops,\n\t};\n\n\tif (!torture_init_begin(torture_type, verbose))\n\t\treturn -EBUSY;\n\n\t/* Process args and tell the world that the torturer is on the job. */\n\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {\n\t\tcur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(torture_ops)) {\n\t\tpr_alert(\"rcu-torture: invalid torture type: \\\"%s\\\"\\n\",\n\t\t\t torture_type);\n\t\tpr_alert(\"rcu-torture types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)\n\t\t\tpr_cont(\" %s\", torture_ops[i]->name);\n\t\tpr_cont(\"\\n\");\n\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_TORTURE_TEST));\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\tif (cur_ops->fqs == NULL && fqs_duration != 0) {\n\t\tpr_alert(\"rcu-torture: ->fqs NULL and non-zero fqs_duration, fqs disabled.\\n\");\n\t\tfqs_duration = 0;\n\t}\n\tif (cur_ops->init)\n\t\tcur_ops->init();\n\n\tif (nreaders >= 0) {\n\t\tnrealreaders = nreaders;\n\t} else {\n\t\tnrealreaders = num_online_cpus() - 2 - nreaders;\n\t\tif (nrealreaders <= 0)\n\t\t\tnrealreaders = 1;\n\t}\n\trcu_torture_print_module_parms(cur_ops, \"Start of test\");\n\n\t/* Set up the freelist. */\n\n\tINIT_LIST_HEAD(&rcu_torture_freelist);\n\tfor (i = 0; i < ARRAY_SIZE(rcu_tortures); i++) {\n\t\trcu_tortures[i].rtort_mbtest = 0;\n\t\tlist_add_tail(&rcu_tortures[i].rtort_free,\n\t\t\t      &rcu_torture_freelist);\n\t}\n\n\t/* Initialize the statistics so that each run gets its own numbers. */\n\n\trcu_torture_current = NULL;\n\trcu_torture_current_version = 0;\n\tatomic_set(&n_rcu_torture_alloc, 0);\n\tatomic_set(&n_rcu_torture_alloc_fail, 0);\n\tatomic_set(&n_rcu_torture_free, 0);\n\tatomic_set(&n_rcu_torture_mberror, 0);\n\tatomic_set(&n_rcu_torture_error, 0);\n\tn_rcu_torture_barrier_error = 0;\n\tn_rcu_torture_boost_ktrerror = 0;\n\tn_rcu_torture_boost_rterror = 0;\n\tn_rcu_torture_boost_failure = 0;\n\tn_rcu_torture_boosts = 0;\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tatomic_set(&rcu_torture_wcount[i], 0);\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tper_cpu(rcu_torture_count, cpu)[i] = 0;\n\t\t\tper_cpu(rcu_torture_batch, cpu)[i] = 0;\n\t\t}\n\t}\n\terr_segs_recorded = 0;\n\trt_read_nsegs = 0;\n\n\t/* Start up the kthreads. */\n\n\tfirsterr = torture_create_kthread(rcu_torture_writer, NULL,\n\t\t\t\t\t  writer_task);\n\tif (firsterr)\n\t\tgoto unwind;\n\tif (nfakewriters > 0) {\n\t\tfakewriter_tasks = kcalloc(nfakewriters,\n\t\t\t\t\t   sizeof(fakewriter_tasks[0]),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (fakewriter_tasks == NULL) {\n\t\t\tVERBOSE_TOROUT_ERRSTRING(\"out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\tfor (i = 0; i < nfakewriters; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t\t  NULL, fakewriter_tasks[i]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\treader_tasks = kcalloc(nrealreaders, sizeof(reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\tif (reader_tasks == NULL) {\n\t\tVERBOSE_TOROUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nrealreaders; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_reader, (void *)i,\n\t\t\t\t\t\t  reader_tasks[i]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_stats, NULL,\n\t\t\t\t\t\t  stats_task);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (test_no_idle_hz && shuffle_interval > 0) {\n\t\tfirsterr = torture_shuffle_init(shuffle_interval * HZ);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (stutter < 0)\n\t\tstutter = 0;\n\tif (stutter) {\n\t\tfirsterr = torture_stutter_init(stutter * HZ);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (fqs_duration < 0)\n\t\tfqs_duration = 0;\n\tif (fqs_duration) {\n\t\t/* Create the fqs thread */\n\t\tfirsterr = torture_create_kthread(rcu_torture_fqs, NULL,\n\t\t\t\t\t\t  fqs_task);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (test_boost_interval < 1)\n\t\ttest_boost_interval = 1;\n\tif (test_boost_duration < 2)\n\t\ttest_boost_duration = 2;\n\tif (rcu_torture_can_boost()) {\n\n\t\tboost_starttime = jiffies + test_boost_interval * HZ;\n\n\t\tfirsterr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"RCU_TORTURE\",\n\t\t\t\t\t     rcutorture_booster_init,\n\t\t\t\t\t     rcutorture_booster_cleanup);\n\t\tif (firsterr < 0)\n\t\t\tgoto unwind;\n\t\trcutor_hp = firsterr;\n\t}\n\tfirsterr = torture_shutdown_init(shutdown_secs, rcu_torture_cleanup);\n\tif (firsterr)\n\t\tgoto unwind;\n\tfirsterr = torture_onoff_init(onoff_holdoff * HZ, onoff_interval);\n\tif (firsterr)\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_stall_init();\n\tif (firsterr)\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_fwd_prog_init();\n\tif (firsterr)\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_barrier_init();\n\tif (firsterr)\n\t\tgoto unwind;\n\tif (object_debug)\n\t\trcu_test_debug_objects();\n\tif (cbflood_n_burst > 0) {\n\t\t/* Create the cbflood threads */\n\t\tncbflooders = (num_online_cpus() + 3) / 4;\n\t\tcbflood_task = kcalloc(ncbflooders, sizeof(*cbflood_task),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!cbflood_task) {\n\t\t\tVERBOSE_TOROUT_ERRSTRING(\"out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t\tfor (i = 0; i < ncbflooders; i++) {\n\t\t\tfirsterr = torture_create_kthread(rcu_torture_cbflood,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  cbflood_task[i]);\n\t\t\tif (firsterr)\n\t\t\t\tgoto unwind;\n\t\t}\n\t}\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\trcu_torture_cleanup();\n\treturn firsterr;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_TORTURE_PIPE_LEN 10"
    ],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static int nrealreaders;",
      "static int ncbflooders;",
      "static struct task_struct *writer_task;",
      "static struct task_struct **fakewriter_tasks;",
      "static struct task_struct **reader_tasks;",
      "static struct task_struct *stats_task;",
      "static struct task_struct **cbflood_task;",
      "static struct task_struct *fqs_task;",
      "static LIST_HEAD(rcu_torture_freelist);",
      "static struct rcu_torture __rcu *rcu_torture_current;",
      "static unsigned long rcu_torture_current_version;",
      "static struct rcu_torture rcu_tortures[10 * RCU_TORTURE_PIPE_LEN];",
      "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];",
      "static atomic_t n_rcu_torture_alloc;",
      "static atomic_t n_rcu_torture_alloc_fail;",
      "static atomic_t n_rcu_torture_free;",
      "static atomic_t n_rcu_torture_mberror;",
      "static atomic_t n_rcu_torture_error;",
      "static long n_rcu_torture_barrier_error;",
      "static long n_rcu_torture_boost_ktrerror;",
      "static long n_rcu_torture_boost_rterror;",
      "static long n_rcu_torture_boost_failure;",
      "static long n_rcu_torture_boosts;",
      "static int err_segs_recorded;",
      "static int rt_read_nsegs;",
      "static unsigned long boost_starttime;",
      "static struct rcu_torture_ops *cur_ops;",
      "static struct rcu_torture_ops rcu_ops = {\n\t.ttype\t\t= RCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,\n\t.readunlock\t= rcu_torture_read_unlock,\n\t.get_gp_seq\t= rcu_get_gp_seq,\n\t.gp_diff\t= rcu_seq_diff,\n\t.deferred_free\t= rcu_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu,\n\t.exp_sync\t= synchronize_rcu_expedited,\n\t.get_state\t= get_state_synchronize_rcu,\n\t.cond_sync\t= cond_synchronize_rcu,\n\t.call\t\t= call_rcu,\n\t.cb_barrier\t= rcu_barrier,\n\t.fqs\t\t= rcu_force_quiescent_state,\n\t.stats\t\t= NULL,\n\t.stall_dur\t= rcu_jiffies_till_stall_check,\n\t.irq_capable\t= 1,\n\t.can_boost\t= rcu_can_boost(),\n\t.extendables\t= RCUTORTURE_MAX_EXTEND,\n\t.name\t\t= \"rcu\"\n};",
      "static struct rcu_torture_ops rcu_busted_ops = {\n\t.ttype\t\t= INVALID_RCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_busted_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_busted,\n\t.exp_sync\t= synchronize_rcu_busted,\n\t.call\t\t= call_rcu_busted,\n\t.cb_barrier\t= NULL,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"busted\"\n};",
      "static struct rcu_torture_ops srcu_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= srcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"srcu\"\n};",
      "static struct rcu_torture_ops srcud_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= srcu_torture_init,\n\t.cleanup\t= srcu_torture_cleanup,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= srcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"srcud\"\n};",
      "static struct rcu_torture_ops busted_srcud_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= srcu_torture_init,\n\t.cleanup\t= srcu_torture_cleanup,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.extendables\t= RCUTORTURE_MAX_EXTEND,\n\t.name\t\t= \"busted_srcud\"\n};",
      "static struct rcu_torture_ops tasks_ops = {\n\t.ttype\t\t= RCU_TASKS_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= tasks_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= tasks_torture_read_unlock,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_tasks_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_tasks,\n\t.exp_sync\t= synchronize_rcu_tasks,\n\t.call\t\t= call_rcu_tasks,\n\t.cb_barrier\t= rcu_barrier_tasks,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"tasks\"\n};",
      "static enum cpuhp_state rcutor_hp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_torture_cleanup",
          "args": [],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1929-2022",
          "snippet": "static void\nrcu_torture_cleanup(void)\n{\n\tint firsttime;\n\tint flags = 0;\n\tunsigned long gp_seq = 0;\n\tint i;\n\n\tif (torture_cleanup_begin()) {\n\t\tif (cur_ops->cb_barrier != NULL)\n\t\t\tcur_ops->cb_barrier();\n\t\treturn;\n\t}\n\n\trcu_torture_barrier_cleanup();\n\ttorture_stop_kthread(rcu_torture_fwd_prog, fwd_prog_task);\n\ttorture_stop_kthread(rcu_torture_stall, stall_task);\n\ttorture_stop_kthread(rcu_torture_writer, writer_task);\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\trcu_torture_current = NULL;\n\n\tif (fakewriter_tasks) {\n\t\tfor (i = 0; i < nfakewriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t     fakewriter_tasks[i]);\n\t\t}\n\t\tkfree(fakewriter_tasks);\n\t\tfakewriter_tasks = NULL;\n\t}\n\n\trcutorture_get_gp_data(cur_ops->ttype, &flags, &gp_seq);\n\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp, &flags, &gp_seq);\n\tpr_alert(\"%s:  End-test grace-period state: g%lu f%#x\\n\",\n\t\t cur_ops->name, gp_seq, flags);\n\ttorture_stop_kthread(rcu_torture_stats, stats_task);\n\ttorture_stop_kthread(rcu_torture_fqs, fqs_task);\n\tfor (i = 0; i < ncbflooders; i++)\n\t\ttorture_stop_kthread(rcu_torture_cbflood, cbflood_task[i]);\n\tif (rcu_torture_can_boost())\n\t\tcpuhp_remove_state(rcutor_hp);\n\n\t/*\n\t * Wait for all RCU callbacks to fire, then do torture-type-specific\n\t * cleanup operations.\n\t */\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\trcu_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (err_segs_recorded) {\n\t\tpr_alert(\"Failure/close-call rcutorture reader segments:\\n\");\n\t\tif (rt_read_nsegs == 0)\n\t\t\tpr_alert(\"\\t: No segments recorded!!!\\n\");\n\t\tfirsttime = 1;\n\t\tfor (i = 0; i < rt_read_nsegs; i++) {\n\t\t\tpr_alert(\"\\t%d: %#x \", i, err_segs[i].rt_readstate);\n\t\t\tif (err_segs[i].rt_delay_jiffies != 0) {\n\t\t\t\tpr_cont(\"%s%ldjiffies\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_jiffies);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_ms != 0) {\n\t\t\t\tpr_cont(\"%s%ldms\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_ms);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_us != 0) {\n\t\t\t\tpr_cont(\"%s%ldus\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_us);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tpr_cont(\"%s\\n\",\n\t\t\t\terr_segs[i].rt_preempted ? \"preempted\" : \"\");\n\n\t\t}\n\t}\n\tif (atomic_read(&n_rcu_torture_error) || n_rcu_torture_barrier_error)\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\trcu_torture_print_module_parms(cur_ops,\n\t\t\t\t\t       \"End of test: RCU_HOTPLUG\");\n\telse\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: SUCCESS\");\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nrealreaders;",
            "static int ncbflooders;",
            "static struct task_struct *writer_task;",
            "static struct task_struct **fakewriter_tasks;",
            "static struct task_struct **reader_tasks;",
            "static struct task_struct *stats_task;",
            "static struct task_struct **cbflood_task;",
            "static struct task_struct *fqs_task;",
            "static struct task_struct *stall_task;",
            "static struct task_struct *fwd_prog_task;",
            "static struct rcu_torture __rcu *rcu_torture_current;",
            "static atomic_t n_rcu_torture_error;",
            "static long n_rcu_torture_barrier_error;",
            "static int err_segs_recorded;",
            "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
            "static int rt_read_nsegs;",
            "static struct rcu_torture_ops *cur_ops;",
            "static struct srcu_struct *srcu_ctlp = &srcu_ctl;",
            "static enum cpuhp_state rcutor_hp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealreaders;\nstatic int ncbflooders;\nstatic struct task_struct *writer_task;\nstatic struct task_struct **fakewriter_tasks;\nstatic struct task_struct **reader_tasks;\nstatic struct task_struct *stats_task;\nstatic struct task_struct **cbflood_task;\nstatic struct task_struct *fqs_task;\nstatic struct task_struct *stall_task;\nstatic struct task_struct *fwd_prog_task;\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\nstatic enum cpuhp_state rcutor_hp;\n\nstatic void\nrcu_torture_cleanup(void)\n{\n\tint firsttime;\n\tint flags = 0;\n\tunsigned long gp_seq = 0;\n\tint i;\n\n\tif (torture_cleanup_begin()) {\n\t\tif (cur_ops->cb_barrier != NULL)\n\t\t\tcur_ops->cb_barrier();\n\t\treturn;\n\t}\n\n\trcu_torture_barrier_cleanup();\n\ttorture_stop_kthread(rcu_torture_fwd_prog, fwd_prog_task);\n\ttorture_stop_kthread(rcu_torture_stall, stall_task);\n\ttorture_stop_kthread(rcu_torture_writer, writer_task);\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\trcu_torture_current = NULL;\n\n\tif (fakewriter_tasks) {\n\t\tfor (i = 0; i < nfakewriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t     fakewriter_tasks[i]);\n\t\t}\n\t\tkfree(fakewriter_tasks);\n\t\tfakewriter_tasks = NULL;\n\t}\n\n\trcutorture_get_gp_data(cur_ops->ttype, &flags, &gp_seq);\n\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp, &flags, &gp_seq);\n\tpr_alert(\"%s:  End-test grace-period state: g%lu f%#x\\n\",\n\t\t cur_ops->name, gp_seq, flags);\n\ttorture_stop_kthread(rcu_torture_stats, stats_task);\n\ttorture_stop_kthread(rcu_torture_fqs, fqs_task);\n\tfor (i = 0; i < ncbflooders; i++)\n\t\ttorture_stop_kthread(rcu_torture_cbflood, cbflood_task[i]);\n\tif (rcu_torture_can_boost())\n\t\tcpuhp_remove_state(rcutor_hp);\n\n\t/*\n\t * Wait for all RCU callbacks to fire, then do torture-type-specific\n\t * cleanup operations.\n\t */\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\trcu_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (err_segs_recorded) {\n\t\tpr_alert(\"Failure/close-call rcutorture reader segments:\\n\");\n\t\tif (rt_read_nsegs == 0)\n\t\t\tpr_alert(\"\\t: No segments recorded!!!\\n\");\n\t\tfirsttime = 1;\n\t\tfor (i = 0; i < rt_read_nsegs; i++) {\n\t\t\tpr_alert(\"\\t%d: %#x \", i, err_segs[i].rt_readstate);\n\t\t\tif (err_segs[i].rt_delay_jiffies != 0) {\n\t\t\t\tpr_cont(\"%s%ldjiffies\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_jiffies);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_ms != 0) {\n\t\t\t\tpr_cont(\"%s%ldms\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_ms);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_us != 0) {\n\t\t\t\tpr_cont(\"%s%ldus\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_us);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tpr_cont(\"%s\\n\",\n\t\t\t\terr_segs[i].rt_preempted ? \"preempted\" : \"\");\n\n\t\t}\n\t}\n\tif (atomic_read(&n_rcu_torture_error) || n_rcu_torture_barrier_error)\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\trcu_torture_print_module_parms(cur_ops,\n\t\t\t\t\t       \"End of test: RCU_HOTPLUG\");\n\telse\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: SUCCESS\");\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_end",
          "args": [],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "674-678",
          "snippet": "void torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(fullstop_mutex);",
            "static struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(fullstop_mutex);\nstatic struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};\n\nvoid torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_cbflood",
            "NULL",
            "cbflood_task[i]"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "ncbflooders",
            "sizeof(*cbflood_task)",
            "GFP_KERNEL"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_test_debug_objects",
          "args": [],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_test_debug_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "2049-2078",
          "snippet": "static void rcu_test_debug_objects(void)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tstruct rcu_head rh1;\n\tstruct rcu_head rh2;\n\n\tinit_rcu_head_on_stack(&rh1);\n\tinit_rcu_head_on_stack(&rh2);\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test starting.\\n\", KBUILD_MODNAME);\n\n\t/* Try to queue the rh2 pair of callbacks for the same grace period. */\n\tpreempt_disable(); /* Prevent preemption from interrupting test. */\n\trcu_read_lock(); /* Make it impossible to finish a grace period. */\n\tcall_rcu(&rh1, rcu_torture_leak_cb); /* Start grace period. */\n\tlocal_irq_disable(); /* Make it harder to start a new grace period. */\n\tcall_rcu(&rh2, rcu_torture_leak_cb);\n\tcall_rcu(&rh2, rcu_torture_err_cb); /* Duplicate callback. */\n\tlocal_irq_enable();\n\trcu_read_unlock();\n\tpreempt_enable();\n\n\t/* Wait for them all to get done so we can safely return. */\n\trcu_barrier();\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test complete.\\n\", KBUILD_MODNAME);\n\tdestroy_rcu_head_on_stack(&rh1);\n\tdestroy_rcu_head_on_stack(&rh2);\n#else /* #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\tpr_alert(\"%s: !CONFIG_DEBUG_OBJECTS_RCU_HEAD, not testing duplicate call_rcu()\\n\", KBUILD_MODNAME);\n#endif /* #else #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_test_debug_objects(void)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tstruct rcu_head rh1;\n\tstruct rcu_head rh2;\n\n\tinit_rcu_head_on_stack(&rh1);\n\tinit_rcu_head_on_stack(&rh2);\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test starting.\\n\", KBUILD_MODNAME);\n\n\t/* Try to queue the rh2 pair of callbacks for the same grace period. */\n\tpreempt_disable(); /* Prevent preemption from interrupting test. */\n\trcu_read_lock(); /* Make it impossible to finish a grace period. */\n\tcall_rcu(&rh1, rcu_torture_leak_cb); /* Start grace period. */\n\tlocal_irq_disable(); /* Make it harder to start a new grace period. */\n\tcall_rcu(&rh2, rcu_torture_leak_cb);\n\tcall_rcu(&rh2, rcu_torture_err_cb); /* Duplicate callback. */\n\tlocal_irq_enable();\n\trcu_read_unlock();\n\tpreempt_enable();\n\n\t/* Wait for them all to get done so we can safely return. */\n\trcu_barrier();\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test complete.\\n\", KBUILD_MODNAME);\n\tdestroy_rcu_head_on_stack(&rh1);\n\tdestroy_rcu_head_on_stack(&rh2);\n#else /* #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\tpr_alert(\"%s: !CONFIG_DEBUG_OBJECTS_RCU_HEAD, not testing duplicate call_rcu()\\n\", KBUILD_MODNAME);\n#endif /* #else #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_barrier_init",
          "args": [],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_barrier_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1848-1882",
          "snippet": "static int rcu_torture_barrier_init(void)\n{\n\tint i;\n\tint ret;\n\n\tif (n_barrier_cbs <= 0)\n\t\treturn 0;\n\tif (cur_ops->call == NULL || cur_ops->cb_barrier == NULL) {\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Call or barrier ops missing for %s,\\n\",\n\t\t\t torture_type, cur_ops->name);\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" RCU barrier testing omitted from run.\\n\",\n\t\t\t torture_type);\n\t\treturn 0;\n\t}\n\tatomic_set(&barrier_cbs_count, 0);\n\tatomic_set(&barrier_cbs_invoked, 0);\n\tbarrier_cbs_tasks =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_tasks[0]),\n\t\t\tGFP_KERNEL);\n\tbarrier_cbs_wq =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_wq[0]), GFP_KERNEL);\n\tif (barrier_cbs_tasks == NULL || !barrier_cbs_wq)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < n_barrier_cbs; i++) {\n\t\tinit_waitqueue_head(&barrier_cbs_wq[i]);\n\t\tret = torture_create_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     (void *)(long)i,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn torture_create_kthread(rcu_torture_barrier, NULL, barrier_task);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type = \"rcu\";",
            "static struct task_struct **barrier_cbs_tasks;",
            "static struct task_struct *barrier_task;",
            "static atomic_t barrier_cbs_count;",
            "static atomic_t barrier_cbs_invoked;",
            "static wait_queue_head_t *barrier_cbs_wq;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct **barrier_cbs_tasks;\nstatic struct task_struct *barrier_task;\nstatic atomic_t barrier_cbs_count;\nstatic atomic_t barrier_cbs_invoked;\nstatic wait_queue_head_t *barrier_cbs_wq;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_barrier_init(void)\n{\n\tint i;\n\tint ret;\n\n\tif (n_barrier_cbs <= 0)\n\t\treturn 0;\n\tif (cur_ops->call == NULL || cur_ops->cb_barrier == NULL) {\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Call or barrier ops missing for %s,\\n\",\n\t\t\t torture_type, cur_ops->name);\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" RCU barrier testing omitted from run.\\n\",\n\t\t\t torture_type);\n\t\treturn 0;\n\t}\n\tatomic_set(&barrier_cbs_count, 0);\n\tatomic_set(&barrier_cbs_invoked, 0);\n\tbarrier_cbs_tasks =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_tasks[0]),\n\t\t\tGFP_KERNEL);\n\tbarrier_cbs_wq =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_wq[0]), GFP_KERNEL);\n\tif (barrier_cbs_tasks == NULL || !barrier_cbs_wq)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < n_barrier_cbs; i++) {\n\t\tinit_waitqueue_head(&barrier_cbs_wq[i]);\n\t\tret = torture_create_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     (void *)(long)i,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn torture_create_kthread(rcu_torture_barrier, NULL, barrier_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_fwd_prog_init",
          "args": [],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_fwd_prog_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1747-1768",
          "snippet": "static int __init rcu_torture_fwd_prog_init(void)\n{\n\tif (!fwd_progress)\n\t\treturn 0; /* Not requested, so don't do it. */\n\tif (!cur_ops->stall_dur || cur_ops->stall_dur() <= 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, unsupported by RCU flavor under test\");\n\t\treturn 0;\n\t}\n\tif (stall_cpu > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, conflicts with CPU-stall testing\");\n\t\tif (IS_MODULE(CONFIG_RCU_TORTURE_TESTS))\n\t\t\treturn -EINVAL; /* In module, can fail back to user. */\n\t\tWARN_ON(1); /* Make sure rcutorture notices conflict. */\n\t\treturn 0;\n\t}\n\tif (fwd_progress_holdoff <= 0)\n\t\tfwd_progress_holdoff = 1;\n\tif (fwd_progress_div <= 0)\n\t\tfwd_progress_div = 4;\n\treturn torture_create_kthread(rcu_torture_fwd_prog,\n\t\t\t\t      NULL, fwd_prog_task);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *fwd_prog_task;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *fwd_prog_task;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int __init rcu_torture_fwd_prog_init(void)\n{\n\tif (!fwd_progress)\n\t\treturn 0; /* Not requested, so don't do it. */\n\tif (!cur_ops->stall_dur || cur_ops->stall_dur() <= 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, unsupported by RCU flavor under test\");\n\t\treturn 0;\n\t}\n\tif (stall_cpu > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, conflicts with CPU-stall testing\");\n\t\tif (IS_MODULE(CONFIG_RCU_TORTURE_TESTS))\n\t\t\treturn -EINVAL; /* In module, can fail back to user. */\n\t\tWARN_ON(1); /* Make sure rcutorture notices conflict. */\n\t\treturn 0;\n\t}\n\tif (fwd_progress_holdoff <= 0)\n\t\tfwd_progress_holdoff = 1;\n\tif (fwd_progress_div <= 0)\n\t\tfwd_progress_div = 4;\n\treturn torture_create_kthread(rcu_torture_fwd_prog,\n\t\t\t\t      NULL, fwd_prog_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_stall_init",
          "args": [],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_stall_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1648-1653",
          "snippet": "static int __init rcu_torture_stall_init(void)\n{\n\tif (stall_cpu <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(rcu_torture_stall, NULL, stall_task);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *stall_task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stall_task;\n\nstatic int __init rcu_torture_stall_init(void)\n{\n\tif (stall_cpu <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(rcu_torture_stall, NULL, stall_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_onoff_init",
          "args": [
            "onoff_holdoff * HZ",
            "onoff_interval"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "234-246",
          "snippet": "int torture_onoff_init(long ooholdoff, long oointerval)\n{\n\tint ret = 0;\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\tret = torture_create_kthread(torture_onoff, NULL, onoff_task);\n#endif /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_onoff_init(long ooholdoff, long oointerval)\n{\n\tint ret = 0;\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\tret = torture_create_kthread(torture_onoff, NULL, onoff_task);\n#endif /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_init",
          "args": [
            "shutdown_secs",
            "rcu_torture_cleanup"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "514-525",
          "snippet": "int torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\tint ret = 0;\n\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\tret = torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *shutdown_task;",
            "static ktime_t shutdown_time;",
            "static void (*torture_shutdown_hook)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *shutdown_task;\nstatic ktime_t shutdown_time;\nstatic void (*torture_shutdown_hook)(void);\n\nint torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\tint ret = 0;\n\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\tret = torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"RCU_TORTURE\"",
            "rcutorture_booster_init",
            "rcutorture_booster_cleanup"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_can_boost",
          "args": [],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_can_boost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1903-1925",
          "snippet": "static bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once  == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once  == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_fqs",
            "NULL",
            "fqs_task"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_stutter_init",
          "args": [
            "stutter * HZ"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "torture_stutter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "623-630",
          "snippet": "int torture_stutter_init(int s)\n{\n\tint ret;\n\n\tstutter = s;\n\tret = torture_create_kthread(torture_stutter, NULL, stutter_task);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *stutter_task;",
            "static int stutter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stutter_task;\nstatic int stutter;\n\nint torture_stutter_init(int s)\n{\n\tint ret;\n\n\tstutter = s;\n\tret = torture_create_kthread(torture_stutter, NULL, stutter_task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shuffle_init",
          "args": [
            "shuffle_interval * HZ"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shuffle_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "419-432",
          "snippet": "int torture_shuffle_init(long shuffint)\n{\n\tshuffle_interval = shuffint;\n\n\tshuffle_idle_cpu = -1;\n\n\tif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\n\t\tVERBOSE_TOROUT_ERRSTRING(\"Failed to alloc mask\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Create the shuffler thread */\n\treturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long shuffle_interval;",
            "static struct task_struct *shuffler_task;",
            "static cpumask_var_t shuffle_tmp_mask;",
            "static int shuffle_idle_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long shuffle_interval;\nstatic struct task_struct *shuffler_task;\nstatic cpumask_var_t shuffle_tmp_mask;\nstatic int shuffle_idle_cpu;\n\nint torture_shuffle_init(long shuffint)\n{\n\tshuffle_interval = shuffint;\n\n\tshuffle_idle_cpu = -1;\n\n\tif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\n\t\tVERBOSE_TOROUT_ERRSTRING(\"Failed to alloc mask\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Create the shuffler thread */\n\treturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_stats",
            "NULL",
            "stats_task"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_reader",
            "(void *)i",
            "reader_tasks[i]"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nrealreaders",
            "sizeof(reader_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_fakewriter",
            "NULL",
            "fakewriter_tasks[i]"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nfakewriters",
            "sizeof(fakewriter_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_writer",
            "NULL",
            "writer_task"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "rcu_torture_batch",
            "cpu"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rcu_torture_wcount[i]",
            "0"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_error",
            "0"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_mberror",
            "0"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_free",
            "0"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_alloc_fail",
            "0"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_rcu_torture_alloc",
            "0"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rcu_tortures[i].rtort_free",
            "&rcu_torture_freelist"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rcu_tortures"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rcu_torture_freelist"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_print_module_parms",
          "args": [
            "cur_ops",
            "\"Start of test\""
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_print_module_parms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1539-1560",
          "snippet": "static void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type = \"rcu\";",
            "static int nrealreaders;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic int nrealreaders;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->init",
          "args": [],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu-torture: ->fqs NULL and non-zero fqs_duration, fqs disabled.\\n\""
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!IS_MODULE(CONFIG_RCU_TORTURE_TEST)"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MODULE",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %s\"",
            "torture_ops[i]->name"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu-torture types:\""
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu-torture: invalid torture type: \\\"%s\\\"\\n\"",
            "torture_type"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "torture_type",
            "cur_ops->name"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_begin",
          "args": [
            "torture_type",
            "verbose"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "654-668",
          "snippet": "bool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"torture_init_begin: Refusing %s init: %s running.\\n\",\n\t\t\t ttype, torture_type);\n\t\tpr_alert(\"torture_init_begin: One torture test at a time!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static char *torture_type;",
            "static int verbose;",
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic char *torture_type;\nstatic int verbose;\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"torture_init_begin: Refusing %s init: %s running.\\n\",\n\t\t\t ttype, torture_type);\n\t\tpr_alert(\"torture_init_begin: One torture test at a time!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic char *torture_type = \"rcu\";\nstatic int nrealreaders;\nstatic int ncbflooders;\nstatic struct task_struct *writer_task;\nstatic struct task_struct **fakewriter_tasks;\nstatic struct task_struct **reader_tasks;\nstatic struct task_struct *stats_task;\nstatic struct task_struct **cbflood_task;\nstatic struct task_struct *fqs_task;\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic unsigned long rcu_torture_current_version;\nstatic struct rcu_torture rcu_tortures[10 * RCU_TORTURE_PIPE_LEN];\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\nstatic atomic_t n_rcu_torture_free;\nstatic atomic_t n_rcu_torture_mberror;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic long n_rcu_torture_boost_ktrerror;\nstatic long n_rcu_torture_boost_rterror;\nstatic long n_rcu_torture_boost_failure;\nstatic long n_rcu_torture_boosts;\nstatic int err_segs_recorded;\nstatic int rt_read_nsegs;\nstatic unsigned long boost_starttime;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct rcu_torture_ops rcu_ops = {\n\t.ttype\t\t= RCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,\n\t.readunlock\t= rcu_torture_read_unlock,\n\t.get_gp_seq\t= rcu_get_gp_seq,\n\t.gp_diff\t= rcu_seq_diff,\n\t.deferred_free\t= rcu_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu,\n\t.exp_sync\t= synchronize_rcu_expedited,\n\t.get_state\t= get_state_synchronize_rcu,\n\t.cond_sync\t= cond_synchronize_rcu,\n\t.call\t\t= call_rcu,\n\t.cb_barrier\t= rcu_barrier,\n\t.fqs\t\t= rcu_force_quiescent_state,\n\t.stats\t\t= NULL,\n\t.stall_dur\t= rcu_jiffies_till_stall_check,\n\t.irq_capable\t= 1,\n\t.can_boost\t= rcu_can_boost(),\n\t.extendables\t= RCUTORTURE_MAX_EXTEND,\n\t.name\t\t= \"rcu\"\n};\nstatic struct rcu_torture_ops rcu_busted_ops = {\n\t.ttype\t\t= INVALID_RCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= rcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= rcu_torture_read_unlock,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_busted_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_busted,\n\t.exp_sync\t= synchronize_rcu_busted,\n\t.call\t\t= call_rcu_busted,\n\t.cb_barrier\t= NULL,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"busted\"\n};\nstatic struct rcu_torture_ops srcu_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= srcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"srcu\"\n};\nstatic struct rcu_torture_ops srcud_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= srcu_torture_init,\n\t.cleanup\t= srcu_torture_cleanup,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= srcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"srcud\"\n};\nstatic struct rcu_torture_ops busted_srcud_ops = {\n\t.ttype\t\t= SRCU_FLAVOR,\n\t.init\t\t= srcu_torture_init,\n\t.cleanup\t= srcu_torture_cleanup,\n\t.readlock\t= srcu_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,\n\t.readunlock\t= srcu_torture_read_unlock,\n\t.get_gp_seq\t= srcu_torture_completed,\n\t.deferred_free\t= srcu_torture_deferred_free,\n\t.sync\t\t= srcu_torture_synchronize,\n\t.exp_sync\t= srcu_torture_synchronize_expedited,\n\t.call\t\t= srcu_torture_call,\n\t.cb_barrier\t= srcu_torture_barrier,\n\t.stats\t\t= srcu_torture_stats,\n\t.irq_capable\t= 1,\n\t.extendables\t= RCUTORTURE_MAX_EXTEND,\n\t.name\t\t= \"busted_srcud\"\n};\nstatic struct rcu_torture_ops tasks_ops = {\n\t.ttype\t\t= RCU_TASKS_FLAVOR,\n\t.init\t\t= rcu_sync_torture_init,\n\t.readlock\t= tasks_torture_read_lock,\n\t.read_delay\t= rcu_read_delay,  /* just reuse rcu's version. */\n\t.readunlock\t= tasks_torture_read_unlock,\n\t.get_gp_seq\t= rcu_no_completed,\n\t.deferred_free\t= rcu_tasks_torture_deferred_free,\n\t.sync\t\t= synchronize_rcu_tasks,\n\t.exp_sync\t= synchronize_rcu_tasks,\n\t.call\t\t= call_rcu_tasks,\n\t.cb_barrier\t= rcu_barrier_tasks,\n\t.fqs\t\t= NULL,\n\t.stats\t\t= NULL,\n\t.irq_capable\t= 1,\n\t.name\t\t= \"tasks\"\n};\nstatic enum cpuhp_state rcutor_hp;\n\nstatic int __init\nrcu_torture_init(void)\n{\n\tlong i;\n\tint cpu;\n\tint firsterr = 0;\n\tstatic struct rcu_torture_ops *torture_ops[] = {\n\t\t&rcu_ops, &rcu_busted_ops, &srcu_ops, &srcud_ops,\n\t\t&busted_srcud_ops, &tasks_ops,\n\t};\n\n\tif (!torture_init_begin(torture_type, verbose))\n\t\treturn -EBUSY;\n\n\t/* Process args and tell the world that the torturer is on the job. */\n\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {\n\t\tcur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(torture_ops)) {\n\t\tpr_alert(\"rcu-torture: invalid torture type: \\\"%s\\\"\\n\",\n\t\t\t torture_type);\n\t\tpr_alert(\"rcu-torture types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)\n\t\t\tpr_cont(\" %s\", torture_ops[i]->name);\n\t\tpr_cont(\"\\n\");\n\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_TORTURE_TEST));\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\tif (cur_ops->fqs == NULL && fqs_duration != 0) {\n\t\tpr_alert(\"rcu-torture: ->fqs NULL and non-zero fqs_duration, fqs disabled.\\n\");\n\t\tfqs_duration = 0;\n\t}\n\tif (cur_ops->init)\n\t\tcur_ops->init();\n\n\tif (nreaders >= 0) {\n\t\tnrealreaders = nreaders;\n\t} else {\n\t\tnrealreaders = num_online_cpus() - 2 - nreaders;\n\t\tif (nrealreaders <= 0)\n\t\t\tnrealreaders = 1;\n\t}\n\trcu_torture_print_module_parms(cur_ops, \"Start of test\");\n\n\t/* Set up the freelist. */\n\n\tINIT_LIST_HEAD(&rcu_torture_freelist);\n\tfor (i = 0; i < ARRAY_SIZE(rcu_tortures); i++) {\n\t\trcu_tortures[i].rtort_mbtest = 0;\n\t\tlist_add_tail(&rcu_tortures[i].rtort_free,\n\t\t\t      &rcu_torture_freelist);\n\t}\n\n\t/* Initialize the statistics so that each run gets its own numbers. */\n\n\trcu_torture_current = NULL;\n\trcu_torture_current_version = 0;\n\tatomic_set(&n_rcu_torture_alloc, 0);\n\tatomic_set(&n_rcu_torture_alloc_fail, 0);\n\tatomic_set(&n_rcu_torture_free, 0);\n\tatomic_set(&n_rcu_torture_mberror, 0);\n\tatomic_set(&n_rcu_torture_error, 0);\n\tn_rcu_torture_barrier_error = 0;\n\tn_rcu_torture_boost_ktrerror = 0;\n\tn_rcu_torture_boost_rterror = 0;\n\tn_rcu_torture_boost_failure = 0;\n\tn_rcu_torture_boosts = 0;\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tatomic_set(&rcu_torture_wcount[i], 0);\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tper_cpu(rcu_torture_count, cpu)[i] = 0;\n\t\t\tper_cpu(rcu_torture_batch, cpu)[i] = 0;\n\t\t}\n\t}\n\terr_segs_recorded = 0;\n\trt_read_nsegs = 0;\n\n\t/* Start up the kthreads. */\n\n\tfirsterr = torture_create_kthread(rcu_torture_writer, NULL,\n\t\t\t\t\t  writer_task);\n\tif (firsterr)\n\t\tgoto unwind;\n\tif (nfakewriters > 0) {\n\t\tfakewriter_tasks = kcalloc(nfakewriters,\n\t\t\t\t\t   sizeof(fakewriter_tasks[0]),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (fakewriter_tasks == NULL) {\n\t\t\tVERBOSE_TOROUT_ERRSTRING(\"out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\tfor (i = 0; i < nfakewriters; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t\t  NULL, fakewriter_tasks[i]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\treader_tasks = kcalloc(nrealreaders, sizeof(reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\tif (reader_tasks == NULL) {\n\t\tVERBOSE_TOROUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nrealreaders; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_reader, (void *)i,\n\t\t\t\t\t\t  reader_tasks[i]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_stats, NULL,\n\t\t\t\t\t\t  stats_task);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (test_no_idle_hz && shuffle_interval > 0) {\n\t\tfirsterr = torture_shuffle_init(shuffle_interval * HZ);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (stutter < 0)\n\t\tstutter = 0;\n\tif (stutter) {\n\t\tfirsterr = torture_stutter_init(stutter * HZ);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (fqs_duration < 0)\n\t\tfqs_duration = 0;\n\tif (fqs_duration) {\n\t\t/* Create the fqs thread */\n\t\tfirsterr = torture_create_kthread(rcu_torture_fqs, NULL,\n\t\t\t\t\t\t  fqs_task);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (test_boost_interval < 1)\n\t\ttest_boost_interval = 1;\n\tif (test_boost_duration < 2)\n\t\ttest_boost_duration = 2;\n\tif (rcu_torture_can_boost()) {\n\n\t\tboost_starttime = jiffies + test_boost_interval * HZ;\n\n\t\tfirsterr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"RCU_TORTURE\",\n\t\t\t\t\t     rcutorture_booster_init,\n\t\t\t\t\t     rcutorture_booster_cleanup);\n\t\tif (firsterr < 0)\n\t\t\tgoto unwind;\n\t\trcutor_hp = firsterr;\n\t}\n\tfirsterr = torture_shutdown_init(shutdown_secs, rcu_torture_cleanup);\n\tif (firsterr)\n\t\tgoto unwind;\n\tfirsterr = torture_onoff_init(onoff_holdoff * HZ, onoff_interval);\n\tif (firsterr)\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_stall_init();\n\tif (firsterr)\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_fwd_prog_init();\n\tif (firsterr)\n\t\tgoto unwind;\n\tfirsterr = rcu_torture_barrier_init();\n\tif (firsterr)\n\t\tgoto unwind;\n\tif (object_debug)\n\t\trcu_test_debug_objects();\n\tif (cbflood_n_burst > 0) {\n\t\t/* Create the cbflood threads */\n\t\tncbflooders = (num_online_cpus() + 3) / 4;\n\t\tcbflood_task = kcalloc(ncbflooders, sizeof(*cbflood_task),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!cbflood_task) {\n\t\t\tVERBOSE_TOROUT_ERRSTRING(\"out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t\tfor (i = 0; i < ncbflooders; i++) {\n\t\t\tfirsterr = torture_create_kthread(rcu_torture_cbflood,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  cbflood_task[i]);\n\t\t\tif (firsterr)\n\t\t\t\tgoto unwind;\n\t\t}\n\t}\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\trcu_torture_cleanup();\n\treturn firsterr;\n}"
  },
  {
    "function_name": "rcu_test_debug_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "2049-2078",
    "snippet": "static void rcu_test_debug_objects(void)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tstruct rcu_head rh1;\n\tstruct rcu_head rh2;\n\n\tinit_rcu_head_on_stack(&rh1);\n\tinit_rcu_head_on_stack(&rh2);\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test starting.\\n\", KBUILD_MODNAME);\n\n\t/* Try to queue the rh2 pair of callbacks for the same grace period. */\n\tpreempt_disable(); /* Prevent preemption from interrupting test. */\n\trcu_read_lock(); /* Make it impossible to finish a grace period. */\n\tcall_rcu(&rh1, rcu_torture_leak_cb); /* Start grace period. */\n\tlocal_irq_disable(); /* Make it harder to start a new grace period. */\n\tcall_rcu(&rh2, rcu_torture_leak_cb);\n\tcall_rcu(&rh2, rcu_torture_err_cb); /* Duplicate callback. */\n\tlocal_irq_enable();\n\trcu_read_unlock();\n\tpreempt_enable();\n\n\t/* Wait for them all to get done so we can safely return. */\n\trcu_barrier();\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test complete.\\n\", KBUILD_MODNAME);\n\tdestroy_rcu_head_on_stack(&rh1);\n\tdestroy_rcu_head_on_stack(&rh2);\n#else /* #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\tpr_alert(\"%s: !CONFIG_DEBUG_OBJECTS_RCU_HEAD, not testing duplicate call_rcu()\\n\", KBUILD_MODNAME);\n#endif /* #else #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: !CONFIG_DEBUG_OBJECTS_RCU_HEAD, not testing duplicate call_rcu()\\n\"",
            "KBUILD_MODNAME"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_rcu_head_on_stack",
          "args": [
            "&rh2"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "413-416",
          "snippet": "void destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: WARN: Duplicate call_rcu() test complete.\\n\"",
            "KBUILD_MODNAME"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "620-624",
          "snippet": "void rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&rh2",
            "rcu_torture_err_cb"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_busted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "490-495",
          "snippet": "static void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: WARN: Duplicate call_rcu() test starting.\\n\"",
            "KBUILD_MODNAME"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rcu_head_on_stack",
          "args": [
            "&rh2"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "396-399",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_test_debug_objects(void)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tstruct rcu_head rh1;\n\tstruct rcu_head rh2;\n\n\tinit_rcu_head_on_stack(&rh1);\n\tinit_rcu_head_on_stack(&rh2);\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test starting.\\n\", KBUILD_MODNAME);\n\n\t/* Try to queue the rh2 pair of callbacks for the same grace period. */\n\tpreempt_disable(); /* Prevent preemption from interrupting test. */\n\trcu_read_lock(); /* Make it impossible to finish a grace period. */\n\tcall_rcu(&rh1, rcu_torture_leak_cb); /* Start grace period. */\n\tlocal_irq_disable(); /* Make it harder to start a new grace period. */\n\tcall_rcu(&rh2, rcu_torture_leak_cb);\n\tcall_rcu(&rh2, rcu_torture_err_cb); /* Duplicate callback. */\n\tlocal_irq_enable();\n\trcu_read_unlock();\n\tpreempt_enable();\n\n\t/* Wait for them all to get done so we can safely return. */\n\trcu_barrier();\n\tpr_alert(\"%s: WARN: Duplicate call_rcu() test complete.\\n\", KBUILD_MODNAME);\n\tdestroy_rcu_head_on_stack(&rh1);\n\tdestroy_rcu_head_on_stack(&rh2);\n#else /* #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\tpr_alert(\"%s: !CONFIG_DEBUG_OBJECTS_RCU_HEAD, not testing duplicate call_rcu()\\n\", KBUILD_MODNAME);\n#endif /* #else #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n}"
  },
  {
    "function_name": "rcu_torture_err_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "2029-2041",
    "snippet": "static void rcu_torture_err_cb(struct rcu_head *rhp)\n{\n\t/*\n\t * This -might- happen due to race conditions, but is unlikely.\n\t * The scenario that leads to this happening is that the\n\t * first of the pair of duplicate callbacks is queued,\n\t * someone else starts a grace period that includes that\n\t * callback, then the second of the pair must wait for the\n\t * next grace period.  Unlikely, but can happen.  If it\n\t * does happen, the debug-objects subsystem won't have splatted.\n\t */\n\tpr_alert(\"%s: duplicated callback was invoked.\\n\", KBUILD_MODNAME);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: duplicated callback was invoked.\\n\"",
            "KBUILD_MODNAME"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_err_cb(struct rcu_head *rhp)\n{\n\t/*\n\t * This -might- happen due to race conditions, but is unlikely.\n\t * The scenario that leads to this happening is that the\n\t * first of the pair of duplicate callbacks is queued,\n\t * someone else starts a grace period that includes that\n\t * callback, then the second of the pair must wait for the\n\t * next grace period.  Unlikely, but can happen.  If it\n\t * does happen, the debug-objects subsystem won't have splatted.\n\t */\n\tpr_alert(\"%s: duplicated callback was invoked.\\n\", KBUILD_MODNAME);\n}"
  },
  {
    "function_name": "rcu_torture_leak_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "2025-2027",
    "snippet": "static void rcu_torture_leak_cb(struct rcu_head *rhp)\n{\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_leak_cb(struct rcu_head *rhp)\n{\n}"
  },
  {
    "function_name": "rcu_torture_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1929-2022",
    "snippet": "static void\nrcu_torture_cleanup(void)\n{\n\tint firsttime;\n\tint flags = 0;\n\tunsigned long gp_seq = 0;\n\tint i;\n\n\tif (torture_cleanup_begin()) {\n\t\tif (cur_ops->cb_barrier != NULL)\n\t\t\tcur_ops->cb_barrier();\n\t\treturn;\n\t}\n\n\trcu_torture_barrier_cleanup();\n\ttorture_stop_kthread(rcu_torture_fwd_prog, fwd_prog_task);\n\ttorture_stop_kthread(rcu_torture_stall, stall_task);\n\ttorture_stop_kthread(rcu_torture_writer, writer_task);\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\trcu_torture_current = NULL;\n\n\tif (fakewriter_tasks) {\n\t\tfor (i = 0; i < nfakewriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t     fakewriter_tasks[i]);\n\t\t}\n\t\tkfree(fakewriter_tasks);\n\t\tfakewriter_tasks = NULL;\n\t}\n\n\trcutorture_get_gp_data(cur_ops->ttype, &flags, &gp_seq);\n\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp, &flags, &gp_seq);\n\tpr_alert(\"%s:  End-test grace-period state: g%lu f%#x\\n\",\n\t\t cur_ops->name, gp_seq, flags);\n\ttorture_stop_kthread(rcu_torture_stats, stats_task);\n\ttorture_stop_kthread(rcu_torture_fqs, fqs_task);\n\tfor (i = 0; i < ncbflooders; i++)\n\t\ttorture_stop_kthread(rcu_torture_cbflood, cbflood_task[i]);\n\tif (rcu_torture_can_boost())\n\t\tcpuhp_remove_state(rcutor_hp);\n\n\t/*\n\t * Wait for all RCU callbacks to fire, then do torture-type-specific\n\t * cleanup operations.\n\t */\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\trcu_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (err_segs_recorded) {\n\t\tpr_alert(\"Failure/close-call rcutorture reader segments:\\n\");\n\t\tif (rt_read_nsegs == 0)\n\t\t\tpr_alert(\"\\t: No segments recorded!!!\\n\");\n\t\tfirsttime = 1;\n\t\tfor (i = 0; i < rt_read_nsegs; i++) {\n\t\t\tpr_alert(\"\\t%d: %#x \", i, err_segs[i].rt_readstate);\n\t\t\tif (err_segs[i].rt_delay_jiffies != 0) {\n\t\t\t\tpr_cont(\"%s%ldjiffies\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_jiffies);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_ms != 0) {\n\t\t\t\tpr_cont(\"%s%ldms\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_ms);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_us != 0) {\n\t\t\t\tpr_cont(\"%s%ldus\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_us);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tpr_cont(\"%s\\n\",\n\t\t\t\terr_segs[i].rt_preempted ? \"preempted\" : \"\");\n\n\t\t}\n\t}\n\tif (atomic_read(&n_rcu_torture_error) || n_rcu_torture_barrier_error)\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\trcu_torture_print_module_parms(cur_ops,\n\t\t\t\t\t       \"End of test: RCU_HOTPLUG\");\n\telse\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: SUCCESS\");\n\ttorture_cleanup_end();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nrealreaders;",
      "static int ncbflooders;",
      "static struct task_struct *writer_task;",
      "static struct task_struct **fakewriter_tasks;",
      "static struct task_struct **reader_tasks;",
      "static struct task_struct *stats_task;",
      "static struct task_struct **cbflood_task;",
      "static struct task_struct *fqs_task;",
      "static struct task_struct *stall_task;",
      "static struct task_struct *fwd_prog_task;",
      "static struct rcu_torture __rcu *rcu_torture_current;",
      "static atomic_t n_rcu_torture_error;",
      "static long n_rcu_torture_barrier_error;",
      "static int err_segs_recorded;",
      "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
      "static int rt_read_nsegs;",
      "static struct rcu_torture_ops *cur_ops;",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;",
      "static enum cpuhp_state rcutor_hp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_cleanup_end",
          "args": [],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "715-720",
          "snippet": "void torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nvoid torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_print_module_parms",
          "args": [
            "cur_ops",
            "\"End of test: SUCCESS\""
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_print_module_parms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1539-1560",
          "snippet": "static void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type = \"rcu\";",
            "static int nrealreaders;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic int nrealreaders;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_onoff_failures",
          "args": [],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_failures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "283-291",
          "snippet": "bool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn false;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn false;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_error"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s\\n\"",
            "err_segs[i].rt_preempted ? \"preempted\" : \"\""
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s%ldus\"",
            "firsttime ? \"\" : \"+\"",
            "err_segs[i].rt_delay_us"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s%ldms\"",
            "firsttime ? \"\" : \"+\"",
            "err_segs[i].rt_delay_ms"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s%ldjiffies\"",
            "firsttime ? \"\" : \"+\"",
            "err_segs[i].rt_delay_jiffies"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"\\t%d: %#x \"",
            "i",
            "err_segs[i].rt_readstate"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"\\t: No segments recorded!!!\\n\""
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"Failure/close-call rcutorture reader segments:\\n\""
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_stats_print",
          "args": [],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_stats_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1420-1520",
          "snippet": "static void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += per_cpu(rcu_torture_count, cpu)[i];\n\t\t\tbatchsummary[i] += per_cpu(rcu_torture_batch, cpu)[i];\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"rtc: %p ver: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trcu_torture_current,\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tn_barrier_successes,\n\t\tn_barrier_attempts,\n\t\tn_rcu_torture_barrier_error);\n\tpr_cont(\"cbflood: %ld\\n\", atomic_long_read(&n_cbfloods));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) != 0 ||\n\t    n_rcu_torture_barrier_error != 0 ||\n\t    n_rcu_torture_boost_ktrerror != 0 ||\n\t    n_rcu_torture_boost_rterror != 0 ||\n\t    n_rcu_torture_boost_failure != 0 ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(1);\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_torture_current != NULL) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#lx cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0UL : wtp->state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tshow_rcu_gp_kthreads();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10"
          ],
          "globals_used": [
            "static char *torture_type = \"rcu\";",
            "static struct task_struct *writer_task;",
            "static LIST_HEAD(rcu_torture_freelist);",
            "static struct rcu_torture __rcu *rcu_torture_current;",
            "static unsigned long rcu_torture_current_version;",
            "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];",
            "static atomic_t n_rcu_torture_alloc;",
            "static atomic_t n_rcu_torture_alloc_fail;",
            "static atomic_t n_rcu_torture_free;",
            "static atomic_t n_rcu_torture_mberror;",
            "static atomic_t n_rcu_torture_error;",
            "static long n_rcu_torture_barrier_error;",
            "static long n_rcu_torture_boost_ktrerror;",
            "static long n_rcu_torture_boost_rterror;",
            "static long n_rcu_torture_boost_failure;",
            "static long n_rcu_torture_boosts;",
            "static atomic_long_t n_rcu_torture_timers;",
            "static long n_barrier_attempts;",
            "static long n_barrier_successes;",
            "static atomic_long_t n_cbfloods;",
            "static int rcu_torture_writer_state;",
            "static struct rcu_torture_ops *cur_ops;",
            "static struct srcu_struct *srcu_ctlp = &srcu_ctl;",
            "static bool __maybe_unused"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct *writer_task;\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic unsigned long rcu_torture_current_version;\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\nstatic atomic_t n_rcu_torture_free;\nstatic atomic_t n_rcu_torture_mberror;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic long n_rcu_torture_boost_ktrerror;\nstatic long n_rcu_torture_boost_rterror;\nstatic long n_rcu_torture_boost_failure;\nstatic long n_rcu_torture_boosts;\nstatic atomic_long_t n_rcu_torture_timers;\nstatic long n_barrier_attempts;\nstatic long n_barrier_successes;\nstatic atomic_long_t n_cbfloods;\nstatic int rcu_torture_writer_state;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\nstatic bool __maybe_unused;\n\nstatic void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += per_cpu(rcu_torture_count, cpu)[i];\n\t\t\tbatchsummary[i] += per_cpu(rcu_torture_batch, cpu)[i];\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"rtc: %p ver: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trcu_torture_current,\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tn_barrier_successes,\n\t\tn_barrier_attempts,\n\t\tn_rcu_torture_barrier_error);\n\tpr_cont(\"cbflood: %ld\\n\", atomic_long_read(&n_cbfloods));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) != 0 ||\n\t    n_rcu_torture_barrier_error != 0 ||\n\t    n_rcu_torture_boost_ktrerror != 0 ||\n\t    n_rcu_torture_boost_rterror != 0 ||\n\t    n_rcu_torture_boost_failure != 0 ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(1);\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_torture_current != NULL) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#lx cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0UL : wtp->state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tshow_rcu_gp_kthreads();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cleanup",
          "args": [],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_remove_state",
          "args": [
            "rcutor_hp"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_can_boost",
          "args": [],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_can_boost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1903-1925",
          "snippet": "static bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once  == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once  == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "rcu_torture_cbflood",
            "cbflood_task[i]"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "787-794",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s:  End-test grace-period state: g%lu f%#x\\n\"",
            "cur_ops->name",
            "gp_seq",
            "flags"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcutorture_get_gp_data",
          "args": [
            "cur_ops->ttype",
            "srcu_ctlp",
            "&flags",
            "&gp_seq"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "srcutorture_get_gp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1260-1268",
          "snippet": "void srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *sp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&sp->srcu_gp_seq);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *sp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&sp->srcu_gp_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_get_gp_data",
          "args": [
            "cur_ops->ttype",
            "&flags",
            "&gp_seq"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_get_gp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "482-487",
          "snippet": "static inline void rcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t\t\t  int *flags, unsigned long *gp_seq)\n{\n\t*flags = 0;\n\t*gp_seq = 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t\t\t  int *flags, unsigned long *gp_seq)\n{\n\t*flags = 0;\n\t*gp_seq = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fakewriter_tasks"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_barrier_cleanup",
          "args": [],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_barrier_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1885-1901",
          "snippet": "static void rcu_torture_barrier_cleanup(void)\n{\n\tint i;\n\n\ttorture_stop_kthread(rcu_torture_barrier, barrier_task);\n\tif (barrier_cbs_tasks != NULL) {\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tkfree(barrier_cbs_tasks);\n\t\tbarrier_cbs_tasks = NULL;\n\t}\n\tif (barrier_cbs_wq != NULL) {\n\t\tkfree(barrier_cbs_wq);\n\t\tbarrier_cbs_wq = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct **barrier_cbs_tasks;",
            "static struct task_struct *barrier_task;",
            "static wait_queue_head_t *barrier_cbs_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **barrier_cbs_tasks;\nstatic struct task_struct *barrier_task;\nstatic wait_queue_head_t *barrier_cbs_wq;\n\nstatic void rcu_torture_barrier_cleanup(void)\n{\n\tint i;\n\n\ttorture_stop_kthread(rcu_torture_barrier, barrier_task);\n\tif (barrier_cbs_tasks != NULL) {\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tkfree(barrier_cbs_tasks);\n\t\tbarrier_cbs_tasks = NULL;\n\t}\n\tif (barrier_cbs_wq != NULL) {\n\t\tkfree(barrier_cbs_wq);\n\t\tbarrier_cbs_wq = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_cleanup_begin",
          "args": [],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "696-712",
          "snippet": "bool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */",
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealreaders;\nstatic int ncbflooders;\nstatic struct task_struct *writer_task;\nstatic struct task_struct **fakewriter_tasks;\nstatic struct task_struct **reader_tasks;\nstatic struct task_struct *stats_task;\nstatic struct task_struct **cbflood_task;\nstatic struct task_struct *fqs_task;\nstatic struct task_struct *stall_task;\nstatic struct task_struct *fwd_prog_task;\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\nstatic enum cpuhp_state rcutor_hp;\n\nstatic void\nrcu_torture_cleanup(void)\n{\n\tint firsttime;\n\tint flags = 0;\n\tunsigned long gp_seq = 0;\n\tint i;\n\n\tif (torture_cleanup_begin()) {\n\t\tif (cur_ops->cb_barrier != NULL)\n\t\t\tcur_ops->cb_barrier();\n\t\treturn;\n\t}\n\n\trcu_torture_barrier_cleanup();\n\ttorture_stop_kthread(rcu_torture_fwd_prog, fwd_prog_task);\n\ttorture_stop_kthread(rcu_torture_stall, stall_task);\n\ttorture_stop_kthread(rcu_torture_writer, writer_task);\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\trcu_torture_current = NULL;\n\n\tif (fakewriter_tasks) {\n\t\tfor (i = 0; i < nfakewriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t     fakewriter_tasks[i]);\n\t\t}\n\t\tkfree(fakewriter_tasks);\n\t\tfakewriter_tasks = NULL;\n\t}\n\n\trcutorture_get_gp_data(cur_ops->ttype, &flags, &gp_seq);\n\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp, &flags, &gp_seq);\n\tpr_alert(\"%s:  End-test grace-period state: g%lu f%#x\\n\",\n\t\t cur_ops->name, gp_seq, flags);\n\ttorture_stop_kthread(rcu_torture_stats, stats_task);\n\ttorture_stop_kthread(rcu_torture_fqs, fqs_task);\n\tfor (i = 0; i < ncbflooders; i++)\n\t\ttorture_stop_kthread(rcu_torture_cbflood, cbflood_task[i]);\n\tif (rcu_torture_can_boost())\n\t\tcpuhp_remove_state(rcutor_hp);\n\n\t/*\n\t * Wait for all RCU callbacks to fire, then do torture-type-specific\n\t * cleanup operations.\n\t */\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\trcu_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (err_segs_recorded) {\n\t\tpr_alert(\"Failure/close-call rcutorture reader segments:\\n\");\n\t\tif (rt_read_nsegs == 0)\n\t\t\tpr_alert(\"\\t: No segments recorded!!!\\n\");\n\t\tfirsttime = 1;\n\t\tfor (i = 0; i < rt_read_nsegs; i++) {\n\t\t\tpr_alert(\"\\t%d: %#x \", i, err_segs[i].rt_readstate);\n\t\t\tif (err_segs[i].rt_delay_jiffies != 0) {\n\t\t\t\tpr_cont(\"%s%ldjiffies\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_jiffies);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_ms != 0) {\n\t\t\t\tpr_cont(\"%s%ldms\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_ms);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tif (err_segs[i].rt_delay_us != 0) {\n\t\t\t\tpr_cont(\"%s%ldus\", firsttime ? \"\" : \"+\",\n\t\t\t\t\terr_segs[i].rt_delay_us);\n\t\t\t\tfirsttime = 0;\n\t\t\t}\n\t\t\tpr_cont(\"%s\\n\",\n\t\t\t\terr_segs[i].rt_preempted ? \"preempted\" : \"\");\n\n\t\t}\n\t}\n\tif (atomic_read(&n_rcu_torture_error) || n_rcu_torture_barrier_error)\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\trcu_torture_print_module_parms(cur_ops,\n\t\t\t\t\t       \"End of test: RCU_HOTPLUG\");\n\telse\n\t\trcu_torture_print_module_parms(cur_ops, \"End of test: SUCCESS\");\n\ttorture_cleanup_end();\n}"
  },
  {
    "function_name": "rcu_torture_can_boost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1903-1925",
    "snippet": "static bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once  == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\"",
            "KBUILD_MODNAME"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_get_gp_kthreads_prio",
          "args": [],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_get_gp_kthreads_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "528-528",
          "snippet": "static inline int rcu_get_gp_kthreads_prio(void) { return 0; }",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int rcu_get_gp_kthreads_prio(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic bool rcu_torture_can_boost(void)\n{\n\tstatic int boost_warn_once;\n\tint prio;\n\n\tif (!(test_boost == 1 && cur_ops->can_boost) && test_boost != 2)\n\t\treturn false;\n\n\tprio = rcu_get_gp_kthreads_prio();\n\tif (!prio)\n\t\treturn false;\n\n\tif (prio < 2) {\n\t\tif (boost_warn_once  == 1)\n\t\t\treturn false;\n\n\t\tpr_alert(\"%s: WARN: RCU kthread priority too low to test boosting.  Skipping RCU boost test. Try passing rcutree.kthread_prio > 1 on the kernel command line.\\n\", KBUILD_MODNAME);\n\t\tboost_warn_once = 1;\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "rcu_torture_barrier_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1885-1901",
    "snippet": "static void rcu_torture_barrier_cleanup(void)\n{\n\tint i;\n\n\ttorture_stop_kthread(rcu_torture_barrier, barrier_task);\n\tif (barrier_cbs_tasks != NULL) {\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tkfree(barrier_cbs_tasks);\n\t\tbarrier_cbs_tasks = NULL;\n\t}\n\tif (barrier_cbs_wq != NULL) {\n\t\tkfree(barrier_cbs_wq);\n\t\tbarrier_cbs_wq = NULL;\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct **barrier_cbs_tasks;",
      "static struct task_struct *barrier_task;",
      "static wait_queue_head_t *barrier_cbs_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "barrier_cbs_wq"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "rcu_torture_barrier_cbs",
            "barrier_cbs_tasks[i]"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "787-794",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct **barrier_cbs_tasks;\nstatic struct task_struct *barrier_task;\nstatic wait_queue_head_t *barrier_cbs_wq;\n\nstatic void rcu_torture_barrier_cleanup(void)\n{\n\tint i;\n\n\ttorture_stop_kthread(rcu_torture_barrier, barrier_task);\n\tif (barrier_cbs_tasks != NULL) {\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tkfree(barrier_cbs_tasks);\n\t\tbarrier_cbs_tasks = NULL;\n\t}\n\tif (barrier_cbs_wq != NULL) {\n\t\tkfree(barrier_cbs_wq);\n\t\tbarrier_cbs_wq = NULL;\n\t}\n}"
  },
  {
    "function_name": "rcu_torture_barrier_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1848-1882",
    "snippet": "static int rcu_torture_barrier_init(void)\n{\n\tint i;\n\tint ret;\n\n\tif (n_barrier_cbs <= 0)\n\t\treturn 0;\n\tif (cur_ops->call == NULL || cur_ops->cb_barrier == NULL) {\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Call or barrier ops missing for %s,\\n\",\n\t\t\t torture_type, cur_ops->name);\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" RCU barrier testing omitted from run.\\n\",\n\t\t\t torture_type);\n\t\treturn 0;\n\t}\n\tatomic_set(&barrier_cbs_count, 0);\n\tatomic_set(&barrier_cbs_invoked, 0);\n\tbarrier_cbs_tasks =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_tasks[0]),\n\t\t\tGFP_KERNEL);\n\tbarrier_cbs_wq =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_wq[0]), GFP_KERNEL);\n\tif (barrier_cbs_tasks == NULL || !barrier_cbs_wq)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < n_barrier_cbs; i++) {\n\t\tinit_waitqueue_head(&barrier_cbs_wq[i]);\n\t\tret = torture_create_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     (void *)(long)i,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn torture_create_kthread(rcu_torture_barrier, NULL, barrier_task);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static struct task_struct **barrier_cbs_tasks;",
      "static struct task_struct *barrier_task;",
      "static atomic_t barrier_cbs_count;",
      "static atomic_t barrier_cbs_invoked;",
      "static wait_queue_head_t *barrier_cbs_wq;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_barrier",
            "NULL",
            "barrier_task"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_barrier_cbs",
            "(void *)(long)i",
            "barrier_cbs_tasks[i]"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&barrier_cbs_wq[i]"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "n_barrier_cbs",
            "sizeof(barrier_cbs_wq[0])",
            "GFP_KERNEL"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "n_barrier_cbs",
            "sizeof(barrier_cbs_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&barrier_cbs_invoked",
            "0"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&barrier_cbs_count",
            "0"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t\t \" RCU barrier testing omitted from run.\\n\"",
            "torture_type"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t\t \" Call or barrier ops missing for %s,\\n\"",
            "torture_type",
            "cur_ops->name"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct **barrier_cbs_tasks;\nstatic struct task_struct *barrier_task;\nstatic atomic_t barrier_cbs_count;\nstatic atomic_t barrier_cbs_invoked;\nstatic wait_queue_head_t *barrier_cbs_wq;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_barrier_init(void)\n{\n\tint i;\n\tint ret;\n\n\tif (n_barrier_cbs <= 0)\n\t\treturn 0;\n\tif (cur_ops->call == NULL || cur_ops->cb_barrier == NULL) {\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Call or barrier ops missing for %s,\\n\",\n\t\t\t torture_type, cur_ops->name);\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" RCU barrier testing omitted from run.\\n\",\n\t\t\t torture_type);\n\t\treturn 0;\n\t}\n\tatomic_set(&barrier_cbs_count, 0);\n\tatomic_set(&barrier_cbs_invoked, 0);\n\tbarrier_cbs_tasks =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_tasks[0]),\n\t\t\tGFP_KERNEL);\n\tbarrier_cbs_wq =\n\t\tkcalloc(n_barrier_cbs, sizeof(barrier_cbs_wq[0]), GFP_KERNEL);\n\tif (barrier_cbs_tasks == NULL || !barrier_cbs_wq)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < n_barrier_cbs; i++) {\n\t\tinit_waitqueue_head(&barrier_cbs_wq[i]);\n\t\tret = torture_create_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     (void *)(long)i,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn torture_create_kthread(rcu_torture_barrier, NULL, barrier_task);\n}"
  },
  {
    "function_name": "rcu_torture_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1813-1845",
    "snippet": "static int rcu_torture_barrier(void *arg)\n{\n\tint i;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_barrier task starting\");\n\tdo {\n\t\tatomic_set(&barrier_cbs_invoked, 0);\n\t\tatomic_set(&barrier_cbs_count, n_barrier_cbs);\n\t\t/* Ensure barrier_phase ordered after prior assignments. */\n\t\tsmp_store_release(&barrier_phase, !barrier_phase);\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\twake_up(&barrier_cbs_wq[i]);\n\t\twait_event(barrier_wq,\n\t\t\t   atomic_read(&barrier_cbs_count) == 0 ||\n\t\t\t   torture_must_stop());\n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\tn_barrier_attempts++;\n\t\tcur_ops->cb_barrier(); /* Implies smp_mb() for wait_event(). */\n\t\tif (atomic_read(&barrier_cbs_invoked) != n_barrier_cbs) {\n\t\t\tn_rcu_torture_barrier_error++;\n\t\t\tpr_err(\"barrier_cbs_invoked = %d, n_barrier_cbs = %d\\n\",\n\t\t\t       atomic_read(&barrier_cbs_invoked),\n\t\t\t       n_barrier_cbs);\n\t\t\tWARN_ON_ONCE(1);\n\t\t} else {\n\t\t\tn_barrier_successes++;\n\t\t}\n\t\tschedule_timeout_interruptible(HZ / 10);\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_barrier\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long n_rcu_torture_barrier_error;",
      "static long n_barrier_attempts;",
      "static long n_barrier_successes;",
      "static atomic_t barrier_cbs_count;",
      "static bool barrier_phase;",
      "static atomic_t barrier_cbs_invoked;",
      "static wait_queue_head_t *barrier_cbs_wq;",
      "static DECLARE_WAIT_QUEUE_HEAD(barrier_wq);",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_barrier\""
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "HZ / 10"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"barrier_cbs_invoked = %d, n_barrier_cbs = %d\\n\"",
            "atomic_read(&barrier_cbs_invoked)",
            "n_barrier_cbs"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&barrier_cbs_invoked"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&barrier_cbs_invoked"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "barrier_wq",
            "atomic_read(&barrier_cbs_count) == 0 ||\n\t\t\t   torture_must_stop()"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&barrier_cbs_count"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&barrier_cbs_wq[i]"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&barrier_phase",
            "!barrier_phase"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&barrier_cbs_count",
            "n_barrier_cbs"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&barrier_cbs_invoked",
            "0"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_barrier task starting\""
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long n_rcu_torture_barrier_error;\nstatic long n_barrier_attempts;\nstatic long n_barrier_successes;\nstatic atomic_t barrier_cbs_count;\nstatic bool barrier_phase;\nstatic atomic_t barrier_cbs_invoked;\nstatic wait_queue_head_t *barrier_cbs_wq;\nstatic DECLARE_WAIT_QUEUE_HEAD(barrier_wq);\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_barrier(void *arg)\n{\n\tint i;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_barrier task starting\");\n\tdo {\n\t\tatomic_set(&barrier_cbs_invoked, 0);\n\t\tatomic_set(&barrier_cbs_count, n_barrier_cbs);\n\t\t/* Ensure barrier_phase ordered after prior assignments. */\n\t\tsmp_store_release(&barrier_phase, !barrier_phase);\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\twake_up(&barrier_cbs_wq[i]);\n\t\twait_event(barrier_wq,\n\t\t\t   atomic_read(&barrier_cbs_count) == 0 ||\n\t\t\t   torture_must_stop());\n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\tn_barrier_attempts++;\n\t\tcur_ops->cb_barrier(); /* Implies smp_mb() for wait_event(). */\n\t\tif (atomic_read(&barrier_cbs_invoked) != n_barrier_cbs) {\n\t\t\tn_rcu_torture_barrier_error++;\n\t\t\tpr_err(\"barrier_cbs_invoked = %d, n_barrier_cbs = %d\\n\",\n\t\t\t       atomic_read(&barrier_cbs_invoked),\n\t\t\t       n_barrier_cbs);\n\t\t\tWARN_ON_ONCE(1);\n\t\t} else {\n\t\t\tn_barrier_successes++;\n\t\t}\n\t\tschedule_timeout_interruptible(HZ / 10);\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_barrier\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_barrier_cbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1777-1810",
    "snippet": "static int rcu_torture_barrier_cbs(void *arg)\n{\n\tlong myid = (long)arg;\n\tbool lastphase = 0;\n\tbool newphase;\n\tstruct rcu_head rcu;\n\n\tinit_rcu_head_on_stack(&rcu);\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_barrier_cbs task started\");\n\tset_user_nice(current, MAX_NICE);\n\tdo {\n\t\twait_event(barrier_cbs_wq[myid],\n\t\t\t   (newphase =\n\t\t\t    smp_load_acquire(&barrier_phase)) != lastphase ||\n\t\t\t   torture_must_stop());\n\t\tlastphase = newphase;\n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\t/*\n\t\t * The above smp_load_acquire() ensures barrier_phase load\n\t\t * is ordered before the following ->call().\n\t\t */\n\t\tlocal_irq_disable(); /* Just to test no-irq call_rcu(). */\n\t\tcur_ops->call(&rcu, rcu_torture_barrier_cbf);\n\t\tlocal_irq_enable();\n\t\tif (atomic_dec_and_test(&barrier_cbs_count))\n\t\t\twake_up(&barrier_wq);\n\t} while (!torture_must_stop());\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tdestroy_rcu_head_on_stack(&rcu);\n\ttorture_kthread_stopping(\"rcu_torture_barrier_cbs\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t barrier_cbs_count;",
      "static bool barrier_phase;",
      "static wait_queue_head_t *barrier_cbs_wq;",
      "static DECLARE_WAIT_QUEUE_HEAD(barrier_wq);",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_barrier_cbs\""
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_rcu_head_on_stack",
          "args": [
            "&rcu"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "413-416",
          "snippet": "void destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&barrier_wq"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&barrier_cbs_count"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "&rcu",
            "rcu_torture_barrier_cbf"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "barrier_cbs_wq[myid]",
            "(newphase =\n\t\t\t    smp_load_acquire(&barrier_phase)) != lastphase ||\n\t\t\t   torture_must_stop()"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&barrier_phase"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_barrier_cbs task started\""
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rcu_head_on_stack",
          "args": [
            "&rcu"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "396-399",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t barrier_cbs_count;\nstatic bool barrier_phase;\nstatic wait_queue_head_t *barrier_cbs_wq;\nstatic DECLARE_WAIT_QUEUE_HEAD(barrier_wq);\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_barrier_cbs(void *arg)\n{\n\tlong myid = (long)arg;\n\tbool lastphase = 0;\n\tbool newphase;\n\tstruct rcu_head rcu;\n\n\tinit_rcu_head_on_stack(&rcu);\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_barrier_cbs task started\");\n\tset_user_nice(current, MAX_NICE);\n\tdo {\n\t\twait_event(barrier_cbs_wq[myid],\n\t\t\t   (newphase =\n\t\t\t    smp_load_acquire(&barrier_phase)) != lastphase ||\n\t\t\t   torture_must_stop());\n\t\tlastphase = newphase;\n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\t/*\n\t\t * The above smp_load_acquire() ensures barrier_phase load\n\t\t * is ordered before the following ->call().\n\t\t */\n\t\tlocal_irq_disable(); /* Just to test no-irq call_rcu(). */\n\t\tcur_ops->call(&rcu, rcu_torture_barrier_cbf);\n\t\tlocal_irq_enable();\n\t\tif (atomic_dec_and_test(&barrier_cbs_count))\n\t\t\twake_up(&barrier_wq);\n\t} while (!torture_must_stop());\n\tif (cur_ops->cb_barrier != NULL)\n\t\tcur_ops->cb_barrier();\n\tdestroy_rcu_head_on_stack(&rcu);\n\ttorture_kthread_stopping(\"rcu_torture_barrier_cbs\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_barrier_cbf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1771-1774",
    "snippet": "static void rcu_torture_barrier_cbf(struct rcu_head *rcu)\n{\n\tatomic_inc(&barrier_cbs_invoked);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t barrier_cbs_invoked;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&barrier_cbs_invoked"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t barrier_cbs_invoked;\n\nstatic void rcu_torture_barrier_cbf(struct rcu_head *rcu)\n{\n\tatomic_inc(&barrier_cbs_invoked);\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1747-1768",
    "snippet": "static int __init rcu_torture_fwd_prog_init(void)\n{\n\tif (!fwd_progress)\n\t\treturn 0; /* Not requested, so don't do it. */\n\tif (!cur_ops->stall_dur || cur_ops->stall_dur() <= 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, unsupported by RCU flavor under test\");\n\t\treturn 0;\n\t}\n\tif (stall_cpu > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, conflicts with CPU-stall testing\");\n\t\tif (IS_MODULE(CONFIG_RCU_TORTURE_TESTS))\n\t\t\treturn -EINVAL; /* In module, can fail back to user. */\n\t\tWARN_ON(1); /* Make sure rcutorture notices conflict. */\n\t\treturn 0;\n\t}\n\tif (fwd_progress_holdoff <= 0)\n\t\tfwd_progress_holdoff = 1;\n\tif (fwd_progress_div <= 0)\n\t\tfwd_progress_div = 4;\n\treturn torture_create_kthread(rcu_torture_fwd_prog,\n\t\t\t\t      NULL, fwd_prog_task);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *fwd_prog_task;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_fwd_prog",
            "NULL",
            "fwd_prog_task"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MODULE",
          "args": [
            "CONFIG_RCU_TORTURE_TESTS"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fwd_prog_init: Disabled, conflicts with CPU-stall testing\""
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fwd_prog_init: Disabled, unsupported by RCU flavor under test\""
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->stall_dur",
          "args": [],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *fwd_prog_task;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int __init rcu_torture_fwd_prog_init(void)\n{\n\tif (!fwd_progress)\n\t\treturn 0; /* Not requested, so don't do it. */\n\tif (!cur_ops->stall_dur || cur_ops->stall_dur() <= 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, unsupported by RCU flavor under test\");\n\t\treturn 0;\n\t}\n\tif (stall_cpu > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_prog_init: Disabled, conflicts with CPU-stall testing\");\n\t\tif (IS_MODULE(CONFIG_RCU_TORTURE_TESTS))\n\t\t\treturn -EINVAL; /* In module, can fail back to user. */\n\t\tWARN_ON(1); /* Make sure rcutorture notices conflict. */\n\t\treturn 0;\n\t}\n\tif (fwd_progress_holdoff <= 0)\n\t\tfwd_progress_holdoff = 1;\n\tif (fwd_progress_div <= 0)\n\t\tfwd_progress_div = 4;\n\treturn torture_create_kthread(rcu_torture_fwd_prog,\n\t\t\t\t      NULL, fwd_prog_task);\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1678-1744",
    "snippet": "static int rcu_torture_fwd_prog(void *args)\n{\n\tunsigned long cver;\n\tunsigned long dur;\n\tstruct fwd_cb_state fcs;\n\tunsigned long gps;\n\tint idx;\n\tint sd;\n\tint sd4;\n\tbool selfpropcb = false;\n\tunsigned long stopat;\n\tint tested = 0;\n\tint tested_tries = 0;\n\tstatic DEFINE_TORTURE_RANDOM(trs);\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_progress task started\");\n\tif (!IS_ENABLED(CONFIG_SMP) || !IS_ENABLED(CONFIG_RCU_BOOST))\n\t\tset_user_nice(current, MAX_NICE);\n\tif  (cur_ops->call && cur_ops->sync && cur_ops->cb_barrier) {\n\t\tinit_rcu_head_on_stack(&fcs.rh);\n\t\tselfpropcb = true;\n\t}\n\tdo {\n\t\tschedule_timeout_interruptible(fwd_progress_holdoff * HZ);\n\t\tif  (selfpropcb) {\n\t\t\tWRITE_ONCE(fcs.stop, 0);\n\t\t\tcur_ops->call(&fcs.rh, rcu_torture_fwd_prog_cb);\n\t\t}\n\t\tcver = READ_ONCE(rcu_torture_current_version);\n\t\tgps = cur_ops->get_gp_seq();\n\t\tsd = cur_ops->stall_dur() + 1;\n\t\tsd4 = (sd + fwd_progress_div - 1) / fwd_progress_div;\n\t\tdur = sd4 + torture_random(&trs) % (sd - sd4);\n\t\tstopat = jiffies + dur;\n\t\twhile (time_before(jiffies, stopat) && !torture_must_stop()) {\n\t\t\tidx = cur_ops->readlock();\n\t\t\tudelay(10);\n\t\t\tcur_ops->readunlock(idx);\n\t\t\tif (!fwd_progress_need_resched || need_resched())\n\t\t\t\tcond_resched();\n\t\t}\n\t\ttested_tries++;\n\t\tif (!time_before(jiffies, stopat) && !torture_must_stop()) {\n\t\t\ttested++;\n\t\t\tcver = READ_ONCE(rcu_torture_current_version) - cver;\n\t\t\tgps = rcutorture_seq_diff(cur_ops->get_gp_seq(), gps);\n\t\t\tWARN_ON(!cver && gps < 2);\n\t\t\tpr_alert(\"%s: Duration %ld cver %ld gps %ld\\n\", __func__, dur, cver, gps);\n\t\t}\n\t\tif (selfpropcb) {\n\t\t\tWRITE_ONCE(fcs.stop, 1);\n\t\t\tcur_ops->sync(); /* Wait for running CB to complete. */\n\t\t\tcur_ops->cb_barrier(); /* Wait for queued callbacks. */\n\t\t}\n\t\t/* Avoid slow periods, better to test when busy. */\n\t\tstutter_wait(\"rcu_torture_fwd_prog\");\n\t} while (!torture_must_stop());\n\tif (selfpropcb) {\n\t\tWARN_ON(READ_ONCE(fcs.stop) != 2);\n\t\tdestroy_rcu_head_on_stack(&fcs.rh);\n\t}\n\t/* Short runs might not contain a valid forward-progress attempt. */\n\tWARN_ON(!tested && tested_tries >= 5);\n\tpr_alert(\"%s: tested %d tested_tries %d\\n\", __func__, tested, tested_tries);\n\ttorture_kthread_stopping(\"rcu_torture_fwd_prog\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long rcu_torture_current_version;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_fwd_prog\""
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: tested %d tested_tries %d\\n\"",
            "__func__",
            "tested",
            "tested_tries"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!tested && tested_tries >= 5"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_rcu_head_on_stack",
          "args": [
            "&fcs.rh"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "413-416",
          "snippet": "void destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "READ_ONCE(fcs.stop) != 2"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "fcs.stop"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_fwd_prog\""
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "576-594",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "fcs.stop",
            "1"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: Duration %ld cver %ld gps %ld\\n\"",
            "__func__",
            "dur",
            "cver",
            "gps"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!cver && gps < 2"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_seq_diff",
          "args": [
            "cur_ops->get_gp_seq()",
            "gps"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_seq_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "698-703",
          "snippet": "static unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_torture_current_version"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "stopat"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readunlock",
          "args": [
            "idx"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "10"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readlock",
          "args": [],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "stopat"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&trs"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->stall_dur",
          "args": [],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_torture_current_version"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "&fcs.rh",
            "rcu_torture_fwd_prog_cb"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "fcs.stop",
            "0"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "fwd_progress_holdoff * HZ"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rcu_head_on_stack",
          "args": [
            "&fcs.rh"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "396-399",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RCU_BOOST"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SMP"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fwd_progress task started\""
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long rcu_torture_current_version;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcu_torture_fwd_prog(void *args)\n{\n\tunsigned long cver;\n\tunsigned long dur;\n\tstruct fwd_cb_state fcs;\n\tunsigned long gps;\n\tint idx;\n\tint sd;\n\tint sd4;\n\tbool selfpropcb = false;\n\tunsigned long stopat;\n\tint tested = 0;\n\tint tested_tries = 0;\n\tstatic DEFINE_TORTURE_RANDOM(trs);\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fwd_progress task started\");\n\tif (!IS_ENABLED(CONFIG_SMP) || !IS_ENABLED(CONFIG_RCU_BOOST))\n\t\tset_user_nice(current, MAX_NICE);\n\tif  (cur_ops->call && cur_ops->sync && cur_ops->cb_barrier) {\n\t\tinit_rcu_head_on_stack(&fcs.rh);\n\t\tselfpropcb = true;\n\t}\n\tdo {\n\t\tschedule_timeout_interruptible(fwd_progress_holdoff * HZ);\n\t\tif  (selfpropcb) {\n\t\t\tWRITE_ONCE(fcs.stop, 0);\n\t\t\tcur_ops->call(&fcs.rh, rcu_torture_fwd_prog_cb);\n\t\t}\n\t\tcver = READ_ONCE(rcu_torture_current_version);\n\t\tgps = cur_ops->get_gp_seq();\n\t\tsd = cur_ops->stall_dur() + 1;\n\t\tsd4 = (sd + fwd_progress_div - 1) / fwd_progress_div;\n\t\tdur = sd4 + torture_random(&trs) % (sd - sd4);\n\t\tstopat = jiffies + dur;\n\t\twhile (time_before(jiffies, stopat) && !torture_must_stop()) {\n\t\t\tidx = cur_ops->readlock();\n\t\t\tudelay(10);\n\t\t\tcur_ops->readunlock(idx);\n\t\t\tif (!fwd_progress_need_resched || need_resched())\n\t\t\t\tcond_resched();\n\t\t}\n\t\ttested_tries++;\n\t\tif (!time_before(jiffies, stopat) && !torture_must_stop()) {\n\t\t\ttested++;\n\t\t\tcver = READ_ONCE(rcu_torture_current_version) - cver;\n\t\t\tgps = rcutorture_seq_diff(cur_ops->get_gp_seq(), gps);\n\t\t\tWARN_ON(!cver && gps < 2);\n\t\t\tpr_alert(\"%s: Duration %ld cver %ld gps %ld\\n\", __func__, dur, cver, gps);\n\t\t}\n\t\tif (selfpropcb) {\n\t\t\tWRITE_ONCE(fcs.stop, 1);\n\t\t\tcur_ops->sync(); /* Wait for running CB to complete. */\n\t\t\tcur_ops->cb_barrier(); /* Wait for queued callbacks. */\n\t\t}\n\t\t/* Avoid slow periods, better to test when busy. */\n\t\tstutter_wait(\"rcu_torture_fwd_prog\");\n\t} while (!torture_must_stop());\n\tif (selfpropcb) {\n\t\tWARN_ON(READ_ONCE(fcs.stop) != 2);\n\t\tdestroy_rcu_head_on_stack(&fcs.rh);\n\t}\n\t/* Short runs might not contain a valid forward-progress attempt. */\n\tWARN_ON(!tested && tested_tries >= 5);\n\tpr_alert(\"%s: tested %d tested_tries %d\\n\", __func__, tested, tested_tries);\n\ttorture_kthread_stopping(\"rcu_torture_fwd_prog\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_fwd_prog_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1666-1675",
    "snippet": "static void rcu_torture_fwd_prog_cb(struct rcu_head *rhp)\n{\n\tstruct fwd_cb_state *fcsp = container_of(rhp, struct fwd_cb_state, rh);\n\n\tif (READ_ONCE(fcsp->stop)) {\n\t\tWRITE_ONCE(fcsp->stop, 2);\n\t\treturn;\n\t}\n\tcur_ops->call(&fcsp->rh, rcu_torture_fwd_prog_cb);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "&fcsp->rh",
            "rcu_torture_fwd_prog_cb"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "fcsp->stop",
            "2"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "fcsp->stop"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhp",
            "structfwd_cb_state",
            "rh"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcu_torture_fwd_prog_cb(struct rcu_head *rhp)\n{\n\tstruct fwd_cb_state *fcsp = container_of(rhp, struct fwd_cb_state, rh);\n\n\tif (READ_ONCE(fcsp->stop)) {\n\t\tWRITE_ONCE(fcsp->stop, 2);\n\t\treturn;\n\t}\n\tcur_ops->call(&fcsp->rh, rcu_torture_fwd_prog_cb);\n}"
  },
  {
    "function_name": "rcu_torture_stall_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1648-1653",
    "snippet": "static int __init rcu_torture_stall_init(void)\n{\n\tif (stall_cpu <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(rcu_torture_stall, NULL, stall_task);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *stall_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "rcu_torture_stall",
            "NULL",
            "stall_task"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stall_task;\n\nstatic int __init rcu_torture_stall_init(void)\n{\n\tif (stall_cpu <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(rcu_torture_stall, NULL, stall_task);\n}"
  },
  {
    "function_name": "rcu_torture_stall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1611-1645",
    "snippet": "static int rcu_torture_stall(void *args)\n{\n\tunsigned long stop_at;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall task started\");\n\tif (stall_cpu_holdoff > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall begin holdoff\");\n\t\tschedule_timeout_interruptible(stall_cpu_holdoff * HZ);\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall end holdoff\");\n\t}\n\tif (!kthread_should_stop()) {\n\t\tstop_at = ktime_get_seconds() + stall_cpu;\n\t\t/* RCU CPU stall is expected behavior in following code. */\n\t\trcu_read_lock();\n\t\tif (stall_cpu_irqsoff)\n\t\t\tlocal_irq_disable();\n\t\telse\n\t\t\tpreempt_disable();\n\t\tpr_alert(\"rcu_torture_stall start on CPU %d.\\n\",\n\t\t\t smp_processor_id());\n\t\twhile (ULONG_CMP_LT((unsigned long)ktime_get_seconds(),\n\t\t\t\t    stop_at))\n\t\t\tcontinue;  /* Induce RCU CPU stall warning. */\n\t\tif (stall_cpu_irqsoff)\n\t\t\tlocal_irq_enable();\n\t\telse\n\t\t\tpreempt_enable();\n\t\trcu_read_unlock();\n\t\tpr_alert(\"rcu_torture_stall end.\\n\");\n\t}\n\ttorture_shutdown_absorb(\"rcu_torture_stall\");\n\twhile (!kthread_should_stop())\n\t\tschedule_timeout_interruptible(10 * HZ);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "10 * HZ"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_absorb",
          "args": [
            "\"rcu_torture_stall\""
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "462-469",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu_torture_stall end.\\n\""
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "(unsigned long)ktime_get_seconds()",
            "stop_at"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_seconds",
          "args": [],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "908-914",
          "snippet": "time64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu_torture_stall start on CPU %d.\\n\"",
            "smp_processor_id()"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_stall end holdoff\""
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_stall begin holdoff\""
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_stall task started\""
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_stall(void *args)\n{\n\tunsigned long stop_at;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall task started\");\n\tif (stall_cpu_holdoff > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall begin holdoff\");\n\t\tschedule_timeout_interruptible(stall_cpu_holdoff * HZ);\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_stall end holdoff\");\n\t}\n\tif (!kthread_should_stop()) {\n\t\tstop_at = ktime_get_seconds() + stall_cpu;\n\t\t/* RCU CPU stall is expected behavior in following code. */\n\t\trcu_read_lock();\n\t\tif (stall_cpu_irqsoff)\n\t\t\tlocal_irq_disable();\n\t\telse\n\t\t\tpreempt_disable();\n\t\tpr_alert(\"rcu_torture_stall start on CPU %d.\\n\",\n\t\t\t smp_processor_id());\n\t\twhile (ULONG_CMP_LT((unsigned long)ktime_get_seconds(),\n\t\t\t\t    stop_at))\n\t\t\tcontinue;  /* Induce RCU CPU stall warning. */\n\t\tif (stall_cpu_irqsoff)\n\t\t\tlocal_irq_enable();\n\t\telse\n\t\t\tpreempt_enable();\n\t\trcu_read_unlock();\n\t\tpr_alert(\"rcu_torture_stall end.\\n\");\n\t}\n\ttorture_shutdown_absorb(\"rcu_torture_stall\");\n\twhile (!kthread_should_stop())\n\t\tschedule_timeout_interruptible(10 * HZ);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcutorture_booster_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1579-1605",
    "snippet": "static int rcutorture_booster_init(unsigned int cpu)\n{\n\tint retval;\n\n\tif (boost_tasks[cpu] != NULL)\n\t\treturn 0;  /* Already created, nothing more to do. */\n\n\t/* Don't allow time recalculation while creating a new task. */\n\tmutex_lock(&boost_mutex);\n\trcu_torture_disable_rt_throttle();\n\tVERBOSE_TOROUT_STRING(\"Creating rcu_torture_boost task\");\n\tboost_tasks[cpu] = kthread_create_on_node(rcu_torture_boost, NULL,\n\t\t\t\t\t\t  cpu_to_node(cpu),\n\t\t\t\t\t\t  \"rcu_torture_boost\");\n\tif (IS_ERR(boost_tasks[cpu])) {\n\t\tretval = PTR_ERR(boost_tasks[cpu]);\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost task create failed\");\n\t\tn_rcu_torture_boost_ktrerror++;\n\t\tboost_tasks[cpu] = NULL;\n\t\tmutex_unlock(&boost_mutex);\n\t\treturn retval;\n\t}\n\tkthread_bind(boost_tasks[cpu], cpu);\n\twake_up_process(boost_tasks[cpu]);\n\tmutex_unlock(&boost_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *boost_tasks[NR_CPUS];",
      "static long n_rcu_torture_boost_ktrerror;",
      "static DEFINE_MUTEX(boost_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&boost_mutex"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "boost_tasks[cpu]"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_bind",
          "args": [
            "boost_tasks[cpu]",
            "cpu"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_bind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "421-424",
          "snippet": "void kthread_bind(struct task_struct *p, unsigned int cpu)\n{\n\t__kthread_bind(p, cpu, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_bind(struct task_struct *p, unsigned int cpu)\n{\n\t__kthread_bind(p, cpu, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_boost task create failed\""
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "boost_tasks[cpu]"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "boost_tasks[cpu]"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create_on_node",
          "args": [
            "rcu_torture_boost",
            "NULL",
            "cpu_to_node(cpu)",
            "\"rcu_torture_boost\""
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_on_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "370-383",
          "snippet": "struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;",
            "struct task_struct *task;",
            "int node = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\nstruct task_struct *task;\nint node = -1;\n\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"Creating rcu_torture_boost task\""
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_disable_rt_throttle",
          "args": [],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_disable_rt_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "733-746",
          "snippet": "static void rcu_torture_disable_rt_throttle(void)\n{\n\t/*\n\t * Disable RT throttling so that rcutorture's boost threads don't get\n\t * throttled. Only possible if rcutorture is built-in otherwise the\n\t * user should manually do this by setting the sched_rt_period_us and\n\t * sched_rt_runtime sysctls.\n\t */\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime != -1)\n\t\treturn;\n\n\told_rt_runtime = sysctl_sched_rt_runtime;\n\tsysctl_sched_rt_runtime = -1;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int old_rt_runtime = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int old_rt_runtime = -1;\n\nstatic void rcu_torture_disable_rt_throttle(void)\n{\n\t/*\n\t * Disable RT throttling so that rcutorture's boost threads don't get\n\t * throttled. Only possible if rcutorture is built-in otherwise the\n\t * user should manually do this by setting the sched_rt_period_us and\n\t * sched_rt_runtime sysctls.\n\t */\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime != -1)\n\t\treturn;\n\n\told_rt_runtime = sysctl_sched_rt_runtime;\n\tsysctl_sched_rt_runtime = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&boost_mutex"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *boost_tasks[NR_CPUS];\nstatic long n_rcu_torture_boost_ktrerror;\nstatic DEFINE_MUTEX(boost_mutex);\n\nstatic int rcutorture_booster_init(unsigned int cpu)\n{\n\tint retval;\n\n\tif (boost_tasks[cpu] != NULL)\n\t\treturn 0;  /* Already created, nothing more to do. */\n\n\t/* Don't allow time recalculation while creating a new task. */\n\tmutex_lock(&boost_mutex);\n\trcu_torture_disable_rt_throttle();\n\tVERBOSE_TOROUT_STRING(\"Creating rcu_torture_boost task\");\n\tboost_tasks[cpu] = kthread_create_on_node(rcu_torture_boost, NULL,\n\t\t\t\t\t\t  cpu_to_node(cpu),\n\t\t\t\t\t\t  \"rcu_torture_boost\");\n\tif (IS_ERR(boost_tasks[cpu])) {\n\t\tretval = PTR_ERR(boost_tasks[cpu]);\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost task create failed\");\n\t\tn_rcu_torture_boost_ktrerror++;\n\t\tboost_tasks[cpu] = NULL;\n\t\tmutex_unlock(&boost_mutex);\n\t\treturn retval;\n\t}\n\tkthread_bind(boost_tasks[cpu], cpu);\n\twake_up_process(boost_tasks[cpu]);\n\tmutex_unlock(&boost_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcutorture_booster_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1562-1577",
    "snippet": "static int rcutorture_booster_cleanup(unsigned int cpu)\n{\n\tstruct task_struct *t;\n\n\tif (boost_tasks[cpu] == NULL)\n\t\treturn 0;\n\tmutex_lock(&boost_mutex);\n\tt = boost_tasks[cpu];\n\tboost_tasks[cpu] = NULL;\n\trcu_torture_enable_rt_throttle();\n\tmutex_unlock(&boost_mutex);\n\n\t/* This must be outside of the mutex, otherwise deadlock! */\n\ttorture_stop_kthread(rcu_torture_boost, t);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *boost_tasks[NR_CPUS];",
      "static DEFINE_MUTEX(boost_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "rcu_torture_boost",
            "t"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "787-794",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&boost_mutex"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_enable_rt_throttle",
          "args": [],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_enable_rt_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "748-755",
          "snippet": "static void rcu_torture_enable_rt_throttle(void)\n{\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime == -1)\n\t\treturn;\n\n\tsysctl_sched_rt_runtime = old_rt_runtime;\n\told_rt_runtime = -1;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int old_rt_runtime = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int old_rt_runtime = -1;\n\nstatic void rcu_torture_enable_rt_throttle(void)\n{\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime == -1)\n\t\treturn;\n\n\tsysctl_sched_rt_runtime = old_rt_runtime;\n\told_rt_runtime = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&boost_mutex"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *boost_tasks[NR_CPUS];\nstatic DEFINE_MUTEX(boost_mutex);\n\nstatic int rcutorture_booster_cleanup(unsigned int cpu)\n{\n\tstruct task_struct *t;\n\n\tif (boost_tasks[cpu] == NULL)\n\t\treturn 0;\n\tmutex_lock(&boost_mutex);\n\tt = boost_tasks[cpu];\n\tboost_tasks[cpu] = NULL;\n\trcu_torture_enable_rt_throttle();\n\tmutex_unlock(&boost_mutex);\n\n\t/* This must be outside of the mutex, otherwise deadlock! */\n\ttorture_stop_kthread(rcu_torture_boost, t);\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_print_module_parms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1539-1560",
    "snippet": "static void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static int nrealreaders;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d\\n\"",
            "torture_type",
            "tag",
            "nrealreaders",
            "nfakewriters",
            "stat_interval",
            "verbose",
            "test_no_idle_hz",
            "shuffle_interval",
            "stutter",
            "irqreader",
            "fqs_duration",
            "fqs_holdoff",
            "fqs_stutter",
            "test_boost",
            "cur_ops->can_boost",
            "test_boost_interval",
            "test_boost_duration",
            "shutdown_secs",
            "stall_cpu",
            "stall_cpu_holdoff",
            "stall_cpu_irqsoff",
            "n_barrier_cbs",
            "onoff_interval",
            "onoff_holdoff"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic int nrealreaders;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_torture_print_module_parms(struct rcu_torture_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s: nreaders=%d nfakewriters=%d \"\n\t\t \"stat_interval=%d verbose=%d test_no_idle_hz=%d \"\n\t\t \"shuffle_interval=%d stutter=%d irqreader=%d \"\n\t\t \"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"\n\t\t \"test_boost=%d/%d test_boost_interval=%d \"\n\t\t \"test_boost_duration=%d shutdown_secs=%d \"\n\t\t \"stall_cpu=%d stall_cpu_holdoff=%d stall_cpu_irqsoff=%d \"\n\t\t \"n_barrier_cbs=%d \"\n\t\t \"onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, nrealreaders, nfakewriters,\n\t\t stat_interval, verbose, test_no_idle_hz, shuffle_interval,\n\t\t stutter, irqreader, fqs_duration, fqs_holdoff, fqs_stutter,\n\t\t test_boost, cur_ops->can_boost,\n\t\t test_boost_interval, test_boost_duration, shutdown_secs,\n\t\t stall_cpu, stall_cpu_holdoff, stall_cpu_irqsoff,\n\t\t n_barrier_cbs,\n\t\t onoff_interval, onoff_holdoff);\n}"
  },
  {
    "function_name": "rcu_torture_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1526-1537",
    "snippet": "static int\nrcu_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\trcu_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"rcu_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_stats\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_stats\""
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_absorb",
          "args": [
            "\"rcu_torture_stats\""
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "462-469",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_stats_print",
          "args": [],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_stats_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1420-1520",
          "snippet": "static void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += per_cpu(rcu_torture_count, cpu)[i];\n\t\t\tbatchsummary[i] += per_cpu(rcu_torture_batch, cpu)[i];\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"rtc: %p ver: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trcu_torture_current,\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tn_barrier_successes,\n\t\tn_barrier_attempts,\n\t\tn_rcu_torture_barrier_error);\n\tpr_cont(\"cbflood: %ld\\n\", atomic_long_read(&n_cbfloods));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) != 0 ||\n\t    n_rcu_torture_barrier_error != 0 ||\n\t    n_rcu_torture_boost_ktrerror != 0 ||\n\t    n_rcu_torture_boost_rterror != 0 ||\n\t    n_rcu_torture_boost_failure != 0 ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(1);\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_torture_current != NULL) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#lx cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0UL : wtp->state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tshow_rcu_gp_kthreads();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10"
          ],
          "globals_used": [
            "static char *torture_type = \"rcu\";",
            "static struct task_struct *writer_task;",
            "static LIST_HEAD(rcu_torture_freelist);",
            "static struct rcu_torture __rcu *rcu_torture_current;",
            "static unsigned long rcu_torture_current_version;",
            "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];",
            "static atomic_t n_rcu_torture_alloc;",
            "static atomic_t n_rcu_torture_alloc_fail;",
            "static atomic_t n_rcu_torture_free;",
            "static atomic_t n_rcu_torture_mberror;",
            "static atomic_t n_rcu_torture_error;",
            "static long n_rcu_torture_barrier_error;",
            "static long n_rcu_torture_boost_ktrerror;",
            "static long n_rcu_torture_boost_rterror;",
            "static long n_rcu_torture_boost_failure;",
            "static long n_rcu_torture_boosts;",
            "static atomic_long_t n_rcu_torture_timers;",
            "static long n_barrier_attempts;",
            "static long n_barrier_successes;",
            "static atomic_long_t n_cbfloods;",
            "static int rcu_torture_writer_state;",
            "static struct rcu_torture_ops *cur_ops;",
            "static struct srcu_struct *srcu_ctlp = &srcu_ctl;",
            "static bool __maybe_unused"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct *writer_task;\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic unsigned long rcu_torture_current_version;\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\nstatic atomic_t n_rcu_torture_free;\nstatic atomic_t n_rcu_torture_mberror;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic long n_rcu_torture_boost_ktrerror;\nstatic long n_rcu_torture_boost_rterror;\nstatic long n_rcu_torture_boost_failure;\nstatic long n_rcu_torture_boosts;\nstatic atomic_long_t n_rcu_torture_timers;\nstatic long n_barrier_attempts;\nstatic long n_barrier_successes;\nstatic atomic_long_t n_cbfloods;\nstatic int rcu_torture_writer_state;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\nstatic bool __maybe_unused;\n\nstatic void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += per_cpu(rcu_torture_count, cpu)[i];\n\t\t\tbatchsummary[i] += per_cpu(rcu_torture_batch, cpu)[i];\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"rtc: %p ver: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trcu_torture_current,\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tn_barrier_successes,\n\t\tn_barrier_attempts,\n\t\tn_rcu_torture_barrier_error);\n\tpr_cont(\"cbflood: %ld\\n\", atomic_long_read(&n_cbfloods));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) != 0 ||\n\t    n_rcu_torture_barrier_error != 0 ||\n\t    n_rcu_torture_boost_ktrerror != 0 ||\n\t    n_rcu_torture_boost_rterror != 0 ||\n\t    n_rcu_torture_boost_failure != 0 ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(1);\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_torture_current != NULL) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#lx cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0UL : wtp->state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tshow_rcu_gp_kthreads();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "stat_interval * HZ"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_stats task started\""
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int\nrcu_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\trcu_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"rcu_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_stats\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_stats_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1420-1520",
    "snippet": "static void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += per_cpu(rcu_torture_count, cpu)[i];\n\t\t\tbatchsummary[i] += per_cpu(rcu_torture_batch, cpu)[i];\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"rtc: %p ver: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trcu_torture_current,\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tn_barrier_successes,\n\t\tn_barrier_attempts,\n\t\tn_rcu_torture_barrier_error);\n\tpr_cont(\"cbflood: %ld\\n\", atomic_long_read(&n_cbfloods));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) != 0 ||\n\t    n_rcu_torture_barrier_error != 0 ||\n\t    n_rcu_torture_boost_ktrerror != 0 ||\n\t    n_rcu_torture_boost_rterror != 0 ||\n\t    n_rcu_torture_boost_failure != 0 ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(1);\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_torture_current != NULL) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#lx cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0UL : wtp->state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tshow_rcu_gp_kthreads();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_TORTURE_PIPE_LEN 10"
    ],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static struct task_struct *writer_task;",
      "static LIST_HEAD(rcu_torture_freelist);",
      "static struct rcu_torture __rcu *rcu_torture_current;",
      "static unsigned long rcu_torture_current_version;",
      "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];",
      "static atomic_t n_rcu_torture_alloc;",
      "static atomic_t n_rcu_torture_alloc_fail;",
      "static atomic_t n_rcu_torture_free;",
      "static atomic_t n_rcu_torture_mberror;",
      "static atomic_t n_rcu_torture_error;",
      "static long n_rcu_torture_barrier_error;",
      "static long n_rcu_torture_boost_ktrerror;",
      "static long n_rcu_torture_boost_rterror;",
      "static long n_rcu_torture_boost_failure;",
      "static long n_rcu_torture_boosts;",
      "static atomic_long_t n_rcu_torture_timers;",
      "static long n_barrier_attempts;",
      "static long n_barrier_successes;",
      "static atomic_long_t n_cbfloods;",
      "static int rcu_torture_writer_state;",
      "static struct rcu_torture_ops *cur_ops;",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;",
      "static bool __maybe_unused"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_rcu_gp_kthreads",
          "args": [],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "show_rcu_gp_kthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "527-527",
          "snippet": "static inline void show_rcu_gp_kthreads(void) { }",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void show_rcu_gp_kthreads(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "wtp"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5268-5295",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"??? Writer stall state %s(%d) g%lu f%#x ->state %#lx cpu %d\\n\"",
            "rcu_torture_writer_state_getname()",
            "rcu_torture_writer_state",
            "gp_seq",
            "flags",
            "wtp == NULL ? ~0UL : wtp->state",
            "wtp == NULL ? -1 : (int)task_cpu(wtp)"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "wtp"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_writer_state_getname",
          "args": [],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_writer_state_getname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "223-230",
          "snippet": "static const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_torture_writer_state;",
            "static const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_writer_state;\nstatic const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};\n\nstatic const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "writer_task"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcutorture_get_gp_data",
          "args": [
            "cur_ops->ttype",
            "srcu_ctlp",
            "&flags",
            "&gp_seq"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "srcutorture_get_gp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1260-1268",
          "snippet": "void srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *sp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&sp->srcu_gp_seq);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *sp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&sp->srcu_gp_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_get_gp_data",
          "args": [
            "cur_ops->ttype",
            "&flags",
            "&gp_seq"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_get_gp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu.h",
          "lines": "482-487",
          "snippet": "static inline void rcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t\t\t  int *flags, unsigned long *gp_seq)\n{\n\t*flags = 0;\n\t*gp_seq = 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t\t\t  int *flags, unsigned long *gp_seq)\n{\n\t*flags = 0;\n\t*gp_seq = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->stats",
          "args": [],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %d\"",
            "atomic_read(&rcu_torture_wcount[i])"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rcu_torture_wcount[i]"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s \"",
            "torture_type",
            "TORTURE_FLAG"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s \"",
            "torture_type",
            "TORTURE_FLAG"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_error"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_mberror"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s \"",
            "torture_type",
            "TORTURE_FLAG"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n_cbfloods"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"barrier: %ld/%ld:%ld \"",
            "n_barrier_successes",
            "n_barrier_attempts",
            "n_rcu_torture_barrier_error"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_onoff_stats",
          "args": [],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "267-277",
          "snippet": "void torture_onoff_stats(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tpr_cont(\"onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (HZ=%d) \",\n\t\tn_online_successes, n_online_attempts,\n\t\tn_offline_successes, n_offline_attempts,\n\t\tmin_online, max_online,\n\t\tmin_offline, max_offline,\n\t\tsum_online, sum_offline, HZ);\n#endif /* #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_onoff_stats(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tpr_cont(\"onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (HZ=%d) \",\n\t\tn_online_successes, n_online_attempts,\n\t\tn_offline_successes, n_offline_attempts,\n\t\tmin_online, max_online,\n\t\tmin_offline, max_offline,\n\t\tsum_online, sum_offline, HZ);\n#endif /* #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"rtbf: %ld rtb: %ld nt: %ld \"",
            "n_rcu_torture_boost_failure",
            "n_rcu_torture_boosts",
            "atomic_long_read(&n_rcu_torture_timers)"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n_rcu_torture_timers"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"rtmbe: %d rtbe: %ld rtbke: %ld rtbre: %ld \"",
            "atomic_read(&n_rcu_torture_mberror)",
            "n_rcu_torture_barrier_error",
            "n_rcu_torture_boost_ktrerror",
            "n_rcu_torture_boost_rterror"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_mberror"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"rtc: %p ver: %lu tfle: %d rta: %d rtaf: %d rtf: %d \"",
            "rcu_torture_current",
            "rcu_torture_current_version",
            "list_empty(&rcu_torture_freelist)",
            "atomic_read(&n_rcu_torture_alloc)",
            "atomic_read(&n_rcu_torture_alloc_fail)",
            "atomic_read(&n_rcu_torture_free)"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_free"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_alloc_fail"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_rcu_torture_alloc"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rcu_torture_freelist"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s \"",
            "torture_type",
            "TORTURE_FLAG"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "rcu_torture_batch",
            "cpu"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct *writer_task;\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic unsigned long rcu_torture_current_version;\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\nstatic atomic_t n_rcu_torture_free;\nstatic atomic_t n_rcu_torture_mberror;\nstatic atomic_t n_rcu_torture_error;\nstatic long n_rcu_torture_barrier_error;\nstatic long n_rcu_torture_boost_ktrerror;\nstatic long n_rcu_torture_boost_rterror;\nstatic long n_rcu_torture_boost_failure;\nstatic long n_rcu_torture_boosts;\nstatic atomic_long_t n_rcu_torture_timers;\nstatic long n_barrier_attempts;\nstatic long n_barrier_successes;\nstatic atomic_long_t n_cbfloods;\nstatic int rcu_torture_writer_state;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\nstatic bool __maybe_unused;\n\nstatic void\nrcu_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong pipesummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tlong batchsummary[RCU_TORTURE_PIPE_LEN + 1] = { 0 };\n\tstatic unsigned long rtcv_snap = ULONG_MAX;\n\tstatic bool splatted;\n\tstruct task_struct *wtp;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\t\tpipesummary[i] += per_cpu(rcu_torture_count, cpu)[i];\n\t\t\tbatchsummary[i] += per_cpu(rcu_torture_batch, cpu)[i];\n\t\t}\n\t}\n\tfor (i = RCU_TORTURE_PIPE_LEN - 1; i >= 0; i--) {\n\t\tif (pipesummary[i] != 0)\n\t\t\tbreak;\n\t}\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"rtc: %p ver: %lu tfle: %d rta: %d rtaf: %d rtf: %d \",\n\t\trcu_torture_current,\n\t\trcu_torture_current_version,\n\t\tlist_empty(&rcu_torture_freelist),\n\t\tatomic_read(&n_rcu_torture_alloc),\n\t\tatomic_read(&n_rcu_torture_alloc_fail),\n\t\tatomic_read(&n_rcu_torture_free));\n\tpr_cont(\"rtmbe: %d rtbe: %ld rtbke: %ld rtbre: %ld \",\n\t\tatomic_read(&n_rcu_torture_mberror),\n\t\tn_rcu_torture_barrier_error,\n\t\tn_rcu_torture_boost_ktrerror,\n\t\tn_rcu_torture_boost_rterror);\n\tpr_cont(\"rtbf: %ld rtb: %ld nt: %ld \",\n\t\tn_rcu_torture_boost_failure,\n\t\tn_rcu_torture_boosts,\n\t\tatomic_long_read(&n_rcu_torture_timers));\n\ttorture_onoff_stats();\n\tpr_cont(\"barrier: %ld/%ld:%ld \",\n\t\tn_barrier_successes,\n\t\tn_barrier_attempts,\n\t\tn_rcu_torture_barrier_error);\n\tpr_cont(\"cbflood: %ld\\n\", atomic_long_read(&n_cbfloods));\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tif (atomic_read(&n_rcu_torture_mberror) != 0 ||\n\t    n_rcu_torture_barrier_error != 0 ||\n\t    n_rcu_torture_boost_ktrerror != 0 ||\n\t    n_rcu_torture_boost_rterror != 0 ||\n\t    n_rcu_torture_boost_failure != 0 ||\n\t    i > 1) {\n\t\tpr_cont(\"%s\", \"!!! \");\n\t\tatomic_inc(&n_rcu_torture_error);\n\t\tWARN_ON_ONCE(1);\n\t}\n\tpr_cont(\"Reader Pipe: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Reader Batch: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, TORTURE_FLAG);\n\tpr_cont(\"Free-Block Circulation: \");\n\tfor (i = 0; i < RCU_TORTURE_PIPE_LEN + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->stats)\n\t\tcur_ops->stats();\n\tif (rtcv_snap == rcu_torture_current_version &&\n\t    rcu_torture_current != NULL) {\n\t\tint __maybe_unused flags = 0;\n\t\tunsigned long __maybe_unused gp_seq = 0;\n\n\t\trcutorture_get_gp_data(cur_ops->ttype,\n\t\t\t\t       &flags, &gp_seq);\n\t\tsrcutorture_get_gp_data(cur_ops->ttype, srcu_ctlp,\n\t\t\t\t\t&flags, &gp_seq);\n\t\twtp = READ_ONCE(writer_task);\n\t\tpr_alert(\"??? Writer stall state %s(%d) g%lu f%#x ->state %#lx cpu %d\\n\",\n\t\t\t rcu_torture_writer_state_getname(),\n\t\t\t rcu_torture_writer_state, gp_seq, flags,\n\t\t\t wtp == NULL ? ~0UL : wtp->state,\n\t\t\t wtp == NULL ? -1 : (int)task_cpu(wtp));\n\t\tif (!splatted && wtp) {\n\t\t\tsched_show_task(wtp);\n\t\t\tsplatted = true;\n\t\t}\n\t\tshow_rcu_gp_kthreads();\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\trtcv_snap = rcu_torture_current_version;\n}"
  },
  {
    "function_name": "rcu_torture_reader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1375-1410",
    "snippet": "static int\nrcu_torture_reader(void *arg)\n{\n\tunsigned long lastsleep = jiffies;\n\tlong myid = (long)arg;\n\tint mynumonline = myid;\n\tDEFINE_TORTURE_RANDOM(rand);\n\tstruct timer_list t;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_reader task started\");\n\tset_user_nice(current, MAX_NICE);\n\tif (irqreader && cur_ops->irq_capable)\n\t\ttimer_setup_on_stack(&t, rcu_torture_timer, 0);\n\n\tdo {\n\t\tif (irqreader && cur_ops->irq_capable) {\n\t\t\tif (!timer_pending(&t))\n\t\t\t\tmod_timer(&t, jiffies + 1);\n\t\t}\n\t\tif (!rcu_torture_one_read(&rand))\n\t\t\tschedule_timeout_interruptible(HZ);\n\t\tif (time_after(jiffies, lastsleep)) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t\tlastsleep = jiffies + 10;\n\t\t}\n\t\twhile (num_online_cpus() < mynumonline && !torture_must_stop())\n\t\t\tschedule_timeout_interruptible(HZ / 5);\n\t\tstutter_wait(\"rcu_torture_reader\");\n\t} while (!torture_must_stop());\n\tif (irqreader && cur_ops->irq_capable) {\n\t\tdel_timer_sync(&t);\n\t\tdestroy_timer_on_stack(&t);\n\t}\n\ttorture_kthread_stopping(\"rcu_torture_reader\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_reader\""
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_timer_on_stack",
          "args": [
            "&t"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_timer_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "742-745",
          "snippet": "void destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&t"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_reader\""
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "576-594",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "HZ / 5"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "lastsleep"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_one_read",
          "args": [
            "&rand"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_one_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1282-1345",
          "snippet": "static bool rcu_torture_one_read(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  rcu_read_lock_bh_held() ||\n\t\t\t\t  rcu_read_lock_sched_held() ||\n\t\t\t\t  srcu_read_lock_held(srcu_ctlp) ||\n\t\t\t\t  torturing_tasks());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = p->rtort_pipe_count;\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate & RCUTORTURE_RDR_MASK);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10",
            "#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)",
            "#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)"
          ],
          "globals_used": [
            "static struct rcu_torture __rcu *rcu_torture_current;",
            "static atomic_t n_rcu_torture_mberror;",
            "static int err_segs_recorded;",
            "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
            "static int rt_read_nsegs;",
            "static struct rcu_torture_ops *cur_ops;",
            "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)\n#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)\n\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic atomic_t n_rcu_torture_mberror;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic bool rcu_torture_one_read(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  rcu_read_lock_bh_held() ||\n\t\t\t\t  rcu_read_lock_sched_held() ||\n\t\t\t\t  srcu_read_lock_held(srcu_ctlp) ||\n\t\t\t\t  torturing_tasks());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = p->rtort_pipe_count;\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate & RCUTORTURE_RDR_MASK);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&t",
            "jiffies + 1"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1100-1103",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&t"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup_on_stack",
          "args": [
            "&t",
            "rcu_torture_timer",
            "0"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_reader task started\""
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_TORTURE_RANDOM",
          "args": [
            "rand"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcu_torture_reader(void *arg)\n{\n\tunsigned long lastsleep = jiffies;\n\tlong myid = (long)arg;\n\tint mynumonline = myid;\n\tDEFINE_TORTURE_RANDOM(rand);\n\tstruct timer_list t;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_reader task started\");\n\tset_user_nice(current, MAX_NICE);\n\tif (irqreader && cur_ops->irq_capable)\n\t\ttimer_setup_on_stack(&t, rcu_torture_timer, 0);\n\n\tdo {\n\t\tif (irqreader && cur_ops->irq_capable) {\n\t\t\tif (!timer_pending(&t))\n\t\t\t\tmod_timer(&t, jiffies + 1);\n\t\t}\n\t\tif (!rcu_torture_one_read(&rand))\n\t\t\tschedule_timeout_interruptible(HZ);\n\t\tif (time_after(jiffies, lastsleep)) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t\tlastsleep = jiffies + 10;\n\t\t}\n\t\twhile (num_online_cpus() < mynumonline && !torture_must_stop())\n\t\t\tschedule_timeout_interruptible(HZ / 5);\n\t\tstutter_wait(\"rcu_torture_reader\");\n\t} while (!torture_must_stop());\n\tif (irqreader && cur_ops->irq_capable) {\n\t\tdel_timer_sync(&t);\n\t\tdestroy_timer_on_stack(&t);\n\t}\n\ttorture_kthread_stopping(\"rcu_torture_reader\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1355-1367",
    "snippet": "static void rcu_torture_timer(struct timer_list *unused)\n{\n\tatomic_long_inc(&n_rcu_torture_timers);\n\t(void)rcu_torture_one_read(this_cpu_ptr(&rcu_torture_timer_rand));\n\n\t/* Test call_rcu() invocation from interrupt handler. */\n\tif (cur_ops->call) {\n\t\tstruct rcu_head *rhp = kmalloc(sizeof(*rhp), GFP_NOWAIT);\n\n\t\tif (rhp)\n\t\t\tcur_ops->call(rhp, rcu_torture_timer_cb);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_long_t n_rcu_torture_timers;",
      "static struct rcu_torture_ops *cur_ops;",
      "static DEFINE_TORTURE_RANDOM_PERCPU(rcu_torture_timer_rand);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "rhp",
            "rcu_torture_timer_cb"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*rhp)",
            "GFP_NOWAIT"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_one_read",
          "args": [
            "this_cpu_ptr(&rcu_torture_timer_rand)"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_one_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1282-1345",
          "snippet": "static bool rcu_torture_one_read(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  rcu_read_lock_bh_held() ||\n\t\t\t\t  rcu_read_lock_sched_held() ||\n\t\t\t\t  srcu_read_lock_held(srcu_ctlp) ||\n\t\t\t\t  torturing_tasks());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = p->rtort_pipe_count;\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate & RCUTORTURE_RDR_MASK);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10",
            "#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)",
            "#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)"
          ],
          "globals_used": [
            "static struct rcu_torture __rcu *rcu_torture_current;",
            "static atomic_t n_rcu_torture_mberror;",
            "static int err_segs_recorded;",
            "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
            "static int rt_read_nsegs;",
            "static struct rcu_torture_ops *cur_ops;",
            "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)\n#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)\n\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic atomic_t n_rcu_torture_mberror;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic bool rcu_torture_one_read(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  rcu_read_lock_bh_held() ||\n\t\t\t\t  rcu_read_lock_sched_held() ||\n\t\t\t\t  srcu_read_lock_held(srcu_ctlp) ||\n\t\t\t\t  torturing_tasks());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = p->rtort_pipe_count;\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate & RCUTORTURE_RDR_MASK);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&rcu_torture_timer_rand"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&n_rcu_torture_timers"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_long_t n_rcu_torture_timers;\nstatic struct rcu_torture_ops *cur_ops;\nstatic DEFINE_TORTURE_RANDOM_PERCPU(rcu_torture_timer_rand);\n\nstatic void rcu_torture_timer(struct timer_list *unused)\n{\n\tatomic_long_inc(&n_rcu_torture_timers);\n\t(void)rcu_torture_one_read(this_cpu_ptr(&rcu_torture_timer_rand));\n\n\t/* Test call_rcu() invocation from interrupt handler. */\n\tif (cur_ops->call) {\n\t\tstruct rcu_head *rhp = kmalloc(sizeof(*rhp), GFP_NOWAIT);\n\n\t\tif (rhp)\n\t\t\tcur_ops->call(rhp, rcu_torture_timer_cb);\n\t}\n}"
  },
  {
    "function_name": "rcu_torture_one_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1282-1345",
    "snippet": "static bool rcu_torture_one_read(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  rcu_read_lock_bh_held() ||\n\t\t\t\t  rcu_read_lock_sched_held() ||\n\t\t\t\t  srcu_read_lock_held(srcu_ctlp) ||\n\t\t\t\t  torturing_tasks());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = p->rtort_pipe_count;\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate & RCUTORTURE_RDR_MASK);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_TORTURE_PIPE_LEN 10",
      "#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)",
      "#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)"
    ],
    "globals_used": [
      "static struct rcu_torture __rcu *rcu_torture_current;",
      "static atomic_t n_rcu_torture_mberror;",
      "static int err_segs_recorded;",
      "static struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];",
      "static int rt_read_nsegs;",
      "static struct rcu_torture_ops *cur_ops;",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&err_segs_recorded",
            "1"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "readstate & RCUTORTURE_RDR_MASK"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_one_extend",
          "args": [
            "&readstate",
            "0",
            "trsp",
            "rtrsp"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_one_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1160-1213",
          "snippet": "static void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tint idxnew = -1;\n\tint idxold = *readstate;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold < 0);\n\tWARN_ON_ONCE((idxold >> RCUTORTURE_RDR_SHIFT) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU)\n\t\tidxnew = cur_ops->readlock() << RCUTORTURE_RDR_SHIFT;\n\n\t/* Next, remove old protection, irq first due to bh conflict. */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_RCU)\n\t\tcur_ops->readunlock(idxold >> RCUTORTURE_RDR_SHIFT);\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew == -1)\n\t\tidxnew = idxold & ~RCUTORTURE_RDR_MASK;\n\tWARN_ON_ONCE(idxnew < 0);\n\tWARN_ON_ONCE((idxnew >> RCUTORTURE_RDR_SHIFT) > 1);\n\t*readstate = idxnew | newstate;\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) < 0);\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) > 1);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */",
            "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
            "#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */",
            "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
            "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
            "#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)",
            "#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)\n#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tint idxnew = -1;\n\tint idxold = *readstate;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold < 0);\n\tWARN_ON_ONCE((idxold >> RCUTORTURE_RDR_SHIFT) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU)\n\t\tidxnew = cur_ops->readlock() << RCUTORTURE_RDR_SHIFT;\n\n\t/* Next, remove old protection, irq first due to bh conflict. */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_RCU)\n\t\tcur_ops->readunlock(idxold >> RCUTORTURE_RDR_SHIFT);\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew == -1)\n\t\tidxnew = idxold & ~RCUTORTURE_RDR_MASK;\n\tWARN_ON_ONCE(idxnew < 0);\n\tWARN_ON_ONCE((idxnew >> RCUTORTURE_RDR_SHIFT) > 1);\n\t*readstate = idxnew | newstate;\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) < 0);\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) > 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "rcu_torture_batch[completed]"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_seq_diff",
          "args": [
            "completed",
            "started"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_seq_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "698-703",
          "snippet": "static unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "rcu_torture_count[pipe_count]"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_trace_rcu_torture_read",
          "args": [
            "cur_ops->name",
            "&p->rtort_rcu",
            "ts",
            "started",
            "completed"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "do_trace_rcu_torture_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "427-432",
          "snippet": "void do_trace_rcu_torture_read(const char *rcutorturename, struct rcu_head *rhp,\n\t\t\t       unsigned long secs,\n\t\t\t       unsigned long c_old, unsigned long c)\n{\n\ttrace_rcu_torture_read(rcutorturename, rhp, secs, c_old, c);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid do_trace_rcu_torture_read(const char *rcutorturename, struct rcu_head *rhp,\n\t\t\t       unsigned long secs,\n\t\t\t       unsigned long c_old, unsigned long c)\n{\n\ttrace_rcu_torture_read(rcutorturename, rhp, secs, c_old, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_loop_extend",
          "args": [
            "&readstate",
            "trsp",
            "rtrsp"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_loop_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1256-1275",
          "snippet": "static struct rt_read_seg *\nrcutorture_loop_extend(int *readstate, struct torture_random_state *trsp,\n\t\t       struct rt_read_seg *rtrsp)\n{\n\tint i;\n\tint j;\n\tint mask = rcutorture_extend_mask_max();\n\n\tWARN_ON_ONCE(!*readstate); /* -Existing- RCU read-side critsect! */\n\tif (!((mask - 1) & mask))\n\t\treturn rtrsp;  /* Current RCU reader not extendable. */\n\t/* Bias towards larger numbers of loops. */\n\ti = (torture_random(trsp) >> 3);\n\ti = ((i | (i >> 3)) & RCUTORTURE_RDR_MAX_LOOPS) + 1;\n\tfor (j = 0; j < i; j++) {\n\t\tmask = rcutorture_extend_mask(*readstate, trsp);\n\t\trcutorture_one_extend(readstate, mask, trsp, &rtrsp[j]);\n\t}\n\treturn &rtrsp[j];\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_RDR_MAX_LOOPS 0x7\t/* Maximum reader extensions. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_MAX_LOOPS 0x7\t/* Maximum reader extensions. */\n\nstatic struct rt_read_seg *\nrcutorture_loop_extend(int *readstate, struct torture_random_state *trsp,\n\t\t       struct rt_read_seg *rtrsp)\n{\n\tint i;\n\tint j;\n\tint mask = rcutorture_extend_mask_max();\n\n\tWARN_ON_ONCE(!*readstate); /* -Existing- RCU read-side critsect! */\n\tif (!((mask - 1) & mask))\n\t\treturn rtrsp;  /* Current RCU reader not extendable. */\n\t/* Bias towards larger numbers of loops. */\n\ti = (torture_random(trsp) >> 3);\n\ti = ((i | (i >> 3)) & RCUTORTURE_RDR_MAX_LOOPS) + 1;\n\tfor (j = 0; j < i; j++) {\n\t\tmask = rcutorture_extend_mask(*readstate, trsp);\n\t\trcutorture_one_extend(readstate, mask, trsp, &rtrsp[j]);\n\t}\n\treturn &rtrsp[j];\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_mberror"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "rcu_torture_current",
            "rcu_read_lock_bh_held() ||\n\t\t\t\t  rcu_read_lock_sched_held() ||\n\t\t\t\t  srcu_read_lock_held(srcu_ctlp) ||\n\t\t\t\t  torturing_tasks()"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torturing_tasks",
          "args": [],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock_held",
          "args": [
            "srcu_ctlp"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched_held",
          "args": [],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh_held",
          "args": [],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_trace_clock_local",
          "args": [],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_trace_clock_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "247-250",
          "snippet": "static u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_extend_mask",
          "args": [
            "readstate",
            "trsp"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_extend_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1227-1250",
          "snippet": "static int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT);\n\t/* Most of the time lots of bits, half the time only one bit. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\t/* Can't enable bh w/irq disabled. */\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    ((!(mask & RCUTORTURE_RDR_BH) && (oldmask & RCUTORTURE_RDR_BH)) ||\n\t     (!(mask & RCUTORTURE_RDR_RBH) && (oldmask & RCUTORTURE_RDR_RBH))))\n\t\tmask |= RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    !(mask & cur_ops->ext_irq_conflict) &&\n\t    (oldmask & cur_ops->ext_irq_conflict))\n\t\tmask |= cur_ops->ext_irq_conflict; /* Or if readers object. */\n\treturn mask ?: RCUTORTURE_RDR_RCU;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_RDR_NBITS\t 6\t/* Number of bits defined above. */",
            "#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
            "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
            "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
            "#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_NBITS\t 6\t/* Number of bits defined above. */\n#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT);\n\t/* Most of the time lots of bits, half the time only one bit. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\t/* Can't enable bh w/irq disabled. */\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    ((!(mask & RCUTORTURE_RDR_BH) && (oldmask & RCUTORTURE_RDR_BH)) ||\n\t     (!(mask & RCUTORTURE_RDR_RBH) && (oldmask & RCUTORTURE_RDR_RBH))))\n\t\tmask |= RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    !(mask & cur_ops->ext_irq_conflict) &&\n\t    (oldmask & cur_ops->ext_irq_conflict))\n\t\tmask |= cur_ops->ext_irq_conflict; /* Or if readers object. */\n\treturn mask ?: RCUTORTURE_RDR_RCU;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n#define RCUTORTURE_RDR_MAX_SEGS (RCUTORTURE_RDR_MAX_LOOPS + 3)\n#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)\n\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic atomic_t n_rcu_torture_mberror;\nstatic int err_segs_recorded;\nstatic struct rt_read_seg err_segs[RCUTORTURE_RDR_MAX_SEGS];\nstatic int rt_read_nsegs;\nstatic struct rcu_torture_ops *cur_ops;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic bool rcu_torture_one_read(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long started;\n\tunsigned long completed;\n\tint newstate;\n\tstruct rcu_torture *p;\n\tint pipe_count;\n\tint readstate = 0;\n\tstruct rt_read_seg rtseg[RCUTORTURE_RDR_MAX_SEGS] = { { 0 } };\n\tstruct rt_read_seg *rtrsp = &rtseg[0];\n\tstruct rt_read_seg *rtrsp1;\n\tunsigned long long ts;\n\n\tnewstate = rcutorture_extend_mask(readstate, trsp);\n\trcutorture_one_extend(&readstate, newstate, trsp, rtrsp++);\n\tstarted = cur_ops->get_gp_seq();\n\tts = rcu_trace_clock_local();\n\tp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t  rcu_read_lock_bh_held() ||\n\t\t\t\t  rcu_read_lock_sched_held() ||\n\t\t\t\t  srcu_read_lock_held(srcu_ctlp) ||\n\t\t\t\t  torturing_tasks());\n\tif (p == NULL) {\n\t\t/* Wait for rcu_torture_writer to get underway */\n\t\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\t\treturn false;\n\t}\n\tif (p->rtort_mbtest == 0)\n\t\tatomic_inc(&n_rcu_torture_mberror);\n\trtrsp = rcutorture_loop_extend(&readstate, trsp, rtrsp);\n\tpreempt_disable();\n\tpipe_count = p->rtort_pipe_count;\n\tif (pipe_count > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tpipe_count = RCU_TORTURE_PIPE_LEN;\n\t}\n\tcompleted = cur_ops->get_gp_seq();\n\tif (pipe_count > 1) {\n\t\tdo_trace_rcu_torture_read(cur_ops->name, &p->rtort_rcu,\n\t\t\t\t\t  ts, started, completed);\n\t\trcu_ftrace_dump(DUMP_ALL);\n\t}\n\t__this_cpu_inc(rcu_torture_count[pipe_count]);\n\tcompleted = rcutorture_seq_diff(completed, started);\n\tif (completed > RCU_TORTURE_PIPE_LEN) {\n\t\t/* Should not happen, but... */\n\t\tcompleted = RCU_TORTURE_PIPE_LEN;\n\t}\n\t__this_cpu_inc(rcu_torture_batch[completed]);\n\tpreempt_enable();\n\trcutorture_one_extend(&readstate, 0, trsp, rtrsp);\n\tWARN_ON_ONCE(readstate & RCUTORTURE_RDR_MASK);\n\n\t/* If error or close call, record the sequence of reader protections. */\n\tif ((pipe_count > 1 || completed > 1) && !xchg(&err_segs_recorded, 1)) {\n\t\ti = 0;\n\t\tfor (rtrsp1 = &rtseg[0]; rtrsp1 < rtrsp; rtrsp1++)\n\t\t\terr_segs[i++] = *rtrsp1;\n\t\trt_read_nsegs = i;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "rcutorture_loop_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1256-1275",
    "snippet": "static struct rt_read_seg *\nrcutorture_loop_extend(int *readstate, struct torture_random_state *trsp,\n\t\t       struct rt_read_seg *rtrsp)\n{\n\tint i;\n\tint j;\n\tint mask = rcutorture_extend_mask_max();\n\n\tWARN_ON_ONCE(!*readstate); /* -Existing- RCU read-side critsect! */\n\tif (!((mask - 1) & mask))\n\t\treturn rtrsp;  /* Current RCU reader not extendable. */\n\t/* Bias towards larger numbers of loops. */\n\ti = (torture_random(trsp) >> 3);\n\ti = ((i | (i >> 3)) & RCUTORTURE_RDR_MAX_LOOPS) + 1;\n\tfor (j = 0; j < i; j++) {\n\t\tmask = rcutorture_extend_mask(*readstate, trsp);\n\t\trcutorture_one_extend(readstate, mask, trsp, &rtrsp[j]);\n\t}\n\treturn &rtrsp[j];\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCUTORTURE_RDR_MAX_LOOPS 0x7\t/* Maximum reader extensions. */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcutorture_one_extend",
          "args": [
            "readstate",
            "mask",
            "trsp",
            "&rtrsp[j]"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_one_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1160-1213",
          "snippet": "static void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tint idxnew = -1;\n\tint idxold = *readstate;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold < 0);\n\tWARN_ON_ONCE((idxold >> RCUTORTURE_RDR_SHIFT) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU)\n\t\tidxnew = cur_ops->readlock() << RCUTORTURE_RDR_SHIFT;\n\n\t/* Next, remove old protection, irq first due to bh conflict. */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_RCU)\n\t\tcur_ops->readunlock(idxold >> RCUTORTURE_RDR_SHIFT);\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew == -1)\n\t\tidxnew = idxold & ~RCUTORTURE_RDR_MASK;\n\tWARN_ON_ONCE(idxnew < 0);\n\tWARN_ON_ONCE((idxnew >> RCUTORTURE_RDR_SHIFT) > 1);\n\t*readstate = idxnew | newstate;\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) < 0);\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) > 1);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */",
            "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
            "#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */",
            "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
            "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
            "#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)",
            "#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)\n#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tint idxnew = -1;\n\tint idxold = *readstate;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold < 0);\n\tWARN_ON_ONCE((idxold >> RCUTORTURE_RDR_SHIFT) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU)\n\t\tidxnew = cur_ops->readlock() << RCUTORTURE_RDR_SHIFT;\n\n\t/* Next, remove old protection, irq first due to bh conflict. */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_RCU)\n\t\tcur_ops->readunlock(idxold >> RCUTORTURE_RDR_SHIFT);\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew == -1)\n\t\tidxnew = idxold & ~RCUTORTURE_RDR_MASK;\n\tWARN_ON_ONCE(idxnew < 0);\n\tWARN_ON_ONCE((idxnew >> RCUTORTURE_RDR_SHIFT) > 1);\n\t*readstate = idxnew | newstate;\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) < 0);\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) > 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_extend_mask",
          "args": [
            "*readstate",
            "trsp"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_extend_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1227-1250",
          "snippet": "static int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT);\n\t/* Most of the time lots of bits, half the time only one bit. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\t/* Can't enable bh w/irq disabled. */\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    ((!(mask & RCUTORTURE_RDR_BH) && (oldmask & RCUTORTURE_RDR_BH)) ||\n\t     (!(mask & RCUTORTURE_RDR_RBH) && (oldmask & RCUTORTURE_RDR_RBH))))\n\t\tmask |= RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    !(mask & cur_ops->ext_irq_conflict) &&\n\t    (oldmask & cur_ops->ext_irq_conflict))\n\t\tmask |= cur_ops->ext_irq_conflict; /* Or if readers object. */\n\treturn mask ?: RCUTORTURE_RDR_RCU;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_RDR_NBITS\t 6\t/* Number of bits defined above. */",
            "#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */",
            "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
            "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
            "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
            "#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_NBITS\t 6\t/* Number of bits defined above. */\n#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT);\n\t/* Most of the time lots of bits, half the time only one bit. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\t/* Can't enable bh w/irq disabled. */\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    ((!(mask & RCUTORTURE_RDR_BH) && (oldmask & RCUTORTURE_RDR_BH)) ||\n\t     (!(mask & RCUTORTURE_RDR_RBH) && (oldmask & RCUTORTURE_RDR_RBH))))\n\t\tmask |= RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    !(mask & cur_ops->ext_irq_conflict) &&\n\t    (oldmask & cur_ops->ext_irq_conflict))\n\t\tmask |= cur_ops->ext_irq_conflict; /* Or if readers object. */\n\treturn mask ?: RCUTORTURE_RDR_RCU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!*readstate"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcutorture_extend_mask_max",
          "args": [],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_extend_mask_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1216-1224",
          "snippet": "static int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU;\n\treturn mask;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)",
            "#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)\n#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU;\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_MAX_LOOPS 0x7\t/* Maximum reader extensions. */\n\nstatic struct rt_read_seg *\nrcutorture_loop_extend(int *readstate, struct torture_random_state *trsp,\n\t\t       struct rt_read_seg *rtrsp)\n{\n\tint i;\n\tint j;\n\tint mask = rcutorture_extend_mask_max();\n\n\tWARN_ON_ONCE(!*readstate); /* -Existing- RCU read-side critsect! */\n\tif (!((mask - 1) & mask))\n\t\treturn rtrsp;  /* Current RCU reader not extendable. */\n\t/* Bias towards larger numbers of loops. */\n\ti = (torture_random(trsp) >> 3);\n\ti = ((i | (i >> 3)) & RCUTORTURE_RDR_MAX_LOOPS) + 1;\n\tfor (j = 0; j < i; j++) {\n\t\tmask = rcutorture_extend_mask(*readstate, trsp);\n\t\trcutorture_one_extend(readstate, mask, trsp, &rtrsp[j]);\n\t}\n\treturn &rtrsp[j];\n}"
  },
  {
    "function_name": "rcutorture_extend_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1227-1250",
    "snippet": "static int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT);\n\t/* Most of the time lots of bits, half the time only one bit. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\t/* Can't enable bh w/irq disabled. */\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    ((!(mask & RCUTORTURE_RDR_BH) && (oldmask & RCUTORTURE_RDR_BH)) ||\n\t     (!(mask & RCUTORTURE_RDR_RBH) && (oldmask & RCUTORTURE_RDR_RBH))))\n\t\tmask |= RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    !(mask & cur_ops->ext_irq_conflict) &&\n\t    (oldmask & cur_ops->ext_irq_conflict))\n\t\tmask |= cur_ops->ext_irq_conflict; /* Or if readers object. */\n\treturn mask ?: RCUTORTURE_RDR_RCU;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCUTORTURE_RDR_NBITS\t 6\t/* Number of bits defined above. */",
      "#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */",
      "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
      "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
      "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
      "#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */"
    ],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "mask >> RCUTORTURE_RDR_SHIFT"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcutorture_extend_mask_max",
          "args": [],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "rcutorture_extend_mask_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "1216-1224",
          "snippet": "static int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU;\n\treturn mask;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)",
            "#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */"
          ],
          "globals_used": [
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)\n#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU;\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_NBITS\t 6\t/* Number of bits defined above. */\n#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcutorture_extend_mask(int oldmask, struct torture_random_state *trsp)\n{\n\tint mask = rcutorture_extend_mask_max();\n\tunsigned long randmask1 = torture_random(trsp) >> 8;\n\tunsigned long randmask2 = randmask1 >> 3;\n\n\tWARN_ON_ONCE(mask >> RCUTORTURE_RDR_SHIFT);\n\t/* Most of the time lots of bits, half the time only one bit. */\n\tif (!(randmask1 & 0x7))\n\t\tmask = mask & randmask2;\n\telse\n\t\tmask = mask & (1 << (randmask2 % RCUTORTURE_RDR_NBITS));\n\t/* Can't enable bh w/irq disabled. */\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    ((!(mask & RCUTORTURE_RDR_BH) && (oldmask & RCUTORTURE_RDR_BH)) ||\n\t     (!(mask & RCUTORTURE_RDR_RBH) && (oldmask & RCUTORTURE_RDR_RBH))))\n\t\tmask |= RCUTORTURE_RDR_BH | RCUTORTURE_RDR_RBH;\n\tif ((mask & RCUTORTURE_RDR_IRQ) &&\n\t    !(mask & cur_ops->ext_irq_conflict) &&\n\t    (oldmask & cur_ops->ext_irq_conflict))\n\t\tmask |= cur_ops->ext_irq_conflict; /* Or if readers object. */\n\treturn mask ?: RCUTORTURE_RDR_RCU;\n}"
  },
  {
    "function_name": "rcutorture_extend_mask_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1216-1224",
    "snippet": "static int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU;\n\treturn mask;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)",
      "#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */"
    ],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "extendables & ~RCUTORTURE_MAX_EXTEND"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_MAX_EXTEND\t \\\n\t(RCUTORTURE_RDR_BH | RCUTORTURE_RDR_IRQ | RCUTORTURE_RDR_PREEMPT | \\\n\t RCUTORTURE_RDR_RBH | RCUTORTURE_RDR_SCHED)\n#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int rcutorture_extend_mask_max(void)\n{\n\tint mask;\n\n\tWARN_ON_ONCE(extendables & ~RCUTORTURE_MAX_EXTEND);\n\tmask = extendables & RCUTORTURE_MAX_EXTEND & cur_ops->extendables;\n\tmask = mask | RCUTORTURE_RDR_RCU;\n\treturn mask;\n}"
  },
  {
    "function_name": "rcutorture_one_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1160-1213",
    "snippet": "static void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tint idxnew = -1;\n\tint idxold = *readstate;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold < 0);\n\tWARN_ON_ONCE((idxold >> RCUTORTURE_RDR_SHIFT) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU)\n\t\tidxnew = cur_ops->readlock() << RCUTORTURE_RDR_SHIFT;\n\n\t/* Next, remove old protection, irq first due to bh conflict. */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_RCU)\n\t\tcur_ops->readunlock(idxold >> RCUTORTURE_RDR_SHIFT);\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew == -1)\n\t\tidxnew = idxold & ~RCUTORTURE_RDR_MASK;\n\tWARN_ON_ONCE(idxnew < 0);\n\tWARN_ON_ONCE((idxnew >> RCUTORTURE_RDR_SHIFT) > 1);\n\t*readstate = idxnew | newstate;\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) < 0);\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) > 1);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */",
      "#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */",
      "#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */",
      "#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */",
      "#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */",
      "#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */",
      "#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)",
      "#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */"
    ],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(*readstate >> RCUTORTURE_RDR_SHIFT) > 1"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(*readstate >> RCUTORTURE_RDR_SHIFT) < 0"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(idxnew >> RCUTORTURE_RDR_SHIFT) > 1"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "idxnew < 0"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->read_delay",
          "args": [
            "trsp",
            "rtrsp"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readunlock",
          "args": [
            "idxold >> RCUTORTURE_RDR_SHIFT"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_bh",
          "args": [],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "159-163",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readlock",
          "args": [],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh",
          "args": [],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(idxold >> RCUTORTURE_RDR_SHIFT) > 1"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "idxold < 0"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCUTORTURE_RDR_RCU\t 0x20\t/*  ... entering another RCU reader. */\n#define RCUTORTURE_RDR_SCHED\t 0x10\t/*  ... rcu_read_lock_sched(). */\n#define RCUTORTURE_RDR_RBH\t 0x08\t/*  ... rcu_read_lock_bh(). */\n#define RCUTORTURE_RDR_PREEMPT\t 0x04\t/*  ... disabling preemption. */\n#define RCUTORTURE_RDR_IRQ\t 0x02\t/*  ... disabling interrupts. */\n#define RCUTORTURE_RDR_BH\t 0x01\t/* Extend readers by disabling bh. */\n#define RCUTORTURE_RDR_MASK\t ((1 << RCUTORTURE_RDR_SHIFT) - 1)\n#define RCUTORTURE_RDR_SHIFT\t 8\t/* Put SRCU index in upper bits. */\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void rcutorture_one_extend(int *readstate, int newstate,\n\t\t\t\t  struct torture_random_state *trsp,\n\t\t\t\t  struct rt_read_seg *rtrsp)\n{\n\tint idxnew = -1;\n\tint idxold = *readstate;\n\tint statesnew = ~*readstate & newstate;\n\tint statesold = *readstate & ~newstate;\n\n\tWARN_ON_ONCE(idxold < 0);\n\tWARN_ON_ONCE((idxold >> RCUTORTURE_RDR_SHIFT) > 1);\n\trtrsp->rt_readstate = newstate;\n\n\t/* First, put new protection in place to avoid critical-section gap. */\n\tif (statesnew & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_disable();\n\tif (statesnew & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_disable();\n\tif (statesnew & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_disable();\n\tif (statesnew & RCUTORTURE_RDR_RBH)\n\t\trcu_read_lock_bh();\n\tif (statesnew & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_lock_sched();\n\tif (statesnew & RCUTORTURE_RDR_RCU)\n\t\tidxnew = cur_ops->readlock() << RCUTORTURE_RDR_SHIFT;\n\n\t/* Next, remove old protection, irq first due to bh conflict. */\n\tif (statesold & RCUTORTURE_RDR_IRQ)\n\t\tlocal_irq_enable();\n\tif (statesold & RCUTORTURE_RDR_BH)\n\t\tlocal_bh_enable();\n\tif (statesold & RCUTORTURE_RDR_PREEMPT)\n\t\tpreempt_enable();\n\tif (statesold & RCUTORTURE_RDR_RBH)\n\t\trcu_read_unlock_bh();\n\tif (statesold & RCUTORTURE_RDR_SCHED)\n\t\trcu_read_unlock_sched();\n\tif (statesold & RCUTORTURE_RDR_RCU)\n\t\tcur_ops->readunlock(idxold >> RCUTORTURE_RDR_SHIFT);\n\n\t/* Delay if neither beginning nor end and there was a change. */\n\tif ((statesnew || statesold) && *readstate && newstate)\n\t\tcur_ops->read_delay(trsp, rtrsp);\n\n\t/* Update the reader state. */\n\tif (idxnew == -1)\n\t\tidxnew = idxold & ~RCUTORTURE_RDR_MASK;\n\tWARN_ON_ONCE(idxnew < 0);\n\tWARN_ON_ONCE((idxnew >> RCUTORTURE_RDR_SHIFT) > 1);\n\t*readstate = idxnew | newstate;\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) < 0);\n\tWARN_ON_ONCE((*readstate >> RCUTORTURE_RDR_SHIFT) > 1);\n}"
  },
  {
    "function_name": "rcu_torture_timer_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1146-1149",
    "snippet": "static void rcu_torture_timer_cb(struct rcu_head *rhp)\n{\n\tkfree(rhp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rhp"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_timer_cb(struct rcu_head *rhp)\n{\n\tkfree(rhp);\n}"
  },
  {
    "function_name": "rcu_torture_fakewriter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "1115-1144",
    "snippet": "static int\nrcu_torture_fakewriter(void *arg)\n{\n\tDEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fakewriter task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\tschedule_timeout_uninterruptible(1 + torture_random(&rand)%10);\n\t\tudelay(torture_random(&rand) & 0x3ff);\n\t\tif (cur_ops->cb_barrier != NULL &&\n\t\t    torture_random(&rand) % (nfakewriters * 8) == 0) {\n\t\t\tcur_ops->cb_barrier();\n\t\t} else if (gp_normal == gp_exp) {\n\t\t\tif (cur_ops->sync && torture_random(&rand) & 0x80)\n\t\t\t\tcur_ops->sync();\n\t\t\telse if (cur_ops->exp_sync)\n\t\t\t\tcur_ops->exp_sync();\n\t\t} else if (gp_normal && cur_ops->sync) {\n\t\t\tcur_ops->sync();\n\t\t} else if (cur_ops->exp_sync) {\n\t\t\tcur_ops->exp_sync();\n\t\t}\n\t\tstutter_wait(\"rcu_torture_fakewriter\");\n\t} while (!torture_must_stop());\n\n\ttorture_kthread_stopping(\"rcu_torture_fakewriter\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_fakewriter\""
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_fakewriter\""
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "576-594",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->exp_sync",
          "args": [],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->exp_sync",
          "args": [],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&rand"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "torture_random(&rand) & 0x3ff"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1 + torture_random(&rand)%10"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1835-1839",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fakewriter task started\""
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_TORTURE_RANDOM",
          "args": [
            "rand"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcu_torture_fakewriter(void *arg)\n{\n\tDEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fakewriter task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\tschedule_timeout_uninterruptible(1 + torture_random(&rand)%10);\n\t\tudelay(torture_random(&rand) & 0x3ff);\n\t\tif (cur_ops->cb_barrier != NULL &&\n\t\t    torture_random(&rand) % (nfakewriters * 8) == 0) {\n\t\t\tcur_ops->cb_barrier();\n\t\t} else if (gp_normal == gp_exp) {\n\t\t\tif (cur_ops->sync && torture_random(&rand) & 0x80)\n\t\t\t\tcur_ops->sync();\n\t\t\telse if (cur_ops->exp_sync)\n\t\t\t\tcur_ops->exp_sync();\n\t\t} else if (gp_normal && cur_ops->sync) {\n\t\t\tcur_ops->sync();\n\t\t} else if (cur_ops->exp_sync) {\n\t\t\tcur_ops->exp_sync();\n\t\t}\n\t\tstutter_wait(\"rcu_torture_fakewriter\");\n\t} while (!torture_must_stop());\n\n\ttorture_kthread_stopping(\"rcu_torture_fakewriter\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "962-1109",
    "snippet": "static int\nrcu_torture_writer(void *arg)\n{\n\tbool can_expedite = !rcu_gp_is_expedited() && !rcu_gp_is_normal();\n\tint expediting = 0;\n\tunsigned long gp_snap;\n\tbool gp_cond1 = gp_cond, gp_exp1 = gp_exp, gp_normal1 = gp_normal;\n\tbool gp_sync1 = gp_sync;\n\tint i;\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *old_rp;\n\tstatic DEFINE_TORTURE_RANDOM(rand);\n\tint synctype[] = { RTWS_DEF_FREE, RTWS_EXP_SYNC,\n\t\t\t   RTWS_COND_GET, RTWS_SYNC };\n\tint nsynctypes = 0;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_writer task started\");\n\tif (!can_expedite)\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" GP expediting controlled from boot/sysfs for %s.\\n\",\n\t\t\t torture_type, cur_ops->name);\n\n\t/* Initialize synctype[] array.  If none set, take default. */\n\tif (!gp_cond1 && !gp_exp1 && !gp_normal1 && !gp_sync1)\n\t\tgp_cond1 = gp_exp1 = gp_normal1 = gp_sync1 = true;\n\tif (gp_cond1 && cur_ops->get_state && cur_ops->cond_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_COND_GET;\n\t\tpr_info(\"%s: Testing conditional GPs.\\n\", __func__);\n\t} else if (gp_cond && (!cur_ops->get_state || !cur_ops->cond_sync)) {\n\t\tpr_alert(\"%s: gp_cond without primitives.\\n\", __func__);\n\t}\n\tif (gp_exp1 && cur_ops->exp_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_EXP_SYNC;\n\t\tpr_info(\"%s: Testing expedited GPs.\\n\", __func__);\n\t} else if (gp_exp && !cur_ops->exp_sync) {\n\t\tpr_alert(\"%s: gp_exp without primitives.\\n\", __func__);\n\t}\n\tif (gp_normal1 && cur_ops->deferred_free) {\n\t\tsynctype[nsynctypes++] = RTWS_DEF_FREE;\n\t\tpr_info(\"%s: Testing asynchronous GPs.\\n\", __func__);\n\t} else if (gp_normal && !cur_ops->deferred_free) {\n\t\tpr_alert(\"%s: gp_normal without primitives.\\n\", __func__);\n\t}\n\tif (gp_sync1 && cur_ops->sync) {\n\t\tsynctype[nsynctypes++] = RTWS_SYNC;\n\t\tpr_info(\"%s: Testing normal GPs.\\n\", __func__);\n\t} else if (gp_sync && !cur_ops->sync) {\n\t\tpr_alert(\"%s: gp_sync without primitives.\\n\", __func__);\n\t}\n\tif (WARN_ONCE(nsynctypes == 0,\n\t\t      \"rcu_torture_writer: No update-side primitives.\\n\")) {\n\t\t/*\n\t\t * No updates primitives, so don't try updating.\n\t\t * The resulting test won't be testing much, hence the\n\t\t * above WARN_ONCE().\n\t\t */\n\t\trcu_torture_writer_state = RTWS_STOPPING;\n\t\ttorture_kthread_stopping(\"rcu_torture_writer\");\n\t}\n\n\tdo {\n\t\trcu_torture_writer_state = RTWS_FIXED_DELAY;\n\t\tschedule_timeout_uninterruptible(1);\n\t\trp = rcu_torture_alloc();\n\t\tif (rp == NULL)\n\t\t\tcontinue;\n\t\trp->rtort_pipe_count = 0;\n\t\trcu_torture_writer_state = RTWS_DELAY;\n\t\tudelay(torture_random(&rand) & 0x3ff);\n\t\trcu_torture_writer_state = RTWS_REPLACE;\n\t\told_rp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t\t       current == writer_task);\n\t\trp->rtort_mbtest = 1;\n\t\trcu_assign_pointer(rcu_torture_current, rp);\n\t\tsmp_wmb(); /* Mods to old_rp must follow rcu_assign_pointer() */\n\t\tif (old_rp) {\n\t\t\ti = old_rp->rtort_pipe_count;\n\t\t\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\t\t\ti = RCU_TORTURE_PIPE_LEN;\n\t\t\tatomic_inc(&rcu_torture_wcount[i]);\n\t\t\told_rp->rtort_pipe_count++;\n\t\t\tswitch (synctype[torture_random(&rand) % nsynctypes]) {\n\t\t\tcase RTWS_DEF_FREE:\n\t\t\t\trcu_torture_writer_state = RTWS_DEF_FREE;\n\t\t\t\tcur_ops->deferred_free(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_EXP_SYNC:\n\t\t\t\trcu_torture_writer_state = RTWS_EXP_SYNC;\n\t\t\t\tcur_ops->exp_sync();\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_COND_GET:\n\t\t\t\trcu_torture_writer_state = RTWS_COND_GET;\n\t\t\t\tgp_snap = cur_ops->get_state();\n\t\t\t\ti = torture_random(&rand) % 16;\n\t\t\t\tif (i != 0)\n\t\t\t\t\tschedule_timeout_interruptible(i);\n\t\t\t\tudelay(torture_random(&rand) % 1000);\n\t\t\t\trcu_torture_writer_state = RTWS_COND_SYNC;\n\t\t\t\tcur_ops->cond_sync(gp_snap);\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_SYNC:\n\t\t\t\trcu_torture_writer_state = RTWS_SYNC;\n\t\t\t\tcur_ops->sync();\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tWRITE_ONCE(rcu_torture_current_version,\n\t\t\t   rcu_torture_current_version + 1);\n\t\t/* Cycle through nesting levels of rcu_expedite_gp() calls. */\n\t\tif (can_expedite &&\n\t\t    !(torture_random(&rand) & 0xff & (!!expediting - 1))) {\n\t\t\tWARN_ON_ONCE(expediting == 0 && rcu_gp_is_expedited());\n\t\t\tif (expediting >= 0)\n\t\t\t\trcu_expedite_gp();\n\t\t\telse\n\t\t\t\trcu_unexpedite_gp();\n\t\t\tif (++expediting > 3)\n\t\t\t\texpediting = -expediting;\n\t\t} else if (!can_expedite) { /* Disabled during boot, recheck. */\n\t\t\tcan_expedite = !rcu_gp_is_expedited() &&\n\t\t\t\t       !rcu_gp_is_normal();\n\t\t}\n\t\trcu_torture_writer_state = RTWS_STUTTER;\n\t\tif (stutter_wait(\"rcu_torture_writer\"))\n\t\t\tfor (i = 0; i < ARRAY_SIZE(rcu_tortures); i++)\n\t\t\t\tif (list_empty(&rcu_tortures[i].rtort_free))\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t} while (!torture_must_stop());\n\t/* Reset expediting back to unexpedited. */\n\tif (expediting > 0)\n\t\texpediting = -expediting;\n\twhile (can_expedite && expediting++ < 0)\n\t\trcu_unexpedite_gp();\n\tWARN_ON_ONCE(can_expedite && rcu_gp_is_expedited());\n\tif (!can_expedite)\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Dynamic grace-period expediting was disabled.\\n\",\n\t\t\t torture_type);\n\trcu_torture_writer_state = RTWS_STOPPING;\n\ttorture_kthread_stopping(\"rcu_torture_writer\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RTWS_STOPPING\t\t9",
      "#define RTWS_STUTTER\t\t8",
      "#define RTWS_SYNC\t\t7",
      "#define RTWS_COND_SYNC\t\t6",
      "#define RTWS_COND_GET\t\t5",
      "#define RTWS_EXP_SYNC\t\t4",
      "#define RTWS_DEF_FREE\t\t3",
      "#define RTWS_REPLACE\t\t2",
      "#define RTWS_DELAY\t\t1",
      "#define RTWS_FIXED_DELAY\t0",
      "#define RCU_TORTURE_PIPE_LEN 10"
    ],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static struct task_struct *writer_task;",
      "static struct rcu_torture __rcu *rcu_torture_current;",
      "static unsigned long rcu_torture_current_version;",
      "static struct rcu_torture rcu_tortures[10 * RCU_TORTURE_PIPE_LEN];",
      "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];",
      "static int rcu_torture_writer_state;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_writer\""
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t\t \" Dynamic grace-period expediting was disabled.\\n\"",
            "torture_type"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "can_expedite && rcu_gp_is_expedited()"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_expedited",
          "args": [],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "149-153",
          "snippet": "bool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting) ||\n\t       rcu_scheduler_active == RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting) ||\n\t       rcu_scheduler_active == RCU_SCHEDULER_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_unexpedite_gp",
          "args": [],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_unexpedite_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "178-181",
          "snippet": "void rcu_unexpedite_gp(void)\n{\n\tatomic_dec(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_unexpedite_gp(void)\n{\n\tatomic_dec(&rcu_expedited_nesting);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rcu_tortures[i].rtort_free"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rcu_tortures"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_writer\""
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "576-594",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_normal",
          "args": [],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "133-137",
          "snippet": "bool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_expedite_gp",
          "args": [],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_expedite_gp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "163-166",
          "snippet": "void rcu_expedite_gp(void)\n{\n\tatomic_inc(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_expedite_gp(void)\n{\n\tatomic_inc(&rcu_expedited_nesting);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "expediting == 0 && rcu_gp_is_expedited()"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&rand"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rcu_torture_current_version",
            "rcu_torture_current_version + 1"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_pipe_update",
          "args": [
            "old_rp"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_pipe_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "401-415",
          "snippet": "static void\nrcu_torture_pipe_update(struct rcu_torture *old_rp)\n{\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *rp1;\n\n\tif (old_rp)\n\t\tlist_add(&old_rp->rtort_free, &rcu_torture_removed);\n\tlist_for_each_entry_safe(rp, rp1, &rcu_torture_removed, rtort_free) {\n\t\tif (rcu_torture_pipe_update_one(rp)) {\n\t\t\tlist_del(&rp->rtort_free);\n\t\t\trcu_torture_free(rp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head rcu_torture_removed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct list_head rcu_torture_removed;\n\nstatic void\nrcu_torture_pipe_update(struct rcu_torture *old_rp)\n{\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *rp1;\n\n\tif (old_rp)\n\t\tlist_add(&old_rp->rtort_free, &rcu_torture_removed);\n\tlist_for_each_entry_safe(rp, rp1, &rcu_torture_removed, rtort_free) {\n\t\tif (rcu_torture_pipe_update_one(rp)) {\n\t\t\tlist_del(&rp->rtort_free);\n\t\t\trcu_torture_free(rp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->sync",
          "args": [],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->cond_sync",
          "args": [
            "gp_snap"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "torture_random(&rand) % 1000"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "i"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_state",
          "args": [],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->exp_sync",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->deferred_free",
          "args": [
            "old_rp"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rcu_torture_wcount[i]"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "rcu_torture_current",
            "rp"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "rcu_torture_current",
            "current == writer_task"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "torture_random(&rand) & 0x3ff"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_alloc",
          "args": [],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "265-281",
          "snippet": "static struct rcu_torture *\nrcu_torture_alloc(void)\n{\n\tstruct list_head *p;\n\n\tspin_lock_bh(&rcu_torture_lock);\n\tif (list_empty(&rcu_torture_freelist)) {\n\t\tatomic_inc(&n_rcu_torture_alloc_fail);\n\t\tspin_unlock_bh(&rcu_torture_lock);\n\t\treturn NULL;\n\t}\n\tatomic_inc(&n_rcu_torture_alloc);\n\tp = rcu_torture_freelist.next;\n\tlist_del_init(p);\n\tspin_unlock_bh(&rcu_torture_lock);\n\treturn container_of(p, struct rcu_torture, rtort_free);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(rcu_torture_freelist);",
            "static DEFINE_SPINLOCK(rcu_torture_lock);",
            "static atomic_t n_rcu_torture_alloc;",
            "static atomic_t n_rcu_torture_alloc_fail;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic DEFINE_SPINLOCK(rcu_torture_lock);\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\n\nstatic struct rcu_torture *\nrcu_torture_alloc(void)\n{\n\tstruct list_head *p;\n\n\tspin_lock_bh(&rcu_torture_lock);\n\tif (list_empty(&rcu_torture_freelist)) {\n\t\tatomic_inc(&n_rcu_torture_alloc_fail);\n\t\tspin_unlock_bh(&rcu_torture_lock);\n\t\treturn NULL;\n\t}\n\tatomic_inc(&n_rcu_torture_alloc);\n\tp = rcu_torture_freelist.next;\n\tlist_del_init(p);\n\tspin_unlock_bh(&rcu_torture_lock);\n\treturn container_of(p, struct rcu_torture, rtort_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1835-1839",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "nsynctypes == 0",
            "\"rcu_torture_writer: No update-side primitives.\\n\""
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: gp_sync without primitives.\\n\"",
            "__func__"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Testing normal GPs.\\n\"",
            "__func__"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: gp_normal without primitives.\\n\"",
            "__func__"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Testing asynchronous GPs.\\n\"",
            "__func__"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: gp_exp without primitives.\\n\"",
            "__func__"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Testing expedited GPs.\\n\"",
            "__func__"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s: gp_cond without primitives.\\n\"",
            "__func__"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Testing conditional GPs.\\n\"",
            "__func__"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t\t \" GP expediting controlled from boot/sysfs for %s.\\n\"",
            "torture_type",
            "cur_ops->name"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_writer task started\""
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RTWS_STOPPING\t\t9\n#define RTWS_STUTTER\t\t8\n#define RTWS_SYNC\t\t7\n#define RTWS_COND_SYNC\t\t6\n#define RTWS_COND_GET\t\t5\n#define RTWS_EXP_SYNC\t\t4\n#define RTWS_DEF_FREE\t\t3\n#define RTWS_REPLACE\t\t2\n#define RTWS_DELAY\t\t1\n#define RTWS_FIXED_DELAY\t0\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic char *torture_type = \"rcu\";\nstatic struct task_struct *writer_task;\nstatic struct rcu_torture __rcu *rcu_torture_current;\nstatic unsigned long rcu_torture_current_version;\nstatic struct rcu_torture rcu_tortures[10 * RCU_TORTURE_PIPE_LEN];\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\nstatic int rcu_torture_writer_state;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcu_torture_writer(void *arg)\n{\n\tbool can_expedite = !rcu_gp_is_expedited() && !rcu_gp_is_normal();\n\tint expediting = 0;\n\tunsigned long gp_snap;\n\tbool gp_cond1 = gp_cond, gp_exp1 = gp_exp, gp_normal1 = gp_normal;\n\tbool gp_sync1 = gp_sync;\n\tint i;\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *old_rp;\n\tstatic DEFINE_TORTURE_RANDOM(rand);\n\tint synctype[] = { RTWS_DEF_FREE, RTWS_EXP_SYNC,\n\t\t\t   RTWS_COND_GET, RTWS_SYNC };\n\tint nsynctypes = 0;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_writer task started\");\n\tif (!can_expedite)\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" GP expediting controlled from boot/sysfs for %s.\\n\",\n\t\t\t torture_type, cur_ops->name);\n\n\t/* Initialize synctype[] array.  If none set, take default. */\n\tif (!gp_cond1 && !gp_exp1 && !gp_normal1 && !gp_sync1)\n\t\tgp_cond1 = gp_exp1 = gp_normal1 = gp_sync1 = true;\n\tif (gp_cond1 && cur_ops->get_state && cur_ops->cond_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_COND_GET;\n\t\tpr_info(\"%s: Testing conditional GPs.\\n\", __func__);\n\t} else if (gp_cond && (!cur_ops->get_state || !cur_ops->cond_sync)) {\n\t\tpr_alert(\"%s: gp_cond without primitives.\\n\", __func__);\n\t}\n\tif (gp_exp1 && cur_ops->exp_sync) {\n\t\tsynctype[nsynctypes++] = RTWS_EXP_SYNC;\n\t\tpr_info(\"%s: Testing expedited GPs.\\n\", __func__);\n\t} else if (gp_exp && !cur_ops->exp_sync) {\n\t\tpr_alert(\"%s: gp_exp without primitives.\\n\", __func__);\n\t}\n\tif (gp_normal1 && cur_ops->deferred_free) {\n\t\tsynctype[nsynctypes++] = RTWS_DEF_FREE;\n\t\tpr_info(\"%s: Testing asynchronous GPs.\\n\", __func__);\n\t} else if (gp_normal && !cur_ops->deferred_free) {\n\t\tpr_alert(\"%s: gp_normal without primitives.\\n\", __func__);\n\t}\n\tif (gp_sync1 && cur_ops->sync) {\n\t\tsynctype[nsynctypes++] = RTWS_SYNC;\n\t\tpr_info(\"%s: Testing normal GPs.\\n\", __func__);\n\t} else if (gp_sync && !cur_ops->sync) {\n\t\tpr_alert(\"%s: gp_sync without primitives.\\n\", __func__);\n\t}\n\tif (WARN_ONCE(nsynctypes == 0,\n\t\t      \"rcu_torture_writer: No update-side primitives.\\n\")) {\n\t\t/*\n\t\t * No updates primitives, so don't try updating.\n\t\t * The resulting test won't be testing much, hence the\n\t\t * above WARN_ONCE().\n\t\t */\n\t\trcu_torture_writer_state = RTWS_STOPPING;\n\t\ttorture_kthread_stopping(\"rcu_torture_writer\");\n\t}\n\n\tdo {\n\t\trcu_torture_writer_state = RTWS_FIXED_DELAY;\n\t\tschedule_timeout_uninterruptible(1);\n\t\trp = rcu_torture_alloc();\n\t\tif (rp == NULL)\n\t\t\tcontinue;\n\t\trp->rtort_pipe_count = 0;\n\t\trcu_torture_writer_state = RTWS_DELAY;\n\t\tudelay(torture_random(&rand) & 0x3ff);\n\t\trcu_torture_writer_state = RTWS_REPLACE;\n\t\told_rp = rcu_dereference_check(rcu_torture_current,\n\t\t\t\t\t       current == writer_task);\n\t\trp->rtort_mbtest = 1;\n\t\trcu_assign_pointer(rcu_torture_current, rp);\n\t\tsmp_wmb(); /* Mods to old_rp must follow rcu_assign_pointer() */\n\t\tif (old_rp) {\n\t\t\ti = old_rp->rtort_pipe_count;\n\t\t\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\t\t\ti = RCU_TORTURE_PIPE_LEN;\n\t\t\tatomic_inc(&rcu_torture_wcount[i]);\n\t\t\told_rp->rtort_pipe_count++;\n\t\t\tswitch (synctype[torture_random(&rand) % nsynctypes]) {\n\t\t\tcase RTWS_DEF_FREE:\n\t\t\t\trcu_torture_writer_state = RTWS_DEF_FREE;\n\t\t\t\tcur_ops->deferred_free(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_EXP_SYNC:\n\t\t\t\trcu_torture_writer_state = RTWS_EXP_SYNC;\n\t\t\t\tcur_ops->exp_sync();\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_COND_GET:\n\t\t\t\trcu_torture_writer_state = RTWS_COND_GET;\n\t\t\t\tgp_snap = cur_ops->get_state();\n\t\t\t\ti = torture_random(&rand) % 16;\n\t\t\t\tif (i != 0)\n\t\t\t\t\tschedule_timeout_interruptible(i);\n\t\t\t\tudelay(torture_random(&rand) % 1000);\n\t\t\t\trcu_torture_writer_state = RTWS_COND_SYNC;\n\t\t\t\tcur_ops->cond_sync(gp_snap);\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tcase RTWS_SYNC:\n\t\t\t\trcu_torture_writer_state = RTWS_SYNC;\n\t\t\t\tcur_ops->sync();\n\t\t\t\trcu_torture_pipe_update(old_rp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tWRITE_ONCE(rcu_torture_current_version,\n\t\t\t   rcu_torture_current_version + 1);\n\t\t/* Cycle through nesting levels of rcu_expedite_gp() calls. */\n\t\tif (can_expedite &&\n\t\t    !(torture_random(&rand) & 0xff & (!!expediting - 1))) {\n\t\t\tWARN_ON_ONCE(expediting == 0 && rcu_gp_is_expedited());\n\t\t\tif (expediting >= 0)\n\t\t\t\trcu_expedite_gp();\n\t\t\telse\n\t\t\t\trcu_unexpedite_gp();\n\t\t\tif (++expediting > 3)\n\t\t\t\texpediting = -expediting;\n\t\t} else if (!can_expedite) { /* Disabled during boot, recheck. */\n\t\t\tcan_expedite = !rcu_gp_is_expedited() &&\n\t\t\t\t       !rcu_gp_is_normal();\n\t\t}\n\t\trcu_torture_writer_state = RTWS_STUTTER;\n\t\tif (stutter_wait(\"rcu_torture_writer\"))\n\t\t\tfor (i = 0; i < ARRAY_SIZE(rcu_tortures); i++)\n\t\t\t\tif (list_empty(&rcu_tortures[i].rtort_free))\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t} while (!torture_must_stop());\n\t/* Reset expediting back to unexpedited. */\n\tif (expediting > 0)\n\t\texpediting = -expediting;\n\twhile (can_expedite && expediting++ < 0)\n\t\trcu_unexpedite_gp();\n\tWARN_ON_ONCE(can_expedite && rcu_gp_is_expedited());\n\tif (!can_expedite)\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \" Dynamic grace-period expediting was disabled.\\n\",\n\t\t\t torture_type);\n\trcu_torture_writer_state = RTWS_STOPPING;\n\ttorture_kthread_stopping(\"rcu_torture_writer\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_fqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "931-955",
    "snippet": "static int\nrcu_torture_fqs(void *arg)\n{\n\tunsigned long fqs_resume_time;\n\tint fqs_burst_remaining;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fqs task started\");\n\tdo {\n\t\tfqs_resume_time = jiffies + fqs_stutter * HZ;\n\t\twhile (ULONG_CMP_LT(jiffies, fqs_resume_time) &&\n\t\t       !kthread_should_stop()) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t}\n\t\tfqs_burst_remaining = fqs_duration;\n\t\twhile (fqs_burst_remaining > 0 &&\n\t\t       !kthread_should_stop()) {\n\t\t\tcur_ops->fqs();\n\t\t\tudelay(fqs_holdoff);\n\t\t\tfqs_burst_remaining -= fqs_holdoff;\n\t\t}\n\t\tstutter_wait(\"rcu_torture_fqs\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_fqs\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_fqs\""
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_fqs\""
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "576-594",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "fqs_holdoff"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->fqs",
          "args": [],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "1"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "jiffies",
            "fqs_resume_time"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_fqs task started\""
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcu_torture_fqs(void *arg)\n{\n\tunsigned long fqs_resume_time;\n\tint fqs_burst_remaining;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_fqs task started\");\n\tdo {\n\t\tfqs_resume_time = jiffies + fqs_stutter * HZ;\n\t\twhile (ULONG_CMP_LT(jiffies, fqs_resume_time) &&\n\t\t       !kthread_should_stop()) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t}\n\t\tfqs_burst_remaining = fqs_duration;\n\t\twhile (fqs_burst_remaining > 0 &&\n\t\t       !kthread_should_stop()) {\n\t\t\tcur_ops->fqs();\n\t\t\tudelay(fqs_holdoff);\n\t\t\tfqs_burst_remaining -= fqs_holdoff;\n\t\t}\n\t\tstutter_wait(\"rcu_torture_fqs\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"rcu_torture_fqs\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_cbflood",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "882-924",
    "snippet": "static int\nrcu_torture_cbflood(void *arg)\n{\n\tint err = 1;\n\tint i;\n\tint j;\n\tstruct rcu_head *rhp;\n\n\tif (cbflood_n_per_burst > 0 &&\n\t    cbflood_inter_holdoff > 0 &&\n\t    cbflood_intra_holdoff > 0 &&\n\t    cur_ops->call &&\n\t    cur_ops->cb_barrier) {\n\t\trhp = vmalloc(array3_size(cbflood_n_burst,\n\t\t\t\t\t  cbflood_n_per_burst,\n\t\t\t\t\t  sizeof(*rhp)));\n\t\terr = !rhp;\n\t}\n\tif (err) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_cbflood disabled: Bad args or OOM\");\n\t\tgoto wait_for_stop;\n\t}\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_cbflood task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(cbflood_inter_holdoff);\n\t\tatomic_long_inc(&n_cbfloods);\n\t\tWARN_ON(signal_pending(current));\n\t\tfor (i = 0; i < cbflood_n_burst; i++) {\n\t\t\tfor (j = 0; j < cbflood_n_per_burst; j++) {\n\t\t\t\tcur_ops->call(&rhp[i * cbflood_n_per_burst + j],\n\t\t\t\t\t      rcu_torture_cbflood_cb);\n\t\t\t}\n\t\t\tschedule_timeout_interruptible(cbflood_intra_holdoff);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t}\n\t\tcur_ops->cb_barrier();\n\t\tstutter_wait(\"rcu_torture_cbflood\");\n\t} while (!torture_must_stop());\n\tvfree(rhp);\nwait_for_stop:\n\ttorture_kthread_stopping(\"rcu_torture_cbflood\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_long_t n_cbfloods;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_cbflood\""
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "rhp"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_cbflood\""
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "576-594",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cb_barrier",
          "args": [],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "cbflood_intra_holdoff"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->call",
          "args": [
            "&rhp[i * cbflood_n_per_burst + j]",
            "rcu_torture_cbflood_cb"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "signal_pending(current)"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&n_cbfloods"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_cbflood task started\""
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_cbflood disabled: Bad args or OOM\""
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "array3_size(cbflood_n_burst,\n\t\t\t\t\t  cbflood_n_per_burst,\n\t\t\t\t\t  sizeof(*rhp))"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array3_size",
          "args": [
            "cbflood_n_burst",
            "cbflood_n_per_burst",
            "sizeof(*rhp)"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_long_t n_cbfloods;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcu_torture_cbflood(void *arg)\n{\n\tint err = 1;\n\tint i;\n\tint j;\n\tstruct rcu_head *rhp;\n\n\tif (cbflood_n_per_burst > 0 &&\n\t    cbflood_inter_holdoff > 0 &&\n\t    cbflood_intra_holdoff > 0 &&\n\t    cur_ops->call &&\n\t    cur_ops->cb_barrier) {\n\t\trhp = vmalloc(array3_size(cbflood_n_burst,\n\t\t\t\t\t  cbflood_n_per_burst,\n\t\t\t\t\t  sizeof(*rhp)));\n\t\terr = !rhp;\n\t}\n\tif (err) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_cbflood disabled: Bad args or OOM\");\n\t\tgoto wait_for_stop;\n\t}\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_cbflood task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(cbflood_inter_holdoff);\n\t\tatomic_long_inc(&n_cbfloods);\n\t\tWARN_ON(signal_pending(current));\n\t\tfor (i = 0; i < cbflood_n_burst; i++) {\n\t\t\tfor (j = 0; j < cbflood_n_per_burst; j++) {\n\t\t\t\tcur_ops->call(&rhp[i * cbflood_n_per_burst + j],\n\t\t\t\t\t      rcu_torture_cbflood_cb);\n\t\t\t}\n\t\t\tschedule_timeout_interruptible(cbflood_intra_holdoff);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t}\n\t\tcur_ops->cb_barrier();\n\t\tstutter_wait(\"rcu_torture_cbflood\");\n\t} while (!torture_must_stop());\n\tvfree(rhp);\nwait_for_stop:\n\ttorture_kthread_stopping(\"rcu_torture_cbflood\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_cbflood_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "873-875",
    "snippet": "static void rcu_torture_cbflood_cb(struct rcu_head *rhp)\n{\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_cbflood_cb(struct rcu_head *rhp)\n{\n}"
  },
  {
    "function_name": "rcu_torture_boost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "769-871",
    "snippet": "static int rcu_torture_boost(void *arg)\n{\n\tunsigned long call_rcu_time;\n\tunsigned long endtime;\n\tunsigned long oldstarttime;\n\tstruct rcu_boost_inflight rbi = { .inflight = 0 };\n\tstruct sched_param sp;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost started\");\n\n\t/* Set real-time priority. */\n\tsp.sched_priority = 1;\n\tif (sched_setscheduler(current, SCHED_FIFO, &sp) < 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost RT prio failed!\");\n\t\tn_rcu_torture_boost_rterror++;\n\t}\n\n\tinit_rcu_head_on_stack(&rbi.rcu);\n\t/* Each pass through the following loop does one boost-test cycle. */\n\tdo {\n\t\t/* Track if the test failed already in this test interval? */\n\t\tbool failed = false;\n\n\t\t/* Increment n_rcu_torture_boosts once per boost-test */\n\t\twhile (!kthread_should_stop()) {\n\t\t\tif (mutex_trylock(&boost_mutex)) {\n\t\t\t\tn_rcu_torture_boosts++;\n\t\t\t\tmutex_unlock(&boost_mutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\t\tif (kthread_should_stop())\n\t\t\tgoto checkwait;\n\n\t\t/* Wait for the next test interval. */\n\t\toldstarttime = boost_starttime;\n\t\twhile (ULONG_CMP_LT(jiffies, oldstarttime)) {\n\t\t\tschedule_timeout_interruptible(oldstarttime - jiffies);\n\t\t\tstutter_wait(\"rcu_torture_boost\");\n\t\t\tif (torture_must_stop())\n\t\t\t\tgoto checkwait;\n\t\t}\n\n\t\t/* Do one boost-test interval. */\n\t\tendtime = oldstarttime + test_boost_duration * HZ;\n\t\tcall_rcu_time = jiffies;\n\t\twhile (ULONG_CMP_LT(jiffies, endtime)) {\n\t\t\t/* If we don't have a callback in flight, post one. */\n\t\t\tif (!smp_load_acquire(&rbi.inflight)) {\n\t\t\t\t/* RCU core before ->inflight = 1. */\n\t\t\t\tsmp_store_release(&rbi.inflight, 1);\n\t\t\t\tcall_rcu(&rbi.rcu, rcu_torture_boost_cb);\n\t\t\t\t/* Check if the boost test failed */\n\t\t\t\tfailed = failed ||\n\t\t\t\t\t rcu_torture_boost_failed(call_rcu_time,\n\t\t\t\t\t\t\t\t jiffies);\n\t\t\t\tcall_rcu_time = jiffies;\n\t\t\t}\n\t\t\tstutter_wait(\"rcu_torture_boost\");\n\t\t\tif (torture_must_stop())\n\t\t\t\tgoto checkwait;\n\t\t}\n\n\t\t/*\n\t\t * If boost never happened, then inflight will always be 1, in\n\t\t * this case the boost check would never happen in the above\n\t\t * loop so do another one here.\n\t\t */\n\t\tif (!failed && smp_load_acquire(&rbi.inflight))\n\t\t\trcu_torture_boost_failed(call_rcu_time, jiffies);\n\n\t\t/*\n\t\t * Set the start time of the next test interval.\n\t\t * Yes, this is vulnerable to long delays, but such\n\t\t * delays simply cause a false negative for the next\n\t\t * interval.  Besides, we are running at RT priority,\n\t\t * so delays should be relatively rare.\n\t\t */\n\t\twhile (oldstarttime == boost_starttime &&\n\t\t       !kthread_should_stop()) {\n\t\t\tif (mutex_trylock(&boost_mutex)) {\n\t\t\t\tboost_starttime = jiffies +\n\t\t\t\t\t\t  test_boost_interval * HZ;\n\t\t\t\tmutex_unlock(&boost_mutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\t\t/* Go do the stutter. */\ncheckwait:\tstutter_wait(\"rcu_torture_boost\");\n\t} while (!torture_must_stop());\n\n\t/* Clean up and exit. */\n\twhile (!kthread_should_stop() || smp_load_acquire(&rbi.inflight)) {\n\t\ttorture_shutdown_absorb(\"rcu_torture_boost\");\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tdestroy_rcu_head_on_stack(&rbi.rcu);\n\ttorture_kthread_stopping(\"rcu_torture_boost\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long n_rcu_torture_boost_rterror;",
      "static long n_rcu_torture_boosts;",
      "static unsigned long boost_starttime;",
      "static DEFINE_MUTEX(boost_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"rcu_torture_boost\""
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_rcu_head_on_stack",
          "args": [
            "&rbi.rcu"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "413-416",
          "snippet": "void destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1835-1839",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_absorb",
          "args": [
            "\"rcu_torture_boost\""
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "462-469",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rbi.inflight"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"rcu_torture_boost\""
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "576-594",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&boost_mutex"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&boost_mutex"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1582-1594",
          "snippet": "int __sched rt_mutex_trylock(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(in_irq() || in_nmi() || in_serving_softirq()))\n\t\treturn 0;\n\n\tret = rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);\n\tif (ret)\n\t\tmutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_trylock(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(in_irq() || in_nmi() || in_serving_softirq()))\n\t\treturn 0;\n\n\tret = rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);\n\tif (ret)\n\t\tmutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_boost_failed",
          "args": [
            "call_rcu_time",
            "jiffies"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_boost_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "757-767",
          "snippet": "static bool rcu_torture_boost_failed(unsigned long start, unsigned long end)\n{\n\tif (end - start > test_boost_duration * HZ - HZ / 2) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost boosting failed\");\n\t\tn_rcu_torture_boost_failure++;\n\n\t\treturn true; /* failed */\n\t}\n\n\treturn false; /* passed */\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long n_rcu_torture_boost_failure;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long n_rcu_torture_boost_failure;\n\nstatic bool rcu_torture_boost_failed(unsigned long start, unsigned long end)\n{\n\tif (end - start > test_boost_duration * HZ - HZ / 2) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost boosting failed\");\n\t\tn_rcu_torture_boost_failure++;\n\n\t\treturn true; /* failed */\n\t}\n\n\treturn false; /* passed */\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rbi.inflight"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&rbi.rcu",
            "rcu_torture_boost_cb"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_busted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "490-495",
          "snippet": "static void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rbi.inflight",
            "1"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rbi.inflight"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "jiffies",
            "endtime"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "oldstarttime - jiffies"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "jiffies",
            "oldstarttime"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rcu_head_on_stack",
          "args": [
            "&rbi.rcu"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "396-399",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_boost RT prio failed!\""
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_setscheduler",
          "args": [
            "current",
            "SCHED_FIFO",
            "&sp"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "do_sched_setscheduler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4423-4443",
          "snippet": "static int\ndo_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)\n{\n\tstruct sched_param lparam;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))\n\t\treturn -EFAULT;\n\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setscheduler(p, policy, &lparam);\n\trcu_read_unlock();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstatic int\ndo_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)\n{\n\tstruct sched_param lparam;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))\n\t\treturn -EFAULT;\n\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setscheduler(p, policy, &lparam);\n\trcu_read_unlock();\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_boost started\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long n_rcu_torture_boost_rterror;\nstatic long n_rcu_torture_boosts;\nstatic unsigned long boost_starttime;\nstatic DEFINE_MUTEX(boost_mutex);\n\nstatic int rcu_torture_boost(void *arg)\n{\n\tunsigned long call_rcu_time;\n\tunsigned long endtime;\n\tunsigned long oldstarttime;\n\tstruct rcu_boost_inflight rbi = { .inflight = 0 };\n\tstruct sched_param sp;\n\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost started\");\n\n\t/* Set real-time priority. */\n\tsp.sched_priority = 1;\n\tif (sched_setscheduler(current, SCHED_FIFO, &sp) < 0) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost RT prio failed!\");\n\t\tn_rcu_torture_boost_rterror++;\n\t}\n\n\tinit_rcu_head_on_stack(&rbi.rcu);\n\t/* Each pass through the following loop does one boost-test cycle. */\n\tdo {\n\t\t/* Track if the test failed already in this test interval? */\n\t\tbool failed = false;\n\n\t\t/* Increment n_rcu_torture_boosts once per boost-test */\n\t\twhile (!kthread_should_stop()) {\n\t\t\tif (mutex_trylock(&boost_mutex)) {\n\t\t\t\tn_rcu_torture_boosts++;\n\t\t\t\tmutex_unlock(&boost_mutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\t\tif (kthread_should_stop())\n\t\t\tgoto checkwait;\n\n\t\t/* Wait for the next test interval. */\n\t\toldstarttime = boost_starttime;\n\t\twhile (ULONG_CMP_LT(jiffies, oldstarttime)) {\n\t\t\tschedule_timeout_interruptible(oldstarttime - jiffies);\n\t\t\tstutter_wait(\"rcu_torture_boost\");\n\t\t\tif (torture_must_stop())\n\t\t\t\tgoto checkwait;\n\t\t}\n\n\t\t/* Do one boost-test interval. */\n\t\tendtime = oldstarttime + test_boost_duration * HZ;\n\t\tcall_rcu_time = jiffies;\n\t\twhile (ULONG_CMP_LT(jiffies, endtime)) {\n\t\t\t/* If we don't have a callback in flight, post one. */\n\t\t\tif (!smp_load_acquire(&rbi.inflight)) {\n\t\t\t\t/* RCU core before ->inflight = 1. */\n\t\t\t\tsmp_store_release(&rbi.inflight, 1);\n\t\t\t\tcall_rcu(&rbi.rcu, rcu_torture_boost_cb);\n\t\t\t\t/* Check if the boost test failed */\n\t\t\t\tfailed = failed ||\n\t\t\t\t\t rcu_torture_boost_failed(call_rcu_time,\n\t\t\t\t\t\t\t\t jiffies);\n\t\t\t\tcall_rcu_time = jiffies;\n\t\t\t}\n\t\t\tstutter_wait(\"rcu_torture_boost\");\n\t\t\tif (torture_must_stop())\n\t\t\t\tgoto checkwait;\n\t\t}\n\n\t\t/*\n\t\t * If boost never happened, then inflight will always be 1, in\n\t\t * this case the boost check would never happen in the above\n\t\t * loop so do another one here.\n\t\t */\n\t\tif (!failed && smp_load_acquire(&rbi.inflight))\n\t\t\trcu_torture_boost_failed(call_rcu_time, jiffies);\n\n\t\t/*\n\t\t * Set the start time of the next test interval.\n\t\t * Yes, this is vulnerable to long delays, but such\n\t\t * delays simply cause a false negative for the next\n\t\t * interval.  Besides, we are running at RT priority,\n\t\t * so delays should be relatively rare.\n\t\t */\n\t\twhile (oldstarttime == boost_starttime &&\n\t\t       !kthread_should_stop()) {\n\t\t\tif (mutex_trylock(&boost_mutex)) {\n\t\t\t\tboost_starttime = jiffies +\n\t\t\t\t\t\t  test_boost_interval * HZ;\n\t\t\t\tmutex_unlock(&boost_mutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\t\t/* Go do the stutter. */\ncheckwait:\tstutter_wait(\"rcu_torture_boost\");\n\t} while (!torture_must_stop());\n\n\t/* Clean up and exit. */\n\twhile (!kthread_should_stop() || smp_load_acquire(&rbi.inflight)) {\n\t\ttorture_shutdown_absorb(\"rcu_torture_boost\");\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tdestroy_rcu_head_on_stack(&rbi.rcu);\n\ttorture_kthread_stopping(\"rcu_torture_boost\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_boost_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "757-767",
    "snippet": "static bool rcu_torture_boost_failed(unsigned long start, unsigned long end)\n{\n\tif (end - start > test_boost_duration * HZ - HZ / 2) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost boosting failed\");\n\t\tn_rcu_torture_boost_failure++;\n\n\t\treturn true; /* failed */\n\t}\n\n\treturn false; /* passed */\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long n_rcu_torture_boost_failure;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"rcu_torture_boost boosting failed\""
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long n_rcu_torture_boost_failure;\n\nstatic bool rcu_torture_boost_failed(unsigned long start, unsigned long end)\n{\n\tif (end - start > test_boost_duration * HZ - HZ / 2) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_boost boosting failed\");\n\t\tn_rcu_torture_boost_failure++;\n\n\t\treturn true; /* failed */\n\t}\n\n\treturn false; /* passed */\n}"
  },
  {
    "function_name": "rcu_torture_enable_rt_throttle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "748-755",
    "snippet": "static void rcu_torture_enable_rt_throttle(void)\n{\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime == -1)\n\t\treturn;\n\n\tsysctl_sched_rt_runtime = old_rt_runtime;\n\told_rt_runtime = -1;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int old_rt_runtime = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_BUILTIN",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int old_rt_runtime = -1;\n\nstatic void rcu_torture_enable_rt_throttle(void)\n{\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime == -1)\n\t\treturn;\n\n\tsysctl_sched_rt_runtime = old_rt_runtime;\n\told_rt_runtime = -1;\n}"
  },
  {
    "function_name": "rcu_torture_disable_rt_throttle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "733-746",
    "snippet": "static void rcu_torture_disable_rt_throttle(void)\n{\n\t/*\n\t * Disable RT throttling so that rcutorture's boost threads don't get\n\t * throttled. Only possible if rcutorture is built-in otherwise the\n\t * user should manually do this by setting the sched_rt_period_us and\n\t * sched_rt_runtime sysctls.\n\t */\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime != -1)\n\t\treturn;\n\n\told_rt_runtime = sysctl_sched_rt_runtime;\n\tsysctl_sched_rt_runtime = -1;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int old_rt_runtime = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_BUILTIN",
          "args": [
            "CONFIG_RCU_TORTURE_TEST"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int old_rt_runtime = -1;\n\nstatic void rcu_torture_disable_rt_throttle(void)\n{\n\t/*\n\t * Disable RT throttling so that rcutorture's boost threads don't get\n\t * throttled. Only possible if rcutorture is built-in otherwise the\n\t * user should manually do this by setting the sched_rt_period_us and\n\t * sched_rt_runtime sysctls.\n\t */\n\tif (!IS_BUILTIN(CONFIG_RCU_TORTURE_TEST) || old_rt_runtime != -1)\n\t\treturn;\n\n\told_rt_runtime = sysctl_sched_rt_runtime;\n\tsysctl_sched_rt_runtime = -1;\n}"
  },
  {
    "function_name": "rcu_torture_boost_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "722-729",
    "snippet": "static void rcu_torture_boost_cb(struct rcu_head *head)\n{\n\tstruct rcu_boost_inflight *rbip =\n\t\tcontainer_of(head, struct rcu_boost_inflight, rcu);\n\n\t/* Ensure RCU-core accesses precede clearing ->inflight */\n\tsmp_store_release(&rbip->inflight, 0);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&rbip->inflight",
            "0"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structrcu_boost_inflight",
            "rcu"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_boost_cb(struct rcu_head *head)\n{\n\tstruct rcu_boost_inflight *rbip =\n\t\tcontainer_of(head, struct rcu_boost_inflight, rcu);\n\n\t/* Ensure RCU-core accesses precede clearing ->inflight */\n\tsmp_store_release(&rbip->inflight, 0);\n}"
  },
  {
    "function_name": "rcutorture_seq_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "698-703",
    "snippet": "static unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->gp_diff",
          "args": [
            "new",
            "old"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic unsigned long rcutorture_seq_diff(unsigned long new, unsigned long old)\n{\n\tif (!cur_ops->gp_diff)\n\t\treturn new - old;\n\treturn cur_ops->gp_diff(new, old);\n}"
  },
  {
    "function_name": "rcu_tasks_torture_deferred_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "675-678",
    "snippet": "static void rcu_tasks_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu_tasks(&p->rtort_rcu, rcu_torture_cb);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_tasks",
          "args": [
            "&p->rtort_rcu",
            "rcu_torture_cb"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_tasks_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu_tasks(&p->rtort_rcu, rcu_torture_cb);\n}"
  },
  {
    "function_name": "tasks_torture_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "671-673",
    "snippet": "static void tasks_torture_read_unlock(int idx)\n{\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_torture_read_unlock(int idx)\n{\n}"
  },
  {
    "function_name": "tasks_torture_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "666-669",
    "snippet": "static int tasks_torture_read_lock(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int tasks_torture_read_lock(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "srcu_torture_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "612-621",
    "snippet": "static void srcu_torture_cleanup(void)\n{\n\tstatic DEFINE_TORTURE_RANDOM(rand);\n\n\tif (torture_random(&rand) & 0x800)\n\t\tcleanup_srcu_struct(&srcu_ctld);\n\telse\n\t\tcleanup_srcu_struct_quiesced(&srcu_ctld);\n\tsrcu_ctlp = &srcu_ctl; /* In case of a later rcutorture run. */\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct srcu_ctld;",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_srcu_struct_quiesced",
          "args": [
            "&srcu_ctld"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_srcu_struct",
          "args": [
            "&srcu_ctld"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&rand"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct srcu_ctld;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_cleanup(void)\n{\n\tstatic DEFINE_TORTURE_RANDOM(rand);\n\n\tif (torture_random(&rand) & 0x800)\n\t\tcleanup_srcu_struct(&srcu_ctld);\n\telse\n\t\tcleanup_srcu_struct_quiesced(&srcu_ctld);\n\tsrcu_ctlp = &srcu_ctl; /* In case of a later rcutorture run. */\n}"
  },
  {
    "function_name": "srcu_torture_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "605-610",
    "snippet": "static void srcu_torture_init(void)\n{\n\trcu_sync_torture_init();\n\tWARN_ON(init_srcu_struct(&srcu_ctld));\n\tsrcu_ctlp = &srcu_ctld;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct srcu_ctld;",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "init_srcu_struct(&srcu_ctld)"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_srcu_struct",
          "args": [
            "&srcu_ctld"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "238-252",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *sp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&sp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(sp, flags);\n\tif (!rcu_seq_state(sp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(sp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(sp, true);\n\tspin_unlock_irqrestore_rcu_node(sp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_sync_torture_init",
          "args": [],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_torture_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "443-446",
          "snippet": "static void rcu_sync_torture_init(void)\n{\n\tINIT_LIST_HEAD(&rcu_torture_removed);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head rcu_torture_removed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct list_head rcu_torture_removed;\n\nstatic void rcu_sync_torture_init(void)\n{\n\tINIT_LIST_HEAD(&rcu_torture_removed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct srcu_ctld;\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_init(void)\n{\n\trcu_sync_torture_init();\n\tWARN_ON(init_srcu_struct(&srcu_ctld));\n\tsrcu_ctlp = &srcu_ctld;\n}"
  },
  {
    "function_name": "srcu_torture_synchronize_expedited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "583-586",
    "snippet": "static void srcu_torture_synchronize_expedited(void)\n{\n\tsynchronize_srcu_expedited(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu_expedited",
          "args": [
            "srcu_ctlp"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_srcu_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "964-967",
          "snippet": "void synchronize_srcu_expedited(struct srcu_struct *sp)\n{\n\t__synchronize_srcu(sp, rcu_gp_is_normal());\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu_expedited(struct srcu_struct *sp)\n{\n\t__synchronize_srcu(sp, rcu_gp_is_normal());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_synchronize_expedited(void)\n{\n\tsynchronize_srcu_expedited(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_torture_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "578-581",
    "snippet": "static void srcu_torture_stats(void)\n{\n\tsrcu_torture_stats_print(srcu_ctlp, torture_type, TORTURE_FLAG);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *torture_type = \"rcu\";",
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_torture_stats_print",
          "args": [
            "srcu_ctlp",
            "torture_type",
            "TORTURE_FLAG"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_torture_stats_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1271-1307",
          "snippet": "void srcu_torture_stats_print(struct srcu_struct *sp, char *tt, char *tf)\n{\n\tint cpu;\n\tint idx;\n\tunsigned long s0 = 0, s1 = 0;\n\n\tidx = sp->srcu_idx & 0x1;\n\tpr_alert(\"%s%s Tree SRCU g%ld per-CPU(idx=%d):\",\n\t\t tt, tf, rcu_seq_current(&sp->srcu_gp_seq), idx);\n\tfor_each_possible_cpu(cpu) {\n\t\tunsigned long l0, l1;\n\t\tunsigned long u0, u1;\n\t\tlong c0, c1;\n\t\tstruct srcu_data *sdp;\n\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tu0 = sdp->srcu_unlock_count[!idx];\n\t\tu1 = sdp->srcu_unlock_count[idx];\n\n\t\t/*\n\t\t * Make sure that a lock is always counted if the corresponding\n\t\t * unlock is counted.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tl0 = sdp->srcu_lock_count[!idx];\n\t\tl1 = sdp->srcu_lock_count[idx];\n\n\t\tc0 = l0 - u0;\n\t\tc1 = l1 - u1;\n\t\tpr_cont(\" %d(%ld,%ld %1p)\",\n\t\t\tcpu, c0, c1, rcu_segcblist_head(&sdp->srcu_cblist));\n\t\ts0 += c0;\n\t\ts1 += c1;\n\t}\n\tpr_cont(\" T(%ld,%ld)\\n\", s0, s1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcu_torture_stats_print(struct srcu_struct *sp, char *tt, char *tf)\n{\n\tint cpu;\n\tint idx;\n\tunsigned long s0 = 0, s1 = 0;\n\n\tidx = sp->srcu_idx & 0x1;\n\tpr_alert(\"%s%s Tree SRCU g%ld per-CPU(idx=%d):\",\n\t\t tt, tf, rcu_seq_current(&sp->srcu_gp_seq), idx);\n\tfor_each_possible_cpu(cpu) {\n\t\tunsigned long l0, l1;\n\t\tunsigned long u0, u1;\n\t\tlong c0, c1;\n\t\tstruct srcu_data *sdp;\n\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tu0 = sdp->srcu_unlock_count[!idx];\n\t\tu1 = sdp->srcu_unlock_count[idx];\n\n\t\t/*\n\t\t * Make sure that a lock is always counted if the corresponding\n\t\t * unlock is counted.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tl0 = sdp->srcu_lock_count[!idx];\n\t\tl1 = sdp->srcu_lock_count[idx];\n\n\t\tc0 = l0 - u0;\n\t\tc1 = l1 - u1;\n\t\tpr_cont(\" %d(%ld,%ld %1p)\",\n\t\t\tcpu, c0, c1, rcu_segcblist_head(&sdp->srcu_cblist));\n\t\ts0 += c0;\n\t\ts1 += c1;\n\t}\n\tpr_cont(\" T(%ld,%ld)\\n\", s0, s1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type = \"rcu\";\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_stats(void)\n{\n\tsrcu_torture_stats_print(srcu_ctlp, torture_type, TORTURE_FLAG);\n}"
  },
  {
    "function_name": "srcu_torture_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "573-576",
    "snippet": "static void srcu_torture_barrier(void)\n{\n\tsrcu_barrier(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_barrier",
          "args": [
            "srcu_ctlp"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1041-1089",
          "snippet": "void srcu_barrier(struct srcu_struct *sp)\n{\n\tint cpu;\n\tstruct srcu_data *sdp;\n\tunsigned long s = rcu_seq_snap(&sp->srcu_barrier_seq);\n\n\tcheck_init_srcu_struct(sp);\n\tmutex_lock(&sp->srcu_barrier_mutex);\n\tif (rcu_seq_done(&sp->srcu_barrier_seq, s)) {\n\t\tsmp_mb(); /* Force ordering following return. */\n\t\tmutex_unlock(&sp->srcu_barrier_mutex);\n\t\treturn; /* Someone else did our work for us. */\n\t}\n\trcu_seq_start(&sp->srcu_barrier_seq);\n\tinit_completion(&sp->srcu_barrier_completion);\n\n\t/* Initial count prevents reaching zero until all CBs are posted. */\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 1);\n\n\t/*\n\t * Each pass through this loop enqueues a callback, but only\n\t * on CPUs already having callbacks enqueued.  Note that if\n\t * a CPU already has callbacks enqueue, it must have already\n\t * registered the need for a future grace period, so all we\n\t * need do is enqueue a callback that will use the same\n\t * grace period as the last callback already in the queue.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tspin_lock_irq_rcu_node(sdp);\n\t\tatomic_inc(&sp->srcu_barrier_cpu_cnt);\n\t\tsdp->srcu_barrier_head.func = srcu_barrier_cb;\n\t\tdebug_rcu_head_queue(&sdp->srcu_barrier_head);\n\t\tif (!rcu_segcblist_entrain(&sdp->srcu_cblist,\n\t\t\t\t\t   &sdp->srcu_barrier_head, 0)) {\n\t\t\tdebug_rcu_head_unqueue(&sdp->srcu_barrier_head);\n\t\t\tatomic_dec(&sp->srcu_barrier_cpu_cnt);\n\t\t}\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t}\n\n\t/* Remove the initial count, at which point reaching zero can happen. */\n\tif (atomic_dec_and_test(&sp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&sp->srcu_barrier_completion);\n\twait_for_completion(&sp->srcu_barrier_completion);\n\n\trcu_seq_end(&sp->srcu_barrier_seq);\n\tmutex_unlock(&sp->srcu_barrier_mutex);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid srcu_barrier(struct srcu_struct *sp)\n{\n\tint cpu;\n\tstruct srcu_data *sdp;\n\tunsigned long s = rcu_seq_snap(&sp->srcu_barrier_seq);\n\n\tcheck_init_srcu_struct(sp);\n\tmutex_lock(&sp->srcu_barrier_mutex);\n\tif (rcu_seq_done(&sp->srcu_barrier_seq, s)) {\n\t\tsmp_mb(); /* Force ordering following return. */\n\t\tmutex_unlock(&sp->srcu_barrier_mutex);\n\t\treturn; /* Someone else did our work for us. */\n\t}\n\trcu_seq_start(&sp->srcu_barrier_seq);\n\tinit_completion(&sp->srcu_barrier_completion);\n\n\t/* Initial count prevents reaching zero until all CBs are posted. */\n\tatomic_set(&sp->srcu_barrier_cpu_cnt, 1);\n\n\t/*\n\t * Each pass through this loop enqueues a callback, but only\n\t * on CPUs already having callbacks enqueued.  Note that if\n\t * a CPU already has callbacks enqueue, it must have already\n\t * registered the need for a future grace period, so all we\n\t * need do is enqueue a callback that will use the same\n\t * grace period as the last callback already in the queue.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(sp->sda, cpu);\n\t\tspin_lock_irq_rcu_node(sdp);\n\t\tatomic_inc(&sp->srcu_barrier_cpu_cnt);\n\t\tsdp->srcu_barrier_head.func = srcu_barrier_cb;\n\t\tdebug_rcu_head_queue(&sdp->srcu_barrier_head);\n\t\tif (!rcu_segcblist_entrain(&sdp->srcu_cblist,\n\t\t\t\t\t   &sdp->srcu_barrier_head, 0)) {\n\t\t\tdebug_rcu_head_unqueue(&sdp->srcu_barrier_head);\n\t\t\tatomic_dec(&sp->srcu_barrier_cpu_cnt);\n\t\t}\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t}\n\n\t/* Remove the initial count, at which point reaching zero can happen. */\n\tif (atomic_dec_and_test(&sp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&sp->srcu_barrier_completion);\n\twait_for_completion(&sp->srcu_barrier_completion);\n\n\trcu_seq_end(&sp->srcu_barrier_seq);\n\tmutex_unlock(&sp->srcu_barrier_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_barrier(void)\n{\n\tsrcu_barrier(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_torture_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "567-571",
    "snippet": "static void srcu_torture_call(struct rcu_head *head,\n\t\t\t      rcu_callback_t func)\n{\n\tcall_srcu(srcu_ctlp, head, func);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_srcu",
          "args": [
            "srcu_ctlp",
            "head",
            "func"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "call_srcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "914-918",
          "snippet": "void call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(sp, rhp, func, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(sp, rhp, func, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_call(struct rcu_head *head,\n\t\t\t      rcu_callback_t func)\n{\n\tcall_srcu(srcu_ctlp, head, func);\n}"
  },
  {
    "function_name": "srcu_torture_synchronize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "562-565",
    "snippet": "static void srcu_torture_synchronize(void)\n{\n\tsynchronize_srcu(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "srcu_ctlp"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_srcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1014-1020",
          "snippet": "void synchronize_srcu(struct srcu_struct *sp)\n{\n\tif (srcu_might_be_idle(sp) || rcu_gp_is_expedited())\n\t\tsynchronize_srcu_expedited(sp);\n\telse\n\t\t__synchronize_srcu(sp, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu(struct srcu_struct *sp)\n{\n\tif (srcu_might_be_idle(sp) || rcu_gp_is_expedited())\n\t\tsynchronize_srcu_expedited(sp);\n\telse\n\t\t__synchronize_srcu(sp, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_synchronize(void)\n{\n\tsynchronize_srcu(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_torture_deferred_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "557-560",
    "snippet": "static void srcu_torture_deferred_free(struct rcu_torture *rp)\n{\n\tcall_srcu(srcu_ctlp, &rp->rtort_rcu, rcu_torture_cb);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_srcu",
          "args": [
            "srcu_ctlp",
            "&rp->rtort_rcu",
            "rcu_torture_cb"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "call_srcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "914-918",
          "snippet": "void call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(sp, rhp, func, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(sp, rhp, func, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_deferred_free(struct rcu_torture *rp)\n{\n\tcall_srcu(srcu_ctlp, &rp->rtort_rcu, rcu_torture_cb);\n}"
  },
  {
    "function_name": "srcu_torture_completed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "552-555",
    "snippet": "static unsigned long srcu_torture_completed(void)\n{\n\treturn srcu_batches_completed(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_batches_completed",
          "args": [
            "srcu_ctlp"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "1099-1102",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *sp)\n{\n\treturn sp->srcu_idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic unsigned long srcu_torture_completed(void)\n{\n\treturn srcu_batches_completed(srcu_ctlp);\n}"
  },
  {
    "function_name": "srcu_torture_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "547-550",
    "snippet": "static void srcu_torture_read_unlock(int idx) __releases(srcu_ctlp)\n{\n\tsrcu_read_unlock(srcu_ctlp, idx);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "srcu_ctlp",
            "idx"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "428-432",
          "snippet": "void __srcu_read_unlock(struct srcu_struct *sp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(sp->sda->srcu_unlock_count[idx]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __srcu_read_unlock(struct srcu_struct *sp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(sp->sda->srcu_unlock_count[idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "srcu_ctlp"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic void srcu_torture_read_unlock(int idx) __releases(srcu_ctlp)\n{\n\tsrcu_read_unlock(srcu_ctlp, idx);\n}"
  },
  {
    "function_name": "srcu_read_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "528-545",
    "snippet": "static void\nsrcu_read_delay(struct torture_random_state *rrsp, struct rt_read_seg *rtrsp)\n{\n\tlong delay;\n\tconst long uspertick = 1000000 / HZ;\n\tconst long longdelay = 10;\n\n\t/* We want there to be long-running readers, but not all the time. */\n\n\tdelay = torture_random(rrsp) %\n\t\t(nrealreaders * 2 * longdelay * uspertick);\n\tif (!delay && in_task()) {\n\t\tschedule_timeout_interruptible(longdelay);\n\t\trtrsp->rt_delay_jiffies = longdelay;\n\t} else {\n\t\trcu_read_delay(rrsp, rtrsp);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nrealreaders;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_delay",
          "args": [
            "rrsp",
            "rtrsp"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_read_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "528-545",
          "snippet": "static void\nsrcu_read_delay(struct torture_random_state *rrsp, struct rt_read_seg *rtrsp)\n{\n\tlong delay;\n\tconst long uspertick = 1000000 / HZ;\n\tconst long longdelay = 10;\n\n\t/* We want there to be long-running readers, but not all the time. */\n\n\tdelay = torture_random(rrsp) %\n\t\t(nrealreaders * 2 * longdelay * uspertick);\n\tif (!delay && in_task()) {\n\t\tschedule_timeout_interruptible(longdelay);\n\t\trtrsp->rt_delay_jiffies = longdelay;\n\t} else {\n\t\trcu_read_delay(rrsp, rtrsp);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "longdelay"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "rrsp"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealreaders;\n\nstatic void\nsrcu_read_delay(struct torture_random_state *rrsp, struct rt_read_seg *rtrsp)\n{\n\tlong delay;\n\tconst long uspertick = 1000000 / HZ;\n\tconst long longdelay = 10;\n\n\t/* We want there to be long-running readers, but not all the time. */\n\n\tdelay = torture_random(rrsp) %\n\t\t(nrealreaders * 2 * longdelay * uspertick);\n\tif (!delay && in_task()) {\n\t\tschedule_timeout_interruptible(longdelay);\n\t\trtrsp->rt_delay_jiffies = longdelay;\n\t} else {\n\t\trcu_read_delay(rrsp, rtrsp);\n\t}\n}"
  },
  {
    "function_name": "srcu_torture_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "523-526",
    "snippet": "static int srcu_torture_read_lock(void) __acquires(srcu_ctlp)\n{\n\treturn srcu_read_lock(srcu_ctlp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_ctl;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "srcu_ctlp"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "412-420",
          "snippet": "int __srcu_read_lock(struct srcu_struct *sp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(sp->srcu_idx) & 0x1;\n\tthis_cpu_inc(sp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *sp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(sp->srcu_idx) & 0x1;\n\tthis_cpu_inc(sp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "srcu_ctlp"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_ctl;\n\nstatic int srcu_torture_read_lock(void) __acquires(srcu_ctlp)\n{\n\treturn srcu_read_lock(srcu_ctlp);\n}"
  },
  {
    "function_name": "call_rcu_busted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "490-495",
    "snippet": "static void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func",
          "args": [
            "head"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_sync_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/sync.c",
          "lines": "164-194",
          "snippet": "static void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tBUG_ON(rsp->gp_state != GP_PASSED);\n\tBUG_ON(rsp->cb_state == CB_IDLE);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t/*\n\t\t * A new rcu_sync_begin() has happened; drop the callback.\n\t\t */\n\t\trsp->cb_state = CB_IDLE;\n\t} else if (rsp->cb_state == CB_REPLAY) {\n\t\t/*\n\t\t * A new rcu_sync_exit() has happened; requeue the callback\n\t\t * to catch a later GP.\n\t\t */\n\t\trsp->cb_state = CB_PENDING;\n\t\tgp_ops[rsp->gp_type].call(&rsp->cb_head, rcu_sync_func);\n\t} else {\n\t\t/*\n\t\t * We're at least a GP after rcu_sync_exit(); eveybody will now\n\t\t * have observed the write side critical section. Let 'em rip!.\n\t\t */\n\t\trsp->cb_state = CB_IDLE;\n\t\trsp->gp_state = GP_IDLE;\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/rcu_sync.h>"
          ],
          "macros_used": [
            "#define\trss_lock\tgp_wait.lock"
          ],
          "globals_used": [
            "static const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nstatic const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};\n\nstatic void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tBUG_ON(rsp->gp_state != GP_PASSED);\n\tBUG_ON(rsp->cb_state == CB_IDLE);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t/*\n\t\t * A new rcu_sync_begin() has happened; drop the callback.\n\t\t */\n\t\trsp->cb_state = CB_IDLE;\n\t} else if (rsp->cb_state == CB_REPLAY) {\n\t\t/*\n\t\t * A new rcu_sync_exit() has happened; requeue the callback\n\t\t * to catch a later GP.\n\t\t */\n\t\trsp->cb_state = CB_PENDING;\n\t\tgp_ops[rsp->gp_type].call(&rsp->cb_head, rcu_sync_func);\n\t} else {\n\t\t/*\n\t\t * We're at least a GP after rcu_sync_exit(); eveybody will now\n\t\t * have observed the write side critical section. Let 'em rip!.\n\t\t */\n\t\trsp->cb_state = CB_IDLE;\n\t\trsp->gp_state = GP_IDLE;\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}"
  },
  {
    "function_name": "synchronize_rcu_busted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "485-488",
    "snippet": "static void synchronize_rcu_busted(void)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void synchronize_rcu_busted(void)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n}"
  },
  {
    "function_name": "rcu_busted_torture_deferred_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "479-483",
    "snippet": "static void rcu_busted_torture_deferred_free(struct rcu_torture *p)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\trcu_torture_cb(&p->rtort_rcu);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_torture_cb",
          "args": [
            "&p->rtort_rcu"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_cbflood",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "882-924",
          "snippet": "static int\nrcu_torture_cbflood(void *arg)\n{\n\tint err = 1;\n\tint i;\n\tint j;\n\tstruct rcu_head *rhp;\n\n\tif (cbflood_n_per_burst > 0 &&\n\t    cbflood_inter_holdoff > 0 &&\n\t    cbflood_intra_holdoff > 0 &&\n\t    cur_ops->call &&\n\t    cur_ops->cb_barrier) {\n\t\trhp = vmalloc(array3_size(cbflood_n_burst,\n\t\t\t\t\t  cbflood_n_per_burst,\n\t\t\t\t\t  sizeof(*rhp)));\n\t\terr = !rhp;\n\t}\n\tif (err) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_cbflood disabled: Bad args or OOM\");\n\t\tgoto wait_for_stop;\n\t}\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_cbflood task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(cbflood_inter_holdoff);\n\t\tatomic_long_inc(&n_cbfloods);\n\t\tWARN_ON(signal_pending(current));\n\t\tfor (i = 0; i < cbflood_n_burst; i++) {\n\t\t\tfor (j = 0; j < cbflood_n_per_burst; j++) {\n\t\t\t\tcur_ops->call(&rhp[i * cbflood_n_per_burst + j],\n\t\t\t\t\t      rcu_torture_cbflood_cb);\n\t\t\t}\n\t\t\tschedule_timeout_interruptible(cbflood_intra_holdoff);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t}\n\t\tcur_ops->cb_barrier();\n\t\tstutter_wait(\"rcu_torture_cbflood\");\n\t} while (!torture_must_stop());\n\tvfree(rhp);\nwait_for_stop:\n\ttorture_kthread_stopping(\"rcu_torture_cbflood\");\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_long_t n_cbfloods;",
            "static struct rcu_torture_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_long_t n_cbfloods;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic int\nrcu_torture_cbflood(void *arg)\n{\n\tint err = 1;\n\tint i;\n\tint j;\n\tstruct rcu_head *rhp;\n\n\tif (cbflood_n_per_burst > 0 &&\n\t    cbflood_inter_holdoff > 0 &&\n\t    cbflood_intra_holdoff > 0 &&\n\t    cur_ops->call &&\n\t    cur_ops->cb_barrier) {\n\t\trhp = vmalloc(array3_size(cbflood_n_burst,\n\t\t\t\t\t  cbflood_n_per_burst,\n\t\t\t\t\t  sizeof(*rhp)));\n\t\terr = !rhp;\n\t}\n\tif (err) {\n\t\tVERBOSE_TOROUT_STRING(\"rcu_torture_cbflood disabled: Bad args or OOM\");\n\t\tgoto wait_for_stop;\n\t}\n\tVERBOSE_TOROUT_STRING(\"rcu_torture_cbflood task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(cbflood_inter_holdoff);\n\t\tatomic_long_inc(&n_cbfloods);\n\t\tWARN_ON(signal_pending(current));\n\t\tfor (i = 0; i < cbflood_n_burst; i++) {\n\t\t\tfor (j = 0; j < cbflood_n_per_burst; j++) {\n\t\t\t\tcur_ops->call(&rhp[i * cbflood_n_per_burst + j],\n\t\t\t\t\t      rcu_torture_cbflood_cb);\n\t\t\t}\n\t\t\tschedule_timeout_interruptible(cbflood_intra_holdoff);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t}\n\t\tcur_ops->cb_barrier();\n\t\tstutter_wait(\"rcu_torture_cbflood\");\n\t} while (!torture_must_stop());\n\tvfree(rhp);\nwait_for_stop:\n\ttorture_kthread_stopping(\"rcu_torture_cbflood\");\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_busted_torture_deferred_free(struct rcu_torture *p)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\trcu_torture_cb(&p->rtort_rcu);\n}"
  },
  {
    "function_name": "rcu_sync_torture_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "443-446",
    "snippet": "static void rcu_sync_torture_init(void)\n{\n\tINIT_LIST_HEAD(&rcu_torture_removed);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head rcu_torture_removed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rcu_torture_removed"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct list_head rcu_torture_removed;\n\nstatic void rcu_sync_torture_init(void)\n{\n\tINIT_LIST_HEAD(&rcu_torture_removed);\n}"
  },
  {
    "function_name": "rcu_torture_deferred_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "438-441",
    "snippet": "static void rcu_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu(&p->rtort_rcu, rcu_torture_cb);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&p->rtort_rcu",
            "rcu_torture_cb"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_busted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "490-495",
          "snippet": "static void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void\ncall_rcu_busted(struct rcu_head *head, rcu_callback_t func)\n{\n\t/* This is a deliberate bug for testing purposes only! */\n\tfunc(head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_deferred_free(struct rcu_torture *p)\n{\n\tcall_rcu(&p->rtort_rcu, rcu_torture_cb);\n}"
  },
  {
    "function_name": "rcu_no_completed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "433-436",
    "snippet": "static unsigned long rcu_no_completed(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic unsigned long rcu_no_completed(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "417-431",
    "snippet": "static void\nrcu_torture_cb(struct rcu_head *p)\n{\n\tstruct rcu_torture *rp = container_of(p, struct rcu_torture, rtort_rcu);\n\n\tif (torture_must_stop_irq()) {\n\t\t/* Test is ending, just drop callbacks on the floor. */\n\t\t/* The next initialization will pick up the pieces. */\n\t\treturn;\n\t}\n\tif (rcu_torture_pipe_update_one(rp))\n\t\trcu_torture_free(rp);\n\telse\n\t\tcur_ops->deferred_free(rp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->deferred_free",
          "args": [
            "rp"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_torture_free",
          "args": [
            "rp"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "286-293",
          "snippet": "static void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(rcu_torture_freelist);",
            "static DEFINE_SPINLOCK(rcu_torture_lock);",
            "static atomic_t n_rcu_torture_free;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic DEFINE_SPINLOCK(rcu_torture_lock);\nstatic atomic_t n_rcu_torture_free;\n\nstatic void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_pipe_update_one",
          "args": [
            "rp"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_pipe_update_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "381-395",
          "snippet": "static bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\n\ti = rp->rtort_pipe_count;\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tif (++rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10"
          ],
          "globals_used": [
            "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\n\nstatic bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\n\ti = rp->rtort_pipe_count;\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tif (++rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop_irq",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structrcu_torture",
            "rtort_rcu"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_torture_cb(struct rcu_head *p)\n{\n\tstruct rcu_torture *rp = container_of(p, struct rcu_torture, rtort_rcu);\n\n\tif (torture_must_stop_irq()) {\n\t\t/* Test is ending, just drop callbacks on the floor. */\n\t\t/* The next initialization will pick up the pieces. */\n\t\treturn;\n\t}\n\tif (rcu_torture_pipe_update_one(rp))\n\t\trcu_torture_free(rp);\n\telse\n\t\tcur_ops->deferred_free(rp);\n}"
  },
  {
    "function_name": "rcu_torture_pipe_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "401-415",
    "snippet": "static void\nrcu_torture_pipe_update(struct rcu_torture *old_rp)\n{\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *rp1;\n\n\tif (old_rp)\n\t\tlist_add(&old_rp->rtort_free, &rcu_torture_removed);\n\tlist_for_each_entry_safe(rp, rp1, &rcu_torture_removed, rtort_free) {\n\t\tif (rcu_torture_pipe_update_one(rp)) {\n\t\t\tlist_del(&rp->rtort_free);\n\t\t\trcu_torture_free(rp);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head rcu_torture_removed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_torture_free",
          "args": [
            "rp"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "286-293",
          "snippet": "static void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(rcu_torture_freelist);",
            "static DEFINE_SPINLOCK(rcu_torture_lock);",
            "static atomic_t n_rcu_torture_free;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic DEFINE_SPINLOCK(rcu_torture_lock);\nstatic atomic_t n_rcu_torture_free;\n\nstatic void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rp->rtort_free"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_torture_pipe_update_one",
          "args": [
            "rp"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_torture_pipe_update_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "381-395",
          "snippet": "static bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\n\ti = rp->rtort_pipe_count;\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tif (++rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define RCU_TORTURE_PIPE_LEN 10"
          ],
          "globals_used": [
            "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\n\nstatic bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\n\ti = rp->rtort_pipe_count;\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tif (++rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rp",
            "rp1",
            "&rcu_torture_removed",
            "rtort_free"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&old_rp->rtort_free",
            "&rcu_torture_removed"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct list_head rcu_torture_removed;\n\nstatic void\nrcu_torture_pipe_update(struct rcu_torture *old_rp)\n{\n\tstruct rcu_torture *rp;\n\tstruct rcu_torture *rp1;\n\n\tif (old_rp)\n\t\tlist_add(&old_rp->rtort_free, &rcu_torture_removed);\n\tlist_for_each_entry_safe(rp, rp1, &rcu_torture_removed, rtort_free) {\n\t\tif (rcu_torture_pipe_update_one(rp)) {\n\t\t\tlist_del(&rp->rtort_free);\n\t\t\trcu_torture_free(rp);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rcu_torture_pipe_update_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "381-395",
    "snippet": "static bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\n\ti = rp->rtort_pipe_count;\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tif (++rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define RCU_TORTURE_PIPE_LEN 10"
    ],
    "globals_used": [
      "static atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rcu_torture_wcount[i]"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define RCU_TORTURE_PIPE_LEN 10\n\nstatic atomic_t rcu_torture_wcount[RCU_TORTURE_PIPE_LEN + 1];\n\nstatic bool\nrcu_torture_pipe_update_one(struct rcu_torture *rp)\n{\n\tint i;\n\n\ti = rp->rtort_pipe_count;\n\tif (i > RCU_TORTURE_PIPE_LEN)\n\t\ti = RCU_TORTURE_PIPE_LEN;\n\tatomic_inc(&rcu_torture_wcount[i]);\n\tif (++rp->rtort_pipe_count >= RCU_TORTURE_PIPE_LEN) {\n\t\trp->rtort_mbtest = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_torture_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "373-376",
    "snippet": "static void rcu_torture_read_unlock(int idx) __releases(RCU)\n{\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "RCU"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_torture_read_unlock(int idx) __releases(RCU)\n{\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "rcu_read_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "338-371",
    "snippet": "static void\nrcu_read_delay(struct torture_random_state *rrsp, struct rt_read_seg *rtrsp)\n{\n\tunsigned long started;\n\tunsigned long completed;\n\tconst unsigned long shortdelay_us = 200;\n\tunsigned long longdelay_ms = 300;\n\tunsigned long long ts;\n\n\t/* We want a short delay sometimes to make a reader delay the grace\n\t * period, and we want a long delay occasionally to trigger\n\t * force_quiescent_state. */\n\n\tif (!(torture_random(rrsp) % (nrealreaders * 2000 * longdelay_ms))) {\n\t\tstarted = cur_ops->get_gp_seq();\n\t\tts = rcu_trace_clock_local();\n\t\tif (preempt_count() & (SOFTIRQ_MASK | HARDIRQ_MASK))\n\t\t\tlongdelay_ms = 5; /* Avoid triggering BH limits. */\n\t\tmdelay(longdelay_ms);\n\t\trtrsp->rt_delay_ms = longdelay_ms;\n\t\tcompleted = cur_ops->get_gp_seq();\n\t\tdo_trace_rcu_torture_read(cur_ops->name, NULL, ts,\n\t\t\t\t\t  started, completed);\n\t}\n\tif (!(torture_random(rrsp) % (nrealreaders * 2 * shortdelay_us))) {\n\t\tudelay(shortdelay_us);\n\t\trtrsp->rt_delay_us = shortdelay_us;\n\t}\n\tif (!preempt_count() &&\n\t    !(torture_random(rrsp) % (nrealreaders * 500))) {\n\t\ttorture_preempt_schedule();  /* QS only if preemptible. */\n\t\trtrsp->rt_preempted = true;\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nrealreaders;",
      "static struct rcu_torture_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "rrsp"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "shortdelay_us"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_trace_rcu_torture_read",
          "args": [
            "cur_ops->name",
            "NULL",
            "ts",
            "started",
            "completed"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "do_trace_rcu_torture_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "427-432",
          "snippet": "void do_trace_rcu_torture_read(const char *rcutorturename, struct rcu_head *rhp,\n\t\t\t       unsigned long secs,\n\t\t\t       unsigned long c_old, unsigned long c)\n{\n\ttrace_rcu_torture_read(rcutorturename, rhp, secs, c_old, c);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid do_trace_rcu_torture_read(const char *rcutorturename, struct rcu_head *rhp,\n\t\t\t       unsigned long secs,\n\t\t\t       unsigned long c_old, unsigned long c)\n{\n\ttrace_rcu_torture_read(rcutorturename, rhp, secs, c_old, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_trace_clock_local",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_trace_clock_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "247-250",
          "snippet": "static u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->get_gp_seq",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int nrealreaders;\nstatic struct rcu_torture_ops *cur_ops;\n\nstatic void\nrcu_read_delay(struct torture_random_state *rrsp, struct rt_read_seg *rtrsp)\n{\n\tunsigned long started;\n\tunsigned long completed;\n\tconst unsigned long shortdelay_us = 200;\n\tunsigned long longdelay_ms = 300;\n\tunsigned long long ts;\n\n\t/* We want a short delay sometimes to make a reader delay the grace\n\t * period, and we want a long delay occasionally to trigger\n\t * force_quiescent_state. */\n\n\tif (!(torture_random(rrsp) % (nrealreaders * 2000 * longdelay_ms))) {\n\t\tstarted = cur_ops->get_gp_seq();\n\t\tts = rcu_trace_clock_local();\n\t\tif (preempt_count() & (SOFTIRQ_MASK | HARDIRQ_MASK))\n\t\t\tlongdelay_ms = 5; /* Avoid triggering BH limits. */\n\t\tmdelay(longdelay_ms);\n\t\trtrsp->rt_delay_ms = longdelay_ms;\n\t\tcompleted = cur_ops->get_gp_seq();\n\t\tdo_trace_rcu_torture_read(cur_ops->name, NULL, ts,\n\t\t\t\t\t  started, completed);\n\t}\n\tif (!(torture_random(rrsp) % (nrealreaders * 2 * shortdelay_us))) {\n\t\tudelay(shortdelay_us);\n\t\trtrsp->rt_delay_us = shortdelay_us;\n\t}\n\tif (!preempt_count() &&\n\t    !(torture_random(rrsp) % (nrealreaders * 500))) {\n\t\ttorture_preempt_schedule();  /* QS only if preemptible. */\n\t\trtrsp->rt_preempted = true;\n\t}\n}"
  },
  {
    "function_name": "rcu_torture_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "332-336",
    "snippet": "static int rcu_torture_read_lock(void) __acquires(RCU)\n{\n\trcu_read_lock();\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_read_lock(void) __acquires(RCU)\n{\n\trcu_read_lock();\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_torture_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "286-293",
    "snippet": "static void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(rcu_torture_freelist);",
      "static DEFINE_SPINLOCK(rcu_torture_lock);",
      "static atomic_t n_rcu_torture_free;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&rcu_torture_lock"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&p->rtort_free",
            "&rcu_torture_freelist"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&rcu_torture_lock"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_free"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic DEFINE_SPINLOCK(rcu_torture_lock);\nstatic atomic_t n_rcu_torture_free;\n\nstatic void\nrcu_torture_free(struct rcu_torture *p)\n{\n\tatomic_inc(&n_rcu_torture_free);\n\tspin_lock_bh(&rcu_torture_lock);\n\tlist_add_tail(&p->rtort_free, &rcu_torture_freelist);\n\tspin_unlock_bh(&rcu_torture_lock);\n}"
  },
  {
    "function_name": "rcu_torture_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "265-281",
    "snippet": "static struct rcu_torture *\nrcu_torture_alloc(void)\n{\n\tstruct list_head *p;\n\n\tspin_lock_bh(&rcu_torture_lock);\n\tif (list_empty(&rcu_torture_freelist)) {\n\t\tatomic_inc(&n_rcu_torture_alloc_fail);\n\t\tspin_unlock_bh(&rcu_torture_lock);\n\t\treturn NULL;\n\t}\n\tatomic_inc(&n_rcu_torture_alloc);\n\tp = rcu_torture_freelist.next;\n\tlist_del_init(p);\n\tspin_unlock_bh(&rcu_torture_lock);\n\treturn container_of(p, struct rcu_torture, rtort_free);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(rcu_torture_freelist);",
      "static DEFINE_SPINLOCK(rcu_torture_lock);",
      "static atomic_t n_rcu_torture_alloc;",
      "static atomic_t n_rcu_torture_alloc_fail;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structrcu_torture",
            "rtort_free"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&rcu_torture_lock"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "p"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_alloc"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_rcu_torture_alloc_fail"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rcu_torture_freelist"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&rcu_torture_lock"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(rcu_torture_freelist);\nstatic DEFINE_SPINLOCK(rcu_torture_lock);\nstatic atomic_t n_rcu_torture_alloc;\nstatic atomic_t n_rcu_torture_alloc_fail;\n\nstatic struct rcu_torture *\nrcu_torture_alloc(void)\n{\n\tstruct list_head *p;\n\n\tspin_lock_bh(&rcu_torture_lock);\n\tif (list_empty(&rcu_torture_freelist)) {\n\t\tatomic_inc(&n_rcu_torture_alloc_fail);\n\t\tspin_unlock_bh(&rcu_torture_lock);\n\t\treturn NULL;\n\t}\n\tatomic_inc(&n_rcu_torture_alloc);\n\tp = rcu_torture_freelist.next;\n\tlist_del_init(p);\n\tspin_unlock_bh(&rcu_torture_lock);\n\treturn container_of(p, struct rcu_torture, rtort_free);\n}"
  },
  {
    "function_name": "rcu_trace_clock_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "247-250",
    "snippet": "static u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}"
  },
  {
    "function_name": "rcu_trace_clock_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "239-245",
    "snippet": "static u64 notrace rcu_trace_clock_local(void)\n{\n\tu64 ts = trace_clock_local();\n\n\t(void)do_div(ts, NSEC_PER_USEC);\n\treturn ts;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ts",
            "NSEC_PER_USEC"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_clock_local",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_trace_clock_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
          "lines": "247-250",
          "snippet": "static u64 notrace rcu_trace_clock_local(void)\n{\n\treturn 0ULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic u64 notrace rcu_trace_clock_local(void)\n{\n\tu64 ts = trace_clock_local();\n\n\t(void)do_div(ts, NSEC_PER_USEC);\n\treturn ts;\n}"
  },
  {
    "function_name": "rcu_torture_writer_state_getname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcutorture.c",
    "lines": "223-230",
    "snippet": "static const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/torture.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/trace_clock.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/freezer.h>",
      "#include <linux/reboot.h>",
      "#include <linux/notifier.h>",
      "#include <linux/percpu.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/err.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int rcu_torture_writer_state;",
      "static const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rcu_torture_writer_state_names"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rcu_torture_writer_state"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/sysctl.h>\n#include <linux/sched/debug.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_torture_writer_state;\nstatic const char * const rcu_torture_writer_state_names[] = {\n\t\"RTWS_FIXED_DELAY\",\n\t\"RTWS_DELAY\",\n\t\"RTWS_REPLACE\",\n\t\"RTWS_DEF_FREE\",\n\t\"RTWS_EXP_SYNC\",\n\t\"RTWS_COND_GET\",\n\t\"RTWS_COND_SYNC\",\n\t\"RTWS_SYNC\",\n\t\"RTWS_STUTTER\",\n\t\"RTWS_STOPPING\",\n};\n\nstatic const char *rcu_torture_writer_state_getname(void)\n{\n\tunsigned int i = READ_ONCE(rcu_torture_writer_state);\n\n\tif (i >= ARRAY_SIZE(rcu_torture_writer_state_names))\n\t\treturn \"???\";\n\treturn rcu_torture_writer_state_names[i];\n}"
  }
]