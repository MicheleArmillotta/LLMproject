[
  {
    "function_name": "stack_map_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "613-623",
    "snippet": "static int __init stack_map_init(void)\n{\n\tint cpu;\n\tstruct stack_map_irq_work *work;\n\n\tfor_each_possible_cpu(cpu) {\n\t\twork = per_cpu_ptr(&up_read_work, cpu);\n\t\tinit_irq_work(&work->irq_work, do_up_read);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct stack_map_irq_work, up_read_work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&work->irq_work",
            "do_up_read"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&up_read_work",
            "cpu"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct stack_map_irq_work, up_read_work);\n\nstatic int __init stack_map_init(void)\n{\n\tint cpu;\n\tstruct stack_map_irq_work *work;\n\n\tfor_each_possible_cpu(cpu) {\n\t\twork = per_cpu_ptr(&up_read_work, cpu);\n\t\tinit_irq_work(&work->irq_work, do_up_read);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "stack_map_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "590-601",
    "snippet": "static void stack_map_free(struct bpf_map *map)\n{\n\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);\n\n\t/* wait for bpf programs to complete before freeing stack map */\n\tsynchronize_rcu();\n\n\tbpf_map_area_free(smap->elems);\n\tpcpu_freelist_destroy(&smap->freelist);\n\tbpf_map_area_free(smap);\n\tput_callchain_buffers();\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_callchain_buffers",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "put_callchain_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "145-151",
          "snippet": "void put_callchain_buffers(void)\n{\n\tif (atomic_dec_and_mutex_lock(&nr_callchain_events, &callchain_mutex)) {\n\t\trelease_callchain_buffers();\n\t\tmutex_unlock(&callchain_mutex);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_callchain_events;",
            "static DEFINE_MUTEX(callchain_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic atomic_t nr_callchain_events;\nstatic DEFINE_MUTEX(callchain_mutex);\n\nvoid put_callchain_buffers(void)\n{\n\tif (atomic_dec_and_mutex_lock(&nr_callchain_events, &callchain_mutex)) {\n\t\trelease_callchain_buffers();\n\t\tmutex_unlock(&callchain_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "smap"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "156-159",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_destroy",
          "args": [
            "&smap->freelist"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "26-29",
          "snippet": "void pcpu_freelist_destroy(struct pcpu_freelist *s)\n{\n\tfree_percpu(s->freelist);\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid pcpu_freelist_destroy(struct pcpu_freelist *s)\n{\n\tfree_percpu(s->freelist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_stack_map",
            "map"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic void stack_map_free(struct bpf_map *map)\n{\n\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);\n\n\t/* wait for bpf programs to complete before freeing stack map */\n\tsynchronize_rcu();\n\n\tbpf_map_area_free(smap->elems);\n\tpcpu_freelist_destroy(&smap->freelist);\n\tbpf_map_area_free(smap);\n\tput_callchain_buffers();\n}"
  },
  {
    "function_name": "stack_map_delete_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "571-587",
    "snippet": "static int stack_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);\n\tstruct stack_map_bucket *old_bucket;\n\tu32 id = *(u32 *)key;\n\n\tif (unlikely(id >= smap->n_buckets))\n\t\treturn -E2BIG;\n\n\told_bucket = xchg(&smap->buckets[id], NULL);\n\tif (old_bucket) {\n\t\tpcpu_freelist_push(&smap->freelist, &old_bucket->fnode);\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_freelist_push",
          "args": [
            "&smap->freelist",
            "&old_bucket->fnode"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "40-46",
          "snippet": "void pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tstruct pcpu_freelist_head *head = this_cpu_ptr(s->freelist);\n\n\t__pcpu_freelist_push(head, node);\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tstruct pcpu_freelist_head *head = this_cpu_ptr(s->freelist);\n\n\t__pcpu_freelist_push(head, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&smap->buckets[id]",
            "NULL"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "id >= smap->n_buckets"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_stack_map",
            "map"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);\n\tstruct stack_map_bucket *old_bucket;\n\tu32 id = *(u32 *)key;\n\n\tif (unlikely(id >= smap->n_buckets))\n\t\treturn -E2BIG;\n\n\told_bucket = xchg(&smap->buckets[id], NULL);\n\tif (old_bucket) {\n\t\tpcpu_freelist_push(&smap->freelist, &old_bucket->fnode);\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n}"
  },
  {
    "function_name": "stack_map_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "564-568",
    "snippet": "static int stack_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t u64 map_flags)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t u64 map_flags)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "stack_map_get_next_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "535-562",
    "snippet": "static int stack_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t  void *next_key)\n{\n\tstruct bpf_stack_map *smap = container_of(map,\n\t\t\t\t\t\t  struct bpf_stack_map, map);\n\tu32 id;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tif (!key) {\n\t\tid = 0;\n\t} else {\n\t\tid = *(u32 *)key;\n\t\tif (id >= smap->n_buckets || !smap->buckets[id])\n\t\t\tid = 0;\n\t\telse\n\t\t\tid++;\n\t}\n\n\twhile (id < smap->n_buckets && !smap->buckets[id])\n\t\tid++;\n\n\tif (id >= smap->n_buckets)\n\t\treturn -ENOENT;\n\n\t*(u32 *)next_key = id;\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "273-282",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_stack_map",
            "map"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t  void *next_key)\n{\n\tstruct bpf_stack_map *smap = container_of(map,\n\t\t\t\t\t\t  struct bpf_stack_map, map);\n\tu32 id;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tif (!key) {\n\t\tid = 0;\n\t} else {\n\t\tid = *(u32 *)key;\n\t\tif (id >= smap->n_buckets || !smap->buckets[id])\n\t\t\tid = 0;\n\t\telse\n\t\t\tid++;\n\t}\n\n\twhile (id < smap->n_buckets && !smap->buckets[id])\n\t\tid++;\n\n\tif (id >= smap->n_buckets)\n\t\treturn -ENOENT;\n\n\t*(u32 *)next_key = id;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_stackmap_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "512-533",
    "snippet": "int bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);\n\tstruct stack_map_bucket *bucket, *old_bucket;\n\tu32 id = *(u32 *)key, trace_len;\n\n\tif (unlikely(id >= smap->n_buckets))\n\t\treturn -ENOENT;\n\n\tbucket = xchg(&smap->buckets[id], NULL);\n\tif (!bucket)\n\t\treturn -ENOENT;\n\n\ttrace_len = bucket->nr * stack_map_data_size(map);\n\tmemcpy(value, bucket->data, trace_len);\n\tmemset(value + trace_len, 0, map->value_size - trace_len);\n\n\told_bucket = xchg(&smap->buckets[id], bucket);\n\tif (old_bucket)\n\t\tpcpu_freelist_push(&smap->freelist, &old_bucket->fnode);\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_freelist_push",
          "args": [
            "&smap->freelist",
            "&old_bucket->fnode"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "40-46",
          "snippet": "void pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tstruct pcpu_freelist_head *head = this_cpu_ptr(s->freelist);\n\n\t__pcpu_freelist_push(head, node);\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tstruct pcpu_freelist_head *head = this_cpu_ptr(s->freelist);\n\n\t__pcpu_freelist_push(head, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&smap->buckets[id]",
            "bucket"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value + trace_len",
            "0",
            "map->value_size - trace_len"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "bucket->data",
            "trace_len"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_map_data_size",
          "args": [
            "map"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "stack_map_data_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
          "lines": "58-62",
          "snippet": "static inline int stack_map_data_size(struct bpf_map *map)\n{\n\treturn stack_map_use_build_id(map) ?\n\t\tsizeof(struct bpf_stack_build_id) : sizeof(u64);\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/irq_work.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/elf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic inline int stack_map_data_size(struct bpf_map *map)\n{\n\treturn stack_map_use_build_id(map) ?\n\t\tsizeof(struct bpf_stack_build_id) : sizeof(u64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "id >= smap->n_buckets"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_stack_map",
            "map"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nint bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);\n\tstruct stack_map_bucket *bucket, *old_bucket;\n\tu32 id = *(u32 *)key, trace_len;\n\n\tif (unlikely(id >= smap->n_buckets))\n\t\treturn -ENOENT;\n\n\tbucket = xchg(&smap->buckets[id], NULL);\n\tif (!bucket)\n\t\treturn -ENOENT;\n\n\ttrace_len = bucket->nr * stack_map_data_size(map);\n\tmemcpy(value, bucket->data, trace_len);\n\tmemset(value + trace_len, 0, map->value_size - trace_len);\n\n\told_bucket = xchg(&smap->buckets[id], bucket);\n\tif (old_bucket)\n\t\tpcpu_freelist_push(&smap->freelist, &old_bucket->fnode);\n\treturn 0;\n}"
  },
  {
    "function_name": "stack_map_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "506-509",
    "snippet": "static void *stack_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic void *stack_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
  },
  {
    "function_name": "stack_map_get_build_id_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "283-336",
    "snippet": "static void stack_map_get_build_id_offset(struct bpf_stack_build_id *id_offs,\n\t\t\t\t\t  u64 *ips, u32 trace_nr, bool user)\n{\n\tint i;\n\tstruct vm_area_struct *vma;\n\tbool irq_work_busy = false;\n\tstruct stack_map_irq_work *work = NULL;\n\n\tif (in_nmi()) {\n\t\twork = this_cpu_ptr(&up_read_work);\n\t\tif (work->irq_work.flags & IRQ_WORK_BUSY)\n\t\t\t/* cannot queue more up_read, fallback */\n\t\t\tirq_work_busy = true;\n\t}\n\n\t/*\n\t * We cannot do up_read() in nmi context. To do build_id lookup\n\t * in nmi context, we need to run up_read() in irq_work. We use\n\t * a percpu variable to do the irq_work. If the irq_work is\n\t * already used by another lookup, we fall back to report ips.\n\t *\n\t * Same fallback is used for kernel stack (!user) on a stackmap\n\t * with build_id.\n\t */\n\tif (!user || !current || !current->mm || irq_work_busy ||\n\t    down_read_trylock(&current->mm->mmap_sem) == 0) {\n\t\t/* cannot access current->mm, fall back to ips */\n\t\tfor (i = 0; i < trace_nr; i++) {\n\t\t\tid_offs[i].status = BPF_STACK_BUILD_ID_IP;\n\t\t\tid_offs[i].ip = ips[i];\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < trace_nr; i++) {\n\t\tvma = find_vma(current->mm, ips[i]);\n\t\tif (!vma || stack_map_get_build_id(vma, id_offs[i].build_id)) {\n\t\t\t/* per entry fall back to ips */\n\t\t\tid_offs[i].status = BPF_STACK_BUILD_ID_IP;\n\t\t\tid_offs[i].ip = ips[i];\n\t\t\tcontinue;\n\t\t}\n\t\tid_offs[i].offset = (vma->vm_pgoff << PAGE_SHIFT) + ips[i]\n\t\t\t- vma->vm_start;\n\t\tid_offs[i].status = BPF_STACK_BUILD_ID_VALID;\n\t}\n\n\tif (!work) {\n\t\tup_read(&current->mm->mmap_sem);\n\t} else {\n\t\twork->sem = &current->mm->mmap_sem;\n\t\tirq_work_queue(&work->irq_work);\n\t}\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct stack_map_irq_work, up_read_work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&work->irq_work"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "90-112",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "do_up_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
          "lines": "42-49",
          "snippet": "static void do_up_read(struct irq_work *entry)\n{\n\tstruct stack_map_irq_work *work;\n\n\twork = container_of(entry, struct stack_map_irq_work, irq_work);\n\tup_read(work->sem);\n\twork->sem = NULL;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/irq_work.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/elf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic void do_up_read(struct irq_work *entry)\n{\n\tstruct stack_map_irq_work *work;\n\n\twork = container_of(entry, struct stack_map_irq_work, irq_work);\n\tup_read(work->sem);\n\twork->sem = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_map_get_build_id",
          "args": [
            "vma",
            "id_offs[i].build_id"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "stack_map_get_build_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
          "lines": "246-281",
          "snippet": "static int stack_map_get_build_id(struct vm_area_struct *vma,\n\t\t\t\t  unsigned char *build_id)\n{\n\tElf32_Ehdr *ehdr;\n\tstruct page *page;\n\tvoid *page_addr;\n\tint ret;\n\n\t/* only works for page backed storage  */\n\tif (!vma->vm_file)\n\t\treturn -EINVAL;\n\n\tpage = find_get_page(vma->vm_file->f_mapping, 0);\n\tif (!page)\n\t\treturn -EFAULT;\t/* page not mapped */\n\n\tret = -EINVAL;\n\tpage_addr = page_address(page);\n\tehdr = (Elf32_Ehdr *)page_addr;\n\n\t/* compare magic x7f \"ELF\" */\n\tif (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* only support executable file and shared object file */\n\tif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN)\n\t\tgoto out;\n\n\tif (ehdr->e_ident[EI_CLASS] == ELFCLASS32)\n\t\tret = stack_map_get_build_id_32(page_addr, build_id);\n\telse if (ehdr->e_ident[EI_CLASS] == ELFCLASS64)\n\t\tret = stack_map_get_build_id_64(page_addr, build_id);\nout:\n\tput_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/irq_work.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/elf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_get_build_id(struct vm_area_struct *vma,\n\t\t\t\t  unsigned char *build_id)\n{\n\tElf32_Ehdr *ehdr;\n\tstruct page *page;\n\tvoid *page_addr;\n\tint ret;\n\n\t/* only works for page backed storage  */\n\tif (!vma->vm_file)\n\t\treturn -EINVAL;\n\n\tpage = find_get_page(vma->vm_file->f_mapping, 0);\n\tif (!page)\n\t\treturn -EFAULT;\t/* page not mapped */\n\n\tret = -EINVAL;\n\tpage_addr = page_address(page);\n\tehdr = (Elf32_Ehdr *)page_addr;\n\n\t/* compare magic x7f \"ELF\" */\n\tif (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* only support executable file and shared object file */\n\tif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN)\n\t\tgoto out;\n\n\tif (ehdr->e_ident[EI_CLASS] == ELFCLASS32)\n\t\tret = stack_map_get_build_id_32(page_addr, build_id);\n\telse if (ehdr->e_ident[EI_CLASS] == ELFCLASS64)\n\t\tret = stack_map_get_build_id_64(page_addr, build_id);\nout:\n\tput_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "current->mm",
            "ips[i]"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "51-60",
          "snippet": "int down_read_trylock(struct rw_semaphore *sem)\n{\n\tint ret = __down_read_trylock(sem);\n\n\tif (ret == 1) {\n\t\trwsem_acquire_read(&sem->dep_map, 0, 1, _RET_IP_);\n\t\trwsem_set_reader_owned(sem);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint down_read_trylock(struct rw_semaphore *sem)\n{\n\tint ret = __down_read_trylock(sem);\n\n\tif (ret == 1) {\n\t\trwsem_acquire_read(&sem->dep_map, 0, 1, _RET_IP_);\n\t\trwsem_set_reader_owned(sem);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&up_read_work"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct stack_map_irq_work, up_read_work);\n\nstatic void stack_map_get_build_id_offset(struct bpf_stack_build_id *id_offs,\n\t\t\t\t\t  u64 *ips, u32 trace_nr, bool user)\n{\n\tint i;\n\tstruct vm_area_struct *vma;\n\tbool irq_work_busy = false;\n\tstruct stack_map_irq_work *work = NULL;\n\n\tif (in_nmi()) {\n\t\twork = this_cpu_ptr(&up_read_work);\n\t\tif (work->irq_work.flags & IRQ_WORK_BUSY)\n\t\t\t/* cannot queue more up_read, fallback */\n\t\t\tirq_work_busy = true;\n\t}\n\n\t/*\n\t * We cannot do up_read() in nmi context. To do build_id lookup\n\t * in nmi context, we need to run up_read() in irq_work. We use\n\t * a percpu variable to do the irq_work. If the irq_work is\n\t * already used by another lookup, we fall back to report ips.\n\t *\n\t * Same fallback is used for kernel stack (!user) on a stackmap\n\t * with build_id.\n\t */\n\tif (!user || !current || !current->mm || irq_work_busy ||\n\t    down_read_trylock(&current->mm->mmap_sem) == 0) {\n\t\t/* cannot access current->mm, fall back to ips */\n\t\tfor (i = 0; i < trace_nr; i++) {\n\t\t\tid_offs[i].status = BPF_STACK_BUILD_ID_IP;\n\t\t\tid_offs[i].ip = ips[i];\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < trace_nr; i++) {\n\t\tvma = find_vma(current->mm, ips[i]);\n\t\tif (!vma || stack_map_get_build_id(vma, id_offs[i].build_id)) {\n\t\t\t/* per entry fall back to ips */\n\t\t\tid_offs[i].status = BPF_STACK_BUILD_ID_IP;\n\t\t\tid_offs[i].ip = ips[i];\n\t\t\tcontinue;\n\t\t}\n\t\tid_offs[i].offset = (vma->vm_pgoff << PAGE_SHIFT) + ips[i]\n\t\t\t- vma->vm_start;\n\t\tid_offs[i].status = BPF_STACK_BUILD_ID_VALID;\n\t}\n\n\tif (!work) {\n\t\tup_read(&current->mm->mmap_sem);\n\t} else {\n\t\twork->sem = &current->mm->mmap_sem;\n\t\tirq_work_queue(&work->irq_work);\n\t}\n}"
  },
  {
    "function_name": "stack_map_get_build_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "246-281",
    "snippet": "static int stack_map_get_build_id(struct vm_area_struct *vma,\n\t\t\t\t  unsigned char *build_id)\n{\n\tElf32_Ehdr *ehdr;\n\tstruct page *page;\n\tvoid *page_addr;\n\tint ret;\n\n\t/* only works for page backed storage  */\n\tif (!vma->vm_file)\n\t\treturn -EINVAL;\n\n\tpage = find_get_page(vma->vm_file->f_mapping, 0);\n\tif (!page)\n\t\treturn -EFAULT;\t/* page not mapped */\n\n\tret = -EINVAL;\n\tpage_addr = page_address(page);\n\tehdr = (Elf32_Ehdr *)page_addr;\n\n\t/* compare magic x7f \"ELF\" */\n\tif (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* only support executable file and shared object file */\n\tif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN)\n\t\tgoto out;\n\n\tif (ehdr->e_ident[EI_CLASS] == ELFCLASS32)\n\t\tret = stack_map_get_build_id_32(page_addr, build_id);\n\telse if (ehdr->e_ident[EI_CLASS] == ELFCLASS64)\n\t\tret = stack_map_get_build_id_64(page_addr, build_id);\nout:\n\tput_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_map_get_build_id_64",
          "args": [
            "page_addr",
            "build_id"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "stack_map_get_build_id_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
          "lines": "223-243",
          "snippet": "static int stack_map_get_build_id_64(void *page_addr,\n\t\t\t\t     unsigned char *build_id)\n{\n\tElf64_Ehdr *ehdr = (Elf64_Ehdr *)page_addr;\n\tElf64_Phdr *phdr;\n\tint i;\n\n\t/* only supports phdr that fits in one page */\n\tif (ehdr->e_phnum >\n\t    (PAGE_SIZE - sizeof(Elf64_Ehdr)) / sizeof(Elf64_Phdr))\n\t\treturn -EINVAL;\n\n\tphdr = (Elf64_Phdr *)(page_addr + sizeof(Elf64_Ehdr));\n\n\tfor (i = 0; i < ehdr->e_phnum; ++i)\n\t\tif (phdr[i].p_type == PT_NOTE)\n\t\t\treturn stack_map_parse_build_id(page_addr, build_id,\n\t\t\t\t\tpage_addr + phdr[i].p_offset,\n\t\t\t\t\tphdr[i].p_filesz);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/irq_work.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/elf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_get_build_id_64(void *page_addr,\n\t\t\t\t     unsigned char *build_id)\n{\n\tElf64_Ehdr *ehdr = (Elf64_Ehdr *)page_addr;\n\tElf64_Phdr *phdr;\n\tint i;\n\n\t/* only supports phdr that fits in one page */\n\tif (ehdr->e_phnum >\n\t    (PAGE_SIZE - sizeof(Elf64_Ehdr)) / sizeof(Elf64_Phdr))\n\t\treturn -EINVAL;\n\n\tphdr = (Elf64_Phdr *)(page_addr + sizeof(Elf64_Ehdr));\n\n\tfor (i = 0; i < ehdr->e_phnum; ++i)\n\t\tif (phdr[i].p_type == PT_NOTE)\n\t\t\treturn stack_map_parse_build_id(page_addr, build_id,\n\t\t\t\t\tpage_addr + phdr[i].p_offset,\n\t\t\t\t\tphdr[i].p_filesz);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_map_get_build_id_32",
          "args": [
            "page_addr",
            "build_id"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "stack_map_get_build_id_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
          "lines": "200-220",
          "snippet": "static int stack_map_get_build_id_32(void *page_addr,\n\t\t\t\t     unsigned char *build_id)\n{\n\tElf32_Ehdr *ehdr = (Elf32_Ehdr *)page_addr;\n\tElf32_Phdr *phdr;\n\tint i;\n\n\t/* only supports phdr that fits in one page */\n\tif (ehdr->e_phnum >\n\t    (PAGE_SIZE - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr))\n\t\treturn -EINVAL;\n\n\tphdr = (Elf32_Phdr *)(page_addr + sizeof(Elf32_Ehdr));\n\n\tfor (i = 0; i < ehdr->e_phnum; ++i)\n\t\tif (phdr[i].p_type == PT_NOTE)\n\t\t\treturn stack_map_parse_build_id(page_addr, build_id,\n\t\t\t\t\tpage_addr + phdr[i].p_offset,\n\t\t\t\t\tphdr[i].p_filesz);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/irq_work.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/elf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_get_build_id_32(void *page_addr,\n\t\t\t\t     unsigned char *build_id)\n{\n\tElf32_Ehdr *ehdr = (Elf32_Ehdr *)page_addr;\n\tElf32_Phdr *phdr;\n\tint i;\n\n\t/* only supports phdr that fits in one page */\n\tif (ehdr->e_phnum >\n\t    (PAGE_SIZE - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr))\n\t\treturn -EINVAL;\n\n\tphdr = (Elf32_Phdr *)(page_addr + sizeof(Elf32_Ehdr));\n\n\tfor (i = 0; i < ehdr->e_phnum; ++i)\n\t\tif (phdr[i].p_type == PT_NOTE)\n\t\t\treturn stack_map_parse_build_id(page_addr, build_id,\n\t\t\t\t\tpage_addr + phdr[i].p_offset,\n\t\t\t\t\tphdr[i].p_filesz);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ehdr->e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "vma->vm_file->f_mapping",
            "0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_get_build_id(struct vm_area_struct *vma,\n\t\t\t\t  unsigned char *build_id)\n{\n\tElf32_Ehdr *ehdr;\n\tstruct page *page;\n\tvoid *page_addr;\n\tint ret;\n\n\t/* only works for page backed storage  */\n\tif (!vma->vm_file)\n\t\treturn -EINVAL;\n\n\tpage = find_get_page(vma->vm_file->f_mapping, 0);\n\tif (!page)\n\t\treturn -EFAULT;\t/* page not mapped */\n\n\tret = -EINVAL;\n\tpage_addr = page_address(page);\n\tehdr = (Elf32_Ehdr *)page_addr;\n\n\t/* compare magic x7f \"ELF\" */\n\tif (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* only support executable file and shared object file */\n\tif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN)\n\t\tgoto out;\n\n\tif (ehdr->e_ident[EI_CLASS] == ELFCLASS32)\n\t\tret = stack_map_get_build_id_32(page_addr, build_id);\n\telse if (ehdr->e_ident[EI_CLASS] == ELFCLASS64)\n\t\tret = stack_map_get_build_id_64(page_addr, build_id);\nout:\n\tput_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "stack_map_get_build_id_64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "223-243",
    "snippet": "static int stack_map_get_build_id_64(void *page_addr,\n\t\t\t\t     unsigned char *build_id)\n{\n\tElf64_Ehdr *ehdr = (Elf64_Ehdr *)page_addr;\n\tElf64_Phdr *phdr;\n\tint i;\n\n\t/* only supports phdr that fits in one page */\n\tif (ehdr->e_phnum >\n\t    (PAGE_SIZE - sizeof(Elf64_Ehdr)) / sizeof(Elf64_Phdr))\n\t\treturn -EINVAL;\n\n\tphdr = (Elf64_Phdr *)(page_addr + sizeof(Elf64_Ehdr));\n\n\tfor (i = 0; i < ehdr->e_phnum; ++i)\n\t\tif (phdr[i].p_type == PT_NOTE)\n\t\t\treturn stack_map_parse_build_id(page_addr, build_id,\n\t\t\t\t\tpage_addr + phdr[i].p_offset,\n\t\t\t\t\tphdr[i].p_filesz);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stack_map_parse_build_id",
          "args": [
            "page_addr",
            "build_id",
            "page_addr + phdr[i].p_offset",
            "phdr[i].p_filesz"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "stack_map_parse_build_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
          "lines": "163-197",
          "snippet": "static inline int stack_map_parse_build_id(void *page_addr,\n\t\t\t\t\t   unsigned char *build_id,\n\t\t\t\t\t   void *note_start,\n\t\t\t\t\t   Elf32_Word note_size)\n{\n\tElf32_Word note_offs = 0, new_offs;\n\n\t/* check for overflow */\n\tif (note_start < page_addr || note_start + note_size < note_start)\n\t\treturn -EINVAL;\n\n\t/* only supports note that fits in the first page */\n\tif (note_start + note_size > page_addr + PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\twhile (note_offs + sizeof(Elf32_Nhdr) < note_size) {\n\t\tElf32_Nhdr *nhdr = (Elf32_Nhdr *)(note_start + note_offs);\n\n\t\tif (nhdr->n_type == BPF_BUILD_ID &&\n\t\t    nhdr->n_namesz == sizeof(\"GNU\") &&\n\t\t    nhdr->n_descsz == BPF_BUILD_ID_SIZE) {\n\t\t\tmemcpy(build_id,\n\t\t\t       note_start + note_offs +\n\t\t\t       ALIGN(sizeof(\"GNU\"), 4) + sizeof(Elf32_Nhdr),\n\t\t\t       BPF_BUILD_ID_SIZE);\n\t\t\treturn 0;\n\t\t}\n\t\tnew_offs = note_offs + sizeof(Elf32_Nhdr) +\n\t\t\tALIGN(nhdr->n_namesz, 4) + ALIGN(nhdr->n_descsz, 4);\n\t\tif (new_offs <= note_offs)  /* overflow */\n\t\t\tbreak;\n\t\tnote_offs = new_offs;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/irq_work.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/elf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_BUILD_ID 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\n#define BPF_BUILD_ID 3\n\nstatic inline int stack_map_parse_build_id(void *page_addr,\n\t\t\t\t\t   unsigned char *build_id,\n\t\t\t\t\t   void *note_start,\n\t\t\t\t\t   Elf32_Word note_size)\n{\n\tElf32_Word note_offs = 0, new_offs;\n\n\t/* check for overflow */\n\tif (note_start < page_addr || note_start + note_size < note_start)\n\t\treturn -EINVAL;\n\n\t/* only supports note that fits in the first page */\n\tif (note_start + note_size > page_addr + PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\twhile (note_offs + sizeof(Elf32_Nhdr) < note_size) {\n\t\tElf32_Nhdr *nhdr = (Elf32_Nhdr *)(note_start + note_offs);\n\n\t\tif (nhdr->n_type == BPF_BUILD_ID &&\n\t\t    nhdr->n_namesz == sizeof(\"GNU\") &&\n\t\t    nhdr->n_descsz == BPF_BUILD_ID_SIZE) {\n\t\t\tmemcpy(build_id,\n\t\t\t       note_start + note_offs +\n\t\t\t       ALIGN(sizeof(\"GNU\"), 4) + sizeof(Elf32_Nhdr),\n\t\t\t       BPF_BUILD_ID_SIZE);\n\t\t\treturn 0;\n\t\t}\n\t\tnew_offs = note_offs + sizeof(Elf32_Nhdr) +\n\t\t\tALIGN(nhdr->n_namesz, 4) + ALIGN(nhdr->n_descsz, 4);\n\t\tif (new_offs <= note_offs)  /* overflow */\n\t\t\tbreak;\n\t\tnote_offs = new_offs;\n\t}\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_get_build_id_64(void *page_addr,\n\t\t\t\t     unsigned char *build_id)\n{\n\tElf64_Ehdr *ehdr = (Elf64_Ehdr *)page_addr;\n\tElf64_Phdr *phdr;\n\tint i;\n\n\t/* only supports phdr that fits in one page */\n\tif (ehdr->e_phnum >\n\t    (PAGE_SIZE - sizeof(Elf64_Ehdr)) / sizeof(Elf64_Phdr))\n\t\treturn -EINVAL;\n\n\tphdr = (Elf64_Phdr *)(page_addr + sizeof(Elf64_Ehdr));\n\n\tfor (i = 0; i < ehdr->e_phnum; ++i)\n\t\tif (phdr[i].p_type == PT_NOTE)\n\t\t\treturn stack_map_parse_build_id(page_addr, build_id,\n\t\t\t\t\tpage_addr + phdr[i].p_offset,\n\t\t\t\t\tphdr[i].p_filesz);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "stack_map_get_build_id_32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "200-220",
    "snippet": "static int stack_map_get_build_id_32(void *page_addr,\n\t\t\t\t     unsigned char *build_id)\n{\n\tElf32_Ehdr *ehdr = (Elf32_Ehdr *)page_addr;\n\tElf32_Phdr *phdr;\n\tint i;\n\n\t/* only supports phdr that fits in one page */\n\tif (ehdr->e_phnum >\n\t    (PAGE_SIZE - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr))\n\t\treturn -EINVAL;\n\n\tphdr = (Elf32_Phdr *)(page_addr + sizeof(Elf32_Ehdr));\n\n\tfor (i = 0; i < ehdr->e_phnum; ++i)\n\t\tif (phdr[i].p_type == PT_NOTE)\n\t\t\treturn stack_map_parse_build_id(page_addr, build_id,\n\t\t\t\t\tpage_addr + phdr[i].p_offset,\n\t\t\t\t\tphdr[i].p_filesz);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stack_map_parse_build_id",
          "args": [
            "page_addr",
            "build_id",
            "page_addr + phdr[i].p_offset",
            "phdr[i].p_filesz"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "stack_map_parse_build_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
          "lines": "163-197",
          "snippet": "static inline int stack_map_parse_build_id(void *page_addr,\n\t\t\t\t\t   unsigned char *build_id,\n\t\t\t\t\t   void *note_start,\n\t\t\t\t\t   Elf32_Word note_size)\n{\n\tElf32_Word note_offs = 0, new_offs;\n\n\t/* check for overflow */\n\tif (note_start < page_addr || note_start + note_size < note_start)\n\t\treturn -EINVAL;\n\n\t/* only supports note that fits in the first page */\n\tif (note_start + note_size > page_addr + PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\twhile (note_offs + sizeof(Elf32_Nhdr) < note_size) {\n\t\tElf32_Nhdr *nhdr = (Elf32_Nhdr *)(note_start + note_offs);\n\n\t\tif (nhdr->n_type == BPF_BUILD_ID &&\n\t\t    nhdr->n_namesz == sizeof(\"GNU\") &&\n\t\t    nhdr->n_descsz == BPF_BUILD_ID_SIZE) {\n\t\t\tmemcpy(build_id,\n\t\t\t       note_start + note_offs +\n\t\t\t       ALIGN(sizeof(\"GNU\"), 4) + sizeof(Elf32_Nhdr),\n\t\t\t       BPF_BUILD_ID_SIZE);\n\t\t\treturn 0;\n\t\t}\n\t\tnew_offs = note_offs + sizeof(Elf32_Nhdr) +\n\t\t\tALIGN(nhdr->n_namesz, 4) + ALIGN(nhdr->n_descsz, 4);\n\t\tif (new_offs <= note_offs)  /* overflow */\n\t\t\tbreak;\n\t\tnote_offs = new_offs;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/irq_work.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/elf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_BUILD_ID 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\n#define BPF_BUILD_ID 3\n\nstatic inline int stack_map_parse_build_id(void *page_addr,\n\t\t\t\t\t   unsigned char *build_id,\n\t\t\t\t\t   void *note_start,\n\t\t\t\t\t   Elf32_Word note_size)\n{\n\tElf32_Word note_offs = 0, new_offs;\n\n\t/* check for overflow */\n\tif (note_start < page_addr || note_start + note_size < note_start)\n\t\treturn -EINVAL;\n\n\t/* only supports note that fits in the first page */\n\tif (note_start + note_size > page_addr + PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\twhile (note_offs + sizeof(Elf32_Nhdr) < note_size) {\n\t\tElf32_Nhdr *nhdr = (Elf32_Nhdr *)(note_start + note_offs);\n\n\t\tif (nhdr->n_type == BPF_BUILD_ID &&\n\t\t    nhdr->n_namesz == sizeof(\"GNU\") &&\n\t\t    nhdr->n_descsz == BPF_BUILD_ID_SIZE) {\n\t\t\tmemcpy(build_id,\n\t\t\t       note_start + note_offs +\n\t\t\t       ALIGN(sizeof(\"GNU\"), 4) + sizeof(Elf32_Nhdr),\n\t\t\t       BPF_BUILD_ID_SIZE);\n\t\t\treturn 0;\n\t\t}\n\t\tnew_offs = note_offs + sizeof(Elf32_Nhdr) +\n\t\t\tALIGN(nhdr->n_namesz, 4) + ALIGN(nhdr->n_descsz, 4);\n\t\tif (new_offs <= note_offs)  /* overflow */\n\t\t\tbreak;\n\t\tnote_offs = new_offs;\n\t}\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_get_build_id_32(void *page_addr,\n\t\t\t\t     unsigned char *build_id)\n{\n\tElf32_Ehdr *ehdr = (Elf32_Ehdr *)page_addr;\n\tElf32_Phdr *phdr;\n\tint i;\n\n\t/* only supports phdr that fits in one page */\n\tif (ehdr->e_phnum >\n\t    (PAGE_SIZE - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr))\n\t\treturn -EINVAL;\n\n\tphdr = (Elf32_Phdr *)(page_addr + sizeof(Elf32_Ehdr));\n\n\tfor (i = 0; i < ehdr->e_phnum; ++i)\n\t\tif (phdr[i].p_type == PT_NOTE)\n\t\t\treturn stack_map_parse_build_id(page_addr, build_id,\n\t\t\t\t\tpage_addr + phdr[i].p_offset,\n\t\t\t\t\tphdr[i].p_filesz);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "stack_map_parse_build_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "163-197",
    "snippet": "static inline int stack_map_parse_build_id(void *page_addr,\n\t\t\t\t\t   unsigned char *build_id,\n\t\t\t\t\t   void *note_start,\n\t\t\t\t\t   Elf32_Word note_size)\n{\n\tElf32_Word note_offs = 0, new_offs;\n\n\t/* check for overflow */\n\tif (note_start < page_addr || note_start + note_size < note_start)\n\t\treturn -EINVAL;\n\n\t/* only supports note that fits in the first page */\n\tif (note_start + note_size > page_addr + PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\twhile (note_offs + sizeof(Elf32_Nhdr) < note_size) {\n\t\tElf32_Nhdr *nhdr = (Elf32_Nhdr *)(note_start + note_offs);\n\n\t\tif (nhdr->n_type == BPF_BUILD_ID &&\n\t\t    nhdr->n_namesz == sizeof(\"GNU\") &&\n\t\t    nhdr->n_descsz == BPF_BUILD_ID_SIZE) {\n\t\t\tmemcpy(build_id,\n\t\t\t       note_start + note_offs +\n\t\t\t       ALIGN(sizeof(\"GNU\"), 4) + sizeof(Elf32_Nhdr),\n\t\t\t       BPF_BUILD_ID_SIZE);\n\t\t\treturn 0;\n\t\t}\n\t\tnew_offs = note_offs + sizeof(Elf32_Nhdr) +\n\t\t\tALIGN(nhdr->n_namesz, 4) + ALIGN(nhdr->n_descsz, 4);\n\t\tif (new_offs <= note_offs)  /* overflow */\n\t\t\tbreak;\n\t\tnote_offs = new_offs;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_BUILD_ID 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "nhdr->n_descsz",
            "4"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "nhdr->n_namesz",
            "4"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "build_id",
            "note_start + note_offs +\n\t\t\t       ALIGN(sizeof(\"GNU\"), 4) + sizeof(Elf32_Nhdr)",
            "BPF_BUILD_ID_SIZE"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sizeof(\"GNU\")",
            "4"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\n#define BPF_BUILD_ID 3\n\nstatic inline int stack_map_parse_build_id(void *page_addr,\n\t\t\t\t\t   unsigned char *build_id,\n\t\t\t\t\t   void *note_start,\n\t\t\t\t\t   Elf32_Word note_size)\n{\n\tElf32_Word note_offs = 0, new_offs;\n\n\t/* check for overflow */\n\tif (note_start < page_addr || note_start + note_size < note_start)\n\t\treturn -EINVAL;\n\n\t/* only supports note that fits in the first page */\n\tif (note_start + note_size > page_addr + PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\twhile (note_offs + sizeof(Elf32_Nhdr) < note_size) {\n\t\tElf32_Nhdr *nhdr = (Elf32_Nhdr *)(note_start + note_offs);\n\n\t\tif (nhdr->n_type == BPF_BUILD_ID &&\n\t\t    nhdr->n_namesz == sizeof(\"GNU\") &&\n\t\t    nhdr->n_descsz == BPF_BUILD_ID_SIZE) {\n\t\t\tmemcpy(build_id,\n\t\t\t       note_start + note_offs +\n\t\t\t       ALIGN(sizeof(\"GNU\"), 4) + sizeof(Elf32_Nhdr),\n\t\t\t       BPF_BUILD_ID_SIZE);\n\t\t\treturn 0;\n\t\t}\n\t\tnew_offs = note_offs + sizeof(Elf32_Nhdr) +\n\t\t\tALIGN(nhdr->n_namesz, 4) + ALIGN(nhdr->n_descsz, 4);\n\t\tif (new_offs <= note_offs)  /* overflow */\n\t\t\tbreak;\n\t\tnote_offs = new_offs;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "stack_map_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "88-155",
    "snippet": "static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id) ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tif (cost >= U32_MAX - PAGE_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = -E2BIG;\n\tcost += n_buckets * (value_size + sizeof(struct stack_map_bucket));\n\tif (cost >= U32_MAX - PAGE_SIZE)\n\t\tgoto free_smap;\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->map.value_size = value_size;\n\tsmap->n_buckets = n_buckets;\n\tsmap->map.pages = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;\n\n\terr = bpf_map_precharge_memlock(smap->map.pages);\n\tif (err)\n\t\tgoto free_smap;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\tif (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\tif (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\nfree_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define STACK_CREATE_FLAG_MASK\t\t\t\t\t\\\n\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY |\t\\\n\t BPF_F_STACK_BUILD_ID)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "smap"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "156-159",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_callchain_buffers",
          "args": [],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "put_callchain_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "145-151",
          "snippet": "void put_callchain_buffers(void)\n{\n\tif (atomic_dec_and_mutex_lock(&nr_callchain_events, &callchain_mutex)) {\n\t\trelease_callchain_buffers();\n\t\tmutex_unlock(&callchain_mutex);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_callchain_events;",
            "static DEFINE_MUTEX(callchain_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nstatic atomic_t nr_callchain_events;\nstatic DEFINE_MUTEX(callchain_mutex);\n\nvoid put_callchain_buffers(void)\n{\n\tif (atomic_dec_and_mutex_lock(&nr_callchain_events, &callchain_mutex)) {\n\t\trelease_callchain_buffers();\n\t\tmutex_unlock(&callchain_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prealloc_elems_and_freelist",
          "args": [
            "smap"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_elems_and_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
          "lines": "64-85",
          "snippet": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/irq_work.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/elf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_callchain_buffers",
          "args": [
            "sysctl_perf_event_max_stack"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "get_callchain_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/callchain.c",
          "lines": "109-143",
          "snippet": "int get_callchain_buffers(int event_max_stack)\n{\n\tint err = 0;\n\tint count;\n\n\tmutex_lock(&callchain_mutex);\n\n\tcount = atomic_inc_return(&nr_callchain_events);\n\tif (WARN_ON_ONCE(count < 1)) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * If requesting per event more than the global cap,\n\t * return a different error to help userspace figure\n\t * this out.\n\t *\n\t * And also do it here so that we have &callchain_mutex held.\n\t */\n\tif (event_max_stack > sysctl_perf_event_max_stack) {\n\t\terr = -EOVERFLOW;\n\t\tgoto exit;\n\t}\n\n\tif (count == 1)\n\t\terr = alloc_callchain_buffers();\nexit:\n\tif (err)\n\t\tatomic_dec(&nr_callchain_events);\n\n\tmutex_unlock(&callchain_mutex);\n\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_perf_event_max_stack",
            "static atomic_t nr_callchain_events;",
            "static DEFINE_MUTEX(callchain_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n\nint sysctl_perf_event_max_stack;\nstatic atomic_t nr_callchain_events;\nstatic DEFINE_MUTEX(callchain_mutex);\n\nint get_callchain_buffers(int event_max_stack)\n{\n\tint err = 0;\n\tint count;\n\n\tmutex_lock(&callchain_mutex);\n\n\tcount = atomic_inc_return(&nr_callchain_events);\n\tif (WARN_ON_ONCE(count < 1)) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * If requesting per event more than the global cap,\n\t * return a different error to help userspace figure\n\t * this out.\n\t *\n\t * And also do it here so that we have &callchain_mutex held.\n\t */\n\tif (event_max_stack > sysctl_perf_event_max_stack) {\n\t\terr = -EOVERFLOW;\n\t\tgoto exit;\n\t}\n\n\tif (count == 1)\n\t\terr = alloc_callchain_buffers();\nexit:\n\tif (err)\n\t\tatomic_dec(&nr_callchain_events);\n\n\tmutex_unlock(&callchain_mutex);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_precharge_memlock",
          "args": [
            "smap->map.pages"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_precharge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "171-182",
          "snippet": "int bpf_map_precharge_memlock(u32 pages)\n{\n\tstruct user_struct *user = get_current_user();\n\tunsigned long memlock_limit, cur;\n\n\tmemlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tcur = atomic_long_read(&user->locked_vm);\n\tfree_uid(user);\n\tif (cur + pages > memlock_limit)\n\t\treturn -EPERM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_map_precharge_memlock(u32 pages)\n{\n\tstruct user_struct *user = get_current_user();\n\tunsigned long memlock_limit, cur;\n\n\tmemlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tcur = atomic_long_read(&user->locked_vm);\n\tfree_uid(user);\n\tif (cur + pages > memlock_limit)\n\t\treturn -EPERM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "cost",
            "PAGE_SIZE"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&smap->map",
            "attr"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "161-169",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "cost",
            "bpf_map_attr_numa_node(attr)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "137-154",
          "snippet": "void *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-E2BIG"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "attr->max_entries"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct bpf_stack_build_id) % sizeof(u64)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\n#define STACK_CREATE_FLAG_MASK\t\t\t\t\t\\\n\t(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY |\t\\\n\t BPF_F_STACK_BUILD_ID)\n\nstatic struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id) ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2 */\n\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tif (cost >= U32_MAX - PAGE_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = -E2BIG;\n\tcost += n_buckets * (value_size + sizeof(struct stack_map_bucket));\n\tif (cost >= U32_MAX - PAGE_SIZE)\n\t\tgoto free_smap;\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->map.value_size = value_size;\n\tsmap->n_buckets = n_buckets;\n\tsmap->map.pages = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;\n\n\terr = bpf_map_precharge_memlock(smap->map.pages);\n\tif (err)\n\t\tgoto free_smap;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\tif (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\tif (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\nfree_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "prealloc_elems_and_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "64-85",
    "snippet": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "smap->elems"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "156-159",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_populate",
          "args": [
            "&smap->freelist",
            "smap->elems",
            "elem_size",
            "smap->map.max_entries"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "48-75",
          "snippet": "void pcpu_freelist_populate(struct pcpu_freelist *s, void *buf, u32 elem_size,\n\t\t\t    u32 nr_elems)\n{\n\tstruct pcpu_freelist_head *head;\n\tunsigned long flags;\n\tint i, cpu, pcpu_entries;\n\n\tpcpu_entries = nr_elems / num_possible_cpus() + 1;\n\ti = 0;\n\n\t/* disable irq to workaround lockdep false positive\n\t * in bpf usage pcpu_freelist_populate() will never race\n\t * with pcpu_freelist_push()\n\t */\n\tlocal_irq_save(flags);\n\tfor_each_possible_cpu(cpu) {\nagain:\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\t__pcpu_freelist_push(head, buf);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid pcpu_freelist_populate(struct pcpu_freelist *s, void *buf, u32 elem_size,\n\t\t\t    u32 nr_elems)\n{\n\tstruct pcpu_freelist_head *head;\n\tunsigned long flags;\n\tint i, cpu, pcpu_entries;\n\n\tpcpu_entries = nr_elems / num_possible_cpus() + 1;\n\ti = 0;\n\n\t/* disable irq to workaround lockdep false positive\n\t * in bpf usage pcpu_freelist_populate() will never race\n\t * with pcpu_freelist_push()\n\t */\n\tlocal_irq_save(flags);\n\tfor_each_possible_cpu(cpu) {\nagain:\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\t__pcpu_freelist_push(head, buf);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_init",
          "args": [
            "&smap->freelist"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "9-24",
          "snippet": "int pcpu_freelist_init(struct pcpu_freelist *s)\n{\n\tint cpu;\n\n\ts->freelist = alloc_percpu(struct pcpu_freelist_head);\n\tif (!s->freelist)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct pcpu_freelist_head *head = per_cpu_ptr(s->freelist, cpu);\n\n\t\traw_spin_lock_init(&head->lock);\n\t\thead->first = NULL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nint pcpu_freelist_init(struct pcpu_freelist *s)\n{\n\tint cpu;\n\n\ts->freelist = alloc_percpu(struct pcpu_freelist_head);\n\tif (!s->freelist)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct pcpu_freelist_head *head = per_cpu_ptr(s->freelist, cpu);\n\n\t\traw_spin_lock_init(&head->lock);\n\t\thead->first = NULL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "elem_size * smap->map.max_entries",
            "smap->map.numa_node"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "137-154",
          "snippet": "void *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}"
  },
  {
    "function_name": "stack_map_data_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "58-62",
    "snippet": "static inline int stack_map_data_size(struct bpf_map *map)\n{\n\treturn stack_map_use_build_id(map) ?\n\t\tsizeof(struct bpf_stack_build_id) : sizeof(u64);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stack_map_use_build_id",
          "args": [
            "map"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "stack_map_use_build_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
          "lines": "53-56",
          "snippet": "static inline bool stack_map_use_build_id(struct bpf_map *map)\n{\n\treturn (map->map_flags & BPF_F_STACK_BUILD_ID);\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/irq_work.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/elf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic inline bool stack_map_use_build_id(struct bpf_map *map)\n{\n\treturn (map->map_flags & BPF_F_STACK_BUILD_ID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic inline int stack_map_data_size(struct bpf_map *map)\n{\n\treturn stack_map_use_build_id(map) ?\n\t\tsizeof(struct bpf_stack_build_id) : sizeof(u64);\n}"
  },
  {
    "function_name": "stack_map_use_build_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "53-56",
    "snippet": "static inline bool stack_map_use_build_id(struct bpf_map *map)\n{\n\treturn (map->map_flags & BPF_F_STACK_BUILD_ID);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic inline bool stack_map_use_build_id(struct bpf_map *map)\n{\n\treturn (map->map_flags & BPF_F_STACK_BUILD_ID);\n}"
  },
  {
    "function_name": "do_up_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
    "lines": "42-49",
    "snippet": "static void do_up_read(struct irq_work *entry)\n{\n\tstruct stack_map_irq_work *work;\n\n\twork = container_of(entry, struct stack_map_irq_work, irq_work);\n\tup_read(work->sem);\n\twork->sem = NULL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/irq_work.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/elf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "work->sem"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "do_up_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/stackmap.c",
          "lines": "42-49",
          "snippet": "static void do_up_read(struct irq_work *entry)\n{\n\tstruct stack_map_irq_work *work;\n\n\twork = container_of(entry, struct stack_map_irq_work, irq_work);\n\tup_read(work->sem);\n\twork->sem = NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "entry",
            "structstack_map_irq_work",
            "irq_work"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/irq_work.h>\n#include <linux/pagemap.h>\n#include <linux/elf.h>\n#include <linux/perf_event.h>\n#include <linux/stacktrace.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/bpf.h>\n\nstatic void do_up_read(struct irq_work *entry)\n{\n\tstruct stack_map_irq_work *work;\n\n\twork = container_of(entry, struct stack_map_irq_work, irq_work);\n\tup_read(work->sem);\n\twork->sem = NULL;\n}"
  }
]