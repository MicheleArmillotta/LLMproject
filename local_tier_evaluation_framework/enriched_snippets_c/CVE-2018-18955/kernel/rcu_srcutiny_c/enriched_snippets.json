[
  {
    "function_name": "srcu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
    "lines": "220-231",
    "snippet": "void __init srcu_init(void)\n{\n\tstruct srcu_struct *sp;\n\n\tsrcu_init_done = true;\n\twhile (!list_empty(&srcu_boot_list)) {\n\t\tsp = list_first_entry(&srcu_boot_list,\n\t\t\t\t      struct srcu_struct, srcu_work.entry);\n\t\tlist_del_init(&sp->srcu_work.entry);\n\t\tschedule_work(&sp->srcu_work);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include \"rcu_segcblist.h\"",
      "#include <linux/rcu_node_tree.h>",
      "#include <linux/srcu.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(srcu_boot_list);",
      "static bool srcu_init_done;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&sp->srcu_work"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sp->srcu_work.entry"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&srcu_boot_list",
            "structsrcu_struct",
            "srcu_work.entry"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&srcu_boot_list"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(srcu_boot_list);\nstatic bool srcu_init_done;\n\nvoid __init srcu_init(void)\n{\n\tstruct srcu_struct *sp;\n\n\tsrcu_init_done = true;\n\twhile (!list_empty(&srcu_boot_list)) {\n\t\tsp = list_first_entry(&srcu_boot_list,\n\t\t\t\t      struct srcu_struct, srcu_work.entry);\n\t\tlist_del_init(&sp->srcu_work.entry);\n\t\tschedule_work(&sp->srcu_work);\n\t}\n}"
  },
  {
    "function_name": "rcu_scheduler_starting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
    "lines": "210-213",
    "snippet": "void __init rcu_scheduler_starting(void)\n{\n\trcu_scheduler_active = RCU_SCHEDULER_RUNNING;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include \"rcu_segcblist.h\"",
      "#include <linux/rcu_node_tree.h>",
      "#include <linux/srcu.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int rcu_scheduler_active"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint rcu_scheduler_active;\n\nvoid __init rcu_scheduler_starting(void)\n{\n\trcu_scheduler_active = RCU_SCHEDULER_RUNNING;\n}"
  },
  {
    "function_name": "synchronize_srcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
    "lines": "197-206",
    "snippet": "void synchronize_srcu(struct srcu_struct *sp)\n{\n\tstruct rcu_synchronize rs;\n\n\tinit_rcu_head_on_stack(&rs.head);\n\tinit_completion(&rs.completion);\n\tcall_srcu(sp, &rs.head, wakeme_after_rcu);\n\twait_for_completion(&rs.completion);\n\tdestroy_rcu_head_on_stack(&rs.head);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include \"rcu_segcblist.h\"",
      "#include <linux/rcu_node_tree.h>",
      "#include <linux/srcu.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_rcu_head_on_stack",
          "args": [
            "&rs.head"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "413-416",
          "snippet": "void destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&rs.completion"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_srcu",
          "args": [
            "sp",
            "&rs.head",
            "wakeme_after_rcu"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "call_srcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
          "lines": "174-191",
          "snippet": "void call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\tunsigned long flags;\n\n\trhp->func = func;\n\trhp->next = NULL;\n\tlocal_irq_save(flags);\n\t*sp->srcu_cb_tail = rhp;\n\tsp->srcu_cb_tail = &rhp->next;\n\tlocal_irq_restore(flags);\n\tif (!READ_ONCE(sp->srcu_gp_running)) {\n\t\tif (likely(srcu_init_done))\n\t\t\tschedule_work(&sp->srcu_work);\n\t\telse if (list_empty(&sp->srcu_work.entry))\n\t\t\tlist_add(&sp->srcu_work.entry, &srcu_boot_list);\n\t}\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcu_node_tree.h>",
            "#include <linux/srcu.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(srcu_boot_list);",
            "static bool srcu_init_done;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(srcu_boot_list);\nstatic bool srcu_init_done;\n\nvoid call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\tunsigned long flags;\n\n\trhp->func = func;\n\trhp->next = NULL;\n\tlocal_irq_save(flags);\n\t*sp->srcu_cb_tail = rhp;\n\tsp->srcu_cb_tail = &rhp->next;\n\tlocal_irq_restore(flags);\n\tif (!READ_ONCE(sp->srcu_gp_running)) {\n\t\tif (likely(srcu_init_done))\n\t\t\tschedule_work(&sp->srcu_work);\n\t\telse if (list_empty(&sp->srcu_work.entry))\n\t\t\tlist_add(&sp->srcu_work.entry, &srcu_boot_list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&rs.completion"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rcu_head_on_stack",
          "args": [
            "&rs.head"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "396-399",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu(struct srcu_struct *sp)\n{\n\tstruct rcu_synchronize rs;\n\n\tinit_rcu_head_on_stack(&rs.head);\n\tinit_completion(&rs.completion);\n\tcall_srcu(sp, &rs.head, wakeme_after_rcu);\n\twait_for_completion(&rs.completion);\n\tdestroy_rcu_head_on_stack(&rs.head);\n}"
  },
  {
    "function_name": "call_srcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
    "lines": "174-191",
    "snippet": "void call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\tunsigned long flags;\n\n\trhp->func = func;\n\trhp->next = NULL;\n\tlocal_irq_save(flags);\n\t*sp->srcu_cb_tail = rhp;\n\tsp->srcu_cb_tail = &rhp->next;\n\tlocal_irq_restore(flags);\n\tif (!READ_ONCE(sp->srcu_gp_running)) {\n\t\tif (likely(srcu_init_done))\n\t\t\tschedule_work(&sp->srcu_work);\n\t\telse if (list_empty(&sp->srcu_work.entry))\n\t\t\tlist_add(&sp->srcu_work.entry, &srcu_boot_list);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include \"rcu_segcblist.h\"",
      "#include <linux/rcu_node_tree.h>",
      "#include <linux/srcu.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(srcu_boot_list);",
      "static bool srcu_init_done;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&sp->srcu_work.entry",
            "&srcu_boot_list"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sp->srcu_work.entry"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&sp->srcu_work"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "srcu_init_done"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_running"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(srcu_boot_list);\nstatic bool srcu_init_done;\n\nvoid call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\tunsigned long flags;\n\n\trhp->func = func;\n\trhp->next = NULL;\n\tlocal_irq_save(flags);\n\t*sp->srcu_cb_tail = rhp;\n\tsp->srcu_cb_tail = &rhp->next;\n\tlocal_irq_restore(flags);\n\tif (!READ_ONCE(sp->srcu_gp_running)) {\n\t\tif (likely(srcu_init_done))\n\t\t\tschedule_work(&sp->srcu_work);\n\t\telse if (list_empty(&sp->srcu_work.entry))\n\t\t\tlist_add(&sp->srcu_work.entry, &srcu_boot_list);\n\t}\n}"
  },
  {
    "function_name": "srcu_drive_gp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
    "lines": "125-167",
    "snippet": "void srcu_drive_gp(struct work_struct *wp)\n{\n\tint idx;\n\tstruct rcu_head *lh;\n\tstruct rcu_head *rhp;\n\tstruct srcu_struct *sp;\n\n\tsp = container_of(wp, struct srcu_struct, srcu_work);\n\tif (sp->srcu_gp_running || !READ_ONCE(sp->srcu_cb_head))\n\t\treturn; /* Already running or nothing to do. */\n\n\t/* Remove recently arrived callbacks and wait for readers. */\n\tWRITE_ONCE(sp->srcu_gp_running, true);\n\tlocal_irq_disable();\n\tlh = sp->srcu_cb_head;\n\tsp->srcu_cb_head = NULL;\n\tsp->srcu_cb_tail = &sp->srcu_cb_head;\n\tlocal_irq_enable();\n\tidx = sp->srcu_idx;\n\tWRITE_ONCE(sp->srcu_idx, !sp->srcu_idx);\n\tWRITE_ONCE(sp->srcu_gp_waiting, true);  /* srcu_read_unlock() wakes! */\n\tswait_event_exclusive(sp->srcu_wq, !READ_ONCE(sp->srcu_lock_nesting[idx]));\n\tWRITE_ONCE(sp->srcu_gp_waiting, false); /* srcu_read_unlock() cheap. */\n\n\t/* Invoke the callbacks we removed above. */\n\twhile (lh) {\n\t\trhp = lh;\n\t\tlh = lh->next;\n\t\tlocal_bh_disable();\n\t\trhp->func(rhp);\n\t\tlocal_bh_enable();\n\t}\n\n\t/*\n\t * Enable rescheduling, and if there are more callbacks,\n\t * reschedule ourselves.  This can race with a call_srcu()\n\t * at interrupt level, but the ->srcu_gp_running checks will\n\t * straighten that out.\n\t */\n\tWRITE_ONCE(sp->srcu_gp_running, false);\n\tif (READ_ONCE(sp->srcu_cb_head))\n\t\tschedule_work(&sp->srcu_work);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include \"rcu_segcblist.h\"",
      "#include <linux/rcu_node_tree.h>",
      "#include <linux/srcu.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&sp->srcu_work"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_cb_head"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sp->srcu_gp_running",
            "false"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "159-163",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rhp->func",
          "args": [
            "rhp"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sp->srcu_gp_waiting",
            "false"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_event_exclusive",
          "args": [
            "sp->srcu_wq",
            "!READ_ONCE(sp->srcu_lock_nesting[idx])"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_lock_nesting[idx]"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sp->srcu_gp_waiting",
            "true"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sp->srcu_idx",
            "!sp->srcu_idx"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sp->srcu_gp_running",
            "true"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_cb_head"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wp",
            "structsrcu_struct",
            "srcu_work"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcu_drive_gp(struct work_struct *wp)\n{\n\tint idx;\n\tstruct rcu_head *lh;\n\tstruct rcu_head *rhp;\n\tstruct srcu_struct *sp;\n\n\tsp = container_of(wp, struct srcu_struct, srcu_work);\n\tif (sp->srcu_gp_running || !READ_ONCE(sp->srcu_cb_head))\n\t\treturn; /* Already running or nothing to do. */\n\n\t/* Remove recently arrived callbacks and wait for readers. */\n\tWRITE_ONCE(sp->srcu_gp_running, true);\n\tlocal_irq_disable();\n\tlh = sp->srcu_cb_head;\n\tsp->srcu_cb_head = NULL;\n\tsp->srcu_cb_tail = &sp->srcu_cb_head;\n\tlocal_irq_enable();\n\tidx = sp->srcu_idx;\n\tWRITE_ONCE(sp->srcu_idx, !sp->srcu_idx);\n\tWRITE_ONCE(sp->srcu_gp_waiting, true);  /* srcu_read_unlock() wakes! */\n\tswait_event_exclusive(sp->srcu_wq, !READ_ONCE(sp->srcu_lock_nesting[idx]));\n\tWRITE_ONCE(sp->srcu_gp_waiting, false); /* srcu_read_unlock() cheap. */\n\n\t/* Invoke the callbacks we removed above. */\n\twhile (lh) {\n\t\trhp = lh;\n\t\tlh = lh->next;\n\t\tlocal_bh_disable();\n\t\trhp->func(rhp);\n\t\tlocal_bh_enable();\n\t}\n\n\t/*\n\t * Enable rescheduling, and if there are more callbacks,\n\t * reschedule ourselves.  This can race with a call_srcu()\n\t * at interrupt level, but the ->srcu_gp_running checks will\n\t * straighten that out.\n\t */\n\tWRITE_ONCE(sp->srcu_gp_running, false);\n\tif (READ_ONCE(sp->srcu_cb_head))\n\t\tschedule_work(&sp->srcu_work);\n}"
  },
  {
    "function_name": "__srcu_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
    "lines": "110-117",
    "snippet": "void __srcu_read_unlock(struct srcu_struct *sp, int idx)\n{\n\tint newval = sp->srcu_lock_nesting[idx] - 1;\n\n\tWRITE_ONCE(sp->srcu_lock_nesting[idx], newval);\n\tif (!newval && READ_ONCE(sp->srcu_gp_waiting))\n\t\tswake_up_one(&sp->srcu_wq);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include \"rcu_segcblist.h\"",
      "#include <linux/rcu_node_tree.h>",
      "#include <linux/srcu.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swake_up_one",
          "args": [
            "&sp->srcu_wq"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/swait.c",
          "lines": "35-42",
          "snippet": "void swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sp->srcu_gp_waiting"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "sp->srcu_lock_nesting[idx]",
            "newval"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __srcu_read_unlock(struct srcu_struct *sp, int idx)\n{\n\tint newval = sp->srcu_lock_nesting[idx] - 1;\n\n\tWRITE_ONCE(sp->srcu_lock_nesting[idx], newval);\n\tif (!newval && READ_ONCE(sp->srcu_gp_waiting))\n\t\tswake_up_one(&sp->srcu_wq);\n}"
  },
  {
    "function_name": "_cleanup_srcu_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
    "lines": "92-103",
    "snippet": "void _cleanup_srcu_struct(struct srcu_struct *sp, bool quiesced)\n{\n\tWARN_ON(sp->srcu_lock_nesting[0] || sp->srcu_lock_nesting[1]);\n\tif (quiesced)\n\t\tWARN_ON(work_pending(&sp->srcu_work));\n\telse\n\t\tflush_work(&sp->srcu_work);\n\tWARN_ON(sp->srcu_gp_running);\n\tWARN_ON(sp->srcu_gp_waiting);\n\tWARN_ON(sp->srcu_cb_head);\n\tWARN_ON(&sp->srcu_cb_head != sp->srcu_cb_tail);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include \"rcu_segcblist.h\"",
      "#include <linux/rcu_node_tree.h>",
      "#include <linux/srcu.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "&sp->srcu_cb_head != sp->srcu_cb_tail"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sp->srcu_cb_head"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sp->srcu_gp_waiting"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sp->srcu_gp_running"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&sp->srcu_work"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2936-2939",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "work_pending(&sp->srcu_work)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_pending",
          "args": [
            "&sp->srcu_work"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sp->srcu_lock_nesting[0] || sp->srcu_lock_nesting[1]"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid _cleanup_srcu_struct(struct srcu_struct *sp, bool quiesced)\n{\n\tWARN_ON(sp->srcu_lock_nesting[0] || sp->srcu_lock_nesting[1]);\n\tif (quiesced)\n\t\tWARN_ON(work_pending(&sp->srcu_work));\n\telse\n\t\tflush_work(&sp->srcu_work);\n\tWARN_ON(sp->srcu_gp_running);\n\tWARN_ON(sp->srcu_gp_waiting);\n\tWARN_ON(sp->srcu_cb_head);\n\tWARN_ON(&sp->srcu_cb_head != sp->srcu_cb_tail);\n}"
  },
  {
    "function_name": "init_srcu_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
    "lines": "77-80",
    "snippet": "int init_srcu_struct(struct srcu_struct *sp)\n{\n\treturn init_srcu_struct_fields(sp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include \"rcu_segcblist.h\"",
      "#include <linux/rcu_node_tree.h>",
      "#include <linux/srcu.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_srcu_struct_fields",
          "args": [
            "sp"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "init_srcu_struct_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
          "lines": "40-53",
          "snippet": "static int init_srcu_struct_fields(struct srcu_struct *sp)\n{\n\tsp->srcu_lock_nesting[0] = 0;\n\tsp->srcu_lock_nesting[1] = 0;\n\tinit_swait_queue_head(&sp->srcu_wq);\n\tsp->srcu_cb_head = NULL;\n\tsp->srcu_cb_tail = &sp->srcu_cb_head;\n\tsp->srcu_gp_running = false;\n\tsp->srcu_gp_waiting = false;\n\tsp->srcu_idx = 0;\n\tINIT_WORK(&sp->srcu_work, srcu_drive_gp);\n\tINIT_LIST_HEAD(&sp->srcu_work.entry);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcu_node_tree.h>",
            "#include <linux/srcu.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic int init_srcu_struct_fields(struct srcu_struct *sp)\n{\n\tsp->srcu_lock_nesting[0] = 0;\n\tsp->srcu_lock_nesting[1] = 0;\n\tinit_swait_queue_head(&sp->srcu_wq);\n\tsp->srcu_cb_head = NULL;\n\tsp->srcu_cb_tail = &sp->srcu_cb_head;\n\tsp->srcu_gp_running = false;\n\tsp->srcu_gp_waiting = false;\n\tsp->srcu_idx = 0;\n\tINIT_WORK(&sp->srcu_work, srcu_drive_gp);\n\tINIT_LIST_HEAD(&sp->srcu_work.entry);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint init_srcu_struct(struct srcu_struct *sp)\n{\n\treturn init_srcu_struct_fields(sp);\n}"
  },
  {
    "function_name": "__init_srcu_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
    "lines": "57-64",
    "snippet": "int __init_srcu_struct(struct srcu_struct *sp, const char *name,\n\t\t       struct lock_class_key *key)\n{\n\t/* Don't re-initialize a lock while it is held. */\n\tdebug_check_no_locks_freed((void *)sp, sizeof(*sp));\n\tlockdep_init_map(&sp->dep_map, name, key, 0);\n\treturn init_srcu_struct_fields(sp);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include \"rcu_segcblist.h\"",
      "#include <linux/rcu_node_tree.h>",
      "#include <linux/srcu.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_srcu_struct_fields",
          "args": [
            "sp"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "init_srcu_struct_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
          "lines": "40-53",
          "snippet": "static int init_srcu_struct_fields(struct srcu_struct *sp)\n{\n\tsp->srcu_lock_nesting[0] = 0;\n\tsp->srcu_lock_nesting[1] = 0;\n\tinit_swait_queue_head(&sp->srcu_wq);\n\tsp->srcu_cb_head = NULL;\n\tsp->srcu_cb_tail = &sp->srcu_cb_head;\n\tsp->srcu_gp_running = false;\n\tsp->srcu_gp_waiting = false;\n\tsp->srcu_idx = 0;\n\tINIT_WORK(&sp->srcu_work, srcu_drive_gp);\n\tINIT_LIST_HEAD(&sp->srcu_work.entry);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include \"rcu_segcblist.h\"",
            "#include <linux/rcu_node_tree.h>",
            "#include <linux/srcu.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic int init_srcu_struct_fields(struct srcu_struct *sp)\n{\n\tsp->srcu_lock_nesting[0] = 0;\n\tsp->srcu_lock_nesting[1] = 0;\n\tinit_swait_queue_head(&sp->srcu_wq);\n\tsp->srcu_cb_head = NULL;\n\tsp->srcu_cb_tail = &sp->srcu_cb_head;\n\tsp->srcu_gp_running = false;\n\tsp->srcu_gp_waiting = false;\n\tsp->srcu_idx = 0;\n\tINIT_WORK(&sp->srcu_work, srcu_drive_gp);\n\tINIT_LIST_HEAD(&sp->srcu_work.entry);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&sp->dep_map",
            "name",
            "key",
            "0"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_init_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3148-3152",
          "snippet": "void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)sp",
            "sizeof(*sp)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4322-4344",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __init_srcu_struct(struct srcu_struct *sp, const char *name,\n\t\t       struct lock_class_key *key)\n{\n\t/* Don't re-initialize a lock while it is held. */\n\tdebug_check_no_locks_freed((void *)sp, sizeof(*sp));\n\tlockdep_init_map(&sp->dep_map, name, key, 0);\n\treturn init_srcu_struct_fields(sp);\n}"
  },
  {
    "function_name": "init_srcu_struct_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutiny.c",
    "lines": "40-53",
    "snippet": "static int init_srcu_struct_fields(struct srcu_struct *sp)\n{\n\tsp->srcu_lock_nesting[0] = 0;\n\tsp->srcu_lock_nesting[1] = 0;\n\tinit_swait_queue_head(&sp->srcu_wq);\n\tsp->srcu_cb_head = NULL;\n\tsp->srcu_cb_tail = &sp->srcu_cb_head;\n\tsp->srcu_gp_running = false;\n\tsp->srcu_gp_waiting = false;\n\tsp->srcu_idx = 0;\n\tINIT_WORK(&sp->srcu_work, srcu_drive_gp);\n\tINIT_LIST_HEAD(&sp->srcu_work.entry);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include \"rcu_segcblist.h\"",
      "#include <linux/rcu_node_tree.h>",
      "#include <linux/srcu.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sp->srcu_work.entry"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&sp->srcu_work",
            "srcu_drive_gp"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_swait_queue_head",
          "args": [
            "&sp->srcu_wq"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include \"rcu_segcblist.h\"\n#include <linux/rcu_node_tree.h>\n#include <linux/srcu.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic int init_srcu_struct_fields(struct srcu_struct *sp)\n{\n\tsp->srcu_lock_nesting[0] = 0;\n\tsp->srcu_lock_nesting[1] = 0;\n\tinit_swait_queue_head(&sp->srcu_wq);\n\tsp->srcu_cb_head = NULL;\n\tsp->srcu_cb_tail = &sp->srcu_cb_head;\n\tsp->srcu_gp_running = false;\n\tsp->srcu_gp_waiting = false;\n\tsp->srcu_idx = 0;\n\tINIT_WORK(&sp->srcu_work, srcu_drive_gp);\n\tINIT_LIST_HEAD(&sp->srcu_work.entry);\n\treturn 0;\n}"
  }
]