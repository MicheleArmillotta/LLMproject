[
  {
    "function_name": "snapshot_device_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/user.c",
    "lines": "480-483",
    "snippet": "static int __init snapshot_device_init(void)\n{\n\treturn misc_register(&snapshot_device);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct miscdevice snapshot_device = {\n\t.minor = SNAPSHOT_MINOR,\n\t.name = \"snapshot\",\n\t.fops = &snapshot_fops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&snapshot_device"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n\nstatic struct miscdevice snapshot_device = {\n\t.minor = SNAPSHOT_MINOR,\n\t.name = \"snapshot\",\n\t.fops = &snapshot_fops,\n};\n\nstatic int __init snapshot_device_init(void)\n{\n\treturn misc_register(&snapshot_device);\n}"
  },
  {
    "function_name": "snapshot_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/user.c",
    "lines": "409-458",
    "snippet": "static long\nsnapshot_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tBUILD_BUG_ON(sizeof(loff_t) != sizeof(compat_loff_t));\n\n\tswitch (cmd) {\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE: {\n\t\tcompat_loff_t __user *uoffset = compat_ptr(arg);\n\t\tloff_t offset;\n\t\tmm_segment_t old_fs;\n\t\tint err;\n\n\t\told_fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = snapshot_ioctl(file, cmd, (unsigned long) &offset);\n\t\tset_fs(old_fs);\n\t\tif (!err && put_user(offset, uoffset))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\t}\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\treturn snapshot_ioctl(file, cmd,\n\t\t\t\t      (unsigned long) compat_ptr(arg));\n\n\tcase SNAPSHOT_SET_SWAP_AREA: {\n\t\tstruct compat_resume_swap_area __user *u_swap_area =\n\t\t\tcompat_ptr(arg);\n\t\tstruct resume_swap_area swap_area;\n\t\tmm_segment_t old_fs;\n\t\tint err;\n\n\t\terr = get_user(swap_area.offset, &u_swap_area->offset);\n\t\terr |= get_user(swap_area.dev, &u_swap_area->dev);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t\told_fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = snapshot_ioctl(file, SNAPSHOT_SET_SWAP_AREA,\n\t\t\t\t     (unsigned long) &swap_area);\n\t\tset_fs(old_fs);\n\t\treturn err;\n\t}\n\n\tdefault:\n\t\treturn snapshot_ioctl(file, cmd, arg);\n\t}\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snapshot_ioctl",
          "args": [
            "file",
            "cmd",
            "arg"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/user.c",
          "lines": "204-400",
          "snippet": "static long snapshot_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint error = 0;\n\tstruct snapshot_data *data;\n\tloff_t size;\n\tsector_t offset;\n\n\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\n\t\treturn -ENOTTY;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!mutex_trylock(&system_transition_mutex))\n\t\treturn -EBUSY;\n\n\tlock_device_hotplug();\n\tdata = filp->private_data;\n\n\tswitch (cmd) {\n\n\tcase SNAPSHOT_FREEZE:\n\t\tif (data->frozen)\n\t\t\tbreak;\n\n\t\tprintk(\"Syncing filesystems ... \");\n\t\tksys_sync();\n\t\tprintk(\"done.\\n\");\n\n\t\terror = freeze_processes();\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = create_basic_memory_bitmaps();\n\t\tif (error)\n\t\t\tthaw_processes();\n\t\telse\n\t\t\tdata->frozen = true;\n\n\t\tbreak;\n\n\tcase SNAPSHOT_UNFREEZE:\n\t\tif (!data->frozen || data->ready)\n\t\t\tbreak;\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tdata->free_bitmaps = false;\n\t\tthaw_processes();\n\t\tdata->frozen = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tpm_restore_gfp_mask();\n\t\terror = hibernation_snapshot(data->platform_support);\n\t\tif (!error) {\n\t\t\terror = put_user(in_suspend, (int __user *)arg);\n\t\t\tdata->ready = !freezer_test_done && !error;\n\t\t\tfreezer_test_done = false;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_ATOMIC_RESTORE:\n\t\tsnapshot_write_finalize(&data->handle);\n\t\tif (data->mode != O_WRONLY || !data->frozen ||\n\t\t    !snapshot_image_loaded(&data->handle)) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terror = hibernation_restore(data->platform_support);\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE:\n\t\tswsusp_free();\n\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\t\tdata->ready = false;\n\t\t/*\n\t\t * It is necessary to thaw kernel threads here, because\n\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after\n\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not\n\t\t * thawed, the preallocation of memory carried out by\n\t\t * hibernation_snapshot() might run into problems (i.e. it\n\t\t * might fail or even deadlock).\n\t\t */\n\t\tthaw_kernel_threads();\n\t\tbreak;\n\n\tcase SNAPSHOT_PREF_IMAGE_SIZE:\n\t\timage_size = arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\t\tif (!data->ready) {\n\t\t\terror = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\tsize = snapshot_get_image_size();\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\t\tsize = count_swap_pages(data->swap, 1);\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\toffset = alloc_swapdev_block(data->swap);\n\t\tif (offset) {\n\t\t\toffset <<= PAGE_SHIFT;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -ENOSPC;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE_SWAP_PAGES:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tfree_all_swap_pages(data->swap);\n\t\tbreak;\n\n\tcase SNAPSHOT_S2RAM:\n\t\tif (!data->frozen) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Tasks are frozen and the notifiers have been called with\n\t\t * PM_HIBERNATION_PREPARE\n\t\t */\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tdata->ready = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_PLATFORM_SUPPORT:\n\t\tdata->platform_support = !!arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_POWER_OFF:\n\t\tif (data->platform_support)\n\t\t\terror = hibernation_platform_enter();\n\t\tbreak;\n\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\tif (swsusp_swap_in_use()) {\n\t\t\terror = -EPERM;\n\t\t} else {\n\t\t\tstruct resume_swap_area swap_area;\n\t\t\tdev_t swdev;\n\n\t\t\terror = copy_from_user(&swap_area, (void __user *)arg,\n\t\t\t\t\tsizeof(struct resume_swap_area));\n\t\t\tif (error) {\n\t\t\t\terror = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * User space encodes device types as two-byte values,\n\t\t\t * so we need to recode them\n\t\t\t */\n\t\t\tswdev = new_decode_dev(swap_area.dev);\n\t\t\tif (swdev) {\n\t\t\t\toffset = swap_area.offset;\n\t\t\t\tdata->swap = swap_type_of(swdev, offset, NULL);\n\t\t\t\tif (data->swap < 0)\n\t\t\t\t\terror = -ENODEV;\n\t\t\t} else {\n\t\t\t\tdata->swap = -1;\n\t\t\t\terror = -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENOTTY;\n\n\t}\n\n\tunlock_device_hotplug();\n\tmutex_unlock(&system_transition_mutex);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n\nstatic long snapshot_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint error = 0;\n\tstruct snapshot_data *data;\n\tloff_t size;\n\tsector_t offset;\n\n\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\n\t\treturn -ENOTTY;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!mutex_trylock(&system_transition_mutex))\n\t\treturn -EBUSY;\n\n\tlock_device_hotplug();\n\tdata = filp->private_data;\n\n\tswitch (cmd) {\n\n\tcase SNAPSHOT_FREEZE:\n\t\tif (data->frozen)\n\t\t\tbreak;\n\n\t\tprintk(\"Syncing filesystems ... \");\n\t\tksys_sync();\n\t\tprintk(\"done.\\n\");\n\n\t\terror = freeze_processes();\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = create_basic_memory_bitmaps();\n\t\tif (error)\n\t\t\tthaw_processes();\n\t\telse\n\t\t\tdata->frozen = true;\n\n\t\tbreak;\n\n\tcase SNAPSHOT_UNFREEZE:\n\t\tif (!data->frozen || data->ready)\n\t\t\tbreak;\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tdata->free_bitmaps = false;\n\t\tthaw_processes();\n\t\tdata->frozen = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tpm_restore_gfp_mask();\n\t\terror = hibernation_snapshot(data->platform_support);\n\t\tif (!error) {\n\t\t\terror = put_user(in_suspend, (int __user *)arg);\n\t\t\tdata->ready = !freezer_test_done && !error;\n\t\t\tfreezer_test_done = false;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_ATOMIC_RESTORE:\n\t\tsnapshot_write_finalize(&data->handle);\n\t\tif (data->mode != O_WRONLY || !data->frozen ||\n\t\t    !snapshot_image_loaded(&data->handle)) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terror = hibernation_restore(data->platform_support);\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE:\n\t\tswsusp_free();\n\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\t\tdata->ready = false;\n\t\t/*\n\t\t * It is necessary to thaw kernel threads here, because\n\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after\n\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not\n\t\t * thawed, the preallocation of memory carried out by\n\t\t * hibernation_snapshot() might run into problems (i.e. it\n\t\t * might fail or even deadlock).\n\t\t */\n\t\tthaw_kernel_threads();\n\t\tbreak;\n\n\tcase SNAPSHOT_PREF_IMAGE_SIZE:\n\t\timage_size = arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\t\tif (!data->ready) {\n\t\t\terror = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\tsize = snapshot_get_image_size();\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\t\tsize = count_swap_pages(data->swap, 1);\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\toffset = alloc_swapdev_block(data->swap);\n\t\tif (offset) {\n\t\t\toffset <<= PAGE_SHIFT;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -ENOSPC;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE_SWAP_PAGES:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tfree_all_swap_pages(data->swap);\n\t\tbreak;\n\n\tcase SNAPSHOT_S2RAM:\n\t\tif (!data->frozen) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Tasks are frozen and the notifiers have been called with\n\t\t * PM_HIBERNATION_PREPARE\n\t\t */\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tdata->ready = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_PLATFORM_SUPPORT:\n\t\tdata->platform_support = !!arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_POWER_OFF:\n\t\tif (data->platform_support)\n\t\t\terror = hibernation_platform_enter();\n\t\tbreak;\n\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\tif (swsusp_swap_in_use()) {\n\t\t\terror = -EPERM;\n\t\t} else {\n\t\t\tstruct resume_swap_area swap_area;\n\t\t\tdev_t swdev;\n\n\t\t\terror = copy_from_user(&swap_area, (void __user *)arg,\n\t\t\t\t\tsizeof(struct resume_swap_area));\n\t\t\tif (error) {\n\t\t\t\terror = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * User space encodes device types as two-byte values,\n\t\t\t * so we need to recode them\n\t\t\t */\n\t\t\tswdev = new_decode_dev(swap_area.dev);\n\t\t\tif (swdev) {\n\t\t\t\toffset = swap_area.offset;\n\t\t\t\tdata->swap = swap_type_of(swdev, offset, NULL);\n\t\t\t\tif (data->swap < 0)\n\t\t\t\t\terror = -ENODEV;\n\t\t\t} else {\n\t\t\t\tdata->swap = -1;\n\t\t\t\terror = -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENOTTY;\n\n\t}\n\n\tunlock_device_hotplug();\n\tmutex_unlock(&system_transition_mutex);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "swap_area.dev",
            "&u_swap_area->dev"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "offset",
            "uoffset"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(loff_t) != sizeof(compat_loff_t)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n\nstatic long\nsnapshot_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tBUILD_BUG_ON(sizeof(loff_t) != sizeof(compat_loff_t));\n\n\tswitch (cmd) {\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE: {\n\t\tcompat_loff_t __user *uoffset = compat_ptr(arg);\n\t\tloff_t offset;\n\t\tmm_segment_t old_fs;\n\t\tint err;\n\n\t\told_fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = snapshot_ioctl(file, cmd, (unsigned long) &offset);\n\t\tset_fs(old_fs);\n\t\tif (!err && put_user(offset, uoffset))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\t}\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\treturn snapshot_ioctl(file, cmd,\n\t\t\t\t      (unsigned long) compat_ptr(arg));\n\n\tcase SNAPSHOT_SET_SWAP_AREA: {\n\t\tstruct compat_resume_swap_area __user *u_swap_area =\n\t\t\tcompat_ptr(arg);\n\t\tstruct resume_swap_area swap_area;\n\t\tmm_segment_t old_fs;\n\t\tint err;\n\n\t\terr = get_user(swap_area.offset, &u_swap_area->offset);\n\t\terr |= get_user(swap_area.dev, &u_swap_area->dev);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t\told_fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = snapshot_ioctl(file, SNAPSHOT_SET_SWAP_AREA,\n\t\t\t\t     (unsigned long) &swap_area);\n\t\tset_fs(old_fs);\n\t\treturn err;\n\t}\n\n\tdefault:\n\t\treturn snapshot_ioctl(file, cmd, arg);\n\t}\n}"
  },
  {
    "function_name": "snapshot_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/user.c",
    "lines": "204-400",
    "snippet": "static long snapshot_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint error = 0;\n\tstruct snapshot_data *data;\n\tloff_t size;\n\tsector_t offset;\n\n\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\n\t\treturn -ENOTTY;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!mutex_trylock(&system_transition_mutex))\n\t\treturn -EBUSY;\n\n\tlock_device_hotplug();\n\tdata = filp->private_data;\n\n\tswitch (cmd) {\n\n\tcase SNAPSHOT_FREEZE:\n\t\tif (data->frozen)\n\t\t\tbreak;\n\n\t\tprintk(\"Syncing filesystems ... \");\n\t\tksys_sync();\n\t\tprintk(\"done.\\n\");\n\n\t\terror = freeze_processes();\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = create_basic_memory_bitmaps();\n\t\tif (error)\n\t\t\tthaw_processes();\n\t\telse\n\t\t\tdata->frozen = true;\n\n\t\tbreak;\n\n\tcase SNAPSHOT_UNFREEZE:\n\t\tif (!data->frozen || data->ready)\n\t\t\tbreak;\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tdata->free_bitmaps = false;\n\t\tthaw_processes();\n\t\tdata->frozen = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tpm_restore_gfp_mask();\n\t\terror = hibernation_snapshot(data->platform_support);\n\t\tif (!error) {\n\t\t\terror = put_user(in_suspend, (int __user *)arg);\n\t\t\tdata->ready = !freezer_test_done && !error;\n\t\t\tfreezer_test_done = false;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_ATOMIC_RESTORE:\n\t\tsnapshot_write_finalize(&data->handle);\n\t\tif (data->mode != O_WRONLY || !data->frozen ||\n\t\t    !snapshot_image_loaded(&data->handle)) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terror = hibernation_restore(data->platform_support);\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE:\n\t\tswsusp_free();\n\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\t\tdata->ready = false;\n\t\t/*\n\t\t * It is necessary to thaw kernel threads here, because\n\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after\n\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not\n\t\t * thawed, the preallocation of memory carried out by\n\t\t * hibernation_snapshot() might run into problems (i.e. it\n\t\t * might fail or even deadlock).\n\t\t */\n\t\tthaw_kernel_threads();\n\t\tbreak;\n\n\tcase SNAPSHOT_PREF_IMAGE_SIZE:\n\t\timage_size = arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\t\tif (!data->ready) {\n\t\t\terror = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\tsize = snapshot_get_image_size();\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\t\tsize = count_swap_pages(data->swap, 1);\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\toffset = alloc_swapdev_block(data->swap);\n\t\tif (offset) {\n\t\t\toffset <<= PAGE_SHIFT;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -ENOSPC;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE_SWAP_PAGES:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tfree_all_swap_pages(data->swap);\n\t\tbreak;\n\n\tcase SNAPSHOT_S2RAM:\n\t\tif (!data->frozen) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Tasks are frozen and the notifiers have been called with\n\t\t * PM_HIBERNATION_PREPARE\n\t\t */\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tdata->ready = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_PLATFORM_SUPPORT:\n\t\tdata->platform_support = !!arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_POWER_OFF:\n\t\tif (data->platform_support)\n\t\t\terror = hibernation_platform_enter();\n\t\tbreak;\n\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\tif (swsusp_swap_in_use()) {\n\t\t\terror = -EPERM;\n\t\t} else {\n\t\t\tstruct resume_swap_area swap_area;\n\t\t\tdev_t swdev;\n\n\t\t\terror = copy_from_user(&swap_area, (void __user *)arg,\n\t\t\t\t\tsizeof(struct resume_swap_area));\n\t\t\tif (error) {\n\t\t\t\terror = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * User space encodes device types as two-byte values,\n\t\t\t * so we need to recode them\n\t\t\t */\n\t\t\tswdev = new_decode_dev(swap_area.dev);\n\t\t\tif (swdev) {\n\t\t\t\toffset = swap_area.offset;\n\t\t\t\tdata->swap = swap_type_of(swdev, offset, NULL);\n\t\t\t\tif (data->swap < 0)\n\t\t\t\t\terror = -ENODEV;\n\t\t\t} else {\n\t\t\t\tdata->swap = -1;\n\t\t\t\terror = -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENOTTY;\n\n\t}\n\n\tunlock_device_hotplug();\n\tmutex_unlock(&system_transition_mutex);\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_type_of",
          "args": [
            "swdev",
            "offset",
            "NULL"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "swap_area.dev"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&swap_area",
            "(void __user *)arg",
            "sizeof(struct resume_swap_area)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_swap_in_use",
          "args": [],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_swap_in_use",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "215-218",
          "snippet": "int swsusp_swap_in_use(void)\n{\n\treturn (swsusp_extents.rb_node != NULL);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nint swsusp_swap_in_use(void)\n{\n\treturn (swsusp_extents.rb_node != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_platform_enter",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_platform_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "534-605",
          "snippet": "int hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin();\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = disable_nonboot_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct platform_hibernation_ops *hibernation_ops;",
            "static bool entering_platform_hibernation;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\nstatic bool entering_platform_hibernation;\n\nint hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t/*\n\t * We have cancelled the power transition by running\n\t * hibernation_ops->finish() before saving the image, so we should let\n\t * the firmware know that we're going to enter the sleep state after all\n\t */\n\terror = hibernation_ops->begin();\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = disable_nonboot_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t/* We should never get here */\n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tenable_nonboot_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "suspend_devices_and_enter",
          "args": [
            "PM_SUSPEND_MEM"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_devices_and_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "198-201",
          "snippet": "static inline int suspend_devices_and_enter(suspend_state_t state)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_devices_and_enter(suspend_state_t state)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_all_swap_pages",
          "args": [
            "data->swap"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "free_all_swap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "198-213",
          "snippet": "void free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "offset",
            "(loff_t __user *)arg"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_swapdev_block",
          "args": [
            "data->swap"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_swapdev_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "178-190",
          "snippet": "sector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nsector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "size",
            "(loff_t __user *)arg"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_swap_pages",
          "args": [
            "data->swap",
            "1"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "size",
            "(loff_t __user *)arg"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_get_image_size",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_get_image_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2028-2031",
          "snippet": "unsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nunsigned long snapshot_get_image_size(void)\n{\n\treturn nr_copy_pages + nr_meta_pages + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_kernel_threads",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_kernel_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
          "lines": "227-245",
          "snippet": "void thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & (PF_KTHREAD | PF_WQ_WORKER))\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nvoid thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & (PF_KTHREAD | PF_WQ_WORKER))\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data->handle",
            "0",
            "sizeof(struct snapshot_handle)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1451-1494",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernation_restore",
          "args": [
            "data->platform_support"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "507-529",
          "snippet": "int hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nint hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t/*\n\t\t * The above should either succeed and jump to the new kernel,\n\t\t * or return with an error. Otherwise things are just\n\t\t * undefined, so let's be paranoid.\n\t\t */\n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_image_loaded",
          "args": [
            "&data->handle"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_image_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2669-2673",
          "snippet": "int snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\n\nint snapshot_image_loaded(struct snapshot_handle *handle)\n{\n\treturn !(!nr_copy_pages || !last_highmem_page_copied() ||\n\t\t\thandle->cur <= nr_meta_pages + nr_copy_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_write_finalize",
          "args": [
            "&data->handle"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_finalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2655-2667",
          "snippet": "void snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\t/* Restore page key for data page (s390 only). */\n\tpage_key_write(handle->buffer);\n\tpage_key_free();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\n\nvoid snapshot_write_finalize(struct snapshot_handle *handle)\n{\n\tcopy_last_highmem_page();\n\t/* Restore page key for data page (s390 only). */\n\tpage_key_write(handle->buffer);\n\tpage_key_free();\n\thibernate_restore_protect_page(handle->buffer);\n\t/* Do that only if we have loaded the image entirely */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages) {\n\t\tmemory_bm_recycle(&orig_bm);\n\t\tfree_highmem_data();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "in_suspend",
            "(int __user *)arg"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_snapshot",
          "args": [
            "data->platform_support"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "343-416",
          "snippet": "int hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool freezer_test_done;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nbool freezer_test_done;\n\nint hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t/* Preallocate image memory before shutting down devices. */\n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t/*\n\t\t * Indicate to the caller that we are returning due to a\n\t\t * successful freezer test.\n\t\t */\n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t/*\n\t * In the case that we call create_image() above, the control\n\t * returns here (1) after the image has been created or the\n\t * image creation has failed and (2) after a successful restore.\n\t */\n\n\t/* We may need to release the preallocated image pages here. */\n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_thaw_processes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "285-287",
          "snippet": "static inline void suspend_thaw_processes(void)\n{\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void suspend_thaw_processes(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_basic_memory_bitmaps",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "free_basic_memory_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1121-1138",
          "snippet": "void free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nvoid free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_basic_memory_bitmaps",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "create_basic_memory_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1071-1112",
          "snippet": "int create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n \tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n#define PG_ANY\t\t0\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nint create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n \tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeze_processes",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_freeze_processes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "280-283",
          "snippet": "static inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"done.\\n\""
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksys_sync",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1582-1594",
          "snippet": "int __sched rt_mutex_trylock(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(in_irq() || in_nmi() || in_serving_softirq()))\n\t\treturn 0;\n\n\tret = rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);\n\tif (ret)\n\t\tmutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_trylock(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(in_irq() || in_nmi() || in_serving_softirq()))\n\t\treturn 0;\n\n\tret = rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);\n\tif (ret)\n\t\tmutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_IOC_NR",
          "args": [
            "cmd"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_TYPE",
          "args": [
            "cmd"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n\nstatic long snapshot_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint error = 0;\n\tstruct snapshot_data *data;\n\tloff_t size;\n\tsector_t offset;\n\n\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\n\t\treturn -ENOTTY;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!mutex_trylock(&system_transition_mutex))\n\t\treturn -EBUSY;\n\n\tlock_device_hotplug();\n\tdata = filp->private_data;\n\n\tswitch (cmd) {\n\n\tcase SNAPSHOT_FREEZE:\n\t\tif (data->frozen)\n\t\t\tbreak;\n\n\t\tprintk(\"Syncing filesystems ... \");\n\t\tksys_sync();\n\t\tprintk(\"done.\\n\");\n\n\t\terror = freeze_processes();\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = create_basic_memory_bitmaps();\n\t\tif (error)\n\t\t\tthaw_processes();\n\t\telse\n\t\t\tdata->frozen = true;\n\n\t\tbreak;\n\n\tcase SNAPSHOT_UNFREEZE:\n\t\tif (!data->frozen || data->ready)\n\t\t\tbreak;\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tdata->free_bitmaps = false;\n\t\tthaw_processes();\n\t\tdata->frozen = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tpm_restore_gfp_mask();\n\t\terror = hibernation_snapshot(data->platform_support);\n\t\tif (!error) {\n\t\t\terror = put_user(in_suspend, (int __user *)arg);\n\t\t\tdata->ready = !freezer_test_done && !error;\n\t\t\tfreezer_test_done = false;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_ATOMIC_RESTORE:\n\t\tsnapshot_write_finalize(&data->handle);\n\t\tif (data->mode != O_WRONLY || !data->frozen ||\n\t\t    !snapshot_image_loaded(&data->handle)) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terror = hibernation_restore(data->platform_support);\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE:\n\t\tswsusp_free();\n\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\t\tdata->ready = false;\n\t\t/*\n\t\t * It is necessary to thaw kernel threads here, because\n\t\t * SNAPSHOT_CREATE_IMAGE may be invoked directly after\n\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not\n\t\t * thawed, the preallocation of memory carried out by\n\t\t * hibernation_snapshot() might run into problems (i.e. it\n\t\t * might fail or even deadlock).\n\t\t */\n\t\tthaw_kernel_threads();\n\t\tbreak;\n\n\tcase SNAPSHOT_PREF_IMAGE_SIZE:\n\t\timage_size = arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\t\tif (!data->ready) {\n\t\t\terror = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\tsize = snapshot_get_image_size();\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\t\tsize = count_swap_pages(data->swap, 1);\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\toffset = alloc_swapdev_block(data->swap);\n\t\tif (offset) {\n\t\t\toffset <<= PAGE_SHIFT;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -ENOSPC;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE_SWAP_PAGES:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tfree_all_swap_pages(data->swap);\n\t\tbreak;\n\n\tcase SNAPSHOT_S2RAM:\n\t\tif (!data->frozen) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Tasks are frozen and the notifiers have been called with\n\t\t * PM_HIBERNATION_PREPARE\n\t\t */\n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tdata->ready = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_PLATFORM_SUPPORT:\n\t\tdata->platform_support = !!arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_POWER_OFF:\n\t\tif (data->platform_support)\n\t\t\terror = hibernation_platform_enter();\n\t\tbreak;\n\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\tif (swsusp_swap_in_use()) {\n\t\t\terror = -EPERM;\n\t\t} else {\n\t\t\tstruct resume_swap_area swap_area;\n\t\t\tdev_t swdev;\n\n\t\t\terror = copy_from_user(&swap_area, (void __user *)arg,\n\t\t\t\t\tsizeof(struct resume_swap_area));\n\t\t\tif (error) {\n\t\t\t\terror = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * User space encodes device types as two-byte values,\n\t\t\t * so we need to recode them\n\t\t\t */\n\t\t\tswdev = new_decode_dev(swap_area.dev);\n\t\t\tif (swdev) {\n\t\t\t\toffset = swap_area.offset;\n\t\t\t\tdata->swap = swap_type_of(swdev, offset, NULL);\n\t\t\t\tif (data->swap < 0)\n\t\t\t\t\terror = -ENODEV;\n\t\t\t} else {\n\t\t\t\tdata->swap = -1;\n\t\t\t\terror = -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENOTTY;\n\n\t}\n\n\tunlock_device_hotplug();\n\tmutex_unlock(&system_transition_mutex);\n\n\treturn error;\n}"
  },
  {
    "function_name": "snapshot_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/user.c",
    "lines": "170-202",
    "snippet": "static ssize_t snapshot_write(struct file *filp, const char __user *buf,\n                              size_t count, loff_t *offp)\n{\n\tstruct snapshot_data *data;\n\tssize_t res;\n\tloff_t pg_offp = *offp & ~PAGE_MASK;\n\n\tlock_system_sleep();\n\n\tdata = filp->private_data;\n\n\tif (!pg_offp) {\n\t\tres = snapshot_write_next(&data->handle);\n\t\tif (res <= 0)\n\t\t\tgoto unlock;\n\t} else {\n\t\tres = PAGE_SIZE - pg_offp;\n\t}\n\n\tif (!data_of(data->handle)) {\n\t\tres = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tres = simple_write_to_buffer(data_of(data->handle), res, &pg_offp,\n\t\t\tbuf, count);\n\tif (res > 0)\n\t\t*offp += res;\nunlock:\n\tunlock_system_sleep();\n\n\treturn res;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_write_to_buffer",
          "args": [
            "data_of(data->handle)",
            "res",
            "&pg_offp",
            "buf",
            "count"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "data->handle"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "data->handle"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_write_next",
          "args": [
            "&data->handle"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_write_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2577-2645",
          "snippet": "int snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* Allocate buffer for page keys. */\n\t\terror = page_key_alloc(nr_copy_pages);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\t/* Restore page key for data page (s390 only). */\n\t\tpage_key_write(handle->buffer);\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_SAFE\t\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "struct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;",
            "static struct linked_page *safe_pages_list;",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_SAFE\t\t1\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstruct linked_page {\n\tstruct linked_page *next;\n\tchar data[LINKED_PAGE_DATA_SIZE];\n} __packed;\nstatic struct linked_page *safe_pages_list;\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_write_next(struct snapshot_handle *handle)\n{\n\tstatic struct chain_allocator ca;\n\tint error = 0;\n\n\t/* Check if we have already loaded the entire image */\n\tif (handle->cur > 1 && handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\thandle->sync_read = 1;\n\n\tif (!handle->cur) {\n\t\tif (!buffer)\n\t\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\thandle->buffer = buffer;\n\t} else if (handle->cur == 1) {\n\t\terror = load_header(buffer);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsafe_pages_list = NULL;\n\n\t\terror = memory_bm_create(&copy_bm, GFP_ATOMIC, PG_ANY);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* Allocate buffer for page keys. */\n\t\terror = page_key_alloc(nr_copy_pages);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\thibernate_restore_protection_begin();\n\t} else if (handle->cur <= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->cur == nr_meta_pages + 1) {\n\t\t\terror = prepare_image(&orig_bm, &copy_bm);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tchain_init(&ca, GFP_ATOMIC, PG_SAFE);\n\t\t\tmemory_bm_position_reset(&orig_bm);\n\t\t\trestore_pblist = NULL;\n\t\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\t\thandle->sync_read = 0;\n\t\t\tif (IS_ERR(handle->buffer))\n\t\t\t\treturn PTR_ERR(handle->buffer);\n\t\t}\n\t} else {\n\t\tcopy_last_highmem_page();\n\t\t/* Restore page key for data page (s390 only). */\n\t\tpage_key_write(handle->buffer);\n\t\thibernate_restore_protect_page(handle->buffer);\n\t\thandle->buffer = get_buffer(&orig_bm, &ca);\n\t\tif (IS_ERR(handle->buffer))\n\t\t\treturn PTR_ERR(handle->buffer);\n\t\tif (handle->buffer != buffer)\n\t\t\thandle->sync_read = 0;\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n\nstatic ssize_t snapshot_write(struct file *filp, const char __user *buf,\n                              size_t count, loff_t *offp)\n{\n\tstruct snapshot_data *data;\n\tssize_t res;\n\tloff_t pg_offp = *offp & ~PAGE_MASK;\n\n\tlock_system_sleep();\n\n\tdata = filp->private_data;\n\n\tif (!pg_offp) {\n\t\tres = snapshot_write_next(&data->handle);\n\t\tif (res <= 0)\n\t\t\tgoto unlock;\n\t} else {\n\t\tres = PAGE_SIZE - pg_offp;\n\t}\n\n\tif (!data_of(data->handle)) {\n\t\tres = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tres = simple_write_to_buffer(data_of(data->handle), res, &pg_offp,\n\t\t\tbuf, count);\n\tif (res > 0)\n\t\t*offp += res;\nunlock:\n\tunlock_system_sleep();\n\n\treturn res;\n}"
  },
  {
    "function_name": "snapshot_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/user.c",
    "lines": "137-168",
    "snippet": "static ssize_t snapshot_read(struct file *filp, char __user *buf,\n                             size_t count, loff_t *offp)\n{\n\tstruct snapshot_data *data;\n\tssize_t res;\n\tloff_t pg_offp = *offp & ~PAGE_MASK;\n\n\tlock_system_sleep();\n\n\tdata = filp->private_data;\n\tif (!data->ready) {\n\t\tres = -ENODATA;\n\t\tgoto Unlock;\n\t}\n\tif (!pg_offp) { /* on page boundary? */\n\t\tres = snapshot_read_next(&data->handle);\n\t\tif (res <= 0)\n\t\t\tgoto Unlock;\n\t} else {\n\t\tres = PAGE_SIZE - pg_offp;\n\t}\n\n\tres = simple_read_from_buffer(buf, count, &pg_offp,\n\t\t\tdata_of(data->handle), res);\n\tif (res > 0)\n\t\t*offp += res;\n\n Unlock:\n\tunlock_system_sleep();\n\n\treturn res;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "&pg_offp",
            "data_of(data->handle)",
            "res"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_of",
          "args": [
            "data->handle"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_read_next",
          "args": [
            "&data->handle"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_read_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "2081-2126",
          "snippet": "int snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "static void *buffer;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static struct memory_bitmap orig_bm;",
            "static struct memory_bitmap copy_bm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_ANY\t\t0\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstatic void *buffer;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic struct memory_bitmap orig_bm;\nstatic struct memory_bitmap copy_bm;\n\nint snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->cur > nr_meta_pages + nr_copy_pages)\n\t\treturn 0;\n\n\tif (!buffer) {\n\t\t/* This makes the buffer be freed by swsusp_free() */\n\t\tbuffer = get_image_page(GFP_ATOMIC, PG_ANY);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (!handle->cur) {\n\t\tint error;\n\n\t\terror = init_header((struct swsusp_info *)buffer);\n\t\tif (error)\n\t\t\treturn error;\n\t\thandle->buffer = buffer;\n\t\tmemory_bm_position_reset(&orig_bm);\n\t\tmemory_bm_position_reset(&copy_bm);\n\t} else if (handle->cur <= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (PageHighMem(page)) {\n\t\t\t/*\n\t\t\t * Highmem pages are copied to the buffer,\n\t\t\t * because we can't return with a kmapped\n\t\t\t * highmem page (we may not be called again).\n\t\t\t */\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->buffer = buffer;\n\t\t} else {\n\t\t\thandle->buffer = page_address(page);\n\t\t}\n\t}\n\thandle->cur++;\n\treturn PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n\nstatic ssize_t snapshot_read(struct file *filp, char __user *buf,\n                             size_t count, loff_t *offp)\n{\n\tstruct snapshot_data *data;\n\tssize_t res;\n\tloff_t pg_offp = *offp & ~PAGE_MASK;\n\n\tlock_system_sleep();\n\n\tdata = filp->private_data;\n\tif (!data->ready) {\n\t\tres = -ENODATA;\n\t\tgoto Unlock;\n\t}\n\tif (!pg_offp) { /* on page boundary? */\n\t\tres = snapshot_read_next(&data->handle);\n\t\tif (res <= 0)\n\t\t\tgoto Unlock;\n\t} else {\n\t\tres = PAGE_SIZE - pg_offp;\n\t}\n\n\tres = simple_read_from_buffer(buf, count, &pg_offp,\n\t\t\tdata_of(data->handle), res);\n\tif (res > 0)\n\t\t*offp += res;\n\n Unlock:\n\tunlock_system_sleep();\n\n\treturn res;\n}"
  },
  {
    "function_name": "snapshot_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/user.c",
    "lines": "112-135",
    "snippet": "static int snapshot_release(struct inode *inode, struct file *filp)\n{\n\tstruct snapshot_data *data;\n\n\tlock_system_sleep();\n\n\tswsusp_free();\n\tdata = filp->private_data;\n\tfree_all_swap_pages(data->swap);\n\tif (data->frozen) {\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tthaw_processes();\n\t} else if (data->free_bitmaps) {\n\t\tfree_basic_memory_bitmaps();\n\t}\n\tpm_notifier_call_chain(data->mode == O_RDONLY ?\n\t\t\tPM_POST_HIBERNATION : PM_POST_RESTORE);\n\tatomic_inc(&snapshot_device_available);\n\n\tunlock_system_sleep();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_t snapshot_device_available = ATOMIC_INIT(1);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&snapshot_device_available"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_notifier_call_chain",
          "args": [
            "data->mode == O_RDONLY ?\n\t\t\tPM_POST_HIBERNATION : PM_POST_RESTORE"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "pm_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "79-82",
          "snippet": "int pm_notifier_call_chain(unsigned long val)\n{\n\treturn __pm_notifier_call_chain(val, -1, NULL);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain(unsigned long val)\n{\n\treturn __pm_notifier_call_chain(val, -1, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_basic_memory_bitmaps",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "free_basic_memory_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1121-1138",
          "snippet": "void free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nvoid free_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\n\tif (WARN_ON(!(forbidden_pages_map && free_pages_map)))\n\t\treturn;\n\n\tbm1 = forbidden_pages_map;\n\tbm2 = free_pages_map;\n\tforbidden_pages_map = NULL;\n\tfree_pages_map = NULL;\n\tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n\tkfree(bm1);\n\tmemory_bm_free(bm2, PG_UNSAFE_CLEAR);\n\tkfree(bm2);\n\n\tpr_debug(\"Basic memory bitmaps freed\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_thaw_processes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "285-287",
          "snippet": "static inline void suspend_thaw_processes(void)\n{\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void suspend_thaw_processes(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_gfp_mask",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_all_swap_pages",
          "args": [
            "data->swap"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "free_all_swap_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "198-213",
          "snippet": "void free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root swsusp_extents = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "swsusp_free",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "swsusp_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1451-1494",
          "snippet": "void swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define BM_END_OF_MAP\t(~0UL)"
          ],
          "globals_used": [
            "static int swsusp_page_is_free(struct page *);",
            "static void swsusp_set_page_forbidden(struct page *);",
            "static void swsusp_unset_page_forbidden(struct page *);",
            "struct pbe *restore_pblist;",
            "static void *buffer;",
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;",
            "static unsigned int nr_copy_pages;",
            "static unsigned int nr_meta_pages;",
            "static unsigned int alloc_normal, alloc_highmem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define BM_END_OF_MAP\t(~0UL)\n\nstatic int swsusp_page_is_free(struct page *);\nstatic void swsusp_set_page_forbidden(struct page *);\nstatic void swsusp_unset_page_forbidden(struct page *);\nstruct pbe *restore_pblist;\nstatic void *buffer;\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\nstatic unsigned int nr_copy_pages;\nstatic unsigned int nr_meta_pages;\nstatic unsigned int alloc_normal, alloc_highmem;\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t/*\n\t * Find the next bit set in both bitmaps. This is guaranteed to\n\t * terminate when fb_pfn == fr_pfn == BM_END_OF_MAP.\n\t */\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != BM_END_OF_MAP && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\thibernate_restore_unprotect_page(page_address(page));\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = NULL;\n\tbuffer = NULL;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\thibernate_restore_protection_end();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n\natomic_t snapshot_device_available = ATOMIC_INIT(1);\n\nstatic int snapshot_release(struct inode *inode, struct file *filp)\n{\n\tstruct snapshot_data *data;\n\n\tlock_system_sleep();\n\n\tswsusp_free();\n\tdata = filp->private_data;\n\tfree_all_swap_pages(data->swap);\n\tif (data->frozen) {\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tthaw_processes();\n\t} else if (data->free_bitmaps) {\n\t\tfree_basic_memory_bitmaps();\n\t}\n\tpm_notifier_call_chain(data->mode == O_RDONLY ?\n\t\t\tPM_POST_HIBERNATION : PM_POST_RESTORE);\n\tatomic_inc(&snapshot_device_available);\n\n\tunlock_system_sleep();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "snapshot_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/user.c",
    "lines": "47-110",
    "snippet": "static int snapshot_open(struct inode *inode, struct file *filp)\n{\n\tstruct snapshot_data *data;\n\tint error, nr_calls = 0;\n\n\tif (!hibernation_available())\n\t\treturn -EPERM;\n\n\tlock_system_sleep();\n\n\tif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tif ((filp->f_flags & O_ACCMODE) == O_RDWR) {\n\t\tatomic_inc(&snapshot_device_available);\n\t\terror = -ENOSYS;\n\t\tgoto Unlock;\n\t}\n\tnonseekable_open(inode, filp);\n\tdata = &snapshot_state;\n\tfilp->private_data = data;\n\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY) {\n\t\t/* Hibernating.  The image device should be accessible. */\n\t\tdata->swap = swsusp_resume_device ?\n\t\t\tswap_type_of(swsusp_resume_device, 0, NULL) : -1;\n\t\tdata->mode = O_RDONLY;\n\t\tdata->free_bitmaps = false;\n\t\terror = __pm_notifier_call_chain(PM_HIBERNATION_PREPARE, -1, &nr_calls);\n\t\tif (error)\n\t\t\t__pm_notifier_call_chain(PM_POST_HIBERNATION, --nr_calls, NULL);\n\t} else {\n\t\t/*\n\t\t * Resuming.  We may need to wait for the image device to\n\t\t * appear.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tdata->swap = -1;\n\t\tdata->mode = O_WRONLY;\n\t\terror = __pm_notifier_call_chain(PM_RESTORE_PREPARE, -1, &nr_calls);\n\t\tif (!error) {\n\t\t\terror = create_basic_memory_bitmaps();\n\t\t\tdata->free_bitmaps = !error;\n\t\t} else\n\t\t\tnr_calls--;\n\n\t\tif (error)\n\t\t\t__pm_notifier_call_chain(PM_POST_RESTORE, nr_calls, NULL);\n\t}\n\tif (error)\n\t\tatomic_inc(&snapshot_device_available);\n\n\tdata->frozen = false;\n\tdata->ready = false;\n\tdata->platform_support = false;\n\n Unlock:\n\tunlock_system_sleep();\n\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/freezer.h>",
      "#include <linux/cpu.h>",
      "#include <linux/console.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs.h>",
      "#include <linux/pm.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/device.h>",
      "#include <linux/string.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/suspend.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct snapshot_data {\n\tstruct snapshot_handle handle;\n\tint swap;\n\tint mode;\n\tbool frozen;\n\tbool ready;\n\tbool platform_support;\n\tbool free_bitmaps;\n} snapshot_state;",
      "atomic_t snapshot_device_available = ATOMIC_INIT(1);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&snapshot_device_available"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_notifier_call_chain",
          "args": [
            "PM_POST_RESTORE",
            "nr_calls",
            "NULL"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__pm_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "70-78",
          "snippet": "int __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)\n{\n\tint ret;\n\n\tret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,\n\t\t\t\t\t\tnr_to_call, nr_calls);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)\n{\n\tint ret;\n\n\tret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,\n\t\t\t\t\t\tnr_to_call, nr_calls);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_basic_memory_bitmaps",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "create_basic_memory_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "1071-1112",
          "snippet": "int create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n \tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [
            "#define PG_UNSAFE_CLEAR\t1",
            "#define PG_ANY\t\t0"
          ],
          "globals_used": [
            "static struct memory_bitmap *forbidden_pages_map;",
            "static struct memory_bitmap *free_pages_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\n#define PG_UNSAFE_CLEAR\t1\n#define PG_ANY\t\t0\n\nstatic struct memory_bitmap *forbidden_pages_map;\nstatic struct memory_bitmap *free_pages_map;\n\nint create_basic_memory_bitmaps(void)\n{\n\tstruct memory_bitmap *bm1, *bm2;\n\tint error = 0;\n\n\tif (forbidden_pages_map && free_pages_map)\n\t\treturn 0;\n\telse\n\t\tBUG_ON(forbidden_pages_map || free_pages_map);\n\n\tbm1 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm1)\n\t\treturn -ENOMEM;\n\n\terror = memory_bm_create(bm1, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_first_object;\n\n\tbm2 = kzalloc(sizeof(struct memory_bitmap), GFP_KERNEL);\n\tif (!bm2)\n\t\tgoto Free_first_bitmap;\n\n\terror = memory_bm_create(bm2, GFP_KERNEL, PG_ANY);\n\tif (error)\n\t\tgoto Free_second_object;\n\n\tforbidden_pages_map = bm1;\n\tfree_pages_map = bm2;\n\tmark_nosave_pages(forbidden_pages_map);\n\n\tpr_debug(\"Basic memory bitmaps created\\n\");\n\n\treturn 0;\n\n Free_second_object:\n\tkfree(bm2);\n Free_first_bitmap:\n \tmemory_bm_free(bm1, PG_UNSAFE_CLEAR);\n Free_first_object:\n\tkfree(bm1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_device_probe",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_type_of",
          "args": [
            "swsusp_resume_device",
            "0",
            "NULL"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data->handle",
            "0",
            "sizeof(struct snapshot_handle)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nonseekable_open",
          "args": [
            "inode",
            "filp"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&snapshot_device_available"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&snapshot_device_available",
            "-1",
            "0"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "71-74",
          "snippet": "bool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n\nstatic struct snapshot_data {\n\tstruct snapshot_handle handle;\n\tint swap;\n\tint mode;\n\tbool frozen;\n\tbool ready;\n\tbool platform_support;\n\tbool free_bitmaps;\n} snapshot_state;\natomic_t snapshot_device_available = ATOMIC_INIT(1);\n\nstatic int snapshot_open(struct inode *inode, struct file *filp)\n{\n\tstruct snapshot_data *data;\n\tint error, nr_calls = 0;\n\n\tif (!hibernation_available())\n\t\treturn -EPERM;\n\n\tlock_system_sleep();\n\n\tif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tif ((filp->f_flags & O_ACCMODE) == O_RDWR) {\n\t\tatomic_inc(&snapshot_device_available);\n\t\terror = -ENOSYS;\n\t\tgoto Unlock;\n\t}\n\tnonseekable_open(inode, filp);\n\tdata = &snapshot_state;\n\tfilp->private_data = data;\n\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY) {\n\t\t/* Hibernating.  The image device should be accessible. */\n\t\tdata->swap = swsusp_resume_device ?\n\t\t\tswap_type_of(swsusp_resume_device, 0, NULL) : -1;\n\t\tdata->mode = O_RDONLY;\n\t\tdata->free_bitmaps = false;\n\t\terror = __pm_notifier_call_chain(PM_HIBERNATION_PREPARE, -1, &nr_calls);\n\t\tif (error)\n\t\t\t__pm_notifier_call_chain(PM_POST_HIBERNATION, --nr_calls, NULL);\n\t} else {\n\t\t/*\n\t\t * Resuming.  We may need to wait for the image device to\n\t\t * appear.\n\t\t */\n\t\twait_for_device_probe();\n\n\t\tdata->swap = -1;\n\t\tdata->mode = O_WRONLY;\n\t\terror = __pm_notifier_call_chain(PM_RESTORE_PREPARE, -1, &nr_calls);\n\t\tif (!error) {\n\t\t\terror = create_basic_memory_bitmaps();\n\t\t\tdata->free_bitmaps = !error;\n\t\t} else\n\t\t\tnr_calls--;\n\n\t\tif (error)\n\t\t\t__pm_notifier_call_chain(PM_POST_RESTORE, nr_calls, NULL);\n\t}\n\tif (error)\n\t\tatomic_inc(&snapshot_device_available);\n\n\tdata->frozen = false;\n\tdata->ready = false;\n\tdata->platform_support = false;\n\n Unlock:\n\tunlock_system_sleep();\n\n\treturn error;\n}"
  }
]