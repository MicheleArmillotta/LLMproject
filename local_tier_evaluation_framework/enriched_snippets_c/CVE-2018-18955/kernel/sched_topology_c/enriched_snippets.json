[
  {
    "function_name": "partition_sched_domains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1934-2007",
    "snippet": "void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tint i, j, n;\n\tint new_topology;\n\n\tmutex_lock(&sched_domains_mutex);\n\n\t/* Always unregister in case we don't destroy any domains: */\n\tunregister_sched_domain_sysctl();\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j])\n\t\t\t    && dattrs_equal(dattr_cur, i, dattr_new, j))\n\t\t\t\tgoto match1;\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j])\n\t\t\t    && dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tregister_sched_domain_sysctl();\n\n\tmutex_unlock(&sched_domains_mutex);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t\t\t\t*doms_cur;",
      "static int\t\t\t\tndoms_cur;",
      "static struct sched_domain_attr\t\t*dattr_cur;",
      "static cpumask_var_t\t\t\tfallback_doms;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_sched_domain_sysctl",
          "args": [],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_sched_domain_sysctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1365-1367",
          "snippet": "static inline void unregister_sched_domain_sysctl(void)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void unregister_sched_domain_sysctl(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dattr_cur"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_sched_domains",
          "args": [
            "doms_cur",
            "ndoms_cur"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "free_sched_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1844-1850",
          "snippet": "void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_sched_domains",
          "args": [
            "doms_new[i]",
            "dattr_new ? dattr_new + i : NULL"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "build_sched_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1706-1799",
          "snippet": "static int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tstruct sched_domain_topology_level *tl_asym;\n\tbool has_asym = false;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\ttl_asym = asym_cpu_capacity_level(cpu_map);\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\t\t\tint dflags = 0;\n\n\t\t\tif (tl == tl_asym) {\n\t\t\t\tdflags |= SD_ASYM_CPUCAPACITY;\n\t\t\t\thas_asym = true;\n\t\t\t}\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, dflags, i);\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_enable_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_enabled) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);",
            "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nstatic int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tstruct sched_domain_topology_level *tl_asym;\n\tbool has_asym = false;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\ttl_asym = asym_cpu_capacity_level(cpu_map);\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\t\t\tint dflags = 0;\n\n\t\t\tif (tl == tl_asym) {\n\t\t\t\tdflags |= SD_ASYM_CPUCAPACITY;\n\t\t\t\thas_asym = true;\n\t\t\t}\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, dflags, i);\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_enable_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_enabled) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dattrs_equal",
          "args": [
            "dattr_new",
            "i",
            "dattr_cur",
            "j"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "dattrs_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1892-1906",
          "snippet": "static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t/* Fast path: */\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = SD_ATTR_INIT;\n\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t/* Fast path: */\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = SD_ATTR_INIT;\n\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "doms_new[i]",
            "doms_cur[j]"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "doms_new[0]",
            "cpu_active_mask",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_DOMAIN"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/isolation.c",
          "lines": "25-31",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_destroy_domains",
          "args": [
            "doms_cur[i]"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "detach_destroy_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1881-1889",
          "snippet": "static void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tint i;\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(NULL, &def_root_domain, i);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct root_domain def_root_domain;",
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstruct root_domain def_root_domain;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tint i;\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(NULL, &def_root_domain, i);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "doms_cur[i]",
            "doms_new[j]"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "doms_new[0]",
            "cpu_active_mask",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_sched_domains",
          "args": [
            "1"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_sched_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1827-1842",
          "snippet": "cpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\ncpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dattr_new"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_update_cpu_topology",
          "args": [],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "arch_update_cpu_topology",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1822-1825",
          "snippet": "int __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t\t\t\t*doms_cur;\nstatic int\t\t\t\tndoms_cur;\nstatic struct sched_domain_attr\t\t*dattr_cur;\nstatic cpumask_var_t\t\t\tfallback_doms;\n\nvoid partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tint i, j, n;\n\tint new_topology;\n\n\tmutex_lock(&sched_domains_mutex);\n\n\t/* Always unregister in case we don't destroy any domains: */\n\tunregister_sched_domain_sysctl();\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j])\n\t\t\t    && dattrs_equal(dattr_cur, i, dattr_new, j))\n\t\t\t\tgoto match1;\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j])\n\t\t\t    && dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tregister_sched_domain_sysctl();\n\n\tmutex_unlock(&sched_domains_mutex);\n}"
  },
  {
    "function_name": "dattrs_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1892-1906",
    "snippet": "static int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t/* Fast path: */\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = SD_ATTR_INIT;\n\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "cur ? (cur + idx_cur) : &tmp",
            "new ? (new + idx_new) : &tmp",
            "sizeof(struct sched_domain_attr)"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t/* Fast path: */\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = SD_ATTR_INIT;\n\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}"
  },
  {
    "function_name": "detach_destroy_domains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1881-1889",
    "snippet": "static void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tint i;\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(NULL, &def_root_domain, i);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct root_domain def_root_domain;",
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_attach_domain",
          "args": [
            "NULL",
            "&def_root_domain",
            "i"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_attach_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "433-478",
          "snippet": "static void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd)\n\t\t\tsd->child = NULL;\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd)\n\t\t\tsd->child = NULL;\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstruct root_domain def_root_domain;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tint i;\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(NULL, &def_root_domain, i);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "sched_init_domains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1857-1875",
    "snippet": "int sched_init_domains(const struct cpumask *cpu_map)\n{\n\tint err;\n\n\tzalloc_cpumask_var(&sched_domains_tmpmask, GFP_KERNEL);\n\tzalloc_cpumask_var(&sched_domains_tmpmask2, GFP_KERNEL);\n\tzalloc_cpumask_var(&fallback_doms, GFP_KERNEL);\n\n\tarch_update_cpu_topology();\n\tndoms_cur = 1;\n\tdoms_cur = alloc_sched_domains(ndoms_cur);\n\tif (!doms_cur)\n\t\tdoms_cur = &fallback_doms;\n\tcpumask_and(doms_cur[0], cpu_map, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\terr = build_sched_domains(doms_cur[0], NULL);\n\tregister_sched_domain_sysctl();\n\n\treturn err;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t sched_domains_tmpmask;",
      "static cpumask_var_t sched_domains_tmpmask2;",
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);",
      "static cpumask_var_t\t\t\t*doms_cur;",
      "static int\t\t\t\tndoms_cur;",
      "static cpumask_var_t\t\t\tfallback_doms;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sched_domain_sysctl",
          "args": [],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_sched_domain_sysctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1365-1367",
          "snippet": "static inline void unregister_sched_domain_sysctl(void)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void unregister_sched_domain_sysctl(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_sched_domains",
          "args": [
            "doms_cur[0]",
            "NULL"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "build_sched_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1706-1799",
          "snippet": "static int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tstruct sched_domain_topology_level *tl_asym;\n\tbool has_asym = false;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\ttl_asym = asym_cpu_capacity_level(cpu_map);\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\t\t\tint dflags = 0;\n\n\t\t\tif (tl == tl_asym) {\n\t\t\t\tdflags |= SD_ASYM_CPUCAPACITY;\n\t\t\t\thas_asym = true;\n\t\t\t}\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, dflags, i);\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_enable_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_enabled) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);",
            "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nstatic int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tstruct sched_domain_topology_level *tl_asym;\n\tbool has_asym = false;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\ttl_asym = asym_cpu_capacity_level(cpu_map);\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\t\t\tint dflags = 0;\n\n\t\t\tif (tl == tl_asym) {\n\t\t\t\tdflags |= SD_ASYM_CPUCAPACITY;\n\t\t\t\thas_asym = true;\n\t\t\t}\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, dflags, i);\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_enable_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_enabled) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "doms_cur[0]",
            "cpu_map",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_DOMAIN"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/isolation.c",
          "lines": "25-31",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_sched_domains",
          "args": [
            "ndoms_cur"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_sched_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1827-1842",
          "snippet": "cpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\ncpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_update_cpu_topology",
          "args": [],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "arch_update_cpu_topology",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1822-1825",
          "snippet": "int __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&fallback_doms",
            "GFP_KERNEL"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&sched_domains_tmpmask2",
            "GFP_KERNEL"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&sched_domains_tmpmask",
            "GFP_KERNEL"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\nstatic cpumask_var_t sched_domains_tmpmask2;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\nstatic cpumask_var_t\t\t\t*doms_cur;\nstatic int\t\t\t\tndoms_cur;\nstatic cpumask_var_t\t\t\tfallback_doms;\n\nint sched_init_domains(const struct cpumask *cpu_map)\n{\n\tint err;\n\n\tzalloc_cpumask_var(&sched_domains_tmpmask, GFP_KERNEL);\n\tzalloc_cpumask_var(&sched_domains_tmpmask2, GFP_KERNEL);\n\tzalloc_cpumask_var(&fallback_doms, GFP_KERNEL);\n\n\tarch_update_cpu_topology();\n\tndoms_cur = 1;\n\tdoms_cur = alloc_sched_domains(ndoms_cur);\n\tif (!doms_cur)\n\t\tdoms_cur = &fallback_doms;\n\tcpumask_and(doms_cur[0], cpu_map, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\terr = build_sched_domains(doms_cur[0], NULL);\n\tregister_sched_domain_sysctl();\n\n\treturn err;\n}"
  },
  {
    "function_name": "free_sched_domains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1844-1850",
    "snippet": "void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "doms"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "doms[i]"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}"
  },
  {
    "function_name": "alloc_sched_domains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1827-1842",
    "snippet": "cpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_sched_domains",
          "args": [
            "doms",
            "i"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "free_sched_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1844-1850",
          "snippet": "void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&doms[i]",
            "GFP_KERNEL"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "ndoms",
            "sizeof(*doms)",
            "GFP_KERNEL"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\ncpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}"
  },
  {
    "function_name": "arch_update_cpu_topology",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1822-1825",
    "snippet": "int __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nint __weak arch_update_cpu_topology(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "build_sched_domains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1706-1799",
    "snippet": "static int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tstruct sched_domain_topology_level *tl_asym;\n\tbool has_asym = false;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\ttl_asym = asym_cpu_capacity_level(cpu_map);\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\t\t\tint dflags = 0;\n\n\t\t\tif (tl == tl_asym) {\n\t\t\t\tdflags |= SD_ASYM_CPUCAPACITY;\n\t\t\t\thas_asym = true;\n\t\t\t}\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, dflags, i);\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_enable_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_enabled) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);",
      "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_domain_allocs",
          "args": [
            "&d",
            "alloc_state",
            "cpu_map"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "__free_domain_allocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "987-1004",
          "snippet": "static void __free_domain_allocs(struct s_data *d, enum s_alloc what,\n\t\t\t\t const struct cpumask *cpu_map)\n{\n\tswitch (what) {\n\tcase sa_rootdomain:\n\t\tif (!atomic_read(&d->rd->refcount))\n\t\t\tfree_rootdomain(&d->rd->rcu);\n\t\t/* Fall through */\n\tcase sa_sd:\n\t\tfree_percpu(d->sd);\n\t\t/* Fall through */\n\tcase sa_sd_storage:\n\t\t__sdt_free(cpu_map);\n\t\t/* Fall through */\n\tcase sa_none:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void __free_domain_allocs(struct s_data *d, enum s_alloc what,\n\t\t\t\t const struct cpumask *cpu_map)\n{\n\tswitch (what) {\n\tcase sa_rootdomain:\n\t\tif (!atomic_read(&d->rd->refcount))\n\t\t\tfree_rootdomain(&d->rd->rcu);\n\t\t/* Fall through */\n\tcase sa_sd:\n\t\tfree_percpu(d->sd);\n\t\t/* Fall through */\n\tcase sa_sd_storage:\n\t\t__sdt_free(cpu_map);\n\t\t/* Fall through */\n\tcase sa_none:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\"",
            "cpumask_pr_args(cpu_map)",
            "rq->rd->max_cpu_capacity"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cpu_map"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable_cpuslocked",
          "args": [
            "&sched_asym_cpucapacity"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_attach_domain",
          "args": [
            "sd",
            "d.rd",
            "i"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_attach_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "433-478",
          "snippet": "static void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd)\n\t\t\tsd->child = NULL;\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd)\n\t\t\tsd->child = NULL;\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "d.rd->max_cpu_capacity",
            "rq->cpu_capacity_orig"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "d.rd->max_cpu_capacity"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "d.sd",
            "i"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_sched_groups_capacity",
          "args": [
            "i",
            "sd"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "init_sched_groups_capacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "914-944",
          "snippet": "static void init_sched_groups_capacity(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_group *sg = sd->groups;\n\n\tWARN_ON(!sg);\n\n\tdo {\n\t\tint cpu, max_cpu = -1;\n\n\t\tsg->group_weight = cpumask_weight(sched_group_span(sg));\n\n\t\tif (!(sd->flags & SD_ASYM_PACKING))\n\t\t\tgoto next;\n\n\t\tfor_each_cpu(cpu, sched_group_span(sg)) {\n\t\t\tif (max_cpu < 0)\n\t\t\t\tmax_cpu = cpu;\n\t\t\telse if (sched_asym_prefer(cpu, max_cpu))\n\t\t\t\tmax_cpu = cpu;\n\t\t}\n\t\tsg->asym_prefer_cpu = max_cpu;\n\nnext:\n\t\tsg = sg->next;\n\t} while (sg != sd->groups);\n\n\tif (cpu != group_balance_cpu(sg))\n\t\treturn;\n\n\tupdate_group_capacity(sd, cpu);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void init_sched_groups_capacity(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_group *sg = sd->groups;\n\n\tWARN_ON(!sg);\n\n\tdo {\n\t\tint cpu, max_cpu = -1;\n\n\t\tsg->group_weight = cpumask_weight(sched_group_span(sg));\n\n\t\tif (!(sd->flags & SD_ASYM_PACKING))\n\t\t\tgoto next;\n\n\t\tfor_each_cpu(cpu, sched_group_span(sg)) {\n\t\t\tif (max_cpu < 0)\n\t\t\t\tmax_cpu = cpu;\n\t\t\telse if (sched_asym_prefer(cpu, max_cpu))\n\t\t\t\tmax_cpu = cpu;\n\t\t}\n\t\tsg->asym_prefer_cpu = max_cpu;\n\nnext:\n\t\tsg = sg->next;\n\t} while (sg != sd->groups);\n\n\tif (cpu != group_balance_cpu(sg))\n\t\treturn;\n\n\tupdate_group_capacity(sd, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "claim_allocations",
          "args": [
            "i",
            "sd"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "claim_allocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1028-1043",
          "snippet": "static void claim_allocations(int cpu, struct sched_domain *sd)\n{\n\tstruct sd_data *sdd = sd->private;\n\n\tWARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);\n\t*per_cpu_ptr(sdd->sd, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sds, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sds, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sg, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sgc, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sgc, cpu) = NULL;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void claim_allocations(int cpu, struct sched_domain *sd)\n{\n\tstruct sd_data *sdd = sd->private;\n\n\tWARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);\n\t*per_cpu_ptr(sdd->sd, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sds, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sds, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sg, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sgc, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sgc, cpu) = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "d.sd",
            "i"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_sched_groups",
          "args": [
            "sd",
            "i"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "build_sched_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "868-902",
          "snippet": "static int\nbuild_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL;\n\tstruct sd_data *sdd = sd->private;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered;\n\tint i;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\tcovered = sched_domains_tmpmask;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct sched_group *sg;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsg = get_group(i, sdd);\n\n\t\tcpumask_or(covered, covered, sched_group_span(sg));\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t}\n\tlast->next = first;\n\tsd->groups = first;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t sched_domains_tmpmask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic int\nbuild_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL;\n\tstruct sd_data *sdd = sd->private;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered;\n\tint i;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\tcovered = sched_domains_tmpmask;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct sched_group *sg;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsg = get_group(i, sdd);\n\n\t\tcpumask_or(covered, covered, sched_group_span(sg));\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t}\n\tlast->next = first;\n\tsd->groups = first;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_overlap_sched_groups",
          "args": [
            "sd",
            "i"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "build_overlap_sched_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "699-756",
          "snippet": "static int\nbuild_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Asymmetric node setups can result in situations where the\n\t\t * domain tree is of unequal depth, make sure to skip domains\n\t\t * that already cover the entire range.\n\t\t *\n\t\t * In that case build_sched_domains() will have terminated the\n\t\t * iteration early and our sibling sd spans will be empty.\n\t\t * Domains should always include the CPU they're built on, so\n\t\t * check that.\n\t\t */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\tsg = build_group_from_child_sched_domain(sibling, cpu);\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_span(sg);\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tinit_overlap_sched_group(sd, sg);\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = first;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t sched_domains_tmpmask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic int\nbuild_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Asymmetric node setups can result in situations where the\n\t\t * domain tree is of unequal depth, make sure to skip domains\n\t\t * that already cover the entire range.\n\t\t *\n\t\t * In that case build_sched_domains() will have terminated the\n\t\t * iteration early and our sibling sd spans will be empty.\n\t\t * Domains should always include the CPU they're built on, so\n\t\t * check that.\n\t\t */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\tsg = build_group_from_child_sched_domain(sibling, cpu);\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_span(sg);\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tinit_overlap_sched_group(sd, sg);\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = first;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "d.sd",
            "i"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "cpu_map",
            "sched_domain_span(sd)"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "d.sd",
            "i"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_sched_domain",
          "args": [
            "tl",
            "cpu_map",
            "attr",
            "sd",
            "dflags",
            "i"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "build_sched_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1613-1641",
          "snippet": "static struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,\n\t\tconst struct cpumask *cpu_map, struct sched_domain_attr *attr,\n\t\tstruct sched_domain *child, int dflags, int cpu)\n{\n\tstruct sched_domain *sd = sd_init(tl, cpu_map, child, dflags, cpu);\n\n\tif (child) {\n\t\tsd->level = child->level + 1;\n\t\tsched_domain_level_max = max(sched_domain_level_max, sd->level);\n\t\tchild->parent = sd;\n\n\t\tif (!cpumask_subset(sched_domain_span(child),\n\t\t\t\t    sched_domain_span(sd))) {\n\t\t\tpr_err(\"BUG: arch topology borken\\n\");\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tpr_err(\"     the %s domain not a subset of the %s domain\\n\",\n\t\t\t\t\tchild->name, sd->name);\n#endif\n\t\t\t/* Fixup, ensure @sd has at least @child CPUs. */\n\t\t\tcpumask_or(sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(child));\n\t\t}\n\n\t}\n\tset_domain_attribute(sd, attr);\n\n\treturn sd;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sched_domain_level_max;",
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint sched_domain_level_max;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,\n\t\tconst struct cpumask *cpu_map, struct sched_domain_attr *attr,\n\t\tstruct sched_domain *child, int dflags, int cpu)\n{\n\tstruct sched_domain *sd = sd_init(tl, cpu_map, child, dflags, cpu);\n\n\tif (child) {\n\t\tsd->level = child->level + 1;\n\t\tsched_domain_level_max = max(sched_domain_level_max, sd->level);\n\t\tchild->parent = sd;\n\n\t\tif (!cpumask_subset(sched_domain_span(child),\n\t\t\t\t    sched_domain_span(sd))) {\n\t\t\tpr_err(\"BUG: arch topology borken\\n\");\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tpr_err(\"     the %s domain not a subset of the %s domain\\n\",\n\t\t\t\t\tchild->name, sd->name);\n#endif\n\t\t\t/* Fixup, ensure @sd has at least @child CPUs. */\n\t\t\tcpumask_or(sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(child));\n\t\t}\n\n\t}\n\tset_domain_attribute(sd, attr);\n\n\treturn sd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asym_cpu_capacity_level",
          "args": [
            "cpu_map"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "asym_cpu_capacity_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1647-1699",
          "snippet": "static struct sched_domain_topology_level\n*asym_cpu_capacity_level(const struct cpumask *cpu_map)\n{\n\tint i, j, asym_level = 0;\n\tbool asym = false;\n\tstruct sched_domain_topology_level *tl, *asym_tl = NULL;\n\tunsigned long cap;\n\n\t/* Is there any asymmetry? */\n\tcap = arch_scale_cpu_capacity(NULL, cpumask_first(cpu_map));\n\n\tfor_each_cpu(i, cpu_map) {\n\t\tif (arch_scale_cpu_capacity(NULL, i) != cap) {\n\t\t\tasym = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!asym)\n\t\treturn NULL;\n\n\t/*\n\t * Examine topology from all CPU's point of views to detect the lowest\n\t * sched_domain_topology_level where a highest capacity CPU is visible\n\t * to everyone.\n\t */\n\tfor_each_cpu(i, cpu_map) {\n\t\tunsigned long max_capacity = arch_scale_cpu_capacity(NULL, i);\n\t\tint tl_id = 0;\n\n\t\tfor_each_sd_topology(tl) {\n\t\t\tif (tl_id < asym_level)\n\t\t\t\tgoto next_level;\n\n\t\t\tfor_each_cpu_and(j, tl->mask(i), cpu_map) {\n\t\t\t\tunsigned long capacity;\n\n\t\t\t\tcapacity = arch_scale_cpu_capacity(NULL, j);\n\n\t\t\t\tif (capacity <= max_capacity)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmax_capacity = capacity;\n\t\t\t\tasym_level = tl_id;\n\t\t\t\tasym_tl = tl;\n\t\t\t}\nnext_level:\n\t\t\ttl_id++;\n\t\t}\n\t}\n\n\treturn asym_tl;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic struct sched_domain_topology_level\n*asym_cpu_capacity_level(const struct cpumask *cpu_map)\n{\n\tint i, j, asym_level = 0;\n\tbool asym = false;\n\tstruct sched_domain_topology_level *tl, *asym_tl = NULL;\n\tunsigned long cap;\n\n\t/* Is there any asymmetry? */\n\tcap = arch_scale_cpu_capacity(NULL, cpumask_first(cpu_map));\n\n\tfor_each_cpu(i, cpu_map) {\n\t\tif (arch_scale_cpu_capacity(NULL, i) != cap) {\n\t\t\tasym = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!asym)\n\t\treturn NULL;\n\n\t/*\n\t * Examine topology from all CPU's point of views to detect the lowest\n\t * sched_domain_topology_level where a highest capacity CPU is visible\n\t * to everyone.\n\t */\n\tfor_each_cpu(i, cpu_map) {\n\t\tunsigned long max_capacity = arch_scale_cpu_capacity(NULL, i);\n\t\tint tl_id = 0;\n\n\t\tfor_each_sd_topology(tl) {\n\t\t\tif (tl_id < asym_level)\n\t\t\t\tgoto next_level;\n\n\t\t\tfor_each_cpu_and(j, tl->mask(i), cpu_map) {\n\t\t\t\tunsigned long capacity;\n\n\t\t\t\tcapacity = arch_scale_cpu_capacity(NULL, j);\n\n\t\t\t\tif (capacity <= max_capacity)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmax_capacity = capacity;\n\t\t\t\tasym_level = tl_id;\n\t\t\t\tasym_tl = tl;\n\t\t\t}\nnext_level:\n\t\t\ttl_id++;\n\t\t}\n\t}\n\n\treturn asym_tl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__visit_domain_allocation_hell",
          "args": [
            "&d",
            "cpu_map"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "__visit_domain_allocation_hell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1006-1021",
          "snippet": "static enum s_alloc\n__visit_domain_allocation_hell(struct s_data *d, const struct cpumask *cpu_map)\n{\n\tmemset(d, 0, sizeof(*d));\n\n\tif (__sdt_alloc(cpu_map))\n\t\treturn sa_sd_storage;\n\td->sd = alloc_percpu(struct sched_domain *);\n\tif (!d->sd)\n\t\treturn sa_sd_storage;\n\td->rd = alloc_rootdomain();\n\tif (!d->rd)\n\t\treturn sa_sd;\n\n\treturn sa_rootdomain;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic enum s_alloc\n__visit_domain_allocation_hell(struct s_data *d, const struct cpumask *cpu_map)\n{\n\tmemset(d, 0, sizeof(*d));\n\n\tif (__sdt_alloc(cpu_map))\n\t\treturn sa_sd_storage;\n\td->sd = alloc_percpu(struct sched_domain *);\n\tif (!d->sd)\n\t\treturn sa_sd_storage;\n\td->rd = alloc_rootdomain();\n\tif (!d->rd)\n\t\treturn sa_sd;\n\n\treturn sa_rootdomain;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nstatic int\nbuild_sched_domains(const struct cpumask *cpu_map, struct sched_domain_attr *attr)\n{\n\tenum s_alloc alloc_state;\n\tstruct sched_domain *sd;\n\tstruct s_data d;\n\tstruct rq *rq = NULL;\n\tint i, ret = -ENOMEM;\n\tstruct sched_domain_topology_level *tl_asym;\n\tbool has_asym = false;\n\n\talloc_state = __visit_domain_allocation_hell(&d, cpu_map);\n\tif (alloc_state != sa_rootdomain)\n\t\tgoto error;\n\n\ttl_asym = asym_cpu_capacity_level(cpu_map);\n\n\t/* Set up domains for CPUs specified by the cpu_map: */\n\tfor_each_cpu(i, cpu_map) {\n\t\tstruct sched_domain_topology_level *tl;\n\n\t\tsd = NULL;\n\t\tfor_each_sd_topology(tl) {\n\t\t\tint dflags = 0;\n\n\t\t\tif (tl == tl_asym) {\n\t\t\t\tdflags |= SD_ASYM_CPUCAPACITY;\n\t\t\t\thas_asym = true;\n\t\t\t}\n\n\t\t\tsd = build_sched_domain(tl, cpu_map, attr, sd, dflags, i);\n\n\t\t\tif (tl == sched_domain_topology)\n\t\t\t\t*per_cpu_ptr(d.sd, i) = sd;\n\t\t\tif (tl->flags & SDTL_OVERLAP)\n\t\t\t\tsd->flags |= SD_OVERLAP;\n\t\t\tif (cpumask_equal(cpu_map, sched_domain_span(sd)))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Build the groups for the domains */\n\tfor_each_cpu(i, cpu_map) {\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tsd->span_weight = cpumask_weight(sched_domain_span(sd));\n\t\t\tif (sd->flags & SD_OVERLAP) {\n\t\t\t\tif (build_overlap_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (build_sched_groups(sd, i))\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Calculate CPU capacity for physical packages and nodes */\n\tfor (i = nr_cpumask_bits-1; i >= 0; i--) {\n\t\tif (!cpumask_test_cpu(i, cpu_map))\n\t\t\tcontinue;\n\n\t\tfor (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd->parent) {\n\t\t\tclaim_allocations(i, sd);\n\t\t\tinit_sched_groups_capacity(i, sd);\n\t\t}\n\t}\n\n\t/* Attach the domains */\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map) {\n\t\trq = cpu_rq(i);\n\t\tsd = *per_cpu_ptr(d.sd, i);\n\n\t\t/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */\n\t\tif (rq->cpu_capacity_orig > READ_ONCE(d.rd->max_cpu_capacity))\n\t\t\tWRITE_ONCE(d.rd->max_cpu_capacity, rq->cpu_capacity_orig);\n\n\t\tcpu_attach_domain(sd, d.rd, i);\n\t}\n\trcu_read_unlock();\n\n\tif (has_asym)\n\t\tstatic_branch_enable_cpuslocked(&sched_asym_cpucapacity);\n\n\tif (rq && sched_debug_enabled) {\n\t\tpr_info(\"root domain span: %*pbl (max cpu_capacity = %lu)\\n\",\n\t\t\tcpumask_pr_args(cpu_map), rq->rd->max_cpu_capacity);\n\t}\n\n\tret = 0;\nerror:\n\t__free_domain_allocs(&d, alloc_state, cpu_map);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "asym_cpu_capacity_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1647-1699",
    "snippet": "static struct sched_domain_topology_level\n*asym_cpu_capacity_level(const struct cpumask *cpu_map)\n{\n\tint i, j, asym_level = 0;\n\tbool asym = false;\n\tstruct sched_domain_topology_level *tl, *asym_tl = NULL;\n\tunsigned long cap;\n\n\t/* Is there any asymmetry? */\n\tcap = arch_scale_cpu_capacity(NULL, cpumask_first(cpu_map));\n\n\tfor_each_cpu(i, cpu_map) {\n\t\tif (arch_scale_cpu_capacity(NULL, i) != cap) {\n\t\t\tasym = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!asym)\n\t\treturn NULL;\n\n\t/*\n\t * Examine topology from all CPU's point of views to detect the lowest\n\t * sched_domain_topology_level where a highest capacity CPU is visible\n\t * to everyone.\n\t */\n\tfor_each_cpu(i, cpu_map) {\n\t\tunsigned long max_capacity = arch_scale_cpu_capacity(NULL, i);\n\t\tint tl_id = 0;\n\n\t\tfor_each_sd_topology(tl) {\n\t\t\tif (tl_id < asym_level)\n\t\t\t\tgoto next_level;\n\n\t\t\tfor_each_cpu_and(j, tl->mask(i), cpu_map) {\n\t\t\t\tunsigned long capacity;\n\n\t\t\t\tcapacity = arch_scale_cpu_capacity(NULL, j);\n\n\t\t\t\tif (capacity <= max_capacity)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmax_capacity = capacity;\n\t\t\t\tasym_level = tl_id;\n\t\t\t\tasym_tl = tl;\n\t\t\t}\nnext_level:\n\t\t\ttl_id++;\n\t\t}\n\t}\n\n\treturn asym_tl;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_scale_cpu_capacity",
          "args": [
            "NULL",
            "j"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "arch_scale_cpu_capacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1872-1876",
          "snippet": "static __always_inline\nunsigned long arch_scale_cpu_capacity(void __always_unused *sd, int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic __always_inline\nunsigned long arch_scale_cpu_capacity(void __always_unused *sd, int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_and",
          "args": [
            "j",
            "tl->mask(i)",
            "cpu_map"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl->mask",
          "args": [
            "i"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "cpu_map"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_map"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic struct sched_domain_topology_level\n*asym_cpu_capacity_level(const struct cpumask *cpu_map)\n{\n\tint i, j, asym_level = 0;\n\tbool asym = false;\n\tstruct sched_domain_topology_level *tl, *asym_tl = NULL;\n\tunsigned long cap;\n\n\t/* Is there any asymmetry? */\n\tcap = arch_scale_cpu_capacity(NULL, cpumask_first(cpu_map));\n\n\tfor_each_cpu(i, cpu_map) {\n\t\tif (arch_scale_cpu_capacity(NULL, i) != cap) {\n\t\t\tasym = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!asym)\n\t\treturn NULL;\n\n\t/*\n\t * Examine topology from all CPU's point of views to detect the lowest\n\t * sched_domain_topology_level where a highest capacity CPU is visible\n\t * to everyone.\n\t */\n\tfor_each_cpu(i, cpu_map) {\n\t\tunsigned long max_capacity = arch_scale_cpu_capacity(NULL, i);\n\t\tint tl_id = 0;\n\n\t\tfor_each_sd_topology(tl) {\n\t\t\tif (tl_id < asym_level)\n\t\t\t\tgoto next_level;\n\n\t\t\tfor_each_cpu_and(j, tl->mask(i), cpu_map) {\n\t\t\t\tunsigned long capacity;\n\n\t\t\t\tcapacity = arch_scale_cpu_capacity(NULL, j);\n\n\t\t\t\tif (capacity <= max_capacity)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmax_capacity = capacity;\n\t\t\t\tasym_level = tl_id;\n\t\t\t\tasym_tl = tl;\n\t\t\t}\nnext_level:\n\t\t\ttl_id++;\n\t\t}\n\t}\n\n\treturn asym_tl;\n}"
  },
  {
    "function_name": "build_sched_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1613-1641",
    "snippet": "static struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,\n\t\tconst struct cpumask *cpu_map, struct sched_domain_attr *attr,\n\t\tstruct sched_domain *child, int dflags, int cpu)\n{\n\tstruct sched_domain *sd = sd_init(tl, cpu_map, child, dflags, cpu);\n\n\tif (child) {\n\t\tsd->level = child->level + 1;\n\t\tsched_domain_level_max = max(sched_domain_level_max, sd->level);\n\t\tchild->parent = sd;\n\n\t\tif (!cpumask_subset(sched_domain_span(child),\n\t\t\t\t    sched_domain_span(sd))) {\n\t\t\tpr_err(\"BUG: arch topology borken\\n\");\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tpr_err(\"     the %s domain not a subset of the %s domain\\n\",\n\t\t\t\t\tchild->name, sd->name);\n#endif\n\t\t\t/* Fixup, ensure @sd has at least @child CPUs. */\n\t\t\tcpumask_or(sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(child));\n\t\t}\n\n\t}\n\tset_domain_attribute(sd, attr);\n\n\treturn sd;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sched_domain_level_max;",
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_domain_attribute",
          "args": [
            "sd",
            "attr"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "set_domain_attribute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "963-982",
          "snippet": "static void set_domain_attribute(struct sched_domain *sd,\n\t\t\t\t struct sched_domain_attr *attr)\n{\n\tint request;\n\n\tif (!attr || attr->relax_domain_level < 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\telse\n\t\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->relax_domain_level;\n\tif (request < sd->level) {\n\t\t/* Turn off idle balance on this domain: */\n\t\tsd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t} else {\n\t\t/* Turn on idle balance on this domain: */\n\t\tsd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int default_relax_domain_level = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int default_relax_domain_level = -1;\n\nstatic void set_domain_attribute(struct sched_domain *sd,\n\t\t\t\t struct sched_domain_attr *attr)\n{\n\tint request;\n\n\tif (!attr || attr->relax_domain_level < 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\telse\n\t\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->relax_domain_level;\n\tif (request < sd->level) {\n\t\t/* Turn off idle balance on this domain: */\n\t\tsd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t} else {\n\t\t/* Turn on idle balance on this domain: */\n\t\tsd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "sched_domain_span(sd)",
            "sched_domain_span(sd)",
            "sched_domain_span(child)"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "child"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"     the %s domain not a subset of the %s domain\\n\"",
            "child->name",
            "sd->name"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BUG: arch topology borken\\n\""
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "sched_domain_span(child)",
            "sched_domain_span(sd)"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "child"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "sched_domain_level_max",
            "sd->level"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "253-256",
          "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_init",
          "args": [
            "tl",
            "cpu_map",
            "child",
            "dflags",
            "cpu"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "sd_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1080-1208",
          "snippet": "static struct sched_domain *\nsd_init(struct sched_domain_topology_level *tl,\n\tconst struct cpumask *cpu_map,\n\tstruct sched_domain *child, int dflags, int cpu)\n{\n\tstruct sd_data *sdd = &tl->data;\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tint sd_id, sd_weight, sd_flags = 0;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Ugly hack to pass state to sd_numa_mask()...\n\t */\n\tsched_domains_curr_level = tl->numa_level;\n#endif\n\n\tsd_weight = cpumask_weight(tl->mask(cpu));\n\n\tif (tl->sd_flags)\n\t\tsd_flags = (*tl->sd_flags)();\n\tif (WARN_ONCE(sd_flags & ~TOPOLOGY_SD_FLAGS,\n\t\t\t\"wrong sd_flags in topology description\\n\"))\n\t\tsd_flags &= ~TOPOLOGY_SD_FLAGS;\n\n\t/* Apply detected topology flags */\n\tsd_flags |= dflags;\n\n\t*sd = (struct sched_domain){\n\t\t.min_interval\t\t= sd_weight,\n\t\t.max_interval\t\t= 2*sd_weight,\n\t\t.busy_factor\t\t= 32,\n\t\t.imbalance_pct\t\t= 125,\n\n\t\t.cache_nice_tries\t= 0,\n\t\t.busy_idx\t\t= 0,\n\t\t.idle_idx\t\t= 0,\n\t\t.newidle_idx\t\t= 0,\n\t\t.wake_idx\t\t= 0,\n\t\t.forkexec_idx\t\t= 0,\n\n\t\t.flags\t\t\t= 1*SD_LOAD_BALANCE\n\t\t\t\t\t| 1*SD_BALANCE_NEWIDLE\n\t\t\t\t\t| 1*SD_BALANCE_EXEC\n\t\t\t\t\t| 1*SD_BALANCE_FORK\n\t\t\t\t\t| 0*SD_BALANCE_WAKE\n\t\t\t\t\t| 1*SD_WAKE_AFFINE\n\t\t\t\t\t| 0*SD_SHARE_CPUCAPACITY\n\t\t\t\t\t| 0*SD_SHARE_PKG_RESOURCES\n\t\t\t\t\t| 0*SD_SERIALIZE\n\t\t\t\t\t| 1*SD_PREFER_SIBLING\n\t\t\t\t\t| 0*SD_NUMA\n\t\t\t\t\t| sd_flags\n\t\t\t\t\t,\n\n\t\t.last_balance\t\t= jiffies,\n\t\t.balance_interval\t= sd_weight,\n\t\t.smt_gain\t\t= 0,\n\t\t.max_newidle_lb_cost\t= 0,\n\t\t.next_decay_max_lb_cost\t= jiffies,\n\t\t.child\t\t\t= child,\n#ifdef CONFIG_SCHED_DEBUG\n\t\t.name\t\t\t= tl->name,\n#endif\n\t};\n\n\tcpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu));\n\tsd_id = cpumask_first(sched_domain_span(sd));\n\n\t/*\n\t * Convert topological properties into behaviour.\n\t */\n\n\tif (sd->flags & SD_ASYM_CPUCAPACITY) {\n\t\tstruct sched_domain *t = sd;\n\n\t\t/*\n\t\t * Don't attempt to spread across CPUs of different capacities.\n\t\t */\n\t\tif (sd->child)\n\t\t\tsd->child->flags &= ~SD_PREFER_SIBLING;\n\n\t\tfor_each_lower_domain(t)\n\t\t\tt->flags |= SD_BALANCE_WAKE;\n\t}\n\n\tif (sd->flags & SD_SHARE_CPUCAPACITY) {\n\t\tsd->imbalance_pct = 110;\n\t\tsd->smt_gain = 1178; /* ~15% */\n\n\t} else if (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->imbalance_pct = 117;\n\t\tsd->cache_nice_tries = 1;\n\t\tsd->busy_idx = 2;\n\n#ifdef CONFIG_NUMA\n\t} else if (sd->flags & SD_NUMA) {\n\t\tsd->cache_nice_tries = 2;\n\t\tsd->busy_idx = 3;\n\t\tsd->idle_idx = 2;\n\n\t\tsd->flags &= ~SD_PREFER_SIBLING;\n\t\tsd->flags |= SD_SERIALIZE;\n\t\tif (sched_domains_numa_distance[tl->numa_level] > RECLAIM_DISTANCE) {\n\t\t\tsd->flags &= ~(SD_BALANCE_EXEC |\n\t\t\t\t       SD_BALANCE_FORK |\n\t\t\t\t       SD_WAKE_AFFINE);\n\t\t}\n\n#endif\n\t} else {\n\t\tsd->cache_nice_tries = 1;\n\t\tsd->busy_idx = 2;\n\t\tsd->idle_idx = 1;\n\t}\n\n\t/*\n\t * For all levels sharing cache; connect a sched_domain_shared\n\t * instance.\n\t */\n\tif (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->shared = *per_cpu_ptr(sdd->sds, sd_id);\n\t\tatomic_inc(&sd->shared->ref);\n\t\tatomic_set(&sd->shared->nr_busy_cpus, sd_weight);\n\t}\n\n\tsd->private = sdd;\n\n\treturn sd;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define TOPOLOGY_SD_FLAGS\t\t\\\n\t(SD_SHARE_CPUCAPACITY\t|\t\\\n\t SD_SHARE_PKG_RESOURCES |\t\\\n\t SD_NUMA\t\t|\t\\\n\t SD_ASYM_PACKING\t|\t\\\n\t SD_SHARE_POWERDOMAIN)"
          ],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define TOPOLOGY_SD_FLAGS\t\t\\\n\t(SD_SHARE_CPUCAPACITY\t|\t\\\n\t SD_SHARE_PKG_RESOURCES |\t\\\n\t SD_NUMA\t\t|\t\\\n\t SD_ASYM_PACKING\t|\t\\\n\t SD_SHARE_POWERDOMAIN)\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic struct sched_domain *\nsd_init(struct sched_domain_topology_level *tl,\n\tconst struct cpumask *cpu_map,\n\tstruct sched_domain *child, int dflags, int cpu)\n{\n\tstruct sd_data *sdd = &tl->data;\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tint sd_id, sd_weight, sd_flags = 0;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Ugly hack to pass state to sd_numa_mask()...\n\t */\n\tsched_domains_curr_level = tl->numa_level;\n#endif\n\n\tsd_weight = cpumask_weight(tl->mask(cpu));\n\n\tif (tl->sd_flags)\n\t\tsd_flags = (*tl->sd_flags)();\n\tif (WARN_ONCE(sd_flags & ~TOPOLOGY_SD_FLAGS,\n\t\t\t\"wrong sd_flags in topology description\\n\"))\n\t\tsd_flags &= ~TOPOLOGY_SD_FLAGS;\n\n\t/* Apply detected topology flags */\n\tsd_flags |= dflags;\n\n\t*sd = (struct sched_domain){\n\t\t.min_interval\t\t= sd_weight,\n\t\t.max_interval\t\t= 2*sd_weight,\n\t\t.busy_factor\t\t= 32,\n\t\t.imbalance_pct\t\t= 125,\n\n\t\t.cache_nice_tries\t= 0,\n\t\t.busy_idx\t\t= 0,\n\t\t.idle_idx\t\t= 0,\n\t\t.newidle_idx\t\t= 0,\n\t\t.wake_idx\t\t= 0,\n\t\t.forkexec_idx\t\t= 0,\n\n\t\t.flags\t\t\t= 1*SD_LOAD_BALANCE\n\t\t\t\t\t| 1*SD_BALANCE_NEWIDLE\n\t\t\t\t\t| 1*SD_BALANCE_EXEC\n\t\t\t\t\t| 1*SD_BALANCE_FORK\n\t\t\t\t\t| 0*SD_BALANCE_WAKE\n\t\t\t\t\t| 1*SD_WAKE_AFFINE\n\t\t\t\t\t| 0*SD_SHARE_CPUCAPACITY\n\t\t\t\t\t| 0*SD_SHARE_PKG_RESOURCES\n\t\t\t\t\t| 0*SD_SERIALIZE\n\t\t\t\t\t| 1*SD_PREFER_SIBLING\n\t\t\t\t\t| 0*SD_NUMA\n\t\t\t\t\t| sd_flags\n\t\t\t\t\t,\n\n\t\t.last_balance\t\t= jiffies,\n\t\t.balance_interval\t= sd_weight,\n\t\t.smt_gain\t\t= 0,\n\t\t.max_newidle_lb_cost\t= 0,\n\t\t.next_decay_max_lb_cost\t= jiffies,\n\t\t.child\t\t\t= child,\n#ifdef CONFIG_SCHED_DEBUG\n\t\t.name\t\t\t= tl->name,\n#endif\n\t};\n\n\tcpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu));\n\tsd_id = cpumask_first(sched_domain_span(sd));\n\n\t/*\n\t * Convert topological properties into behaviour.\n\t */\n\n\tif (sd->flags & SD_ASYM_CPUCAPACITY) {\n\t\tstruct sched_domain *t = sd;\n\n\t\t/*\n\t\t * Don't attempt to spread across CPUs of different capacities.\n\t\t */\n\t\tif (sd->child)\n\t\t\tsd->child->flags &= ~SD_PREFER_SIBLING;\n\n\t\tfor_each_lower_domain(t)\n\t\t\tt->flags |= SD_BALANCE_WAKE;\n\t}\n\n\tif (sd->flags & SD_SHARE_CPUCAPACITY) {\n\t\tsd->imbalance_pct = 110;\n\t\tsd->smt_gain = 1178; /* ~15% */\n\n\t} else if (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->imbalance_pct = 117;\n\t\tsd->cache_nice_tries = 1;\n\t\tsd->busy_idx = 2;\n\n#ifdef CONFIG_NUMA\n\t} else if (sd->flags & SD_NUMA) {\n\t\tsd->cache_nice_tries = 2;\n\t\tsd->busy_idx = 3;\n\t\tsd->idle_idx = 2;\n\n\t\tsd->flags &= ~SD_PREFER_SIBLING;\n\t\tsd->flags |= SD_SERIALIZE;\n\t\tif (sched_domains_numa_distance[tl->numa_level] > RECLAIM_DISTANCE) {\n\t\t\tsd->flags &= ~(SD_BALANCE_EXEC |\n\t\t\t\t       SD_BALANCE_FORK |\n\t\t\t\t       SD_WAKE_AFFINE);\n\t\t}\n\n#endif\n\t} else {\n\t\tsd->cache_nice_tries = 1;\n\t\tsd->busy_idx = 2;\n\t\tsd->idle_idx = 1;\n\t}\n\n\t/*\n\t * For all levels sharing cache; connect a sched_domain_shared\n\t * instance.\n\t */\n\tif (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->shared = *per_cpu_ptr(sdd->sds, sd_id);\n\t\tatomic_inc(&sd->shared->ref);\n\t\tatomic_set(&sd->shared->nr_busy_cpus, sd_weight);\n\t}\n\n\tsd->private = sdd;\n\n\treturn sd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint sched_domain_level_max;\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic struct sched_domain *build_sched_domain(struct sched_domain_topology_level *tl,\n\t\tconst struct cpumask *cpu_map, struct sched_domain_attr *attr,\n\t\tstruct sched_domain *child, int dflags, int cpu)\n{\n\tstruct sched_domain *sd = sd_init(tl, cpu_map, child, dflags, cpu);\n\n\tif (child) {\n\t\tsd->level = child->level + 1;\n\t\tsched_domain_level_max = max(sched_domain_level_max, sd->level);\n\t\tchild->parent = sd;\n\n\t\tif (!cpumask_subset(sched_domain_span(child),\n\t\t\t\t    sched_domain_span(sd))) {\n\t\t\tpr_err(\"BUG: arch topology borken\\n\");\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tpr_err(\"     the %s domain not a subset of the %s domain\\n\",\n\t\t\t\t\tchild->name, sd->name);\n#endif\n\t\t\t/* Fixup, ensure @sd has at least @child CPUs. */\n\t\t\tcpumask_or(sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(sd),\n\t\t\t\t   sched_domain_span(child));\n\t\t}\n\n\t}\n\tset_domain_attribute(sd, attr);\n\n\treturn sd;\n}"
  },
  {
    "function_name": "__sdt_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1577-1611",
    "snippet": "static void __sdt_free(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\n\t\t\tif (sdd->sd) {\n\t\t\t\tsd = *per_cpu_ptr(sdd->sd, j);\n\t\t\t\tif (sd && (sd->flags & SD_OVERLAP))\n\t\t\t\t\tfree_sched_groups(sd->groups, 0);\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sd, j));\n\t\t\t}\n\n\t\t\tif (sdd->sds)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sds, j));\n\t\t\tif (sdd->sg)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sg, j));\n\t\t\tif (sdd->sgc)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sgc, j));\n\t\t}\n\t\tfree_percpu(sdd->sd);\n\t\tsdd->sd = NULL;\n\t\tfree_percpu(sdd->sds);\n\t\tsdd->sds = NULL;\n\t\tfree_percpu(sdd->sg);\n\t\tsdd->sg = NULL;\n\t\tfree_percpu(sdd->sgc);\n\t\tsdd->sgc = NULL;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "sdd->sgc"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*per_cpu_ptr(sdd->sgc, j)"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "j"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sg",
            "j"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sds",
            "j"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "j"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_sched_groups",
          "args": [
            "sd->groups",
            "0"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "free_sched_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "335-353",
          "snippet": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "j"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "j",
            "cpu_map"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void __sdt_free(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\n\t\t\tif (sdd->sd) {\n\t\t\t\tsd = *per_cpu_ptr(sdd->sd, j);\n\t\t\t\tif (sd && (sd->flags & SD_OVERLAP))\n\t\t\t\t\tfree_sched_groups(sd->groups, 0);\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sd, j));\n\t\t\t}\n\n\t\t\tif (sdd->sds)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sds, j));\n\t\t\tif (sdd->sg)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sg, j));\n\t\t\tif (sdd->sgc)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sgc, j));\n\t\t}\n\t\tfree_percpu(sdd->sd);\n\t\tsdd->sd = NULL;\n\t\tfree_percpu(sdd->sds);\n\t\tsdd->sds = NULL;\n\t\tfree_percpu(sdd->sg);\n\t\tsdd->sg = NULL;\n\t\tfree_percpu(sdd->sgc);\n\t\tsdd->sgc = NULL;\n\t}\n}"
  },
  {
    "function_name": "__sdt_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1508-1575",
    "snippet": "static int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tsdd->sd = alloc_percpu(struct sched_domain *);\n\t\tif (!sdd->sd)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sds = alloc_percpu(struct sched_domain_shared *);\n\t\tif (!sdd->sds)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sg = alloc_percpu(struct sched_group *);\n\t\tif (!sdd->sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sgc = alloc_percpu(struct sched_group_capacity *);\n\t\tif (!sdd->sgc)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\t\t\tstruct sched_domain_shared *sds;\n\t\t\tstruct sched_group *sg;\n\t\t\tstruct sched_group_capacity *sgc;\n\n\t\t\tsd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sd, j) = sd;\n\n\t\t\tsds = kzalloc_node(sizeof(struct sched_domain_shared),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sds)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sds, j) = sds;\n\n\t\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsg->next = sg;\n\n\t\t\t*per_cpu_ptr(sdd->sg, j) = sg;\n\n\t\t\tsgc = kzalloc_node(sizeof(struct sched_group_capacity) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sgc)\n\t\t\t\treturn -ENOMEM;\n\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tsgc->id = j;\n#endif\n\n\t\t\t*per_cpu_ptr(sdd->sgc, j) = sgc;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "j"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(struct sched_group_capacity) + cpumask_size()",
            "GFP_KERNEL",
            "cpu_to_node(j)"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "j"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sg",
            "j"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(struct sched_group) + cpumask_size()",
            "GFP_KERNEL",
            "cpu_to_node(j)"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "j"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sds",
            "j"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(struct sched_domain_shared)",
            "GFP_KERNEL",
            "cpu_to_node(j)"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "j"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "j"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(struct sched_domain) + cpumask_size()",
            "GFP_KERNEL",
            "cpu_to_node(j)"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "j"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "j",
            "cpu_map"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "struct sched_group_capacity *"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tsdd->sd = alloc_percpu(struct sched_domain *);\n\t\tif (!sdd->sd)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sds = alloc_percpu(struct sched_domain_shared *);\n\t\tif (!sdd->sds)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sg = alloc_percpu(struct sched_group *);\n\t\tif (!sdd->sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sgc = alloc_percpu(struct sched_group_capacity *);\n\t\tif (!sdd->sgc)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\t\t\tstruct sched_domain_shared *sds;\n\t\t\tstruct sched_group *sg;\n\t\t\tstruct sched_group_capacity *sgc;\n\n\t\t\tsd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sd, j) = sd;\n\n\t\t\tsds = kzalloc_node(sizeof(struct sched_domain_shared),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sds)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sds, j) = sds;\n\n\t\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsg->next = sg;\n\n\t\t\t*per_cpu_ptr(sdd->sg, j) = sg;\n\n\t\t\tsgc = kzalloc_node(sizeof(struct sched_group_capacity) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sgc)\n\t\t\t\treturn -ENOMEM;\n\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tsgc->id = j;\n#endif\n\n\t\t\t*per_cpu_ptr(sdd->sgc, j) = sgc;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_domains_numa_masks_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1496-1504",
    "snippet": "void sched_domains_numa_masks_clear(unsigned int cpu)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tcpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "sched_domains_numa_masks[i][j]"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid sched_domains_numa_masks_clear(unsigned int cpu)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tcpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t}\n}"
  },
  {
    "function_name": "sched_domains_numa_masks_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1483-1494",
    "snippet": "void sched_domains_numa_masks_set(unsigned int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (node_distance(j, node) <= sched_domains_numa_distance[i])\n\t\t\t\tcpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "sched_domains_numa_masks[i][j]"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "j",
            "node"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid sched_domains_numa_masks_set(unsigned int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tint i, j;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (node_distance(j, node) <= sched_domains_numa_distance[i])\n\t\t\t\tcpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "sched_init_numa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1333-1481",
    "snippet": "void sched_init_numa(void)\n{\n\tint next_distance, curr_distance = node_distance(0, 0);\n\tstruct sched_domain_topology_level *tl;\n\tint level = 0;\n\tint i, j, k;\n\n\tsched_domains_numa_distance = kzalloc(sizeof(int) * (nr_node_ids + 1), GFP_KERNEL);\n\tif (!sched_domains_numa_distance)\n\t\treturn;\n\n\t/* Includes NUMA identity node at level 0. */\n\tsched_domains_numa_distance[level++] = curr_distance;\n\tsched_domains_numa_levels = level;\n\n\t/*\n\t * O(nr_nodes^2) deduplicating selection sort -- in order to find the\n\t * unique distances in the node_distance() table.\n\t *\n\t * Assumes node_distance(0,j) includes all distances in\n\t * node_distance(i,j) in order to avoid cubic time.\n\t */\n\tnext_distance = curr_distance;\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tfor (k = 0; k < nr_node_ids; k++) {\n\t\t\t\tint distance = node_distance(i, k);\n\n\t\t\t\tif (distance > curr_distance &&\n\t\t\t\t    (distance < next_distance ||\n\t\t\t\t     next_distance == curr_distance))\n\t\t\t\t\tnext_distance = distance;\n\n\t\t\t\t/*\n\t\t\t\t * While not a strong assumption it would be nice to know\n\t\t\t\t * about cases where if node A is connected to B, B is not\n\t\t\t\t * equally connected to A.\n\t\t\t\t */\n\t\t\t\tif (sched_debug() && node_distance(k, i) != distance)\n\t\t\t\t\tsched_numa_warn(\"Node-distance not symmetric\");\n\n\t\t\t\tif (sched_debug() && i && !find_numa_distance(distance))\n\t\t\t\t\tsched_numa_warn(\"Node-0 not representative\");\n\t\t\t}\n\t\t\tif (next_distance != curr_distance) {\n\t\t\t\tsched_domains_numa_distance[level++] = next_distance;\n\t\t\t\tsched_domains_numa_levels = level;\n\t\t\t\tcurr_distance = next_distance;\n\t\t\t} else break;\n\t\t}\n\n\t\t/*\n\t\t * In case of sched_debug() we verify the above assumption.\n\t\t */\n\t\tif (!sched_debug())\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * 'level' contains the number of unique distances\n\t *\n\t * The sched_domains_numa_distance[] array includes the actual distance\n\t * numbers.\n\t */\n\n\t/*\n\t * Here, we should temporarily reset sched_domains_numa_levels to 0.\n\t * If it fails to allocate memory for array sched_domains_numa_masks[][],\n\t * the array will contain less then 'level' members. This could be\n\t * dangerous when we use it to iterate array sched_domains_numa_masks[][]\n\t * in other functions.\n\t *\n\t * We reset it to 'level' at the end of this function.\n\t */\n\tsched_domains_numa_levels = 0;\n\n\tsched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL);\n\tif (!sched_domains_numa_masks)\n\t\treturn;\n\n\t/*\n\t * Now for each level, construct a mask per node which contains all\n\t * CPUs of nodes that are that many hops away from us.\n\t */\n\tfor (i = 0; i < level; i++) {\n\t\tsched_domains_numa_masks[i] =\n\t\t\tkzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL);\n\t\tif (!sched_domains_numa_masks[i])\n\t\t\treturn;\n\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tstruct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL);\n\t\t\tif (!mask)\n\t\t\t\treturn;\n\n\t\t\tsched_domains_numa_masks[i][j] = mask;\n\n\t\t\tfor_each_node(k) {\n\t\t\t\tif (node_distance(j, k) > sched_domains_numa_distance[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcpumask_or(mask, mask, cpumask_of_node(k));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compute default topology size */\n\tfor (i = 0; sched_domain_topology[i].mask; i++);\n\n\ttl = kzalloc((i + level + 1) *\n\t\t\tsizeof(struct sched_domain_topology_level), GFP_KERNEL);\n\tif (!tl)\n\t\treturn;\n\n\t/*\n\t * Copy the default topology bits..\n\t */\n\tfor (i = 0; sched_domain_topology[i].mask; i++)\n\t\ttl[i] = sched_domain_topology[i];\n\n\t/*\n\t * Add the NUMA identity distance, aka single NODE.\n\t */\n\ttl[i++] = (struct sched_domain_topology_level){\n\t\t.mask = sd_numa_mask,\n\t\t.numa_level = 0,\n\t\tSD_INIT_NAME(NODE)\n\t};\n\n\t/*\n\t * .. and append 'j' levels of NUMA goodness.\n\t */\n\tfor (j = 1; j < level; i++, j++) {\n\t\ttl[i] = (struct sched_domain_topology_level){\n\t\t\t.mask = sd_numa_mask,\n\t\t\t.sd_flags = cpu_numa_flags,\n\t\t\t.flags = SDTL_OVERLAP,\n\t\t\t.numa_level = j,\n\t\t\tSD_INIT_NAME(NUMA)\n\t\t};\n\t}\n\n\tsched_domain_topology = tl;\n\n\tsched_domains_numa_levels = level;\n\tsched_max_numa_distance = sched_domains_numa_distance[level - 1];\n\n\tinit_numa_topology_type();\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_numa_topology_type",
          "args": [],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "init_numa_topology_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1300-1331",
          "snippet": "static void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (sched_domains_numa_levels <= 2) {\n\t\tsched_numa_topology_type = NUMA_DIRECT;\n\t\treturn;\n\t}\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t/* Find two nodes furthest removed from each other. */\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t/* Is there an intermediary node between a and b? */\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tNUMA_GLUELESS_MESH;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = NUMA_BACKPLANE;\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (sched_domains_numa_levels <= 2) {\n\t\tsched_numa_topology_type = NUMA_DIRECT;\n\t\treturn;\n\t}\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t/* Find two nodes furthest removed from each other. */\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t/* Is there an intermediary node between a and b? */\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tNUMA_GLUELESS_MESH;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = NUMA_BACKPLANE;\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SD_INIT_NAME",
          "args": [
            "NUMA"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SD_INIT_NAME",
          "args": [
            "NODE"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "(i + level + 1) *\n\t\t\tsizeof(struct sched_domain_topology_level)",
            "GFP_KERNEL"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "mask",
            "mask",
            "cpumask_of_node(k)"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "k"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "j",
            "k"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "cpumask_size()",
            "GFP_KERNEL"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "nr_node_ids * sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(void *) * level",
            "GFP_KERNEL"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_debug",
          "args": [],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "sched_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "142-145",
          "snippet": "static inline bool sched_debug(void)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline bool sched_debug(void)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_numa_warn",
          "args": [
            "\"Node-0 not representative\""
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "sched_numa_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1245-1264",
          "snippet": "static void sched_numa_warn(const char *str)\n{\n\tstatic int done = false;\n\tint i,j;\n\n\tif (done)\n\t\treturn;\n\n\tdone = true;\n\n\tprintk(KERN_WARNING \"ERROR: %s\\n\\n\", str);\n\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tprintk(KERN_WARNING \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(KERN_CONT \"%02d \", node_distance(i,j));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tprintk(KERN_WARNING \"\\n\");\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_numa_warn(const char *str)\n{\n\tstatic int done = false;\n\tint i,j;\n\n\tif (done)\n\t\treturn;\n\n\tdone = true;\n\n\tprintk(KERN_WARNING \"ERROR: %s\\n\\n\", str);\n\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tprintk(KERN_WARNING \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(KERN_CONT \"%02d \", node_distance(i,j));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tprintk(KERN_WARNING \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_numa_distance",
          "args": [
            "distance"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "find_numa_distance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1266-1279",
          "snippet": "bool find_numa_distance(int distance)\n{\n\tint i;\n\n\tif (distance == node_distance(0, 0))\n\t\treturn true;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tif (sched_domains_numa_distance[i] == distance)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool find_numa_distance(int distance)\n{\n\tint i;\n\n\tif (distance == node_distance(0, 0))\n\t\treturn true;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tif (sched_domains_numa_distance[i] == distance)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "k",
            "i"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "i",
            "k"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(int) * (nr_node_ids + 1)",
            "GFP_KERNEL"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "0",
            "0"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nvoid sched_init_numa(void)\n{\n\tint next_distance, curr_distance = node_distance(0, 0);\n\tstruct sched_domain_topology_level *tl;\n\tint level = 0;\n\tint i, j, k;\n\n\tsched_domains_numa_distance = kzalloc(sizeof(int) * (nr_node_ids + 1), GFP_KERNEL);\n\tif (!sched_domains_numa_distance)\n\t\treturn;\n\n\t/* Includes NUMA identity node at level 0. */\n\tsched_domains_numa_distance[level++] = curr_distance;\n\tsched_domains_numa_levels = level;\n\n\t/*\n\t * O(nr_nodes^2) deduplicating selection sort -- in order to find the\n\t * unique distances in the node_distance() table.\n\t *\n\t * Assumes node_distance(0,j) includes all distances in\n\t * node_distance(i,j) in order to avoid cubic time.\n\t */\n\tnext_distance = curr_distance;\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tfor (k = 0; k < nr_node_ids; k++) {\n\t\t\t\tint distance = node_distance(i, k);\n\n\t\t\t\tif (distance > curr_distance &&\n\t\t\t\t    (distance < next_distance ||\n\t\t\t\t     next_distance == curr_distance))\n\t\t\t\t\tnext_distance = distance;\n\n\t\t\t\t/*\n\t\t\t\t * While not a strong assumption it would be nice to know\n\t\t\t\t * about cases where if node A is connected to B, B is not\n\t\t\t\t * equally connected to A.\n\t\t\t\t */\n\t\t\t\tif (sched_debug() && node_distance(k, i) != distance)\n\t\t\t\t\tsched_numa_warn(\"Node-distance not symmetric\");\n\n\t\t\t\tif (sched_debug() && i && !find_numa_distance(distance))\n\t\t\t\t\tsched_numa_warn(\"Node-0 not representative\");\n\t\t\t}\n\t\t\tif (next_distance != curr_distance) {\n\t\t\t\tsched_domains_numa_distance[level++] = next_distance;\n\t\t\t\tsched_domains_numa_levels = level;\n\t\t\t\tcurr_distance = next_distance;\n\t\t\t} else break;\n\t\t}\n\n\t\t/*\n\t\t * In case of sched_debug() we verify the above assumption.\n\t\t */\n\t\tif (!sched_debug())\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * 'level' contains the number of unique distances\n\t *\n\t * The sched_domains_numa_distance[] array includes the actual distance\n\t * numbers.\n\t */\n\n\t/*\n\t * Here, we should temporarily reset sched_domains_numa_levels to 0.\n\t * If it fails to allocate memory for array sched_domains_numa_masks[][],\n\t * the array will contain less then 'level' members. This could be\n\t * dangerous when we use it to iterate array sched_domains_numa_masks[][]\n\t * in other functions.\n\t *\n\t * We reset it to 'level' at the end of this function.\n\t */\n\tsched_domains_numa_levels = 0;\n\n\tsched_domains_numa_masks = kzalloc(sizeof(void *) * level, GFP_KERNEL);\n\tif (!sched_domains_numa_masks)\n\t\treturn;\n\n\t/*\n\t * Now for each level, construct a mask per node which contains all\n\t * CPUs of nodes that are that many hops away from us.\n\t */\n\tfor (i = 0; i < level; i++) {\n\t\tsched_domains_numa_masks[i] =\n\t\t\tkzalloc(nr_node_ids * sizeof(void *), GFP_KERNEL);\n\t\tif (!sched_domains_numa_masks[i])\n\t\t\treturn;\n\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tstruct cpumask *mask = kzalloc(cpumask_size(), GFP_KERNEL);\n\t\t\tif (!mask)\n\t\t\t\treturn;\n\n\t\t\tsched_domains_numa_masks[i][j] = mask;\n\n\t\t\tfor_each_node(k) {\n\t\t\t\tif (node_distance(j, k) > sched_domains_numa_distance[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcpumask_or(mask, mask, cpumask_of_node(k));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compute default topology size */\n\tfor (i = 0; sched_domain_topology[i].mask; i++);\n\n\ttl = kzalloc((i + level + 1) *\n\t\t\tsizeof(struct sched_domain_topology_level), GFP_KERNEL);\n\tif (!tl)\n\t\treturn;\n\n\t/*\n\t * Copy the default topology bits..\n\t */\n\tfor (i = 0; sched_domain_topology[i].mask; i++)\n\t\ttl[i] = sched_domain_topology[i];\n\n\t/*\n\t * Add the NUMA identity distance, aka single NODE.\n\t */\n\ttl[i++] = (struct sched_domain_topology_level){\n\t\t.mask = sd_numa_mask,\n\t\t.numa_level = 0,\n\t\tSD_INIT_NAME(NODE)\n\t};\n\n\t/*\n\t * .. and append 'j' levels of NUMA goodness.\n\t */\n\tfor (j = 1; j < level; i++, j++) {\n\t\ttl[i] = (struct sched_domain_topology_level){\n\t\t\t.mask = sd_numa_mask,\n\t\t\t.sd_flags = cpu_numa_flags,\n\t\t\t.flags = SDTL_OVERLAP,\n\t\t\t.numa_level = j,\n\t\t\tSD_INIT_NAME(NUMA)\n\t\t};\n\t}\n\n\tsched_domain_topology = tl;\n\n\tsched_domains_numa_levels = level;\n\tsched_max_numa_distance = sched_domains_numa_distance[level - 1];\n\n\tinit_numa_topology_type();\n}"
  },
  {
    "function_name": "init_numa_topology_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1300-1331",
    "snippet": "static void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (sched_domains_numa_levels <= 2) {\n\t\tsched_numa_topology_type = NUMA_DIRECT;\n\t\treturn;\n\t}\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t/* Find two nodes furthest removed from each other. */\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t/* Is there an intermediary node between a and b? */\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tNUMA_GLUELESS_MESH;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = NUMA_BACKPLANE;\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "b",
            "c"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "a",
            "c"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "a",
            "b"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (sched_domains_numa_levels <= 2) {\n\t\tsched_numa_topology_type = NUMA_DIRECT;\n\t\treturn;\n\t}\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t/* Find two nodes furthest removed from each other. */\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t/* Is there an intermediary node between a and b? */\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tNUMA_GLUELESS_MESH;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = NUMA_BACKPLANE;\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "find_numa_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1266-1279",
    "snippet": "bool find_numa_distance(int distance)\n{\n\tint i;\n\n\tif (distance == node_distance(0, 0))\n\t\treturn true;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tif (sched_domains_numa_distance[i] == distance)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "0",
            "0"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nbool find_numa_distance(int distance)\n{\n\tint i;\n\n\tif (distance == node_distance(0, 0))\n\t\treturn true;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tif (sched_domains_numa_distance[i] == distance)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "sched_numa_warn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1245-1264",
    "snippet": "static void sched_numa_warn(const char *str)\n{\n\tstatic int done = false;\n\tint i,j;\n\n\tif (done)\n\t\treturn;\n\n\tdone = true;\n\n\tprintk(KERN_WARNING \"ERROR: %s\\n\\n\", str);\n\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tprintk(KERN_WARNING \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(KERN_CONT \"%02d \", node_distance(i,j));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tprintk(KERN_WARNING \"\\n\");\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"\\n\""
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%02d \"",
            "node_distance(i,j)"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "i",
            "j"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void sched_numa_warn(const char *str)\n{\n\tstatic int done = false;\n\tint i,j;\n\n\tif (done)\n\t\treturn;\n\n\tdone = true;\n\n\tprintk(KERN_WARNING \"ERROR: %s\\n\\n\", str);\n\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tprintk(KERN_WARNING \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(KERN_CONT \"%02d \", node_distance(i,j));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\tprintk(KERN_WARNING \"\\n\");\n}"
  },
  {
    "function_name": "sd_numa_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1240-1243",
    "snippet": "static const struct cpumask *sd_numa_mask(int cpu)\n{\n\treturn sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)];\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic const struct cpumask *sd_numa_mask(int cpu)\n{\n\treturn sched_domains_numa_masks[sched_domains_curr_level][cpu_to_node(cpu)];\n}"
  },
  {
    "function_name": "set_sched_topology",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1230-1236",
    "snippet": "void set_sched_topology(struct sched_domain_topology_level *tl)\n{\n\tif (WARN_ON_ONCE(sched_smp_initialized))\n\t\treturn;\n\n\tsched_domain_topology = tl;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "sched_smp_initialized"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic struct sched_domain_topology_level *sched_domain_topology =\n\tdefault_topology;\n\nvoid set_sched_topology(struct sched_domain_topology_level *tl)\n{\n\tif (WARN_ON_ONCE(sched_smp_initialized))\n\t\treturn;\n\n\tsched_domain_topology = tl;\n}"
  },
  {
    "function_name": "sd_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1080-1208",
    "snippet": "static struct sched_domain *\nsd_init(struct sched_domain_topology_level *tl,\n\tconst struct cpumask *cpu_map,\n\tstruct sched_domain *child, int dflags, int cpu)\n{\n\tstruct sd_data *sdd = &tl->data;\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tint sd_id, sd_weight, sd_flags = 0;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Ugly hack to pass state to sd_numa_mask()...\n\t */\n\tsched_domains_curr_level = tl->numa_level;\n#endif\n\n\tsd_weight = cpumask_weight(tl->mask(cpu));\n\n\tif (tl->sd_flags)\n\t\tsd_flags = (*tl->sd_flags)();\n\tif (WARN_ONCE(sd_flags & ~TOPOLOGY_SD_FLAGS,\n\t\t\t\"wrong sd_flags in topology description\\n\"))\n\t\tsd_flags &= ~TOPOLOGY_SD_FLAGS;\n\n\t/* Apply detected topology flags */\n\tsd_flags |= dflags;\n\n\t*sd = (struct sched_domain){\n\t\t.min_interval\t\t= sd_weight,\n\t\t.max_interval\t\t= 2*sd_weight,\n\t\t.busy_factor\t\t= 32,\n\t\t.imbalance_pct\t\t= 125,\n\n\t\t.cache_nice_tries\t= 0,\n\t\t.busy_idx\t\t= 0,\n\t\t.idle_idx\t\t= 0,\n\t\t.newidle_idx\t\t= 0,\n\t\t.wake_idx\t\t= 0,\n\t\t.forkexec_idx\t\t= 0,\n\n\t\t.flags\t\t\t= 1*SD_LOAD_BALANCE\n\t\t\t\t\t| 1*SD_BALANCE_NEWIDLE\n\t\t\t\t\t| 1*SD_BALANCE_EXEC\n\t\t\t\t\t| 1*SD_BALANCE_FORK\n\t\t\t\t\t| 0*SD_BALANCE_WAKE\n\t\t\t\t\t| 1*SD_WAKE_AFFINE\n\t\t\t\t\t| 0*SD_SHARE_CPUCAPACITY\n\t\t\t\t\t| 0*SD_SHARE_PKG_RESOURCES\n\t\t\t\t\t| 0*SD_SERIALIZE\n\t\t\t\t\t| 1*SD_PREFER_SIBLING\n\t\t\t\t\t| 0*SD_NUMA\n\t\t\t\t\t| sd_flags\n\t\t\t\t\t,\n\n\t\t.last_balance\t\t= jiffies,\n\t\t.balance_interval\t= sd_weight,\n\t\t.smt_gain\t\t= 0,\n\t\t.max_newidle_lb_cost\t= 0,\n\t\t.next_decay_max_lb_cost\t= jiffies,\n\t\t.child\t\t\t= child,\n#ifdef CONFIG_SCHED_DEBUG\n\t\t.name\t\t\t= tl->name,\n#endif\n\t};\n\n\tcpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu));\n\tsd_id = cpumask_first(sched_domain_span(sd));\n\n\t/*\n\t * Convert topological properties into behaviour.\n\t */\n\n\tif (sd->flags & SD_ASYM_CPUCAPACITY) {\n\t\tstruct sched_domain *t = sd;\n\n\t\t/*\n\t\t * Don't attempt to spread across CPUs of different capacities.\n\t\t */\n\t\tif (sd->child)\n\t\t\tsd->child->flags &= ~SD_PREFER_SIBLING;\n\n\t\tfor_each_lower_domain(t)\n\t\t\tt->flags |= SD_BALANCE_WAKE;\n\t}\n\n\tif (sd->flags & SD_SHARE_CPUCAPACITY) {\n\t\tsd->imbalance_pct = 110;\n\t\tsd->smt_gain = 1178; /* ~15% */\n\n\t} else if (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->imbalance_pct = 117;\n\t\tsd->cache_nice_tries = 1;\n\t\tsd->busy_idx = 2;\n\n#ifdef CONFIG_NUMA\n\t} else if (sd->flags & SD_NUMA) {\n\t\tsd->cache_nice_tries = 2;\n\t\tsd->busy_idx = 3;\n\t\tsd->idle_idx = 2;\n\n\t\tsd->flags &= ~SD_PREFER_SIBLING;\n\t\tsd->flags |= SD_SERIALIZE;\n\t\tif (sched_domains_numa_distance[tl->numa_level] > RECLAIM_DISTANCE) {\n\t\t\tsd->flags &= ~(SD_BALANCE_EXEC |\n\t\t\t\t       SD_BALANCE_FORK |\n\t\t\t\t       SD_WAKE_AFFINE);\n\t\t}\n\n#endif\n\t} else {\n\t\tsd->cache_nice_tries = 1;\n\t\tsd->busy_idx = 2;\n\t\tsd->idle_idx = 1;\n\t}\n\n\t/*\n\t * For all levels sharing cache; connect a sched_domain_shared\n\t * instance.\n\t */\n\tif (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->shared = *per_cpu_ptr(sdd->sds, sd_id);\n\t\tatomic_inc(&sd->shared->ref);\n\t\tatomic_set(&sd->shared->nr_busy_cpus, sd_weight);\n\t}\n\n\tsd->private = sdd;\n\n\treturn sd;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define TOPOLOGY_SD_FLAGS\t\t\\\n\t(SD_SHARE_CPUCAPACITY\t|\t\\\n\t SD_SHARE_PKG_RESOURCES |\t\\\n\t SD_NUMA\t\t|\t\\\n\t SD_ASYM_PACKING\t|\t\\\n\t SD_SHARE_POWERDOMAIN)"
    ],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sd->shared->nr_busy_cpus",
            "sd_weight"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sd->shared->ref"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sds",
            "sd_id"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "sched_domain_span(sd)",
            "cpu_map",
            "tl->mask(cpu)"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl->mask",
          "args": [
            "cpu"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "sd_flags & ~TOPOLOGY_SD_FLAGS",
            "\"wrong sd_flags in topology description\\n\""
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "tl->mask(cpu)"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tl->mask",
          "args": [
            "cpu"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "cpu"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define TOPOLOGY_SD_FLAGS\t\t\\\n\t(SD_SHARE_CPUCAPACITY\t|\t\\\n\t SD_SHARE_PKG_RESOURCES |\t\\\n\t SD_NUMA\t\t|\t\\\n\t SD_ASYM_PACKING\t|\t\\\n\t SD_SHARE_POWERDOMAIN)\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic struct sched_domain *\nsd_init(struct sched_domain_topology_level *tl,\n\tconst struct cpumask *cpu_map,\n\tstruct sched_domain *child, int dflags, int cpu)\n{\n\tstruct sd_data *sdd = &tl->data;\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tint sd_id, sd_weight, sd_flags = 0;\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Ugly hack to pass state to sd_numa_mask()...\n\t */\n\tsched_domains_curr_level = tl->numa_level;\n#endif\n\n\tsd_weight = cpumask_weight(tl->mask(cpu));\n\n\tif (tl->sd_flags)\n\t\tsd_flags = (*tl->sd_flags)();\n\tif (WARN_ONCE(sd_flags & ~TOPOLOGY_SD_FLAGS,\n\t\t\t\"wrong sd_flags in topology description\\n\"))\n\t\tsd_flags &= ~TOPOLOGY_SD_FLAGS;\n\n\t/* Apply detected topology flags */\n\tsd_flags |= dflags;\n\n\t*sd = (struct sched_domain){\n\t\t.min_interval\t\t= sd_weight,\n\t\t.max_interval\t\t= 2*sd_weight,\n\t\t.busy_factor\t\t= 32,\n\t\t.imbalance_pct\t\t= 125,\n\n\t\t.cache_nice_tries\t= 0,\n\t\t.busy_idx\t\t= 0,\n\t\t.idle_idx\t\t= 0,\n\t\t.newidle_idx\t\t= 0,\n\t\t.wake_idx\t\t= 0,\n\t\t.forkexec_idx\t\t= 0,\n\n\t\t.flags\t\t\t= 1*SD_LOAD_BALANCE\n\t\t\t\t\t| 1*SD_BALANCE_NEWIDLE\n\t\t\t\t\t| 1*SD_BALANCE_EXEC\n\t\t\t\t\t| 1*SD_BALANCE_FORK\n\t\t\t\t\t| 0*SD_BALANCE_WAKE\n\t\t\t\t\t| 1*SD_WAKE_AFFINE\n\t\t\t\t\t| 0*SD_SHARE_CPUCAPACITY\n\t\t\t\t\t| 0*SD_SHARE_PKG_RESOURCES\n\t\t\t\t\t| 0*SD_SERIALIZE\n\t\t\t\t\t| 1*SD_PREFER_SIBLING\n\t\t\t\t\t| 0*SD_NUMA\n\t\t\t\t\t| sd_flags\n\t\t\t\t\t,\n\n\t\t.last_balance\t\t= jiffies,\n\t\t.balance_interval\t= sd_weight,\n\t\t.smt_gain\t\t= 0,\n\t\t.max_newidle_lb_cost\t= 0,\n\t\t.next_decay_max_lb_cost\t= jiffies,\n\t\t.child\t\t\t= child,\n#ifdef CONFIG_SCHED_DEBUG\n\t\t.name\t\t\t= tl->name,\n#endif\n\t};\n\n\tcpumask_and(sched_domain_span(sd), cpu_map, tl->mask(cpu));\n\tsd_id = cpumask_first(sched_domain_span(sd));\n\n\t/*\n\t * Convert topological properties into behaviour.\n\t */\n\n\tif (sd->flags & SD_ASYM_CPUCAPACITY) {\n\t\tstruct sched_domain *t = sd;\n\n\t\t/*\n\t\t * Don't attempt to spread across CPUs of different capacities.\n\t\t */\n\t\tif (sd->child)\n\t\t\tsd->child->flags &= ~SD_PREFER_SIBLING;\n\n\t\tfor_each_lower_domain(t)\n\t\t\tt->flags |= SD_BALANCE_WAKE;\n\t}\n\n\tif (sd->flags & SD_SHARE_CPUCAPACITY) {\n\t\tsd->imbalance_pct = 110;\n\t\tsd->smt_gain = 1178; /* ~15% */\n\n\t} else if (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->imbalance_pct = 117;\n\t\tsd->cache_nice_tries = 1;\n\t\tsd->busy_idx = 2;\n\n#ifdef CONFIG_NUMA\n\t} else if (sd->flags & SD_NUMA) {\n\t\tsd->cache_nice_tries = 2;\n\t\tsd->busy_idx = 3;\n\t\tsd->idle_idx = 2;\n\n\t\tsd->flags &= ~SD_PREFER_SIBLING;\n\t\tsd->flags |= SD_SERIALIZE;\n\t\tif (sched_domains_numa_distance[tl->numa_level] > RECLAIM_DISTANCE) {\n\t\t\tsd->flags &= ~(SD_BALANCE_EXEC |\n\t\t\t\t       SD_BALANCE_FORK |\n\t\t\t\t       SD_WAKE_AFFINE);\n\t\t}\n\n#endif\n\t} else {\n\t\tsd->cache_nice_tries = 1;\n\t\tsd->busy_idx = 2;\n\t\tsd->idle_idx = 1;\n\t}\n\n\t/*\n\t * For all levels sharing cache; connect a sched_domain_shared\n\t * instance.\n\t */\n\tif (sd->flags & SD_SHARE_PKG_RESOURCES) {\n\t\tsd->shared = *per_cpu_ptr(sdd->sds, sd_id);\n\t\tatomic_inc(&sd->shared->ref);\n\t\tatomic_set(&sd->shared->nr_busy_cpus, sd_weight);\n\t}\n\n\tsd->private = sdd;\n\n\treturn sd;\n}"
  },
  {
    "function_name": "claim_allocations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1028-1043",
    "snippet": "static void claim_allocations(int cpu, struct sched_domain *sd)\n{\n\tstruct sd_data *sdd = sd->private;\n\n\tWARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);\n\t*per_cpu_ptr(sdd->sd, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sds, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sds, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sg, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sgc, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sgc, cpu) = NULL;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "cpu"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(*per_cpu_ptr(sdd->sgc, cpu))->ref"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "cpu"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sg",
            "cpu"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(*per_cpu_ptr(sdd->sg, cpu))->ref"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sg",
            "cpu"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sds",
            "cpu"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(*per_cpu_ptr(sdd->sds, cpu))->ref"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sds",
            "cpu"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "cpu"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "*per_cpu_ptr(sdd->sd, cpu) != sd"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "cpu"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void claim_allocations(int cpu, struct sched_domain *sd)\n{\n\tstruct sd_data *sdd = sd->private;\n\n\tWARN_ON_ONCE(*per_cpu_ptr(sdd->sd, cpu) != sd);\n\t*per_cpu_ptr(sdd->sd, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sds, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sds, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sg, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sg, cpu) = NULL;\n\n\tif (atomic_read(&(*per_cpu_ptr(sdd->sgc, cpu))->ref))\n\t\t*per_cpu_ptr(sdd->sgc, cpu) = NULL;\n}"
  },
  {
    "function_name": "__visit_domain_allocation_hell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "1006-1021",
    "snippet": "static enum s_alloc\n__visit_domain_allocation_hell(struct s_data *d, const struct cpumask *cpu_map)\n{\n\tmemset(d, 0, sizeof(*d));\n\n\tif (__sdt_alloc(cpu_map))\n\t\treturn sa_sd_storage;\n\td->sd = alloc_percpu(struct sched_domain *);\n\tif (!d->sd)\n\t\treturn sa_sd_storage;\n\td->rd = alloc_rootdomain();\n\tif (!d->rd)\n\t\treturn sa_sd;\n\n\treturn sa_rootdomain;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_rootdomain",
          "args": [],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_rootdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "319-333",
          "snippet": "static struct root_domain *alloc_rootdomain(void)\n{\n\tstruct root_domain *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tif (init_rootdomain(rd) != 0) {\n\t\tkfree(rd);\n\t\treturn NULL;\n\t}\n\n\treturn rd;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic struct root_domain *alloc_rootdomain(void)\n{\n\tstruct root_domain *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tif (init_rootdomain(rd) != 0) {\n\t\tkfree(rd);\n\t\treturn NULL;\n\t}\n\n\treturn rd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "struct sched_domain *"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sdt_alloc",
          "args": [
            "cpu_map"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "__sdt_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1508-1575",
          "snippet": "static int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tsdd->sd = alloc_percpu(struct sched_domain *);\n\t\tif (!sdd->sd)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sds = alloc_percpu(struct sched_domain_shared *);\n\t\tif (!sdd->sds)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sg = alloc_percpu(struct sched_group *);\n\t\tif (!sdd->sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sgc = alloc_percpu(struct sched_group_capacity *);\n\t\tif (!sdd->sgc)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\t\t\tstruct sched_domain_shared *sds;\n\t\t\tstruct sched_group *sg;\n\t\t\tstruct sched_group_capacity *sgc;\n\n\t\t\tsd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sd, j) = sd;\n\n\t\t\tsds = kzalloc_node(sizeof(struct sched_domain_shared),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sds)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sds, j) = sds;\n\n\t\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsg->next = sg;\n\n\t\t\t*per_cpu_ptr(sdd->sg, j) = sg;\n\n\t\t\tsgc = kzalloc_node(sizeof(struct sched_group_capacity) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sgc)\n\t\t\t\treturn -ENOMEM;\n\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tsgc->id = j;\n#endif\n\n\t\t\t*per_cpu_ptr(sdd->sgc, j) = sgc;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tsdd->sd = alloc_percpu(struct sched_domain *);\n\t\tif (!sdd->sd)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sds = alloc_percpu(struct sched_domain_shared *);\n\t\tif (!sdd->sds)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sg = alloc_percpu(struct sched_group *);\n\t\tif (!sdd->sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sgc = alloc_percpu(struct sched_group_capacity *);\n\t\tif (!sdd->sgc)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\t\t\tstruct sched_domain_shared *sds;\n\t\t\tstruct sched_group *sg;\n\t\t\tstruct sched_group_capacity *sgc;\n\n\t\t\tsd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sd, j) = sd;\n\n\t\t\tsds = kzalloc_node(sizeof(struct sched_domain_shared),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sds)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sds, j) = sds;\n\n\t\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsg->next = sg;\n\n\t\t\t*per_cpu_ptr(sdd->sg, j) = sg;\n\n\t\t\tsgc = kzalloc_node(sizeof(struct sched_group_capacity) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sgc)\n\t\t\t\treturn -ENOMEM;\n\n#ifdef CONFIG_SCHED_DEBUG\n\t\t\tsgc->id = j;\n#endif\n\n\t\t\t*per_cpu_ptr(sdd->sgc, j) = sgc;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "d",
            "0",
            "sizeof(*d)"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic enum s_alloc\n__visit_domain_allocation_hell(struct s_data *d, const struct cpumask *cpu_map)\n{\n\tmemset(d, 0, sizeof(*d));\n\n\tif (__sdt_alloc(cpu_map))\n\t\treturn sa_sd_storage;\n\td->sd = alloc_percpu(struct sched_domain *);\n\tif (!d->sd)\n\t\treturn sa_sd_storage;\n\td->rd = alloc_rootdomain();\n\tif (!d->rd)\n\t\treturn sa_sd;\n\n\treturn sa_rootdomain;\n}"
  },
  {
    "function_name": "__free_domain_allocs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "987-1004",
    "snippet": "static void __free_domain_allocs(struct s_data *d, enum s_alloc what,\n\t\t\t\t const struct cpumask *cpu_map)\n{\n\tswitch (what) {\n\tcase sa_rootdomain:\n\t\tif (!atomic_read(&d->rd->refcount))\n\t\t\tfree_rootdomain(&d->rd->rcu);\n\t\t/* Fall through */\n\tcase sa_sd:\n\t\tfree_percpu(d->sd);\n\t\t/* Fall through */\n\tcase sa_sd_storage:\n\t\t__sdt_free(cpu_map);\n\t\t/* Fall through */\n\tcase sa_none:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void __sdt_free(const struct cpumask *cpu_map);",
      "static int __sdt_alloc(const struct cpumask *cpu_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sdt_free",
          "args": [
            "cpu_map"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "__sdt_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "1577-1611",
          "snippet": "static void __sdt_free(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\n\t\t\tif (sdd->sd) {\n\t\t\t\tsd = *per_cpu_ptr(sdd->sd, j);\n\t\t\t\tif (sd && (sd->flags & SD_OVERLAP))\n\t\t\t\t\tfree_sched_groups(sd->groups, 0);\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sd, j));\n\t\t\t}\n\n\t\t\tif (sdd->sds)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sds, j));\n\t\t\tif (sdd->sg)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sg, j));\n\t\t\tif (sdd->sgc)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sgc, j));\n\t\t}\n\t\tfree_percpu(sdd->sd);\n\t\tsdd->sd = NULL;\n\t\tfree_percpu(sdd->sds);\n\t\tsdd->sds = NULL;\n\t\tfree_percpu(sdd->sg);\n\t\tsdd->sg = NULL;\n\t\tfree_percpu(sdd->sgc);\n\t\tsdd->sgc = NULL;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sdt_free(const struct cpumask *cpu_map);",
            "static int __sdt_alloc(const struct cpumask *cpu_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void __sdt_free(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\n\t\t\tif (sdd->sd) {\n\t\t\t\tsd = *per_cpu_ptr(sdd->sd, j);\n\t\t\t\tif (sd && (sd->flags & SD_OVERLAP))\n\t\t\t\t\tfree_sched_groups(sd->groups, 0);\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sd, j));\n\t\t\t}\n\n\t\t\tif (sdd->sds)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sds, j));\n\t\t\tif (sdd->sg)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sg, j));\n\t\t\tif (sdd->sgc)\n\t\t\t\tkfree(*per_cpu_ptr(sdd->sgc, j));\n\t\t}\n\t\tfree_percpu(sdd->sd);\n\t\tsdd->sd = NULL;\n\t\tfree_percpu(sdd->sds);\n\t\tsdd->sds = NULL;\n\t\tfree_percpu(sdd->sg);\n\t\tsdd->sg = NULL;\n\t\tfree_percpu(sdd->sgc);\n\t\tsdd->sgc = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "d->sd"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_rootdomain",
          "args": [
            "&d->rd->rcu"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "free_rootdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "204-215",
          "snippet": "static void free_rootdomain(struct rcu_head *rcu)\n{\n\tstruct root_domain *rd = container_of(rcu, struct root_domain, rcu);\n\n\tcpupri_cleanup(&rd->cpupri);\n\tcpudl_cleanup(&rd->cpudl);\n\tfree_cpumask_var(rd->dlo_mask);\n\tfree_cpumask_var(rd->rto_mask);\n\tfree_cpumask_var(rd->online);\n\tfree_cpumask_var(rd->span);\n\tkfree(rd);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void free_rootdomain(struct rcu_head *rcu)\n{\n\tstruct root_domain *rd = container_of(rcu, struct root_domain, rcu);\n\n\tcpupri_cleanup(&rd->cpupri);\n\tcpudl_cleanup(&rd->cpudl);\n\tfree_cpumask_var(rd->dlo_mask);\n\tfree_cpumask_var(rd->rto_mask);\n\tfree_cpumask_var(rd->online);\n\tfree_cpumask_var(rd->span);\n\tkfree(rd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&d->rd->refcount"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void __sdt_free(const struct cpumask *cpu_map);\nstatic int __sdt_alloc(const struct cpumask *cpu_map);\n\nstatic void __free_domain_allocs(struct s_data *d, enum s_alloc what,\n\t\t\t\t const struct cpumask *cpu_map)\n{\n\tswitch (what) {\n\tcase sa_rootdomain:\n\t\tif (!atomic_read(&d->rd->refcount))\n\t\t\tfree_rootdomain(&d->rd->rcu);\n\t\t/* Fall through */\n\tcase sa_sd:\n\t\tfree_percpu(d->sd);\n\t\t/* Fall through */\n\tcase sa_sd_storage:\n\t\t__sdt_free(cpu_map);\n\t\t/* Fall through */\n\tcase sa_none:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "set_domain_attribute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "963-982",
    "snippet": "static void set_domain_attribute(struct sched_domain *sd,\n\t\t\t\t struct sched_domain_attr *attr)\n{\n\tint request;\n\n\tif (!attr || attr->relax_domain_level < 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\telse\n\t\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->relax_domain_level;\n\tif (request < sd->level) {\n\t\t/* Turn off idle balance on this domain: */\n\t\tsd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t} else {\n\t\t/* Turn on idle balance on this domain: */\n\t\tsd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int default_relax_domain_level = -1;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int default_relax_domain_level = -1;\n\nstatic void set_domain_attribute(struct sched_domain *sd,\n\t\t\t\t struct sched_domain_attr *attr)\n{\n\tint request;\n\n\tif (!attr || attr->relax_domain_level < 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\telse\n\t\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->relax_domain_level;\n\tif (request < sd->level) {\n\t\t/* Turn off idle balance on this domain: */\n\t\tsd->flags &= ~(SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t} else {\n\t\t/* Turn on idle balance on this domain: */\n\t\tsd->flags |= (SD_BALANCE_WAKE|SD_BALANCE_NEWIDLE);\n\t}\n}"
  },
  {
    "function_name": "setup_relax_domain_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "954-960",
    "snippet": "static int __init setup_relax_domain_level(char *str)\n{\n\tif (kstrtoint(str, 0, &default_relax_domain_level))\n\t\tpr_warn(\"Unable to set relax_domain_level\\n\");\n\n\treturn 1;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int default_relax_domain_level = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unable to set relax_domain_level\\n\""
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "str",
            "0",
            "&default_relax_domain_level"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int default_relax_domain_level = -1;\n\nstatic int __init setup_relax_domain_level(char *str)\n{\n\tif (kstrtoint(str, 0, &default_relax_domain_level))\n\t\tpr_warn(\"Unable to set relax_domain_level\\n\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "init_sched_groups_capacity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "914-944",
    "snippet": "static void init_sched_groups_capacity(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_group *sg = sd->groups;\n\n\tWARN_ON(!sg);\n\n\tdo {\n\t\tint cpu, max_cpu = -1;\n\n\t\tsg->group_weight = cpumask_weight(sched_group_span(sg));\n\n\t\tif (!(sd->flags & SD_ASYM_PACKING))\n\t\t\tgoto next;\n\n\t\tfor_each_cpu(cpu, sched_group_span(sg)) {\n\t\t\tif (max_cpu < 0)\n\t\t\t\tmax_cpu = cpu;\n\t\t\telse if (sched_asym_prefer(cpu, max_cpu))\n\t\t\t\tmax_cpu = cpu;\n\t\t}\n\t\tsg->asym_prefer_cpu = max_cpu;\n\nnext:\n\t\tsg = sg->next;\n\t} while (sg != sd->groups);\n\n\tif (cpu != group_balance_cpu(sg))\n\t\treturn;\n\n\tupdate_group_capacity(sd, cpu);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_group_capacity",
          "args": [
            "sd",
            "cpu"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_balance_cpu",
          "args": [
            "sg"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "group_balance_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "501-504",
          "snippet": "int group_balance_cpu(struct sched_group *sg)\n{\n\treturn cpumask_first(group_balance_mask(sg));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint group_balance_cpu(struct sched_group *sg)\n{\n\treturn cpumask_first(group_balance_mask(sg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_asym_prefer",
          "args": [
            "cpu",
            "max_cpu"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "sched_asym_prefer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "701-704",
          "snippet": "static inline bool sched_asym_prefer(int a, int b)\n{\n\treturn arch_asym_cpu_priority(a) > arch_asym_cpu_priority(b);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool sched_asym_prefer(int a, int b)\n{\n\treturn arch_asym_cpu_priority(a) > arch_asym_cpu_priority(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "sched_group_span(sg)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1330-1333",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_group_span(sg)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sg"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void init_sched_groups_capacity(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_group *sg = sd->groups;\n\n\tWARN_ON(!sg);\n\n\tdo {\n\t\tint cpu, max_cpu = -1;\n\n\t\tsg->group_weight = cpumask_weight(sched_group_span(sg));\n\n\t\tif (!(sd->flags & SD_ASYM_PACKING))\n\t\t\tgoto next;\n\n\t\tfor_each_cpu(cpu, sched_group_span(sg)) {\n\t\t\tif (max_cpu < 0)\n\t\t\t\tmax_cpu = cpu;\n\t\t\telse if (sched_asym_prefer(cpu, max_cpu))\n\t\t\t\tmax_cpu = cpu;\n\t\t}\n\t\tsg->asym_prefer_cpu = max_cpu;\n\nnext:\n\t\tsg = sg->next;\n\t} while (sg != sd->groups);\n\n\tif (cpu != group_balance_cpu(sg))\n\t\treturn;\n\n\tupdate_group_capacity(sd, cpu);\n}"
  },
  {
    "function_name": "build_sched_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "868-902",
    "snippet": "static int\nbuild_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL;\n\tstruct sd_data *sdd = sd->private;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered;\n\tint i;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\tcovered = sched_domains_tmpmask;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct sched_group *sg;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsg = get_group(i, sdd);\n\n\t\tcpumask_or(covered, covered, sched_group_span(sg));\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t}\n\tlast->next = first;\n\tsd->groups = first;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t sched_domains_tmpmask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "covered",
            "covered",
            "sched_group_span(sg)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1330-1333",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_group",
          "args": [
            "i",
            "sdd"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "get_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "830-859",
          "snippet": "static struct sched_group *get_group(int cpu, struct sd_data *sdd)\n{\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *sg;\n\n\tif (child)\n\t\tcpu = cpumask_first(sched_domain_span(child));\n\n\tsg = *per_cpu_ptr(sdd->sg, cpu);\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\n\t/* For claim_allocations: */\n\tatomic_inc(&sg->ref);\n\tatomic_inc(&sg->sgc->ref);\n\n\tif (child) {\n\t\tcpumask_copy(sched_group_span(sg), sched_domain_span(child));\n\t\tcpumask_copy(group_balance_mask(sg), sched_group_span(sg));\n\t} else {\n\t\tcpumask_set_cpu(cpu, sched_group_span(sg));\n\t\tcpumask_set_cpu(cpu, group_balance_mask(sg));\n\t}\n\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sched_group_span(sg));\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n\n\treturn sg;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic struct sched_group *get_group(int cpu, struct sd_data *sdd)\n{\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *sg;\n\n\tif (child)\n\t\tcpu = cpumask_first(sched_domain_span(child));\n\n\tsg = *per_cpu_ptr(sdd->sg, cpu);\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\n\t/* For claim_allocations: */\n\tatomic_inc(&sg->ref);\n\tatomic_inc(&sg->sgc->ref);\n\n\tif (child) {\n\t\tcpumask_copy(sched_group_span(sg), sched_domain_span(child));\n\t\tcpumask_copy(group_balance_mask(sg), sched_group_span(sg));\n\t} else {\n\t\tcpumask_set_cpu(cpu, sched_group_span(sg));\n\t\tcpumask_set_cpu(cpu, group_balance_mask(sg));\n\t}\n\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sched_group_span(sg));\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n\n\treturn sg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "i",
            "covered"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu_wrap",
          "args": [
            "i",
            "span",
            "cpu"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "covered"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic int\nbuild_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL;\n\tstruct sd_data *sdd = sd->private;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered;\n\tint i;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\tcovered = sched_domains_tmpmask;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct sched_group *sg;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsg = get_group(i, sdd);\n\n\t\tcpumask_or(covered, covered, sched_group_span(sg));\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t}\n\tlast->next = first;\n\tsd->groups = first;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "830-859",
    "snippet": "static struct sched_group *get_group(int cpu, struct sd_data *sdd)\n{\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *sg;\n\n\tif (child)\n\t\tcpu = cpumask_first(sched_domain_span(child));\n\n\tsg = *per_cpu_ptr(sdd->sg, cpu);\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\n\t/* For claim_allocations: */\n\tatomic_inc(&sg->ref);\n\tatomic_inc(&sg->sgc->ref);\n\n\tif (child) {\n\t\tcpumask_copy(sched_group_span(sg), sched_domain_span(child));\n\t\tcpumask_copy(group_balance_mask(sg), sched_group_span(sg));\n\t} else {\n\t\tcpumask_set_cpu(cpu, sched_group_span(sg));\n\t\tcpumask_set_cpu(cpu, group_balance_mask(sg));\n\t}\n\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sched_group_span(sg));\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n\n\treturn sg;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_group_span(sg)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1330-1333",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "group_balance_mask(sg)"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_balance_mask",
          "args": [
            "sg"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "group_balance_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1338-1341",
          "snippet": "static inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "sched_group_span(sg)"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "group_balance_mask(sg)",
            "sched_group_span(sg)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "sched_group_span(sg)",
            "sched_domain_span(child)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "child"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sg->sgc->ref"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sg->ref"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "cpu"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sg",
            "cpu"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "sched_domain_span(child)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "child"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "cpu"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic struct sched_group *get_group(int cpu, struct sd_data *sdd)\n{\n\tstruct sched_domain *sd = *per_cpu_ptr(sdd->sd, cpu);\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *sg;\n\n\tif (child)\n\t\tcpu = cpumask_first(sched_domain_span(child));\n\n\tsg = *per_cpu_ptr(sdd->sg, cpu);\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\n\t/* For claim_allocations: */\n\tatomic_inc(&sg->ref);\n\tatomic_inc(&sg->sgc->ref);\n\n\tif (child) {\n\t\tcpumask_copy(sched_group_span(sg), sched_domain_span(child));\n\t\tcpumask_copy(group_balance_mask(sg), sched_group_span(sg));\n\t} else {\n\t\tcpumask_set_cpu(cpu, sched_group_span(sg));\n\t\tcpumask_set_cpu(cpu, group_balance_mask(sg));\n\t}\n\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sched_group_span(sg));\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n\n\treturn sg;\n}"
  },
  {
    "function_name": "build_overlap_sched_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "699-756",
    "snippet": "static int\nbuild_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Asymmetric node setups can result in situations where the\n\t\t * domain tree is of unequal depth, make sure to skip domains\n\t\t * that already cover the entire range.\n\t\t *\n\t\t * In that case build_sched_domains() will have terminated the\n\t\t * iteration early and our sibling sd spans will be empty.\n\t\t * Domains should always include the CPU they're built on, so\n\t\t * check that.\n\t\t */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\tsg = build_group_from_child_sched_domain(sibling, cpu);\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_span(sg);\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tinit_overlap_sched_group(sd, sg);\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = first;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t sched_domains_tmpmask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_sched_groups",
          "args": [
            "first",
            "0"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "free_sched_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "335-353",
          "snippet": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_overlap_sched_group",
          "args": [
            "sd",
            "sg"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "init_overlap_sched_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "671-697",
          "snippet": "static void init_overlap_sched_group(struct sched_domain *sd,\n\t\t\t\t     struct sched_group *sg)\n{\n\tstruct cpumask *mask = sched_domains_tmpmask2;\n\tstruct sd_data *sdd = sd->private;\n\tstruct cpumask *sg_span;\n\tint cpu;\n\n\tbuild_balance_mask(sd, sg, mask);\n\tcpu = cpumask_first_and(sched_group_span(sg), mask);\n\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\tcpumask_copy(group_balance_mask(sg), mask);\n\telse\n\t\tWARN_ON_ONCE(!cpumask_equal(group_balance_mask(sg), mask));\n\n\t/*\n\t * Initialize sgc->capacity such that even if we mess up the\n\t * domains and no possible iteration will get us here, we won't\n\t * die on a /0 trap.\n\t */\n\tsg_span = sched_group_span(sg);\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t sched_domains_tmpmask2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask2;\n\nstatic void init_overlap_sched_group(struct sched_domain *sd,\n\t\t\t\t     struct sched_group *sg)\n{\n\tstruct cpumask *mask = sched_domains_tmpmask2;\n\tstruct sd_data *sdd = sd->private;\n\tstruct cpumask *sg_span;\n\tint cpu;\n\n\tbuild_balance_mask(sd, sg, mask);\n\tcpu = cpumask_first_and(sched_group_span(sg), mask);\n\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\tcpumask_copy(group_balance_mask(sg), mask);\n\telse\n\t\tWARN_ON_ONCE(!cpumask_equal(group_balance_mask(sg), mask));\n\n\t/*\n\t * Initialize sgc->capacity such that even if we mess up the\n\t * domains and no possible iteration will get us here, we won't\n\t * die on a /0 trap.\n\t */\n\tsg_span = sched_group_span(sg);\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "covered",
            "covered",
            "sg_span"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1330-1333",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_group_from_child_sched_domain",
          "args": [
            "sibling",
            "cpu"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "build_group_from_child_sched_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "649-669",
          "snippet": "static struct sched_group *\nbuild_group_from_child_sched_domain(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *sg;\n\tstruct cpumask *sg_span;\n\n\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\tif (!sg)\n\t\treturn NULL;\n\n\tsg_span = sched_group_span(sg);\n\tif (sd->child)\n\t\tcpumask_copy(sg_span, sched_domain_span(sd->child));\n\telse\n\t\tcpumask_copy(sg_span, sched_domain_span(sd));\n\n\tatomic_inc(&sg->ref);\n\treturn sg;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic struct sched_group *\nbuild_group_from_child_sched_domain(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *sg;\n\tstruct cpumask *sg_span;\n\n\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\tif (!sg)\n\t\treturn NULL;\n\n\tsg_span = sched_group_span(sg);\n\tif (sd->child)\n\t\tcpumask_copy(sg_span, sched_domain_span(sd->child));\n\telse\n\t\tcpumask_copy(sg_span, sched_domain_span(sd));\n\n\tatomic_inc(&sg->ref);\n\treturn sg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "i",
            "sched_domain_span(sibling)"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sibling"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "i"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "i",
            "covered"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu_wrap",
          "args": [
            "i",
            "span",
            "cpu"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "covered"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic int\nbuild_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu_wrap(i, span, cpu) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Asymmetric node setups can result in situations where the\n\t\t * domain tree is of unequal depth, make sure to skip domains\n\t\t * that already cover the entire range.\n\t\t *\n\t\t * In that case build_sched_domains() will have terminated the\n\t\t * iteration early and our sibling sd spans will be empty.\n\t\t * Domains should always include the CPU they're built on, so\n\t\t * check that.\n\t\t */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\tsg = build_group_from_child_sched_domain(sibling, cpu);\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_span(sg);\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tinit_overlap_sched_group(sd, sg);\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = first;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "init_overlap_sched_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "671-697",
    "snippet": "static void init_overlap_sched_group(struct sched_domain *sd,\n\t\t\t\t     struct sched_group *sg)\n{\n\tstruct cpumask *mask = sched_domains_tmpmask2;\n\tstruct sd_data *sdd = sd->private;\n\tstruct cpumask *sg_span;\n\tint cpu;\n\n\tbuild_balance_mask(sd, sg, mask);\n\tcpu = cpumask_first_and(sched_group_span(sg), mask);\n\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\tcpumask_copy(group_balance_mask(sg), mask);\n\telse\n\t\tWARN_ON_ONCE(!cpumask_equal(group_balance_mask(sg), mask));\n\n\t/*\n\t * Initialize sgc->capacity such that even if we mess up the\n\t * domains and no possible iteration will get us here, we won't\n\t * die on a /0 trap.\n\t */\n\tsg_span = sched_group_span(sg);\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t sched_domains_tmpmask2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sg_span"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1330-1333",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cpumask_equal(group_balance_mask(sg), mask)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "group_balance_mask(sg)",
            "mask"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_balance_mask",
          "args": [
            "sg"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "group_balance_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1338-1341",
          "snippet": "static inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "group_balance_mask(sg)",
            "mask"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&sg->sgc->ref"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sgc",
            "cpu"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first_and",
          "args": [
            "sched_group_span(sg)",
            "mask"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_balance_mask",
          "args": [
            "sd",
            "sg",
            "mask"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "build_balance_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "612-642",
          "snippet": "static void\nbuild_balance_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)\n{\n\tconst struct cpumask *sg_span = sched_group_span(sg);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(mask);\n\n\tfor_each_cpu(i, sg_span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Can happen in the asymmetric case, where these siblings are\n\t\t * unused. The mask will not be empty because those CPUs that\n\t\t * do have the top domain _should_ span the domain.\n\t\t */\n\t\tif (!sibling->child)\n\t\t\tcontinue;\n\n\t\t/* If we would not end up here, we can't continue from here */\n\t\tif (!cpumask_equal(sg_span, sched_domain_span(sibling->child)))\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(i, mask);\n\t}\n\n\t/* We must not have empty masks here */\n\tWARN_ON_ONCE(cpumask_empty(mask));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void\nbuild_balance_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)\n{\n\tconst struct cpumask *sg_span = sched_group_span(sg);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(mask);\n\n\tfor_each_cpu(i, sg_span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Can happen in the asymmetric case, where these siblings are\n\t\t * unused. The mask will not be empty because those CPUs that\n\t\t * do have the top domain _should_ span the domain.\n\t\t */\n\t\tif (!sibling->child)\n\t\t\tcontinue;\n\n\t\t/* If we would not end up here, we can't continue from here */\n\t\tif (!cpumask_equal(sg_span, sched_domain_span(sibling->child)))\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(i, mask);\n\t}\n\n\t/* We must not have empty masks here */\n\tWARN_ON_ONCE(cpumask_empty(mask));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask2;\n\nstatic void init_overlap_sched_group(struct sched_domain *sd,\n\t\t\t\t     struct sched_group *sg)\n{\n\tstruct cpumask *mask = sched_domains_tmpmask2;\n\tstruct sd_data *sdd = sd->private;\n\tstruct cpumask *sg_span;\n\tint cpu;\n\n\tbuild_balance_mask(sd, sg, mask);\n\tcpu = cpumask_first_and(sched_group_span(sg), mask);\n\n\tsg->sgc = *per_cpu_ptr(sdd->sgc, cpu);\n\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\tcpumask_copy(group_balance_mask(sg), mask);\n\telse\n\t\tWARN_ON_ONCE(!cpumask_equal(group_balance_mask(sg), mask));\n\n\t/*\n\t * Initialize sgc->capacity such that even if we mess up the\n\t * domains and no possible iteration will get us here, we won't\n\t * die on a /0 trap.\n\t */\n\tsg_span = sched_group_span(sg);\n\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\tsg->sgc->min_capacity = SCHED_CAPACITY_SCALE;\n\tsg->sgc->max_capacity = SCHED_CAPACITY_SCALE;\n}"
  },
  {
    "function_name": "build_group_from_child_sched_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "649-669",
    "snippet": "static struct sched_group *\nbuild_group_from_child_sched_domain(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *sg;\n\tstruct cpumask *sg_span;\n\n\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\tif (!sg)\n\t\treturn NULL;\n\n\tsg_span = sched_group_span(sg);\n\tif (sd->child)\n\t\tcpumask_copy(sg_span, sched_domain_span(sd->child));\n\telse\n\t\tcpumask_copy(sg_span, sched_domain_span(sd));\n\n\tatomic_inc(&sg->ref);\n\treturn sg;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sg->ref"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "sg_span",
            "sched_domain_span(sd)"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "sg_span",
            "sched_domain_span(sd->child)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd->child"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1330-1333",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(struct sched_group) + cpumask_size()",
            "GFP_KERNEL",
            "cpu_to_node(cpu)"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic struct sched_group *\nbuild_group_from_child_sched_domain(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *sg;\n\tstruct cpumask *sg_span;\n\n\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\tif (!sg)\n\t\treturn NULL;\n\n\tsg_span = sched_group_span(sg);\n\tif (sd->child)\n\t\tcpumask_copy(sg_span, sched_domain_span(sd->child));\n\telse\n\t\tcpumask_copy(sg_span, sched_domain_span(sd));\n\n\tatomic_inc(&sg->ref);\n\treturn sg;\n}"
  },
  {
    "function_name": "build_balance_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "612-642",
    "snippet": "static void\nbuild_balance_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)\n{\n\tconst struct cpumask *sg_span = sched_group_span(sg);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(mask);\n\n\tfor_each_cpu(i, sg_span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Can happen in the asymmetric case, where these siblings are\n\t\t * unused. The mask will not be empty because those CPUs that\n\t\t * do have the top domain _should_ span the domain.\n\t\t */\n\t\tif (!sibling->child)\n\t\t\tcontinue;\n\n\t\t/* If we would not end up here, we can't continue from here */\n\t\tif (!cpumask_equal(sg_span, sched_domain_span(sibling->child)))\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(i, mask);\n\t}\n\n\t/* We must not have empty masks here */\n\tWARN_ON_ONCE(cpumask_empty(mask));\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpumask_empty(mask)"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "mask"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "i",
            "mask"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "sg_span",
            "sched_domain_span(sibling->child)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sibling->child"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sdd->sd",
            "i"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "i",
            "sg_span"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "mask"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "sg"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1330-1333",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void\nbuild_balance_mask(struct sched_domain *sd, struct sched_group *sg, struct cpumask *mask)\n{\n\tconst struct cpumask *sg_span = sched_group_span(sg);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(mask);\n\n\tfor_each_cpu(i, sg_span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/*\n\t\t * Can happen in the asymmetric case, where these siblings are\n\t\t * unused. The mask will not be empty because those CPUs that\n\t\t * do have the top domain _should_ span the domain.\n\t\t */\n\t\tif (!sibling->child)\n\t\t\tcontinue;\n\n\t\t/* If we would not end up here, we can't continue from here */\n\t\tif (!cpumask_equal(sg_span, sched_domain_span(sibling->child)))\n\t\t\tcontinue;\n\n\t\tcpumask_set_cpu(i, mask);\n\t}\n\n\t/* We must not have empty masks here */\n\tWARN_ON_ONCE(cpumask_empty(mask));\n}"
  },
  {
    "function_name": "group_balance_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "501-504",
    "snippet": "int group_balance_cpu(struct sched_group *sg)\n{\n\treturn cpumask_first(group_balance_mask(sg));\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "group_balance_mask(sg)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_balance_mask",
          "args": [
            "sg"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "group_balance_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1338-1341",
          "snippet": "static inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint group_balance_cpu(struct sched_group *sg)\n{\n\treturn cpumask_first(group_balance_mask(sg));\n}"
  },
  {
    "function_name": "cpu_attach_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "433-478",
    "snippet": "static void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd)\n\t\t\tsd->child = NULL;\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_top_cache_domain",
          "args": [
            "cpu"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "update_top_cache_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "403-427",
          "snippet": "static void update_top_cache_domain(int cpu)\n{\n\tstruct sched_domain_shared *sds = NULL;\n\tstruct sched_domain *sd;\n\tint id = cpu;\n\tint size = 1;\n\n\tsd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);\n\tif (sd) {\n\t\tid = cpumask_first(sched_domain_span(sd));\n\t\tsize = cpumask_weight(sched_domain_span(sd));\n\t\tsds = sd->shared;\n\t}\n\n\trcu_assign_pointer(per_cpu(sd_llc, cpu), sd);\n\tper_cpu(sd_llc_size, cpu) = size;\n\tper_cpu(sd_llc_id, cpu) = id;\n\trcu_assign_pointer(per_cpu(sd_llc_shared, cpu), sds);\n\n\tsd = lowest_flag_domain(cpu, SD_NUMA);\n\trcu_assign_pointer(per_cpu(sd_numa, cpu), sd);\n\n\tsd = highest_flag_domain(cpu, SD_ASYM_PACKING);\n\trcu_assign_pointer(per_cpu(sd_asym, cpu), sd);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void update_top_cache_domain(int cpu)\n{\n\tstruct sched_domain_shared *sds = NULL;\n\tstruct sched_domain *sd;\n\tint id = cpu;\n\tint size = 1;\n\n\tsd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);\n\tif (sd) {\n\t\tid = cpumask_first(sched_domain_span(sd));\n\t\tsize = cpumask_weight(sched_domain_span(sd));\n\t\tsds = sd->shared;\n\t}\n\n\trcu_assign_pointer(per_cpu(sd_llc, cpu), sd);\n\tper_cpu(sd_llc_size, cpu) = size;\n\tper_cpu(sd_llc_id, cpu) = id;\n\trcu_assign_pointer(per_cpu(sd_llc_shared, cpu), sds);\n\n\tsd = lowest_flag_domain(cpu, SD_NUMA);\n\trcu_assign_pointer(per_cpu(sd_numa, cpu), sd);\n\n\tsd = highest_flag_domain(cpu, SD_ASYM_PACKING);\n\trcu_assign_pointer(per_cpu(sd_asym, cpu), sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_sched_domains",
          "args": [
            "tmp"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_sched_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "380-384",
          "snippet": "static void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirty_sched_domain_sysctl",
          "args": [
            "cpu"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_sched_domain_sysctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1362-1364",
          "snippet": "static inline void dirty_sched_domain_sysctl(int cpu)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline void dirty_sched_domain_sysctl(int cpu)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "rq->sd",
            "sd"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_attach_root",
          "args": [
            "rq",
            "rd"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "rq_attach_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "217-252",
          "snippet": "void rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\n\tif (old_rd)\n\t\tcall_rcu_sched(&old_rd->rcu, free_rootdomain);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\n\tif (old_rd)\n\t\tcall_rcu_sched(&old_rd->rcu, free_rootdomain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_domain_debug",
          "args": [
            "sd",
            "cpu"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "sched_domain_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "115-137",
          "snippet": "static void sched_domain_debug(struct sched_domain *sd, int cpu)\n{\n\tint level = 0;\n\n\tif (!sched_debug_enabled)\n\t\treturn;\n\n\tif (!sd) {\n\t\tprintk(KERN_DEBUG \"CPU%d attaching NULL sched-domain.\\n\", cpu);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\", cpu);\n\n\tfor (;;) {\n\t\tif (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))\n\t\t\tbreak;\n\t\tlevel++;\n\t\tsd = sd->parent;\n\t\tif (!sd)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t sched_domains_tmpmask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic void sched_domain_debug(struct sched_domain *sd, int cpu)\n{\n\tint level = 0;\n\n\tif (!sched_debug_enabled)\n\t\treturn;\n\n\tif (!sd) {\n\t\tprintk(KERN_DEBUG \"CPU%d attaching NULL sched-domain.\\n\", cpu);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\", cpu);\n\n\tfor (;;) {\n\t\tif (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))\n\t\t\tbreak;\n\t\tlevel++;\n\t\tsd = sd->parent;\n\t\tif (!sd)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_degenerate",
          "args": [
            "sd"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "sd_degenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "148-171",
          "snippet": "static int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif (sd->flags & (SD_LOAD_BALANCE |\n\t\t\t SD_BALANCE_NEWIDLE |\n\t\t\t SD_BALANCE_FORK |\n\t\t\t SD_BALANCE_EXEC |\n\t\t\t SD_SHARE_CPUCAPACITY |\n\t\t\t SD_ASYM_CPUCAPACITY |\n\t\t\t SD_SHARE_PKG_RESOURCES |\n\t\t\t SD_SHARE_POWERDOMAIN)) {\n\t\tif (sd->groups != sd->groups->next)\n\t\t\treturn 0;\n\t}\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif (sd->flags & (SD_LOAD_BALANCE |\n\t\t\t SD_BALANCE_NEWIDLE |\n\t\t\t SD_BALANCE_FORK |\n\t\t\t SD_BALANCE_EXEC |\n\t\t\t SD_SHARE_CPUCAPACITY |\n\t\t\t SD_ASYM_CPUCAPACITY |\n\t\t\t SD_SHARE_PKG_RESOURCES |\n\t\t\t SD_SHARE_POWERDOMAIN)) {\n\t\tif (sd->groups != sd->groups->next)\n\t\t\treturn 0;\n\t}\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sd_parent_degenerate",
          "args": [
            "tmp",
            "parent"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "sd_parent_degenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "173-202",
          "snippet": "static int\nsd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)\n{\n\tunsigned long cflags = sd->flags, pflags = parent->flags;\n\n\tif (sd_degenerate(parent))\n\t\treturn 1;\n\n\tif (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))\n\t\treturn 0;\n\n\t/* Flags needing groups don't count if only 1 group in parent */\n\tif (parent->groups == parent->groups->next) {\n\t\tpflags &= ~(SD_LOAD_BALANCE |\n\t\t\t\tSD_BALANCE_NEWIDLE |\n\t\t\t\tSD_BALANCE_FORK |\n\t\t\t\tSD_BALANCE_EXEC |\n\t\t\t\tSD_ASYM_CPUCAPACITY |\n\t\t\t\tSD_SHARE_CPUCAPACITY |\n\t\t\t\tSD_SHARE_PKG_RESOURCES |\n\t\t\t\tSD_PREFER_SIBLING |\n\t\t\t\tSD_SHARE_POWERDOMAIN);\n\t\tif (nr_node_ids == 1)\n\t\t\tpflags &= ~SD_SERIALIZE;\n\t}\n\tif (~cflags & pflags)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int\nsd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)\n{\n\tunsigned long cflags = sd->flags, pflags = parent->flags;\n\n\tif (sd_degenerate(parent))\n\t\treturn 1;\n\n\tif (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))\n\t\treturn 0;\n\n\t/* Flags needing groups don't count if only 1 group in parent */\n\tif (parent->groups == parent->groups->next) {\n\t\tpflags &= ~(SD_LOAD_BALANCE |\n\t\t\t\tSD_BALANCE_NEWIDLE |\n\t\t\t\tSD_BALANCE_FORK |\n\t\t\t\tSD_BALANCE_EXEC |\n\t\t\t\tSD_ASYM_CPUCAPACITY |\n\t\t\t\tSD_SHARE_CPUCAPACITY |\n\t\t\t\tSD_SHARE_PKG_RESOURCES |\n\t\t\t\tSD_PREFER_SIBLING |\n\t\t\t\tSD_SHARE_POWERDOMAIN);\n\t\tif (nr_node_ids == 1)\n\t\t\tpflags &= ~SD_SERIALIZE;\n\t}\n\tif (~cflags & pflags)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void\ncpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp);\n\t\tif (sd)\n\t\t\tsd->child = NULL;\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdirty_sched_domain_sysctl(cpu);\n\tdestroy_sched_domains(tmp);\n\n\tupdate_top_cache_domain(cpu);\n}"
  },
  {
    "function_name": "update_top_cache_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "403-427",
    "snippet": "static void update_top_cache_domain(int cpu)\n{\n\tstruct sched_domain_shared *sds = NULL;\n\tstruct sched_domain *sd;\n\tint id = cpu;\n\tint size = 1;\n\n\tsd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);\n\tif (sd) {\n\t\tid = cpumask_first(sched_domain_span(sd));\n\t\tsize = cpumask_weight(sched_domain_span(sd));\n\t\tsds = sd->shared;\n\t}\n\n\trcu_assign_pointer(per_cpu(sd_llc, cpu), sd);\n\tper_cpu(sd_llc_size, cpu) = size;\n\tper_cpu(sd_llc_id, cpu) = id;\n\trcu_assign_pointer(per_cpu(sd_llc_shared, cpu), sds);\n\n\tsd = lowest_flag_domain(cpu, SD_NUMA);\n\trcu_assign_pointer(per_cpu(sd_numa, cpu), sd);\n\n\tsd = highest_flag_domain(cpu, SD_ASYM_PACKING);\n\trcu_assign_pointer(per_cpu(sd_asym, cpu), sd);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "per_cpu(sd_asym, cpu)",
            "sd"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "sd_asym",
            "cpu"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "highest_flag_domain",
          "args": [
            "cpu",
            "SD_ASYM_PACKING"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "highest_flag_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1260-1271",
          "snippet": "static inline struct sched_domain *highest_flag_domain(int cpu, int flag)\n{\n\tstruct sched_domain *sd, *hsd = NULL;\n\n\tfor_each_domain(cpu, sd) {\n\t\tif (!(sd->flags & flag))\n\t\t\tbreak;\n\t\thsd = sd;\n\t}\n\n\treturn hsd;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline struct sched_domain *highest_flag_domain(int cpu, int flag)\n{\n\tstruct sched_domain *sd, *hsd = NULL;\n\n\tfor_each_domain(cpu, sd) {\n\t\tif (!(sd->flags & flag))\n\t\t\tbreak;\n\t\thsd = sd;\n\t}\n\n\treturn hsd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "per_cpu(sd_numa, cpu)",
            "sd"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowest_flag_domain",
          "args": [
            "cpu",
            "SD_NUMA"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "lowest_flag_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1273-1283",
          "snippet": "static inline struct sched_domain *lowest_flag_domain(int cpu, int flag)\n{\n\tstruct sched_domain *sd;\n\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & flag)\n\t\t\tbreak;\n\t}\n\n\treturn sd;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline struct sched_domain *lowest_flag_domain(int cpu, int flag)\n{\n\tstruct sched_domain *sd;\n\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & flag)\n\t\t\tbreak;\n\t}\n\n\treturn sd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "per_cpu(sd_llc_shared, cpu)",
            "sds"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "per_cpu(sd_llc, cpu)",
            "sd"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void update_top_cache_domain(int cpu)\n{\n\tstruct sched_domain_shared *sds = NULL;\n\tstruct sched_domain *sd;\n\tint id = cpu;\n\tint size = 1;\n\n\tsd = highest_flag_domain(cpu, SD_SHARE_PKG_RESOURCES);\n\tif (sd) {\n\t\tid = cpumask_first(sched_domain_span(sd));\n\t\tsize = cpumask_weight(sched_domain_span(sd));\n\t\tsds = sd->shared;\n\t}\n\n\trcu_assign_pointer(per_cpu(sd_llc, cpu), sd);\n\tper_cpu(sd_llc_size, cpu) = size;\n\tper_cpu(sd_llc_id, cpu) = id;\n\trcu_assign_pointer(per_cpu(sd_llc_shared, cpu), sds);\n\n\tsd = lowest_flag_domain(cpu, SD_NUMA);\n\trcu_assign_pointer(per_cpu(sd_numa, cpu), sd);\n\n\tsd = highest_flag_domain(cpu, SD_ASYM_PACKING);\n\trcu_assign_pointer(per_cpu(sd_asym, cpu), sd);\n}"
  },
  {
    "function_name": "destroy_sched_domains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "380-384",
    "snippet": "static void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&sd->rcu",
            "destroy_sched_domains_rcu"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}"
  },
  {
    "function_name": "destroy_sched_domains_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "369-378",
    "snippet": "static void destroy_sched_domains_rcu(struct rcu_head *rcu)\n{\n\tstruct sched_domain *sd = container_of(rcu, struct sched_domain, rcu);\n\n\twhile (sd) {\n\t\tstruct sched_domain *parent = sd->parent;\n\t\tdestroy_sched_domain(sd);\n\t\tsd = parent;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_sched_domain",
          "args": [
            "sd"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_sched_domains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "380-384",
          "snippet": "static void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void destroy_sched_domains(struct sched_domain *sd)\n{\n\tif (sd)\n\t\tcall_rcu(&sd->rcu, destroy_sched_domains_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structsched_domain",
            "rcu"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void destroy_sched_domains_rcu(struct rcu_head *rcu)\n{\n\tstruct sched_domain *sd = container_of(rcu, struct sched_domain, rcu);\n\n\twhile (sd) {\n\t\tstruct sched_domain *parent = sd->parent;\n\t\tdestroy_sched_domain(sd);\n\t\tsd = parent;\n\t}\n}"
  },
  {
    "function_name": "destroy_sched_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "355-367",
    "snippet": "static void destroy_sched_domain(struct sched_domain *sd)\n{\n\t/*\n\t * A normal sched domain may have multiple group references, an\n\t * overlapping domain, having private groups, only one.  Iterate,\n\t * dropping group/capacity references, freeing where none remain.\n\t */\n\tfree_sched_groups(sd->groups, 1);\n\n\tif (sd->shared && atomic_dec_and_test(&sd->shared->ref))\n\t\tkfree(sd->shared);\n\tkfree(sd);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sd"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sd->shared->ref"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_sched_groups",
          "args": [
            "sd->groups",
            "1"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "free_sched_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "335-353",
          "snippet": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void destroy_sched_domain(struct sched_domain *sd)\n{\n\t/*\n\t * A normal sched domain may have multiple group references, an\n\t * overlapping domain, having private groups, only one.  Iterate,\n\t * dropping group/capacity references, freeing where none remain.\n\t */\n\tfree_sched_groups(sd->groups, 1);\n\n\tif (sd->shared && atomic_dec_and_test(&sd->shared->ref))\n\t\tkfree(sd->shared);\n\tkfree(sd);\n}"
  },
  {
    "function_name": "free_sched_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "335-353",
    "snippet": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sg"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sg->ref"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&sg->sgc->ref"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\n\tif (!sg)\n\t\treturn;\n\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\n\t\tif (atomic_dec_and_test(&sg->ref))\n\t\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}"
  },
  {
    "function_name": "alloc_rootdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "319-333",
    "snippet": "static struct root_domain *alloc_rootdomain(void)\n{\n\tstruct root_domain *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tif (init_rootdomain(rd) != 0) {\n\t\tkfree(rd);\n\t\treturn NULL;\n\t}\n\n\treturn rd;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rd"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rootdomain",
          "args": [
            "rd"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "init_rootdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "267-304",
          "snippet": "static int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\tinit_irq_work(&rd->rto_push_work, rto_push_irq_work_func);\n#endif\n\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\tinit_irq_work(&rd->rto_push_work, rto_push_irq_work_func);\n#endif\n\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rd)",
            "GFP_KERNEL"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic struct root_domain *alloc_rootdomain(void)\n{\n\tstruct root_domain *rd;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tif (init_rootdomain(rd) != 0) {\n\t\tkfree(rd);\n\t\treturn NULL;\n\t}\n\n\treturn rd;\n}"
  },
  {
    "function_name": "init_defrootdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "312-317",
    "snippet": "void init_defrootdomain(void)\n{\n\tinit_rootdomain(&def_root_domain);\n\n\tatomic_set(&def_root_domain.refcount, 1);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct root_domain def_root_domain;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&def_root_domain.refcount",
            "1"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rootdomain",
          "args": [
            "&def_root_domain"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "init_rootdomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "267-304",
          "snippet": "static int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\tinit_irq_work(&rd->rto_push_work, rto_push_irq_work_func);\n#endif\n\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\tinit_irq_work(&rd->rto_push_work, rto_push_irq_work_func);\n#endif\n\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstruct root_domain def_root_domain;\n\nvoid init_defrootdomain(void)\n{\n\tinit_rootdomain(&def_root_domain);\n\n\tatomic_set(&def_root_domain.refcount, 1);\n}"
  },
  {
    "function_name": "init_rootdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "267-304",
    "snippet": "static int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\tinit_irq_work(&rd->rto_push_work, rto_push_irq_work_func);\n#endif\n\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->span"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->online"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->dlo_mask"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->rto_mask"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpudl_cleanup",
          "args": [
            "&rd->cpudl"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "272-276",
          "snippet": "void cpudl_cleanup(struct cpudl *cp)\n{\n\tfree_cpumask_var(cp->free_cpus);\n\tkfree(cp->elements);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_cleanup(struct cpudl *cp)\n{\n\tfree_cpumask_var(cp->free_cpus);\n\tkfree(cp->elements);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpupri_init",
          "args": [
            "&rd->cpupri"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "cpupri_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
          "lines": "203-228",
          "snippet": "int cpupri_init(struct cpupri *cp)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\n\n\t\tatomic_set(&vec->count, 0);\n\t\tif (!zalloc_cpumask_var(&vec->mask, GFP_KERNEL))\n\t\t\tgoto cleanup;\n\t}\n\n\tcp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), GFP_KERNEL);\n\tif (!cp->cpu_to_pri)\n\t\tgoto cleanup;\n\n\tfor_each_possible_cpu(i)\n\t\tcp->cpu_to_pri[i] = CPUPRI_INVALID;\n\n\treturn 0;\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint cpupri_init(struct cpupri *cp)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\n\n\t\tatomic_set(&vec->count, 0);\n\t\tif (!zalloc_cpumask_var(&vec->mask, GFP_KERNEL))\n\t\t\tgoto cleanup;\n\t}\n\n\tcp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), GFP_KERNEL);\n\tif (!cp->cpu_to_pri)\n\t\tgoto cleanup;\n\n\tfor_each_possible_cpu(i)\n\t\tcp->cpu_to_pri[i] = CPUPRI_INVALID;\n\n\treturn 0;\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpudl_init",
          "args": [
            "&rd->cpudl"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "244-266",
          "snippet": "int cpudl_init(struct cpudl *cp)\n{\n\tint i;\n\n\traw_spin_lock_init(&cp->lock);\n\tcp->size = 0;\n\n\tcp->elements = kcalloc(nr_cpu_ids,\n\t\t\t       sizeof(struct cpudl_item),\n\t\t\t       GFP_KERNEL);\n\tif (!cp->elements)\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(&cp->free_cpus, GFP_KERNEL)) {\n\t\tkfree(cp->elements);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor_each_possible_cpu(i)\n\t\tcp->elements[i].idx = IDX_INVALID;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint cpudl_init(struct cpudl *cp)\n{\n\tint i;\n\n\traw_spin_lock_init(&cp->lock);\n\tcp->size = 0;\n\n\tcp->elements = kcalloc(nr_cpu_ids,\n\t\t\t       sizeof(struct cpudl_item),\n\t\t\t       GFP_KERNEL);\n\tif (!cp->elements)\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(&cp->free_cpus, GFP_KERNEL)) {\n\t\tkfree(cp->elements);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor_each_possible_cpu(i)\n\t\tcp->elements[i].idx = IDX_INVALID;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dl_bw",
          "args": [
            "&rd->dl_bw"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "345-355",
          "snippet": "void init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct dl_bandwidth def_dl_bandwidth;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstruct dl_bandwidth def_dl_bandwidth;\n\nvoid init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&rd->rto_push_work",
            "rto_push_irq_work_func"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&rd->rto_lock"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&rd->rto_mask",
            "GFP_KERNEL"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&rd->dlo_mask",
            "GFP_KERNEL"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&rd->online",
            "GFP_KERNEL"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&rd->span",
            "GFP_KERNEL"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int init_rootdomain(struct root_domain *rd)\n{\n\tif (!zalloc_cpumask_var(&rd->span, GFP_KERNEL))\n\t\tgoto out;\n\tif (!zalloc_cpumask_var(&rd->online, GFP_KERNEL))\n\t\tgoto free_span;\n\tif (!zalloc_cpumask_var(&rd->dlo_mask, GFP_KERNEL))\n\t\tgoto free_online;\n\tif (!zalloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))\n\t\tgoto free_dlo_mask;\n\n#ifdef HAVE_RT_PUSH_IPI\n\trd->rto_cpu = -1;\n\traw_spin_lock_init(&rd->rto_lock);\n\tinit_irq_work(&rd->rto_push_work, rto_push_irq_work_func);\n#endif\n\n\tinit_dl_bw(&rd->dl_bw);\n\tif (cpudl_init(&rd->cpudl) != 0)\n\t\tgoto free_rto_mask;\n\n\tif (cpupri_init(&rd->cpupri) != 0)\n\t\tgoto free_cpudl;\n\treturn 0;\n\nfree_cpudl:\n\tcpudl_cleanup(&rd->cpudl);\nfree_rto_mask:\n\tfree_cpumask_var(rd->rto_mask);\nfree_dlo_mask:\n\tfree_cpumask_var(rd->dlo_mask);\nfree_online:\n\tfree_cpumask_var(rd->online);\nfree_span:\n\tfree_cpumask_var(rd->span);\nout:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "sched_put_rd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "259-265",
    "snippet": "void sched_put_rd(struct root_domain *rd)\n{\n\tif (!atomic_dec_and_test(&rd->refcount))\n\t\treturn;\n\n\tcall_rcu_sched(&rd->rcu, free_rootdomain);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&rd->rcu",
            "free_rootdomain"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rd->refcount"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid sched_put_rd(struct root_domain *rd)\n{\n\tif (!atomic_dec_and_test(&rd->refcount))\n\t\treturn;\n\n\tcall_rcu_sched(&rd->rcu, free_rootdomain);\n}"
  },
  {
    "function_name": "sched_get_rd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "254-257",
    "snippet": "void sched_get_rd(struct root_domain *rd)\n{\n\tatomic_inc(&rd->refcount);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rd->refcount"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid sched_get_rd(struct root_domain *rd)\n{\n\tatomic_inc(&rd->refcount);\n}"
  },
  {
    "function_name": "rq_attach_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "217-252",
    "snippet": "void rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\n\tif (old_rd)\n\t\tcall_rcu_sched(&old_rd->rcu, free_rootdomain);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&old_rd->rcu",
            "free_rootdomain"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rq->lock",
            "flags"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rq_online",
          "args": [
            "rq"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "set_rq_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5656-5669",
          "snippet": "void set_rq_online(struct rq *rq)\n{\n\tif (!rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tcpumask_set_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 1;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_online)\n\t\t\t\tclass->rq_online(rq);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_rq_online(struct rq *rq)\n{\n\tif (!rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tcpumask_set_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 1;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_online)\n\t\t\t\tclass->rq_online(rq);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "rq->cpu",
            "cpu_active_mask"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "rq->cpu",
            "rd->span"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rd->refcount"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&old_rd->refcount"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "rq->cpu",
            "old_rd->span"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_rq_offline",
          "args": [
            "rq"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "set_rq_offline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5671-5684",
          "snippet": "void set_rq_offline(struct rq *rq)\n{\n\tif (rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_offline)\n\t\t\t\tclass->rq_offline(rq);\n\t\t}\n\n\t\tcpumask_clear_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 0;\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_rq_offline(struct rq *rq)\n{\n\tif (rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_offline)\n\t\t\t\tclass->rq_offline(rq);\n\t\t}\n\n\t\tcpumask_clear_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "rq->cpu",
            "old_rd->online"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rq->lock",
            "flags"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\n\tif (old_rd)\n\t\tcall_rcu_sched(&old_rd->rcu, free_rootdomain);\n}"
  },
  {
    "function_name": "free_rootdomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "204-215",
    "snippet": "static void free_rootdomain(struct rcu_head *rcu)\n{\n\tstruct root_domain *rd = container_of(rcu, struct root_domain, rcu);\n\n\tcpupri_cleanup(&rd->cpupri);\n\tcpudl_cleanup(&rd->cpudl);\n\tfree_cpumask_var(rd->dlo_mask);\n\tfree_cpumask_var(rd->rto_mask);\n\tfree_cpumask_var(rd->online);\n\tfree_cpumask_var(rd->span);\n\tkfree(rd);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rd"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->span"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->online"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->rto_mask"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "rd->dlo_mask"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpudl_cleanup",
          "args": [
            "&rd->cpudl"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "272-276",
          "snippet": "void cpudl_cleanup(struct cpudl *cp)\n{\n\tfree_cpumask_var(cp->free_cpus);\n\tkfree(cp->elements);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_cleanup(struct cpudl *cp)\n{\n\tfree_cpumask_var(cp->free_cpus);\n\tkfree(cp->elements);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpupri_cleanup",
          "args": [
            "&rd->cpupri"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "cpupri_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpupri.c",
          "lines": "234-241",
          "snippet": "void cpupri_cleanup(struct cpupri *cp)\n{\n\tint i;\n\n\tkfree(cp->cpu_to_pri);\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpupri_cleanup(struct cpupri *cp)\n{\n\tint i;\n\n\tkfree(cp->cpu_to_pri);\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structroot_domain",
            "rcu"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void free_rootdomain(struct rcu_head *rcu)\n{\n\tstruct root_domain *rd = container_of(rcu, struct root_domain, rcu);\n\n\tcpupri_cleanup(&rd->cpupri);\n\tcpudl_cleanup(&rd->cpudl);\n\tfree_cpumask_var(rd->dlo_mask);\n\tfree_cpumask_var(rd->rto_mask);\n\tfree_cpumask_var(rd->online);\n\tfree_cpumask_var(rd->span);\n\tkfree(rd);\n}"
  },
  {
    "function_name": "sd_parent_degenerate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "173-202",
    "snippet": "static int\nsd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)\n{\n\tunsigned long cflags = sd->flags, pflags = parent->flags;\n\n\tif (sd_degenerate(parent))\n\t\treturn 1;\n\n\tif (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))\n\t\treturn 0;\n\n\t/* Flags needing groups don't count if only 1 group in parent */\n\tif (parent->groups == parent->groups->next) {\n\t\tpflags &= ~(SD_LOAD_BALANCE |\n\t\t\t\tSD_BALANCE_NEWIDLE |\n\t\t\t\tSD_BALANCE_FORK |\n\t\t\t\tSD_BALANCE_EXEC |\n\t\t\t\tSD_ASYM_CPUCAPACITY |\n\t\t\t\tSD_SHARE_CPUCAPACITY |\n\t\t\t\tSD_SHARE_PKG_RESOURCES |\n\t\t\t\tSD_PREFER_SIBLING |\n\t\t\t\tSD_SHARE_POWERDOMAIN);\n\t\tif (nr_node_ids == 1)\n\t\t\tpflags &= ~SD_SERIALIZE;\n\t}\n\tif (~cflags & pflags)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "sched_domain_span(sd)",
            "sched_domain_span(parent)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "parent"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sd_degenerate",
          "args": [
            "parent"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "sd_degenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "148-171",
          "snippet": "static int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif (sd->flags & (SD_LOAD_BALANCE |\n\t\t\t SD_BALANCE_NEWIDLE |\n\t\t\t SD_BALANCE_FORK |\n\t\t\t SD_BALANCE_EXEC |\n\t\t\t SD_SHARE_CPUCAPACITY |\n\t\t\t SD_ASYM_CPUCAPACITY |\n\t\t\t SD_SHARE_PKG_RESOURCES |\n\t\t\t SD_SHARE_POWERDOMAIN)) {\n\t\tif (sd->groups != sd->groups->next)\n\t\t\treturn 0;\n\t}\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif (sd->flags & (SD_LOAD_BALANCE |\n\t\t\t SD_BALANCE_NEWIDLE |\n\t\t\t SD_BALANCE_FORK |\n\t\t\t SD_BALANCE_EXEC |\n\t\t\t SD_SHARE_CPUCAPACITY |\n\t\t\t SD_ASYM_CPUCAPACITY |\n\t\t\t SD_SHARE_PKG_RESOURCES |\n\t\t\t SD_SHARE_POWERDOMAIN)) {\n\t\tif (sd->groups != sd->groups->next)\n\t\t\treturn 0;\n\t}\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int\nsd_parent_degenerate(struct sched_domain *sd, struct sched_domain *parent)\n{\n\tunsigned long cflags = sd->flags, pflags = parent->flags;\n\n\tif (sd_degenerate(parent))\n\t\treturn 1;\n\n\tif (!cpumask_equal(sched_domain_span(sd), sched_domain_span(parent)))\n\t\treturn 0;\n\n\t/* Flags needing groups don't count if only 1 group in parent */\n\tif (parent->groups == parent->groups->next) {\n\t\tpflags &= ~(SD_LOAD_BALANCE |\n\t\t\t\tSD_BALANCE_NEWIDLE |\n\t\t\t\tSD_BALANCE_FORK |\n\t\t\t\tSD_BALANCE_EXEC |\n\t\t\t\tSD_ASYM_CPUCAPACITY |\n\t\t\t\tSD_SHARE_CPUCAPACITY |\n\t\t\t\tSD_SHARE_PKG_RESOURCES |\n\t\t\t\tSD_PREFER_SIBLING |\n\t\t\t\tSD_SHARE_POWERDOMAIN);\n\t\tif (nr_node_ids == 1)\n\t\t\tpflags &= ~SD_SERIALIZE;\n\t}\n\tif (~cflags & pflags)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "sd_degenerate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "148-171",
    "snippet": "static int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif (sd->flags & (SD_LOAD_BALANCE |\n\t\t\t SD_BALANCE_NEWIDLE |\n\t\t\t SD_BALANCE_FORK |\n\t\t\t SD_BALANCE_EXEC |\n\t\t\t SD_SHARE_CPUCAPACITY |\n\t\t\t SD_ASYM_CPUCAPACITY |\n\t\t\t SD_SHARE_PKG_RESOURCES |\n\t\t\t SD_SHARE_POWERDOMAIN)) {\n\t\tif (sd->groups != sd->groups->next)\n\t\t\treturn 0;\n\t}\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int sd_degenerate(struct sched_domain *sd)\n{\n\tif (cpumask_weight(sched_domain_span(sd)) == 1)\n\t\treturn 1;\n\n\t/* Following flags need at least 2 groups */\n\tif (sd->flags & (SD_LOAD_BALANCE |\n\t\t\t SD_BALANCE_NEWIDLE |\n\t\t\t SD_BALANCE_FORK |\n\t\t\t SD_BALANCE_EXEC |\n\t\t\t SD_SHARE_CPUCAPACITY |\n\t\t\t SD_ASYM_CPUCAPACITY |\n\t\t\t SD_SHARE_PKG_RESOURCES |\n\t\t\t SD_SHARE_POWERDOMAIN)) {\n\t\tif (sd->groups != sd->groups->next)\n\t\t\treturn 0;\n\t}\n\n\t/* Following flags don't use groups */\n\tif (sd->flags & (SD_WAKE_AFFINE))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "sched_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "142-145",
    "snippet": "static inline bool sched_debug(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline bool sched_debug(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "sched_domain_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "115-137",
    "snippet": "static void sched_domain_debug(struct sched_domain *sd, int cpu)\n{\n\tint level = 0;\n\n\tif (!sched_debug_enabled)\n\t\treturn;\n\n\tif (!sd) {\n\t\tprintk(KERN_DEBUG \"CPU%d attaching NULL sched-domain.\\n\", cpu);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\", cpu);\n\n\tfor (;;) {\n\t\tif (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))\n\t\t\tbreak;\n\t\tlevel++;\n\t\tsd = sd->parent;\n\t\tif (!sd)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t sched_domains_tmpmask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_domain_debug_one",
          "args": [
            "sd",
            "cpu",
            "level",
            "sched_domains_tmpmask"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "sched_domain_debug_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
          "lines": "28-113",
          "snippet": "static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,\n\t\t\t\t  struct cpumask *groupmask)\n{\n\tstruct sched_group *group = sd->groups;\n\n\tcpumask_clear(groupmask);\n\n\tprintk(KERN_DEBUG \"%*s domain-%d: \", level, \"\", level);\n\n\tif (!(sd->flags & SD_LOAD_BALANCE)) {\n\t\tprintk(\"does not load-balance\\n\");\n\t\tif (sd->parent)\n\t\t\tprintk(KERN_ERR \"ERROR: !SD_LOAD_BALANCE domain has parent\");\n\t\treturn -1;\n\t}\n\n\tprintk(KERN_CONT \"span=%*pbl level=%s\\n\",\n\t       cpumask_pr_args(sched_domain_span(sd)), sd->name);\n\n\tif (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->span does not contain CPU%d\\n\", cpu);\n\t}\n\tif (group && !cpumask_test_cpu(cpu, sched_group_span(group))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->groups does not contain CPU%d\\n\", cpu);\n\t}\n\n\tprintk(KERN_DEBUG \"%*s groups:\", level + 1, \"\");\n\tdo {\n\t\tif (!group) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: group is NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cpumask_weight(sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: empty group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sd->flags & SD_OVERLAP) &&\n\t\t    cpumask_intersects(groupmask, sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: repeated CPUs\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpumask_or(groupmask, groupmask, sched_group_span(group));\n\n\t\tprintk(KERN_CONT \" %d:{ span=%*pbl\",\n\t\t\t\tgroup->sgc->id,\n\t\t\t\tcpumask_pr_args(sched_group_span(group)));\n\n\t\tif ((sd->flags & SD_OVERLAP) &&\n\t\t    !cpumask_equal(group_balance_mask(group), sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \" mask=%*pbl\",\n\t\t\t\tcpumask_pr_args(group_balance_mask(group)));\n\t\t}\n\n\t\tif (group->sgc->capacity != SCHED_CAPACITY_SCALE)\n\t\t\tprintk(KERN_CONT \" cap=%lu\", group->sgc->capacity);\n\n\t\tif (group == sd->groups && sd->child &&\n\t\t    !cpumask_equal(sched_domain_span(sd->child),\n\t\t\t\t   sched_group_span(group))) {\n\t\t\tprintk(KERN_ERR \"ERROR: domain->groups does not match domain->child\\n\");\n\t\t}\n\n\t\tprintk(KERN_CONT \" }\");\n\n\t\tgroup = group->next;\n\n\t\tif (group != sd->groups)\n\t\t\tprintk(KERN_CONT \",\");\n\n\t} while (group != sd->groups);\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (!cpumask_equal(sched_domain_span(sd), groupmask))\n\t\tprintk(KERN_ERR \"ERROR: groups don't span domain->span\\n\");\n\n\tif (sd->parent &&\n\t    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))\n\t\tprintk(KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,\n\t\t\t\t  struct cpumask *groupmask)\n{\n\tstruct sched_group *group = sd->groups;\n\n\tcpumask_clear(groupmask);\n\n\tprintk(KERN_DEBUG \"%*s domain-%d: \", level, \"\", level);\n\n\tif (!(sd->flags & SD_LOAD_BALANCE)) {\n\t\tprintk(\"does not load-balance\\n\");\n\t\tif (sd->parent)\n\t\t\tprintk(KERN_ERR \"ERROR: !SD_LOAD_BALANCE domain has parent\");\n\t\treturn -1;\n\t}\n\n\tprintk(KERN_CONT \"span=%*pbl level=%s\\n\",\n\t       cpumask_pr_args(sched_domain_span(sd)), sd->name);\n\n\tif (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->span does not contain CPU%d\\n\", cpu);\n\t}\n\tif (group && !cpumask_test_cpu(cpu, sched_group_span(group))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->groups does not contain CPU%d\\n\", cpu);\n\t}\n\n\tprintk(KERN_DEBUG \"%*s groups:\", level + 1, \"\");\n\tdo {\n\t\tif (!group) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: group is NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cpumask_weight(sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: empty group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sd->flags & SD_OVERLAP) &&\n\t\t    cpumask_intersects(groupmask, sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: repeated CPUs\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpumask_or(groupmask, groupmask, sched_group_span(group));\n\n\t\tprintk(KERN_CONT \" %d:{ span=%*pbl\",\n\t\t\t\tgroup->sgc->id,\n\t\t\t\tcpumask_pr_args(sched_group_span(group)));\n\n\t\tif ((sd->flags & SD_OVERLAP) &&\n\t\t    !cpumask_equal(group_balance_mask(group), sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \" mask=%*pbl\",\n\t\t\t\tcpumask_pr_args(group_balance_mask(group)));\n\t\t}\n\n\t\tif (group->sgc->capacity != SCHED_CAPACITY_SCALE)\n\t\t\tprintk(KERN_CONT \" cap=%lu\", group->sgc->capacity);\n\n\t\tif (group == sd->groups && sd->child &&\n\t\t    !cpumask_equal(sched_domain_span(sd->child),\n\t\t\t\t   sched_group_span(group))) {\n\t\t\tprintk(KERN_ERR \"ERROR: domain->groups does not match domain->child\\n\");\n\t\t}\n\n\t\tprintk(KERN_CONT \" }\");\n\n\t\tgroup = group->next;\n\n\t\tif (group != sd->groups)\n\t\t\tprintk(KERN_CONT \",\");\n\n\t} while (group != sd->groups);\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (!cpumask_equal(sched_domain_span(sd), groupmask))\n\t\tprintk(KERN_ERR \"ERROR: groups don't span domain->span\\n\");\n\n\tif (sd->parent &&\n\t    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))\n\t\tprintk(KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\"",
            "cpu"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t sched_domains_tmpmask;\n\nstatic void sched_domain_debug(struct sched_domain *sd, int cpu)\n{\n\tint level = 0;\n\n\tif (!sched_debug_enabled)\n\t\treturn;\n\n\tif (!sd) {\n\t\tprintk(KERN_DEBUG \"CPU%d attaching NULL sched-domain.\\n\", cpu);\n\t\treturn;\n\t}\n\n\tprintk(KERN_DEBUG \"CPU%d attaching sched-domain(s):\\n\", cpu);\n\n\tfor (;;) {\n\t\tif (sched_domain_debug_one(sd, cpu, level, sched_domains_tmpmask))\n\t\t\tbreak;\n\t\tlevel++;\n\t\tsd = sd->parent;\n\t\tif (!sd)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "sched_domain_debug_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "28-113",
    "snippet": "static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,\n\t\t\t\t  struct cpumask *groupmask)\n{\n\tstruct sched_group *group = sd->groups;\n\n\tcpumask_clear(groupmask);\n\n\tprintk(KERN_DEBUG \"%*s domain-%d: \", level, \"\", level);\n\n\tif (!(sd->flags & SD_LOAD_BALANCE)) {\n\t\tprintk(\"does not load-balance\\n\");\n\t\tif (sd->parent)\n\t\t\tprintk(KERN_ERR \"ERROR: !SD_LOAD_BALANCE domain has parent\");\n\t\treturn -1;\n\t}\n\n\tprintk(KERN_CONT \"span=%*pbl level=%s\\n\",\n\t       cpumask_pr_args(sched_domain_span(sd)), sd->name);\n\n\tif (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->span does not contain CPU%d\\n\", cpu);\n\t}\n\tif (group && !cpumask_test_cpu(cpu, sched_group_span(group))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->groups does not contain CPU%d\\n\", cpu);\n\t}\n\n\tprintk(KERN_DEBUG \"%*s groups:\", level + 1, \"\");\n\tdo {\n\t\tif (!group) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: group is NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cpumask_weight(sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: empty group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sd->flags & SD_OVERLAP) &&\n\t\t    cpumask_intersects(groupmask, sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: repeated CPUs\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpumask_or(groupmask, groupmask, sched_group_span(group));\n\n\t\tprintk(KERN_CONT \" %d:{ span=%*pbl\",\n\t\t\t\tgroup->sgc->id,\n\t\t\t\tcpumask_pr_args(sched_group_span(group)));\n\n\t\tif ((sd->flags & SD_OVERLAP) &&\n\t\t    !cpumask_equal(group_balance_mask(group), sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \" mask=%*pbl\",\n\t\t\t\tcpumask_pr_args(group_balance_mask(group)));\n\t\t}\n\n\t\tif (group->sgc->capacity != SCHED_CAPACITY_SCALE)\n\t\t\tprintk(KERN_CONT \" cap=%lu\", group->sgc->capacity);\n\n\t\tif (group == sd->groups && sd->child &&\n\t\t    !cpumask_equal(sched_domain_span(sd->child),\n\t\t\t\t   sched_group_span(group))) {\n\t\t\tprintk(KERN_ERR \"ERROR: domain->groups does not match domain->child\\n\");\n\t\t}\n\n\t\tprintk(KERN_CONT \" }\");\n\n\t\tgroup = group->next;\n\n\t\tif (group != sd->groups)\n\t\t\tprintk(KERN_CONT \",\");\n\n\t} while (group != sd->groups);\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (!cpumask_equal(sched_domain_span(sd), groupmask))\n\t\tprintk(KERN_ERR \"ERROR: groups don't span domain->span\\n\");\n\n\tif (sd->parent &&\n\t    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))\n\t\tprintk(KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\""
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "groupmask",
            "sched_domain_span(sd->parent)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd->parent"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "sched_domain_span(sd)",
            "groupmask"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "sched_domain_span(sd->child)",
            "sched_group_span(group)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_group_span",
          "args": [
            "group"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_span",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1330-1333",
          "snippet": "static inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd->child"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" cap=%lu\"",
            "group->sgc->capacity"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "group_balance_mask(group)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_balance_mask",
          "args": [
            "group"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "group_balance_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1338-1341",
          "snippet": "static inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "group_balance_mask(group)",
            "sched_group_span(group)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "sched_group_span(group)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "groupmask",
            "groupmask",
            "sched_group_span(group)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "groupmask",
            "sched_group_span(group)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "sched_group_span(group)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "sched_group_span(group)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "sched_domain_span(sd)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "groupmask"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,\n\t\t\t\t  struct cpumask *groupmask)\n{\n\tstruct sched_group *group = sd->groups;\n\n\tcpumask_clear(groupmask);\n\n\tprintk(KERN_DEBUG \"%*s domain-%d: \", level, \"\", level);\n\n\tif (!(sd->flags & SD_LOAD_BALANCE)) {\n\t\tprintk(\"does not load-balance\\n\");\n\t\tif (sd->parent)\n\t\t\tprintk(KERN_ERR \"ERROR: !SD_LOAD_BALANCE domain has parent\");\n\t\treturn -1;\n\t}\n\n\tprintk(KERN_CONT \"span=%*pbl level=%s\\n\",\n\t       cpumask_pr_args(sched_domain_span(sd)), sd->name);\n\n\tif (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->span does not contain CPU%d\\n\", cpu);\n\t}\n\tif (group && !cpumask_test_cpu(cpu, sched_group_span(group))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->groups does not contain CPU%d\\n\", cpu);\n\t}\n\n\tprintk(KERN_DEBUG \"%*s groups:\", level + 1, \"\");\n\tdo {\n\t\tif (!group) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: group is NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cpumask_weight(sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: empty group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sd->flags & SD_OVERLAP) &&\n\t\t    cpumask_intersects(groupmask, sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: repeated CPUs\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpumask_or(groupmask, groupmask, sched_group_span(group));\n\n\t\tprintk(KERN_CONT \" %d:{ span=%*pbl\",\n\t\t\t\tgroup->sgc->id,\n\t\t\t\tcpumask_pr_args(sched_group_span(group)));\n\n\t\tif ((sd->flags & SD_OVERLAP) &&\n\t\t    !cpumask_equal(group_balance_mask(group), sched_group_span(group))) {\n\t\t\tprintk(KERN_CONT \" mask=%*pbl\",\n\t\t\t\tcpumask_pr_args(group_balance_mask(group)));\n\t\t}\n\n\t\tif (group->sgc->capacity != SCHED_CAPACITY_SCALE)\n\t\t\tprintk(KERN_CONT \" cap=%lu\", group->sgc->capacity);\n\n\t\tif (group == sd->groups && sd->child &&\n\t\t    !cpumask_equal(sched_domain_span(sd->child),\n\t\t\t\t   sched_group_span(group))) {\n\t\t\tprintk(KERN_ERR \"ERROR: domain->groups does not match domain->child\\n\");\n\t\t}\n\n\t\tprintk(KERN_CONT \" }\");\n\n\t\tgroup = group->next;\n\n\t\tif (group != sd->groups)\n\t\t\tprintk(KERN_CONT \",\");\n\n\t} while (group != sd->groups);\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (!cpumask_equal(sched_domain_span(sd), groupmask))\n\t\tprintk(KERN_ERR \"ERROR: groups don't span domain->span\\n\");\n\n\tif (sd->parent &&\n\t    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))\n\t\tprintk(KERN_ERR \"ERROR: parent span is not a superset of domain->span\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "23-26",
    "snippet": "static inline bool sched_debug(void)\n{\n\treturn sched_debug_enabled;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline bool sched_debug(void)\n{\n\treturn sched_debug_enabled;\n}"
  },
  {
    "function_name": "sched_debug_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/topology.c",
    "lines": "15-20",
    "snippet": "static int __init sched_debug_setup(char *str)\n{\n\tsched_debug_enabled = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic int __init sched_debug_setup(char *str)\n{\n\tsched_debug_enabled = true;\n\n\treturn 0;\n}"
  }
]